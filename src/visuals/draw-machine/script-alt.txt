import { scaler, pull, wrap, scale } from '../../ixfx/data.js';
import * as Rx from '../../ixfx/rx.js';
import * as Dom from '../../ixfx/dom.js';
import { continuously, frequencyTimer } from '../../ixfx/flow.js';
import * as Visuals from '../../ixfx/visual.js';
import { Points, Polar, degreeToRadian, Line, Lines, Point } from '../../ixfx/geometry.js';
import * as Modulation from '../../ixfx/modulation.js';
import { reactiveUpdate } from '../../ixfx/data.js';
import { resample } from './resample.js';
import * as Settings from './settings.js';
import { CanvasSettings, DrawSettings } from './types.js';
import { initDrawing } from './drawing.js';

const piPi = Math.PI * 2;
const halfPi = Math.PI / 2;

const d = initDrawing();

const defaultSettings = {
  armLengthMin: 0.1,
  armLengthMax: 0.4,
  armThickness: 20,
  armOrigin: { x: 0.5, y: 1 },
  armAngleMin: degreeToRadian(180),
  armAngleMax: degreeToRadian(360),
  canvasRpm: 0.01,
  canvasFade: 0.1,
  canvasRpmMax: 120,
  canvasBg: Visuals.Colour.toHsl(`whitesmoke`),
  drawFreq: 0.5,
  armDraw: true,
};

const settings = Rx.From.object({ ...defaultSettings });

const uiState = Rx.combineLatestToObject({
  armLengthMin: Rx.From.domNumberInputValue(`#armLengthMin`, { relative: true }),
  armLengthMax: Rx.From.domNumberInputValue(`#armLengthMax`, { relative: true }),
  canvasRpm: Rx.From.domNumberInputValue(`#canvasRpm`, { relative: true }),
  canvasFade: Rx.From.domNumberInputValue(`#canvasFade`, { relative: true }),
  canvasBg: Rx.From.domHslInputValue(`#canvasBg`),
  drawFreq: Rx.From.domNumberInputValue(`#drawFreq`, { relative: true })
});

// Update UI with loaded settings
uiState.setWith(settings.last());

// If UI changes, sync back to settings
uiState.onValue(value => {
  settings.update(value);
});

// If settings change, update state perhaps
settings.onDiff(changes => {
  console.log(changes);
  if (changes.some(c => c.path.startsWith(`canvasBg`))) {
    d.clear(Visuals.Colour.toHex(settings.last().canvasBg));
  }
})

const rxState = reactiveUpdate(
  {
    /**
     * Current rotation of canvas
     */
    canvasRotationRadian: 0,
    /** 
     * Angle of arm in radians
     */
    armAngle: degreeToRadian(-90),
    armLength: 1,
    /**
     * Time of last draw
     */
    lastDraw: 0
  },
  {
    canvasRotationRadian: Rx.run(
      Modulation.Oscillators.saw(frequencyTimer(0.1)),
      Rx.Ops.transform(v => v * piPi)
    ),
    armAngle: Rx.run(
      // Angle of arm based on sine oscillator
      Modulation.Oscillators.sine(frequencyTimer(0.1)),
      // Scale
      Rx.Ops.transform(v => {
        const s = settings.last();
        return scale(v, 0, 1, s.armAngleMin, s.armAngleMax);
      })
    )
  }
);

d.clear(Visuals.Colour.toHex(settings.last().canvasBg));

continuously(async () => {
  await update();
  //await use();
}, 200).start();

const resampler = resample(d.composedContext, {
  scale: d.ratio,
  bg: Visuals.Colour.toString(settings.last().canvasBg),
  smoothingQuality: `high`,
  smoothingEnabled: true
});

async function update() {
  const state = await rxState.pull();
  const set = settings.last();
  const size = d.composedSize;

  let armLength = 0.5;
  let armOriginAbs = Points.multiply(set.armOrigin, window.innerWidth, window.innerHeight);
  const armEnd = Polar.toCartesian(
    armLength * d.ratio,
    state.armAngle,
    armOriginAbs
  );
  const armAbsolute: Line = { a: armOriginAbs, b: armEnd };

  const context = resampler.run(state.canvasRotationRadian);

  // if (set.canvasFade > 0) {
  //   const hsl = set.canvasBg;
  //   context.fillStyle = `hsla(0%,0%,100%,0.1)`;//`hsla(${ Number.isNaN(hsl.h) ? 0 : hsl.h * 360 },${ hsl.s * 100 }%,${ hsl.l * 100 }%,${ set.canvasFade / 80 })`;
  //   context.globalCompositeOperation = `saturation`;
  //   context.fillRect(0, 0, size.width, size.height);
  //   context.globalCompositeOperation = `copy`;
  // }

  //const elapsed = performance.now() - lastDraw;
  //if (elapsed >= settings.draw.freq) {
  context.save();
  context.translate(armAbsolute.b.x, armAbsolute.b.y);
  context.rotate(Lines.angleRadian(armAbsolute));
  d.drawAtArmEnd(context);
  context.restore();
  //saveState({ lastDraw: performance.now() });
  //}

  if (set.armDraw) d.drawArm(armAbsolute, set.armThickness)

};


/*
const initFromSettings = () => {
  const { arm, canvas, draw, mod } = settings;

  const angleRangeMax = arm.angle;
  const angleRangeMin = angleRangeMax - arm.angleRange;

  scalers = {
    armLength: scaler(0, 1, arm.lengthRange[ 0 ], arm.lengthRange[ 1 ]),
    angleScale: scaler(0, 1, angleRangeMin, angleRangeMax),
  }

  let stateArm = pull({
    lengthOsc: Oscillators.sine(mod.armLengthFreq),
    angleOsc: Oscillators.sine(mod.armAngleFreq),
    length: () => {}
  });

  let stateDraw = pull({
    drawParam1Osc: Oscillators.sine(mod.drawParam1Freq)
  })

  const rpm = settings.canvas.rpm * settings.canvas.rpmMax * Math.PI * 2;
  console.log(rpm);

  let canvasState = pull({
    rotationByTime: perMinute(rpm),
  });

  return { arm: stateArm, draw: stateDraw, canvas: canvasState }
  // return {
  //   drawParam1Osc: Oscillators.sine(mod.drawParam1Freq),
  //   drawRateMs: draw.freq,
  //   hideArm: draw.hideArm,
  //   armThickness: 20
  // }
}

//let states_ = initFromSettings();

//Math.min(size.height, size.width)


let settings = Settings.load();
let scalers = {
  armLength: scaler(0, 1),
  angleScale: scaler(0, 1)
};


const use = async () => {
  const { armEndAbsolute, canvasRotationRadian, lastDraw } = state;

  const ratio = composedCanvas.ratio;

  // Absolute position of arm start & end
  const armAbsolute = {
    // Start
    a: Points.multiply(settings.arm.origin, window.innerWidth, window.innerHeight),
    // End
    b: armEndAbsolute
  };

  const onPreDraw = (context: CanvasRenderingContext2D) => {
    context.translate(composedCanvas.width / 2, composedCanvas.height / 2);
    context.rotate(canvasRotationRadian);
  }
  const r = resample(composedCanvas.ctx, {
    scale: ratio, onPreDraw,
    bg: Visuals.Colour.toString(settings.canvas.bgColour),
    smoothingQuality: `high`,
    smoothingEnabled: true
  });

  // const composedContext = composedCanvas.ctx;
  // const off = new OffscreenCanvas(composedCanvas.width * ratio, composedCanvas.height * ratio);
  // const offContext = off.getContext(`2d`);
  // if (offContext) {
  //   offContext.scale(1 / ratio, 1 / ratio);
  //   //offCtx.imageSmoothingQuality = `high`;
  //   //offCtx.imageSmoothingEnabled = false;
  //   offContext.drawImage(composedCanvas.el, 0, 0);
  // }
  // composedContext.clearRect(0, 0, composedCanvas.width, composedCanvas.height);
  // composedContext.save();
  // composedContext.imageSmoothingQuality = `high`;
  // composedContext.imageSmoothingEnabled = false;
  // composedContext.translate(composedCanvas.width / 2, composedCanvas.height / 2);
  // composedContext.rotate(canvasRotation);
  // composedContext.drawImage(off, -composedCanvas.width / 2, -composedCanvas.height / 2);
  // composedContext.restore();

  const context = r.run();

  if (settings.canvas.fade > 0) {
    const hsl = settings.canvas.bgColour;
    context.fillStyle = `hsla(${ Number.isNaN(hsl.h) ? 0 : hsl.h * 360 },${ hsl.s * 100 }%,${ hsl.l * 100 }%,${ settings.canvas.fade / 80 })`;
    context.globalCompositeOperation = `saturation`;
    context.fillRect(0, 0, composedCanvas.width, composedCanvas.height);
    context.globalCompositeOperation = `copy`;
  }

  const elapsed = performance.now() - lastDraw;
  if (elapsed >= settings.draw.freq) {
    context.save();
    context.translate(armAbsolute.b.x, armAbsolute.b.y);
    context.rotate(Lines.angleRadian(armAbsolute));
    drawAtArmEnd(context);
    context.restore();
    saveState({ lastDraw: performance.now() });
  }
  if (!settings.draw.hideArm) drawArm(armAbsolute);
};









// function saveState(s: Partial<typeof state>) {
//   state = Object.freeze({
//     ...state,
//     ...s
//   });
// }

type Modulators = {
  canvasRadians?: () => number
}

type StateProper = {
  canvasRpm: number
}

let modulators: Modulators = {};

let stateProper: StateProper = {
  canvasRpm: settings.canvas.rpm
}

const compose = <T>(options: { key: keyof StateProper, input: Rx.Reactive<T> & Rx.ReactiveWritable<T>, changed: (value: T) => void }) => {
  const { input, changed } = options;

  const off = input.value(changed);
}

compose({
  key: `canvasRpm`,
  input: Rx.From.domValueAsNumber(`#canvasRpm`, { makeRelative: true }),
  changed: (value) => {
    // Update state
    // Update modulator
    modulators = {
      ...modulators,
      canvasRadians: perMinute(value * settings.canvas.rpmMax * Math.PI * 2)
    }
  }
});


// const bindNumber = (target: HTMLInputElement | string, initialValue: number) => {
//   const r = Rx.run<number, number>(
//     Rx.From.domValueAsNumber(target, { makeRelative: true, initialValue }),
//     Rx.Ops.transform<number, number>(value => {
//       return expoIn(value);
//     })
//   );
//   r.value(value => {
//     console.log(`bindNumber value: ${ value }`);
//   });
// }
// bindNumber(`#canvasRpm`, settings.canvas.rpm);

const expoIn = Easings.get(`expoIn`);
console.log(`settings: ${ JSON.stringify(settings.canvas.bgColour) }`);
const uiState = Rx.combineLatestToObject({
  canvasRpm: Rx.From.domNumberInputValue(`#canvasRpm`, {
    makeRelative: true,
    initialValue: settings.canvas.rpm,
    transform(value) {
      return expoIn(value);
    },
  }),
  canvasFade: Rx.From.domNumberInputValue(`#canvasFade`, { makeRelative: true, initialValue: settings.canvas.fade }),
  canvasBg: Rx.From.domHslInputValue(`#canvasBg`, { initialValue: settings.canvas.bgColour }),
  drawFreq: Rx.From.domNumberInputValue(`#drawFreq`, { invert: true, initialValue: settings.draw.freq })
});

// TODO: Update UI with loaded settings


// Update settings based on UI
uiState.value(value => {
  const canvas: CanvasSettings = {
    ...settings.canvas,
    bgColour: value.canvasBg!,
    fade: value.canvasFade!,
    rpm: value.canvasRpm!
  }

  const compareCanvas = changedDataFields(settings.canvas, canvas);

  const draw: DrawSettings = {
    ...settings.draw,
    freq: value.drawFreq!
  }

  const bgColourChange = !isEqualValueIgnoreOrder(settings.canvas.bgColour, canvas.bgColour);
  settings = { ...settings, canvas, draw };
  states_ = initFromSettings();
  if (bgColourChange) {
    console.log(`bg changed`);
    initCanvas();
  }
})
  */