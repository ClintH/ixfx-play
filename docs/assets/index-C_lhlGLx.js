import{i as V}from"./interpolate-CjV-b_hr.js";import{f as K}from"./from-top-left-CR5-Vjbi.js";import{i as Q,a as nt}from"./guard-DHhxSbUy.js";const{abs:R,cos:A,sin:F,acos:et,atan2:I,sqrt:P,pow:j}=Math;function L(s){return s<0?-j(-s,1/3):j(s,1/3)}const B=Math.PI,X=2*B,$=B/2,it=1e-6,W=Number.MAX_SAFE_INTEGER||9007199254740991,Y=Number.MIN_SAFE_INTEGER||-9007199254740991,rt={x:0,y:0,z:0},h={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(s,n){const e=n(s);let i=e.x*e.x+e.y*e.y;return typeof e.z<"u"&&(i+=e.z*e.z),P(i)},compute:function(s,n,e){if(s===0)return n[0].t=0,n[0];const i=n.length-1;if(s===1)return n[i].t=1,n[i];const o=1-s;let c=n;if(i===0)return n[0].t=s,n[0];if(i===1){const u={x:o*c[0].x+s*c[1].x,y:o*c[0].y+s*c[1].y,t:s};return e&&(u.z=o*c[0].z+s*c[1].z),u}if(i<4){let u=o*o,f=s*s,a,x,l,y=0;i===2?(c=[c[0],c[1],c[2],rt],a=u,x=o*s*2,l=f):i===3&&(a=u*o,x=u*s*3,l=o*f*3,y=s*f);const p={x:a*c[0].x+x*c[1].x+l*c[2].x+y*c[3].x,y:a*c[0].y+x*c[1].y+l*c[2].y+y*c[3].y,t:s};return e&&(p.z=a*c[0].z+x*c[1].z+l*c[2].z+y*c[3].z),p}const r=JSON.parse(JSON.stringify(n));for(;r.length>1;){for(let u=0;u<r.length-1;u++)r[u]={x:r[u].x+(r[u+1].x-r[u].x)*s,y:r[u].y+(r[u+1].y-r[u].y)*s},typeof r[u].z<"u"&&(r[u].z=r[u].z+(r[u+1].z-r[u].z)*s);r.splice(r.length-1,1)}return r[0].t=s,r[0]},computeWithRatios:function(s,n,e,i){const o=1-s,c=e,r=n;let u=c[0],f=c[1],a=c[2],x=c[3],l;if(u*=o,f*=s,r.length===2)return l=u+f,{x:(u*r[0].x+f*r[1].x)/l,y:(u*r[0].y+f*r[1].y)/l,z:i?(u*r[0].z+f*r[1].z)/l:!1,t:s};if(u*=o,f*=2*o,a*=s*s,r.length===3)return l=u+f+a,{x:(u*r[0].x+f*r[1].x+a*r[2].x)/l,y:(u*r[0].y+f*r[1].y+a*r[2].y)/l,z:i?(u*r[0].z+f*r[1].z+a*r[2].z)/l:!1,t:s};if(u*=o,f*=1.5*o,a*=3*o,x*=s*s*s,r.length===4)return l=u+f+a+x,{x:(u*r[0].x+f*r[1].x+a*r[2].x+x*r[3].x)/l,y:(u*r[0].y+f*r[1].y+a*r[2].y+x*r[3].y)/l,z:i?(u*r[0].z+f*r[1].z+a*r[2].z+x*r[3].z)/l:!1,t:s}},derive:function(s,n){const e=[];for(let i=s,o=i.length,c=o-1;o>1;o--,c--){const r=[];for(let u=0,f;u<c;u++)f={x:c*(i[u+1].x-i[u].x),y:c*(i[u+1].y-i[u].y)},n&&(f.z=c*(i[u+1].z-i[u].z)),r.push(f);e.push(r),i=r}return e},between:function(s,n,e){return n<=s&&s<=e||h.approximately(s,n)||h.approximately(s,e)},approximately:function(s,n,e){return R(s-n)<=(e||it)},length:function(s){const e=h.Tvalues.length;let i=0;for(let o=0,c;o<e;o++)c=.5*h.Tvalues[o]+.5,i+=h.Cvalues[o]*h.arcfn(c,s);return .5*i},map:function(s,n,e,i,o){const c=e-n,r=o-i,u=s-n,f=u/c;return i+r*f},lerp:function(s,n,e){const i={x:n.x+s*(e.x-n.x),y:n.y+s*(e.y-n.y)};return n.z!==void 0&&e.z!==void 0&&(i.z=n.z+s*(e.z-n.z)),i},pointToString:function(s){let n=s.x+"/"+s.y;return typeof s.z<"u"&&(n+="/"+s.z),n},pointsToString:function(s){return"["+s.map(h.pointToString).join(", ")+"]"},copy:function(s){return JSON.parse(JSON.stringify(s))},angle:function(s,n,e){const i=n.x-s.x,o=n.y-s.y,c=e.x-s.x,r=e.y-s.y,u=i*r-o*c,f=i*c+o*r;return I(u,f)},round:function(s,n){const e=""+s,i=e.indexOf(".");return parseFloat(e.substring(0,i+1+n))},dist:function(s,n){const e=s.x-n.x,i=s.y-n.y;return P(e*e+i*i)},closest:function(s,n){let e=j(2,63),i,o;return s.forEach(function(c,r){o=h.dist(n,c),o<e&&(e=o,i=r)}),{mdist:e,mpos:i}},abcratio:function(s,n){if(n!==2&&n!==3)return!1;if(typeof s>"u")s=.5;else if(s===0||s===1)return s;const e=j(s,n)+j(1-s,n),i=e-1;return R(i/e)},projectionratio:function(s,n){if(n!==2&&n!==3)return!1;if(typeof s>"u")s=.5;else if(s===0||s===1)return s;const e=j(1-s,n),i=j(s,n)+e;return e/i},lli8:function(s,n,e,i,o,c,r,u){const f=(s*i-n*e)*(o-r)-(s-e)*(o*u-c*r),a=(s*i-n*e)*(c-u)-(n-i)*(o*u-c*r),x=(s-e)*(c-u)-(n-i)*(o-r);return x==0?!1:{x:f/x,y:a/x}},lli4:function(s,n,e,i){const o=s.x,c=s.y,r=n.x,u=n.y,f=e.x,a=e.y,x=i.x,l=i.y;return h.lli8(o,c,r,u,f,a,x,l)},lli:function(s,n){return h.lli4(s,s.c,n,n.c)},makeline:function(s,n){return new w(s.x,s.y,(s.x+n.x)/2,(s.y+n.y)/2,n.x,n.y)},findbbox:function(s){let n=W,e=W,i=Y,o=Y;return s.forEach(function(c){const r=c.bbox();n>r.x.min&&(n=r.x.min),e>r.y.min&&(e=r.y.min),i<r.x.max&&(i=r.x.max),o<r.y.max&&(o=r.y.max)}),{x:{min:n,mid:(n+i)/2,max:i,size:i-n},y:{min:e,mid:(e+o)/2,max:o,size:o-e}}},shapeintersections:function(s,n,e,i,o){if(!h.bboxoverlap(n,i))return[];const c=[],r=[s.startcap,s.forward,s.back,s.endcap],u=[e.startcap,e.forward,e.back,e.endcap];return r.forEach(function(f){f.virtual||u.forEach(function(a){if(a.virtual)return;const x=f.intersects(a,o);x.length>0&&(x.c1=f,x.c2=a,x.s1=s,x.s2=e,c.push(x))})}),c},makeshape:function(s,n,e){const i=n.points.length,o=s.points.length,c=h.makeline(n.points[i-1],s.points[0]),r=h.makeline(s.points[o-1],n.points[0]),u={startcap:c,forward:s,back:n,endcap:r,bbox:h.findbbox([c,s,n,r])};return u.intersections=function(f){return h.shapeintersections(u,u.bbox,f,f.bbox,e)},u},getminmax:function(s,n,e){if(!e)return{min:0,max:0};let i=W,o=Y,c,r;e.indexOf(0)===-1&&(e=[0].concat(e)),e.indexOf(1)===-1&&e.push(1);for(let u=0,f=e.length;u<f;u++)c=e[u],r=s.get(c),r[n]<i&&(i=r[n]),r[n]>o&&(o=r[n]);return{min:i,mid:(i+o)/2,max:o,size:o-i}},align:function(s,n){const e=n.p1.x,i=n.p1.y,o=-I(n.p2.y-i,n.p2.x-e),c=function(r){return{x:(r.x-e)*A(o)-(r.y-i)*F(o),y:(r.x-e)*F(o)+(r.y-i)*A(o)}};return s.map(c)},roots:function(s,n){n=n||{p1:{x:0,y:0},p2:{x:1,y:0}};const e=s.length-1,i=h.align(s,n),o=function(d){return 0<=d&&d<=1};if(e===2){const d=i[0].y,z=i[1].y,S=i[2].y,b=d-2*z+S;if(b!==0){const q=-P(z*z-d*S),T=-d+z,C=-(q+T)/b,U=-(-q+T)/b;return[C,U].filter(o)}else if(z!==S&&b===0)return[(2*z-S)/(2*z-2*S)].filter(o);return[]}const c=i[0].y,r=i[1].y,u=i[2].y,f=i[3].y;let a=-c+3*r-3*u+f,x=3*c-6*r+3*u,l=-3*c+3*r,y=c;if(h.approximately(a,0)){if(h.approximately(x,0))return h.approximately(l,0)?[]:[-y/l].filter(o);const d=P(l*l-4*x*y),z=2*x;return[(d-l)/z,(-l-d)/z].filter(o)}x/=a,l/=a,y/=a;const p=(3*l-x*x)/3,g=p/3,v=(2*x*x*x-9*x*l+27*y)/27,M=v/2,E=M*M+g*g*g;let O,_,N,m,k;if(E<0){const d=-p/3,z=d*d*d,S=P(z),b=-v/(2*S),q=b<-1?-1:b>1?1:b,T=et(q),C=L(S),U=2*C;return N=U*A(T/3)-x/3,m=U*A((T+X)/3)-x/3,k=U*A((T+2*X)/3)-x/3,[N,m,k].filter(o)}else{if(E===0)return O=M<0?L(-M):-L(M),N=2*O-x/3,m=-O-x/3,[N,m].filter(o);{const d=P(E);return O=L(-M+d),_=L(M+d),[O-_-x/3].filter(o)}}},droots:function(s){if(s.length===3){const n=s[0],e=s[1],i=s[2],o=n-2*e+i;if(o!==0){const c=-P(e*e-n*i),r=-n+e,u=-(c+r)/o,f=-(-c+r)/o;return[u,f]}else if(e!==i&&o===0)return[(2*e-i)/(2*(e-i))];return[]}if(s.length===2){const n=s[0],e=s[1];return n!==e?[n/(n-e)]:[]}return[]},curvature:function(s,n,e,i,o){let c,r,u,f,a=0,x=0;const l=h.compute(s,n),y=h.compute(s,e),p=l.x*l.x+l.y*l.y;if(i?(c=P(j(l.y*y.z-y.y*l.z,2)+j(l.z*y.x-y.z*l.x,2)+j(l.x*y.y-y.x*l.y,2)),r=j(p+l.z*l.z,3/2)):(c=l.x*y.y-l.y*y.x,r=j(p,3/2)),c===0||r===0)return{k:0,r:0};if(a=c/r,x=r/c,!o){const g=h.curvature(s-.001,n,e,i,!0).k,v=h.curvature(s+.001,n,e,i,!0).k;f=(v-a+(a-g))/2,u=(R(v-a)+R(a-g))/2}return{k:a,r:x,dk:f,adk:u}},inflections:function(s){if(s.length<4)return[];const n=h.align(s,{p1:s[0],p2:s.slice(-1)[0]}),e=n[2].x*n[1].y,i=n[3].x*n[1].y,o=n[1].x*n[2].y,c=n[3].x*n[2].y,r=18*(-3*e+2*i+3*o-c),u=18*(3*e-i-3*o),f=18*(o-e);if(h.approximately(r,0)){if(!h.approximately(u,0)){let y=-f/u;if(0<=y&&y<=1)return[y]}return[]}const a=2*r;if(h.approximately(a,0))return[];const x=u*u-4*r*f;if(x<0)return[];const l=Math.sqrt(x);return[(l-u)/a,-(u+l)/a].filter(function(y){return 0<=y&&y<=1})},bboxoverlap:function(s,n){const e=["x","y"],i=e.length;for(let o=0,c,r,u,f;o<i;o++)if(c=e[o],r=s[c].mid,u=n[c].mid,f=(s[c].size+n[c].size)/2,R(r-u)>=f)return!1;return!0},expandbox:function(s,n){n.x.min<s.x.min&&(s.x.min=n.x.min),n.y.min<s.y.min&&(s.y.min=n.y.min),n.z&&n.z.min<s.z.min&&(s.z.min=n.z.min),n.x.max>s.x.max&&(s.x.max=n.x.max),n.y.max>s.y.max&&(s.y.max=n.y.max),n.z&&n.z.max>s.z.max&&(s.z.max=n.z.max),s.x.mid=(s.x.min+s.x.max)/2,s.y.mid=(s.y.min+s.y.max)/2,s.z&&(s.z.mid=(s.z.min+s.z.max)/2),s.x.size=s.x.max-s.x.min,s.y.size=s.y.max-s.y.min,s.z&&(s.z.size=s.z.max-s.z.min)},pairiteration:function(s,n,e){const i=s.bbox(),o=n.bbox(),c=1e5,r=e||.5;if(i.x.size+i.y.size<r&&o.x.size+o.y.size<r)return[(c*(s._t1+s._t2)/2|0)/c+"/"+(c*(n._t1+n._t2)/2|0)/c];let u=s.split(.5),f=n.split(.5),a=[{left:u.left,right:f.left},{left:u.left,right:f.right},{left:u.right,right:f.right},{left:u.right,right:f.left}];a=a.filter(function(l){return h.bboxoverlap(l.left.bbox(),l.right.bbox())});let x=[];return a.length===0||(a.forEach(function(l){x=x.concat(h.pairiteration(l.left,l.right,r))}),x=x.filter(function(l,y){return x.indexOf(l)===y})),x},getccenter:function(s,n,e){const i=n.x-s.x,o=n.y-s.y,c=e.x-n.x,r=e.y-n.y,u=i*A($)-o*F($),f=i*F($)+o*A($),a=c*A($)-r*F($),x=c*F($)+r*A($),l=(s.x+n.x)/2,y=(s.y+n.y)/2,p=(n.x+e.x)/2,g=(n.y+e.y)/2,v=l+u,M=y+f,E=p+a,O=g+x,_=h.lli8(l,y,v,M,p,g,E,O),N=h.dist(_,s);let m=I(s.y-_.y,s.x-_.x),k=I(n.y-_.y,n.x-_.x),d=I(e.y-_.y,e.x-_.x),z;return m<d?((m>k||k>d)&&(m+=X),m>d&&(z=d,d=m,m=z)):d<k&&k<m?(z=d,d=m,m=z):d+=X,_.s=m,_.e=d,_.r=N,_},numberSort:function(s,n){return s-n}};class G{constructor(n){this.curves=[],this._3d=!1,n&&(this.curves=n,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map(function(n){return h.pointsToString(n.points)}).join(", ")+"]"}addCurve(n){this.curves.push(n),this._3d=this._3d||n._3d}length(){return this.curves.map(function(n){return n.length()}).reduce(function(n,e){return n+e})}curve(n){return this.curves[n]}bbox(){const n=this.curves;for(var e=n[0].bbox(),i=1;i<n.length;i++)h.expandbox(e,n[i].bbox());return e}offset(n){const e=[];return this.curves.forEach(function(i){e.push(...i.offset(n))}),new G(e)}}const{abs:J,min:Z,max:H,cos:st,sin:ot,acos:ct,sqrt:D}=Math,ut=Math.PI;class w{constructor(n){let e=n&&n.forEach?n:Array.from(arguments).slice(),i=!1;if(typeof e[0]=="object"){i=e.length;const p=[];e.forEach(function(g){["x","y","z"].forEach(function(v){typeof g[v]<"u"&&p.push(g[v])})}),e=p}let o=!1;const c=e.length;if(i){if(i>4){if(arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");o=!0}}else if(c!==6&&c!==8&&c!==9&&c!==12&&arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");const r=this._3d=!o&&(c===9||c===12)||n&&n[0]&&typeof n[0].z<"u",u=this.points=[];for(let p=0,g=r?3:2;p<c;p+=g){var f={x:e[p],y:e[p+1]};r&&(f.z=e[p+2]),u.push(f)}const a=this.order=u.length-1,x=this.dims=["x","y"];r&&x.push("z"),this.dimlen=x.length;const l=h.align(u,{p1:u[0],p2:u[a]}),y=h.dist(u[0],u[a]);this._linear=l.reduce((p,g)=>p+J(g.y),0)<y/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(n,e,i,o){if(typeof o>"u"&&(o=.5),o===0)return new w(e,e,i);if(o===1)return new w(n,e,e);const c=w.getABC(2,n,e,i,o);return new w(n,c.A,i)}static cubicFromPoints(n,e,i,o,c){typeof o>"u"&&(o=.5);const r=w.getABC(3,n,e,i,o);typeof c>"u"&&(c=h.dist(e,r.C));const u=c*(1-o)/o,f=h.dist(n,i),a=(i.x-n.x)/f,x=(i.y-n.y)/f,l=c*a,y=c*x,p=u*a,g=u*x,v={x:e.x-l,y:e.y-y},M={x:e.x+p,y:e.y+g},E=r.A,O={x:E.x+(v.x-E.x)/(1-o),y:E.y+(v.y-E.y)/(1-o)},_={x:E.x+(M.x-E.x)/o,y:E.y+(M.y-E.y)/o},N={x:n.x+(O.x-n.x)/o,y:n.y+(O.y-n.y)/o},m={x:i.x+(_.x-i.x)/(1-o),y:i.y+(_.y-i.y)/(1-o)};return new w(n,N,m,i)}static getUtils(){return h}getUtils(){return w.getUtils()}static get PolyBezier(){return G}valueOf(){return this.toString()}toString(){return h.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const n=this.points,e=n[0].x,i=n[0].y,o=["M",e,i,this.order===2?"Q":"C"];for(let c=1,r=n.length;c<r;c++)o.push(n[c].x),o.push(n[c].y);return o.join(" ")}setRatios(n){if(n.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=n,this._lut=[]}verify(){const n=this.coordDigest();n!==this._print&&(this._print=n,this.update())}coordDigest(){return this.points.map(function(n,e){return""+e+n.x+n.y+(n.z?n.z:0)}).join("")}update(){this._lut=[],this.dpoints=h.derive(this.points,this._3d),this.computedirection()}computedirection(){const n=this.points,e=h.angle(n[0],n[this.order],n[1]);this.clockwise=e>0}length(){return h.length(this.derivative.bind(this))}static getABC(n=2,e,i,o,c=.5){const r=h.projectionratio(c,n),u=1-r,f={x:r*e.x+u*o.x,y:r*e.y+u*o.y},a=h.abcratio(c,n);return{A:{x:i.x+(i.x-f.x)/a,y:i.y+(i.y-f.y)/a},B:i,C:f,S:e,E:o}}getABC(n,e){e=e||this.get(n);let i=this.points[0],o=this.points[this.order];return w.getABC(this.order,i,e,o,n)}getLUT(n){if(this.verify(),n=n||100,this._lut.length===n+1)return this._lut;this._lut=[],n++,this._lut=[];for(let e=0,i,o;e<n;e++)o=e/(n-1),i=this.compute(o),i.t=o,this._lut.push(i);return this._lut}on(n,e){e=e||5;const i=this.getLUT(),o=[];for(let c=0,r,u=0;c<i.length;c++)r=i[c],h.dist(r,n)<e&&(o.push(r),u+=c/i.length);return o.length?t/=o.length:!1}project(n){const e=this.getLUT(),i=e.length-1,o=h.closest(e,n),c=o.mpos,r=(c-1)/i,u=(c+1)/i,f=.1/i;let a=o.mdist,x=r,l=x,y;a+=1;for(let p;x<u+f;x+=f)y=this.compute(x),p=h.dist(n,y),p<a&&(a=p,l=x);return l=l<0?0:l>1?1:l,y=this.compute(l),y.t=l,y.d=a,y}get(n){return this.compute(n)}point(n){return this.points[n]}compute(n){return this.ratios?h.computeWithRatios(n,this.points,this.ratios,this._3d):h.compute(n,this.points,this._3d,this.ratios)}raise(){const n=this.points,e=[n[0]],i=n.length;for(let o=1,c,r;o<i;o++)c=n[o],r=n[o-1],e[o]={x:(i-o)/i*c.x+o/i*r.x,y:(i-o)/i*c.y+o/i*r.y};return e[i]=n[i-1],new w(e)}derivative(n){return h.compute(n,this.dpoints[0],this._3d)}dderivative(n){return h.compute(n,this.dpoints[1],this._3d)}align(){let n=this.points;return new w(h.align(n,{p1:n[0],p2:n[n.length-1]}))}curvature(n){return h.curvature(n,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return h.inflections(this.points)}normal(n){return this._3d?this.__normal3(n):this.__normal2(n)}__normal2(n){const e=this.derivative(n),i=D(e.x*e.x+e.y*e.y);return{t:n,x:-e.y/i,y:e.x/i}}__normal3(n){const e=this.derivative(n),i=this.derivative(n+.01),o=D(e.x*e.x+e.y*e.y+e.z*e.z),c=D(i.x*i.x+i.y*i.y+i.z*i.z);e.x/=o,e.y/=o,e.z/=o,i.x/=c,i.y/=c,i.z/=c;const r={x:i.y*e.z-i.z*e.y,y:i.z*e.x-i.x*e.z,z:i.x*e.y-i.y*e.x},u=D(r.x*r.x+r.y*r.y+r.z*r.z);r.x/=u,r.y/=u,r.z/=u;const f=[r.x*r.x,r.x*r.y-r.z,r.x*r.z+r.y,r.x*r.y+r.z,r.y*r.y,r.y*r.z-r.x,r.x*r.z-r.y,r.y*r.z+r.x,r.z*r.z];return{t:n,x:f[0]*e.x+f[1]*e.y+f[2]*e.z,y:f[3]*e.x+f[4]*e.y+f[5]*e.z,z:f[6]*e.x+f[7]*e.y+f[8]*e.z}}hull(n){let e=this.points,i=[],o=[],c=0;for(o[c++]=e[0],o[c++]=e[1],o[c++]=e[2],this.order===3&&(o[c++]=e[3]);e.length>1;){i=[];for(let r=0,u,f=e.length-1;r<f;r++)u=h.lerp(n,e[r],e[r+1]),o[c++]=u,i.push(u);e=i}return o}split(n,e){if(n===0&&e)return this.split(e).left;if(e===1)return this.split(n).right;const i=this.hull(n),o={left:this.order===2?new w([i[0],i[3],i[5]]):new w([i[0],i[4],i[7],i[9]]),right:this.order===2?new w([i[5],i[4],i[2]]):new w([i[9],i[8],i[6],i[3]]),span:i};return o.left._t1=h.map(0,0,1,this._t1,this._t2),o.left._t2=h.map(n,0,1,this._t1,this._t2),o.right._t1=h.map(n,0,1,this._t1,this._t2),o.right._t2=h.map(1,0,1,this._t1,this._t2),e?(e=h.map(e,n,1,0,1),o.right.split(e).left):o}extrema(){const n={};let e=[];return this.dims.forEach((function(i){let o=function(r){return r[i]},c=this.dpoints[0].map(o);n[i]=h.droots(c),this.order===3&&(c=this.dpoints[1].map(o),n[i]=n[i].concat(h.droots(c))),n[i]=n[i].filter(function(r){return r>=0&&r<=1}),e=e.concat(n[i].sort(h.numberSort))}).bind(this)),n.values=e.sort(h.numberSort).filter(function(i,o){return e.indexOf(i)===o}),n}bbox(){const n=this.extrema(),e={};return this.dims.forEach((function(i){e[i]=h.getminmax(this,i,n[i])}).bind(this)),e}overlaps(n){const e=this.bbox(),i=n.bbox();return h.bboxoverlap(e,i)}offset(n,e){if(typeof e<"u"){const i=this.get(n),o=this.normal(n),c={c:i,n:o,x:i.x+o.x*e,y:i.y+o.y*e};return this._3d&&(c.z=i.z+o.z*e),c}if(this._linear){const i=this.normal(0),o=this.points.map(function(c){const r={x:c.x+n*i.x,y:c.y+n*i.y};return c.z&&i.z&&(r.z=c.z+n*i.z),r});return[new w(o)]}return this.reduce().map(function(i){return i._linear?i.offset(n)[0]:i.scale(n)})}simple(){if(this.order===3){const o=h.angle(this.points[0],this.points[3],this.points[1]),c=h.angle(this.points[0],this.points[3],this.points[2]);if(o>0&&c<0||o<0&&c>0)return!1}const n=this.normal(0),e=this.normal(1);let i=n.x*e.x+n.y*e.y;return this._3d&&(i+=n.z*e.z),J(ct(i))<ut/3}reduce(){let n,e=0,i=0,o=.01,c,r=[],u=[],f=this.extrema().values;for(f.indexOf(0)===-1&&(f=[0].concat(f)),f.indexOf(1)===-1&&f.push(1),e=f[0],n=1;n<f.length;n++)i=f[n],c=this.split(e,i),c._t1=e,c._t2=i,r.push(c),e=i;return r.forEach(function(a){for(e=0,i=0;i<=1;)for(i=e+o;i<=1+o;i+=o)if(c=a.split(e,i),!c.simple()){if(i-=o,J(e-i)<o)return[];c=a.split(e,i),c._t1=h.map(e,0,1,a._t1,a._t2),c._t2=h.map(i,0,1,a._t1,a._t2),u.push(c),e=i;break}e<1&&(c=a.split(e,1),c._t1=h.map(e,0,1,a._t1,a._t2),c._t2=a._t2,u.push(c))}),u}translate(n,e,i){i=typeof i=="number"?i:e;const o=this.order;let c=this.points.map((r,u)=>(1-u/o)*e+u/o*i);return new w(this.points.map((r,u)=>({x:r.x+n.x*c[u],y:r.y+n.y*c[u]})))}scale(n){const e=this.order;let i=!1;if(typeof n=="function"&&(i=n),i&&e===2)return this.raise().scale(i);const o=this.clockwise,c=this.points;if(this._linear)return this.translate(this.normal(0),i?i(0):n,i?i(1):n);const r=i?i(0):n,u=i?i(1):n,f=[this.offset(0,10),this.offset(1,10)],a=[],x=h.lli4(f[0],f[0].c,f[1],f[1].c);if(!x)throw new Error("cannot scale this curve. Try reducing it first.");return[0,1].forEach(function(l){const y=a[l*e]=h.copy(c[l*e]);y.x+=(l?u:r)*f[l].n.x,y.y+=(l?u:r)*f[l].n.y}),i?([0,1].forEach(function(l){if(!(e===2&&l)){var y=c[l+1],p={x:y.x-x.x,y:y.y-x.y},g=i?i((l+1)/e):n;i&&!o&&(g=-g);var v=D(p.x*p.x+p.y*p.y);p.x/=v,p.y/=v,a[l+1]={x:y.x+g*p.x,y:y.y+g*p.y}}}),new w(a)):([0,1].forEach(l=>{if(e===2&&l)return;const y=a[l*e],p=this.derivative(l),g={x:y.x+p.x,y:y.y+p.y};a[l+1]=h.lli4(y,g,x,c[l+1])}),new w(a))}outline(n,e,i,o){if(e=e===void 0?n:e,this._linear){const m=this.normal(0),k=this.points[0],d=this.points[this.points.length-1];let z,S,b;i===void 0&&(i=n,o=e),z={x:k.x+m.x*n,y:k.y+m.y*n},b={x:d.x+m.x*i,y:d.y+m.y*i},S={x:(z.x+b.x)/2,y:(z.y+b.y)/2};const q=[z,S,b];z={x:k.x-m.x*e,y:k.y-m.y*e},b={x:d.x-m.x*o,y:d.y-m.y*o},S={x:(z.x+b.x)/2,y:(z.y+b.y)/2};const T=[b,S,z],C=h.makeline(T[2],q[0]),U=h.makeline(q[2],T[0]),tt=[C,new w(q),U,new w(T)];return new G(tt)}const c=this.reduce(),r=c.length,u=[];let f=[],a,x=0,l=this.length();const y=typeof i<"u"&&typeof o<"u";function p(m,k,d,z,S){return function(b){const q=z/d,T=(z+S)/d,C=k-m;return h.map(b,0,1,m+q*C,m+T*C)}}c.forEach(function(m){const k=m.length();y?(u.push(m.scale(p(n,i,l,x,k))),f.push(m.scale(p(-e,-o,l,x,k)))):(u.push(m.scale(n)),f.push(m.scale(-e))),x+=k}),f=f.map(function(m){return a=m.points,a[3]?m.points=[a[3],a[2],a[1],a[0]]:m.points=[a[2],a[1],a[0]],m}).reverse();const g=u[0].points[0],v=u[r-1].points[u[r-1].points.length-1],M=f[r-1].points[f[r-1].points.length-1],E=f[0].points[0],O=h.makeline(M,g),_=h.makeline(v,E),N=[O].concat(u).concat([_]).concat(f);return new G(N)}outlineshapes(n,e,i){e=e||n;const o=this.outline(n,e).curves,c=[];for(let r=1,u=o.length;r<u/2;r++){const f=h.makeshape(o[r],o[u-r],i);f.startcap.virtual=r>1,f.endcap.virtual=r<u/2-1,c.push(f)}return c}intersects(n,e){return n?n.p1&&n.p2?this.lineIntersects(n):(n instanceof w&&(n=n.reduce()),this.curveintersects(this.reduce(),n,e)):this.selfintersects(e)}lineIntersects(n){const e=Z(n.p1.x,n.p2.x),i=Z(n.p1.y,n.p2.y),o=H(n.p1.x,n.p2.x),c=H(n.p1.y,n.p2.y);return h.roots(this.points,n).filter(r=>{var u=this.get(r);return h.between(u.x,e,o)&&h.between(u.y,i,c)})}selfintersects(n){const e=this.reduce(),i=e.length-2,o=[];for(let c=0,r,u,f;c<i;c++)u=e.slice(c,c+1),f=e.slice(c+2),r=this.curveintersects(u,f,n),o.push(...r);return o}curveintersects(n,e,i){const o=[];n.forEach(function(r){e.forEach(function(u){r.overlaps(u)&&o.push({left:r,right:u})})});let c=[];return o.forEach(function(r){const u=h.pairiteration(r.left,r.right,i);u.length>0&&(c=c.concat(u))}),c}arcs(n){return n=n||.5,this._iterate(n,[])}_error(n,e,i,o){const c=(o-i)/4,r=this.get(i+c),u=this.get(o-c),f=h.dist(n,e),a=h.dist(n,r),x=h.dist(n,u);return J(a-f)+J(x-f)}_iterate(n,e){let i=0,o=1,c;do{c=0,o=1;let r=this.get(i),u,f,a,x,l=!1,y=!1,p,g=o,v=1;do if(y=l,x=a,g=(i+o)/2,u=this.get(g),f=this.get(o),a=h.getccenter(r,u,f),a.interval={start:i,end:o},l=this._error(a,r,i,o)<=n,p=y&&!l,p||(v=o),l){if(o>=1){if(a.interval.end=v=1,x=a,o>1){let E={x:a.x+a.r*st(a.e),y:a.y+a.r*ot(a.e)};a.e+=h.angle({x:a.x,y:a.y},E,this.get(1))}break}o=o+(o-i)/2}else o=g;while(!p&&c++<100);if(c>=100)break;x=x||a,e.push(x),i=v}while(o<1);return e}}const mt=(s,n,e=0)=>{if(Number.isNaN(e))throw new Error("bend is NaN");if(e<-1||e>1)throw new Error("Expects bend range of -1 to 1");const i=V(.5,s,n);let o=i;n.y<s.y?o=e>0?{x:Math.min(s.x,n.x),y:Math.min(s.y,n.y)}:{x:Math.max(s.x,n.x),y:Math.max(s.y,n.y)}:o=e>0?{x:Math.max(s.x,n.x),y:Math.min(s.y,n.y)}:{x:Math.min(s.x,n.x),y:Math.max(s.y,n.y)};const c=V(Math.abs(e),i,o);return lt(s,n,c)},dt=s=>{const n=Q(s)?new w(s.a.x,s.a.y,s.cubic1.x,s.cubic1.y,s.cubic2.x,s.cubic2.y,s.b.x,s.b.y):new w(s.a,s.quadratic,s.b);return e=>n.compute(e)},ft=(s,n,e)=>[`M ${s.x} ${s.y} Q ${e.x} ${e.y} ${n.x} ${n.y}`],gt=s=>{if(Q(s))return at(s);if(nt(s))return ht(s);throw new Error("Unknown bezier type")},zt=(s,n,e,i)=>({a:Object.freeze(s),b:Object.freeze(n),cubic1:Object.freeze(e),cubic2:Object.freeze(i)}),at=s=>{const{a:n,cubic1:e,cubic2:i,b:o}=s,c=new w(n,e,i,o);return Object.freeze({...s,length:()=>c.length(),interpolate:r=>c.compute(r),nearest:r=>{throw new Error("not implemented")},bbox:()=>{const{x:r,y:u}=c.bbox(),f=r.size,a=u.size;if(f===void 0)throw new Error("x.size not present on calculated bbox");if(a===void 0)throw new Error("x.size not present on calculated bbox");return K({x:r.min,y:u.min},f,a)},relativePosition:(r,u)=>{throw new Error("Not implemented")},distanceToPoint:r=>{throw new Error("Not implemented")},toSvgString:()=>["brrup"],kind:"bezier/cubic"})},lt=(s,n,e)=>({a:Object.freeze(s),b:Object.freeze(n),quadratic:Object.freeze(e)}),ht=s=>{const{a:n,b:e,quadratic:i}=s,o=new w(n,i,e);return Object.freeze({...s,length:()=>o.length(),interpolate:c=>o.compute(c),nearest:c=>{throw new Error("not implemented")},bbox:()=>{const{x:c,y:r}=o.bbox(),u=c.size,f=r.size;if(u===void 0)throw new Error("x.size not present on calculated bbox");if(f===void 0)throw new Error("x.size not present on calculated bbox");return K({x:c.min,y:r.min},u,f)},distanceToPoint:c=>{throw new Error("Not implemented")},relativePosition:(c,r)=>{throw new Error("Not implemented")},toString:()=>o.toString(),toSvgString:()=>ft(n,e,i),kind:"bezier/quadratic"})};export{lt as a,zt as c,dt as i,mt as q,gt as t};
