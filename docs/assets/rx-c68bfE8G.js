import{r as J,a as B,_ as j,i as H,b as X}from"./src-2eX6lIN8-VI_Nykma.js";import{c as $}from"./records-Cei7yF1D-C5ys4Q3F.js";import{i as K,w as Y,D as z,a as Z,b as F,s as Q,c as E,d as ee,e as R,t as h,n as te,f as ne,g as _,h as re,j as T}from"./src-CURfSkGx-Bgs9tt00.js";import{c as V,g as se,u as oe}from"./src-DUdYWbDU-DVRE-5Mg.js";function ie(t){return t.value!==void 0?!1:"signal"in t&&t.signal!==void 0}function ae(t){return t.value!==void 0?!1:"signal"in t&&t.signal==="done"}function D(t){return t.value!==void 0}const O=t=>typeof t!="object"||t===null?!1:"on"in t&&"onValue"in t,le=t=>O(t)?"set"in t:!1,ce=t=>!(typeof t!="object"||!("source"in t)||!("annotate"in t));function N(t,e={}){const r=e.maximumRepeats??Number.MAX_SAFE_INTEGER,n=e.closeOnError??!0,s=e.interval?E(e.interval):-1;let o=e.manual??!1;if(e.interval===void 0&&e.manual===void 0&&(o=!0),o&&e.interval)throw new Error("If option 'manual' is set, option 'interval' cannot be used");const a=E(e.predelay,0),c=e.lazy??"very",d=e.signal,u=new AbortController,f=p=>{u.abort(p)};let b=0,y=!1;const g=p=>{v.dispose(p),y=!1,l&&l.cancel()},i=async()=>{if(!y)return!1;if(a&&await ne(a),b>=r)return g(`Maximum repeats reached ${r.toString()}`),!1;try{if(d?.aborted)return g(`Signal (${d.aborted})`),!1;const p=await t(f);return b++,v.set(p),!0}catch(p){return n?(g(`Function error: ${_(p)}`),!1):(v.signal("warn",_(p)),!0)}},l=o?void 0:R(async()=>{if(!await i())return!1;if(u.signal.aborted)return g(`callback function aborted (${u.signal.reason})`),!1},s),v=w({lazy:c,onStart(){y=!0,l&&l.start()},onStop(){y=!1,l&&l.cancel()}});return c==="never"&&l&&l.start(),{...v,ping:i}}function L(t,e={}){const r=e.lazy??"very",n=e.traceLifecycle?g=>{console.log(`Rx.From.iterator ${g}`)}:g=>{},s=E(e.readInterval,5),o=E(e.readTimeout,300*1e3),a=e.whenStopped??"continue";let c,d,u=ee({idle:["wait_for_next"],wait_for_next:["processing_result","stopping","disposed"],processing_result:["queued","disposed","stopping"],queued:["wait_for_next","disposed","stopping"],stopping:"idle",disposed:null},"idle");const f=()=>{n("onExternalSignal"),d?.abort(e.signal?.reason)};e.signal&&e.signal.addEventListener("abort",f,{once:!0});const b=async()=>{n(`read. State: ${u.value}`),d=new AbortController;try{u=h(u,"wait_for_next");const g=await te(c,{signal:d.signal,millis:o});if(u=h(u,"processing_result"),d.abort("nextWithTimeout completed"),g.done&&(n("read v.done true"),y.dispose("Generator complete"),u=h(u,"disposed")),u.value==="stopping"){n("read. sm.value = stopping"),u=h(u,"idle");return}if(u.value==="disposed"){n("read. sm.value = disposed");return}y.set(g.value)}catch(g){y.dispose(`Generator error: ${g.toString()}`);return}u.value==="processing_result"?(u=h(u,"queued"),n(`scheduling read. State: ${u.value}`),setTimeout(b,s)):u=h(u,"idle")},y=w({...e,lazy:r,onStart(){n(`onStart state: ${u.value} whenStopped: ${a}`),u.value==="idle"&&((u.value==="idle"&&a==="reset"||c===void 0)&&(c=F(t)?t[Symbol.asyncIterator]():t[Symbol.iterator]()),b())},onStop(){n(`onStop state: ${u.value} whenStopped: ${a}`),u=h(u,"stopping"),a==="reset"&&(n("onStop reiniting iterator"),c=F(t)?t[Symbol.asyncIterator]():t[Symbol.iterator]())},onDispose(g){n(`onDispose (${g})`),d?.abort(`Rx.From.iterator disposed (${g})`),e.signal&&e.signal.removeEventListener("abort",f)}});return y}const I=(t,e={})=>{if(O(t))return t;const r=e.generator??{lazy:"initial",interval:5},n=e.function??{lazy:"very"};if(Array.isArray(t))return L(t.values(),r);if(typeof t=="function")return N(t,n);if(typeof t=="object"){if(ce(t))return t.source;if(Z(t)||F(t))return L(t,r)}throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${typeof t}`)};function ue(t,e){let r=e;return t.onValue(n=>{r=n}),{...t,last(){return r},resetCachedValue(){r=void 0}}}function k(t,e){const r=e.lazy??"initial",n=e.disposeIfSourceDone??!0,s=e.onValue??(b=>{}),o=I(t);let a;const c=e.debugLabel?`[${e.debugLabel}]`:"",d=()=>{a!==void 0&&(a(),a=void 0,e.onStop&&e.onStop())},f=w({...e,lazy:r,onStart:()=>{a===void 0&&(e.onStart&&e.onStart(),a=o.on(b=>{ie(b)?b.signal==="done"?(d(),f.signal(b.signal,b.context),n&&f.dispose(`Upstream source ${c} has completed (${b.context??""})`)):f.signal(b.signal,b.context):D(b)&&s(b.value)}))},onStop:d});return f}function w(t){const e=t.lazy??"initial",r=t.onStop??(()=>{}),n=t.onStart??(()=>{});t.debugLabel&&`${t.debugLabel}`;const s=S({...t,onFirstSubscribe(){e!=="never"&&n()},onNoSubscribers(){e==="very"&&r()}});return e==="never"&&n(),s}function S(t={}){let e,r=!1,n=!1,s=!0;const o=t.onFirstSubscribe??void 0,a=t.onNoSubscribers??void 0,c=t.debugLabel?`[${t.debugLabel}]`:"",d=()=>{e!==void 0&&e.isEmpty&&(s||(s=!0,n=!1,a&&a()))},u=f=>{if(r)throw new Error(`Disposed, cannot subscribe ${c}`);e===void 0&&(e=new z);const b=e.add(f);return s=!1,n||(n=!0,o&&o()),()=>{e?.remove(b),d()}};return{dispose:f=>{r||(e?.notify({value:void 0,signal:"done",context:`Disposed: ${f}`}),r=!0,t.onDispose&&t.onDispose(f))},isDisposed:()=>r,removeAllSubscribers:()=>{e?.clear(),d()},set:f=>{if(r)throw new Error(`${c} Disposed, cannot set`);e?.notify({value:f})},signal:(f,b)=>{if(r)throw new Error(`${c} Disposed, cannot signal`);e?.notify({signal:f,value:void 0,context:b})},on:f=>u(f),onValue:f=>u(y=>{D(y)&&f(y.value)})}}const fe=t=>({on:t.on,dispose:t.dispose,isDisposed:t.isDisposed,onValue:t.onValue});function A(t,e={}){const r=e.eq??K,n=S(),s=S(),o=[];let a=t,c=!1;const d=i=>{const l=[...V(a??{},i,{...e,includeMissingFromA:!0})];l.length!==0&&(a=i,n.set(i),s.set(l))},u=(i,l)=>{for(const[v,p,m]of o)v(i)&&m.notify({fieldName:i,pattern:p,value:l})},f={asPartial:!0,includeParents:!0},b=i=>{if(a===void 0){a=i,n.set(a);for(const[l,v]of Object.entries(i))u(l,v);return a}else{const l=[...V(a,i,f)];if(l.length===0)return a;a={...a,...i},n.set(a),s.set(l);for(const v of l)u(v.path,v.value);return a}};return{dispose:i=>{c||(s.dispose(i),n.dispose(i),c=!0)},isDisposed(){return c},updateField:(i,l)=>{if(a===void 0)throw new Error("Cannot update value when it has not already been set");const v=se(a,i);if(J(v))throw B(v);if(r(v.value,l,i))return;let p=[...V(v.value,l,{...e,includeMissingFromA:!0})];p=p.map(x=>x.path.length>0?{...x,path:i+"."+x.path}:{...x,path:i});const m=oe(a,i,l,!0);a=m,n.set(m),s.set(p),u(i,l)},last:()=>a,on:n.on,onValue:n.onValue,onDiff:s.onValue,onField(i,l){const v=Y(i),p=new z;o.push([v,i,p]);const m=p.add(l);return()=>p.remove(m)},set:d,update:b}}function de(t,e={}){const r=e.disposeSources??!0,n=A(void 0),s=e.onSourceDone??"break",o=e.emitInitial??!0;let a=!1;const c=new Map;for(const[i,l]of Object.entries(t)){const v="last"in l?l.last():void 0,p={source:I(l),done:!1,data:v,off:()=>{}};c.set(i,p)}const d=Object.fromEntries(Object.entries(c).map(i=>[i[0],i[1].source])),u=()=>Q(c,i=>!i.done),f=()=>{for(const i of c.values())i.off()},b=()=>{const i={};for(const[l,v]of c)v.data!==void 0&&(i[l]=v.data);return i},y=()=>{a=!0;const i=b();n.set(i)},g=i=>{i.off=i.source.on(l=>{if(ae(l)){if(i.done=!0,i.off(),i.off=()=>{},s==="break"){f(),n.dispose("Source has completed and 'break' is behaviour");return}u()||(f(),n.dispose("All sources completed"))}else D(l)&&(i.data=l.value,y())})};for(const i of c.values())g(i);return!a&&o&&y(),{...n,hasSource(i){return c.has(i)},replaceSource(i,l){const v=c.get(i);if(v===void 0)throw new Error(`Field does not exist: '${i}'`);v.off();const p=I(l);v.source=p,g(v)},setWith(i){const l={};for(const[v,p]of Object.entries(i)){const m=c.get(v);m!==void 0&&(le(m.source)&&(m.source.set(p),l[v]=p),m.data=p)}return l},sources:d,last(){return b()},dispose(i){if(f(),n.dispose(i),r)for(const l of c.values())l.source.dispose("Part of disposed mergeToObject")}}}function ve(t,e,r={}){const n=r.fallbackFieldValue,s=r.fallbackObject,o=k(t,{disposeIfSourceDone:!0,...r,onValue(a){let c;e in a?c=a[e]:s&&e in s&&(c=s[e]),c===void 0&&(c=n),c!==void 0&&o.set(c)}});return fe(o)}const be=(t,e={})=>{if(Array.isArray(t))return q(t,e)},q=(t,e={})=>{const r=e.lazy??"initial",n=e.signal,s=e.whenStopped??"continue",o=e.debugLifecycle??!1,a=[...t];if(r!=="very"&&s==="reset")throw new Error(`whenStopped:'reset' has no effect with 'lazy:${r}'. Use lazy:'very' instead.`);const c=E(e.interval,5);let d=0,u=a[0];const f=w({...e,lazy:r,onStart(){o&&console.log("Rx.readFromArray:onStart"),b.start()},onStop(){o&&console.log(`Rx.readFromArray:onStop. whenStopped: ${s} index: ${d}`),b.cancel(),s==="reset"&&(d=0)}}),b=R(()=>{if(n?.aborted)return f.dispose(`Signalled (${n.reason})`),!1;if(u=a[d],d++,f.set(u),d===a.length)return f.dispose("Source array complete"),!1},c);return r||b.start(),{dispose:f.dispose,isDisposed:f.isDisposed,isDone(){return d===a.length},last(){return u},on:f.on,onValue:f.onValue}};function P(t=[],e={}){const r=e.eq??T,n=S(),s=S();let o=t,a=!1;const c=l=>{$(o,l,r),o=l,n.set([...l])},d=(l,v)=>{o[l]=v,n.set([...o])},u=l=>{o=[...o,l],n.set([...o]);const v=["add",o.length-1,l];s.set([v])},f=l=>{const v=X(o,l);if(v.length===o.length)return;const p=$(o,v,r);o=v,n.set([...o]),s.set(p.summary)},b=l=>{const v=o.filter(x=>!l(x)),p=o.length-v.length,m=$(o,v,r);return o=v,n.set([...o]),s.set(m.summary),p},y=(l,v)=>{const p=H(o,l,v),m=$(o,p,r);o=p,n.set([...o]),s.set(m.summary)};return{dispose:l=>{a||(n.dispose(l),a=!0)},isDisposed(){return a},last:()=>o,on:n.on,onArray:s.on,onValue:n.onValue,setAt:d,push:u,deleteAt:f,deleteWhere:b,insertAt:y,set:c}}function pe(t){let e=t;const r=S(),n=s=>{e=s,r.set(s)};return{dispose:r.dispose,isDisposed:r.isDisposed,last:()=>e,on:r.on,onValue:r.onValue,set:n}}function ge(t={}){const e=t.lazy??"initial",r=E(t.interval,1e3),n=t.amount??1,s=t.offset??0;let o=0,a=s;const c=f=>{u.dispose(f)},d=R(()=>{if(t.signal?.aborted)return c(`Aborted (${t.signal.reason})`),!1;if(u.set(a),a+=1,o++,o>=n)return c("Limit reached"),!1},r),u=w({onStart(){d.start()},onStop(){d.cancel()},onDispose(){d.cancel()},lazy:e});return u}function ye(t,e,r={}){const n=r.ignoreIdentical??!0,s=r.eq??T,o=de(e),a=u=>{const f=d.last(),b=t(u);if(b!==void 0){if(n&&f!==void 0&&s(b,f))return b;d.set(b)}return b},c=k(o,{...r,onValue(u){a(u)}}),d=ue(c,t(o.last()));return d}function me(t,e,r,n,s={}){const o={};return o[r]=n,ve(C(t,e,o,s),r,s)}function C(t,e,r,n={}){let s;if(typeof t=="string"){if(s=document.querySelector(t),s===null)throw new Error(`Target query did not resolve to an element. Query: '${t}'`)}else s=t;if(s===null)throw new Error("Param 'targetOrQuery' is null");const o=n.debugLifecycle??!1,a=n.debugFiring??!1;n.diff;const c=n.lazy??!1;r===void 0&&(r={});const d=A(r,{deepEntries:!0});let u=!1,f=!1;const b=i=>{a&&console.log(`Reactive.event '${e}' firing '${JSON.stringify(i)}`),d.set(i)},y=()=>{u&&(u=!1,s.removeEventListener(e,b),o&&console.log(`Rx.From.event remove '${e}'`))},g=()=>{u||(u=!0,s.addEventListener(e,b),o&&console.log(`Rx.From.event add '${e}'`))};return c||g(),{last:()=>(c&&g(),d.last()),dispose:i=>{f||(f=!0,y(),d.dispose(i))},isDisposed(){return f},on:i=>(c&&g(),d.on(i)),onValue:i=>(c&&g(),d.onValue(i))}}function Se(t,e,r={}){let n;if(typeof t=="string"){if(n=document.querySelector(t),n===null)throw new Error(`Target query did not resolve to an element. Query: '${t}'`)}else n=t;if(n===null)throw new Error("Param 'targetOrQuery' is null");const s=r.debugLifecycle??!1,o=r.debugFiring??!1,a=r.fireInitial??!1;let c=0;const d=re(),u=w({lazy:r.lazy??"very",onStart(){n.addEventListener(e,f),s&&console.log(`Rx.From.eventTrigger add '${e}'`),a&&c===0&&((s||o)&&console.log("Rx.From.eventTrigger: firing initial"),f())},onStop(){n.removeEventListener(e,f),s&&console.log(`Rx.From.eventTrigger remove '${e}'`)}}),f=b=>{o&&console.log(`Rx.From.eventTrigger '${e}' triggered'`),u.set({sinceLast:d(),total:++c})};return u}function he(...t){return W(t)}function W(t,e={}){let r=[];const n=w({...e,onStart(){for(const s of t)r.push(s.onValue(o=>{n.set(o)}))},onStop(){for(const s of r)s();r=[]}});return n}function we(t){let e=t;const r=S(),n=s=>{e=s,r.set(s)};return{dispose:r.dispose,isDisposed:r.isDisposed,last:()=>e,on:r.on,onValue:r.onValue,set:n}}const xe=Symbol("Rx"),M=t=>{const e=A(t);return{proxy:new Proxy(t,{set(n,s,o,a){const c=Array.isArray(n);if(c&&s==="length")return!0;if(typeof s=="string"&&e.updateField(s,o),c&&typeof s=="string"){const d=Number.parseInt(s);if(!Number.isNaN(d))return n[d]=o,!0}return n[s]=o,!0}}),rx:e}},Ee=t=>{const e=P(t);return{proxy:new Proxy(t,{set(n,s,o,a){if(s==="length")return!0;if(typeof s!="string")throw new Error(`Expected numeric index, got type: ${typeof s} value: ${JSON.stringify(s)}`);const c=Number.parseInt(s);if(Number.isNaN(c))throw new Error(`Expected numeric index, got: '${s}'`);return e.setAt(c,o),n[c]=o,!0}}),rx:e}},$e=t=>{const{proxy:e,rx:r}=M(t),n=e;return n[xe]=r,n};function De(t){const e=U(t);return{dispose:e.dispose,isDisposed:e.isDisposed,on:e.on,onValue:e.onValue}}function U(t){let e=()=>{};const r=G({onFirstSubscribe(){e=t(r)},onNoSubscribers(){e&&e()}});return{...r,onValue:n=>r.on(s=>{D(s)&&n(s.value)})}}function Ae(t){let e=t;const r=S(),n=s=>{e=s,r.set(s)};return{dispose:r.dispose,isDisposed:r.isDisposed,last:()=>e,on:r.on,onValue:r.onValue,set:n}}var Ve={};j(Ve,{array:()=>q,arrayObject:()=>P,arrayProxy:()=>Ee,boolean:()=>pe,count:()=>ge,derived:()=>ye,event:()=>C,eventField:()=>me,eventTrigger:()=>Se,func:()=>N,iterator:()=>L,merged:()=>he,mergedWithOptions:()=>W,number:()=>we,object:()=>A,objectProxy:()=>M,objectProxySymbol:()=>$e,observable:()=>De,observableWritable:()=>U,of:()=>be,string:()=>Ae});function Fe(t){const e=G({onNoSubscribers(){t.removeEventListener("removed",r),t.removeEventListener("enqueue",n)},onFirstSubscribe(){t.addEventListener("removed",r),t.addEventListener("enqueue",n),e.set(t.toArray())}}),r=o=>{e.set(o.finalData)},n=o=>{e.set(o.finalData)};return{...e,set:o=>{t.enqueue(...o)}}}var Le={};j(Le,{asResponsive:()=>Fe});function G(t={}){const e=S(t);return{dispose:e.dispose,isDisposed:e.isDisposed,set(r){e.set(r)},on:e.on,onValue:e.onValue}}export{de as c,Ve as f};
