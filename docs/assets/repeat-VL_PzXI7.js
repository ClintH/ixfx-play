import{i as d}from"./interval-type-CIaujdcR.js";import{s as b}from"./sleep-DwDBk_RX.js";const y=e=>typeof e!="object"||e===null?!1:"on"in e&&"onValue"in e,h=e=>y(e)?"last"in e&&e.last()!==void 0:!1;async function g(e,...n){if(typeof e=="object")if("next"in e){const r=e[Symbol.toStringTag];if(r==="Generator"||r=="Array Iterator"){const t=e.next();return"done"in t&&"value"in t?t.value:t}else if(r==="AsyncGenerator"){const t=await e.next();return"done"in t&&"value"in t?t.value:t}else throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${r}'`)}else if(y(e)){if(h(e))return e.last();throw new Error("Reactive does not have last value")}else return e;else return typeof e=="function"?await e(n):e}function S(e,...n){if(typeof e=="object")if("next"in e){const r=e[Symbol.toStringTag];if(r==="Generator"||r=="Array Iterator"){const t=e.next();return"done"in t&&"value"in t?t.value:t}else throw r==="AsyncGenerator"?new Error("resolveSync cannot work with an async generator"):new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${r}'`)}else if(y(e)){if(h(e))return e.last();throw new Error("Reactive does not have last value")}else return e;else return typeof e=="function"?e(n):e}async function*M(e,n){const r=n.signal??void 0,t=n.delayWhen??"before",f=n.count??void 0,i=n.allowUndefined??!1,o=n.delayMinimum?d(n.delayMinimum):void 0,l=n.while;let a=!1,u=d(n.delay,d(n.delayMinimum,0)),w=performance.now();const v=async()=>{const s=performance.now()-w;if(typeof o<"u"&&(u=Math.max(0,o-s)),u&&await b({millis:u,signal:r}),w=performance.now(),r?.aborted)throw new Error(`Signal aborted ${r.reason}`)};Array.isArray(e)&&(e=e.values()),n.onStart&&n.onStart();let m=!0,c=0;try{for(;!a;){c++,(t==="before"||t==="both")&&await v();const s=await g(e);typeof s>"u"&&!i?a=!0:(yield s,(t==="after"||t==="both")&&await v(),f!==void 0&&c>=f&&(a=!0)),l&&(l(c)||(a=!0))}m=!1}finally{a=!0,n.onComplete&&n.onComplete(m)}}function*E(e,n){const r=n.signal??void 0,t=n.count??void 0,f=n.allowUndefined??!1;let i=!1;Array.isArray(e)&&(e=e.values()),n.onStart&&n.onStart();let o=!0,l=0;try{for(;!i;){l++;const a=S(e);typeof a>"u"&&!f?i=!0:(yield a,t!==void 0&&l>=t&&(i=!0),r?.aborted&&(i=!0))}o=!1}finally{i=!0,n.onComplete&&n.onComplete(o)}}export{E as a,M as r};
