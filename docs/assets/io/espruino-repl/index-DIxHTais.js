import"../../modulepreload-polyfill-B5Qt9EMX.js";import{e as Ge}from"../../io-D4vlQEz_.js";import{l as vr}from"../../dom-DCcQsJJW.js";import{_ as y,m as ce,o as gr,c as l,p as G,s as mr,n as wr,g as We,r as R}from"../../src-BeVDUOoq-B6OoJ3p3.js";import{ai as f,ag as Je,aj as _,ak as br,ae as fe,a6 as Er,al as Vr,am as Sr,an as re,ao as Ue,ap as Mr,s as xr,aq as N,ar as Pr,as as kr,at as Cr,au as Ar,av as Qe,aw as Br,ax as Lr,ay as Ir,az as Rr,aA as Tr,aB as Xe,aC as Dr,aD as jr,ab as Nr,aE as He,aF as Fr,aG as qr,aH as Or,aI as Ze,aJ as Kr,aK as Gr,_ as X,k as T,aL as O,aM as te,aN as _r,c as $r,f as zr}from"../../src-C7XtfIer-DYL4nwfS.js";import"../../flow-2AOw9vu2.js";import"../../src-sHR31-XU-C1xj0KeO.js";import"../../dist-DE4H3J9W-BscYlIcj.js";var Wr=class Ye extends Array{#e;#t;constructor(t=0){super(),l(We(t,"positive","capacity")),this.#e=t,this.#t=0}add(t){const r=Ye.from(this);return r[this.#t]=t,r.#e=this.#e,this.#e>0?r.#t=this.#t+1===this.#e?0:this.#t+1:r.#t=this.#t+1,r}get pointer(){return this.#t}get isFull(){return this.#e===0?!1:this.length===this.#e}};const Jr=(e,t)=>{e.debug&&console.log(`queue:${t}`)},et=(e,t,r)=>{const n=t.length+r.length,s=e.capacity??n,i=n-s,o=e.discardPolicy??"additions";switch(o){case"additions":return t.length===0?r.slice(0,r.length-i):t.length===e.capacity?t:[...t,...r.slice(0,i-1)];case"newer":if(i>=t.length)return t.length===0?[...r.slice(0,s-1),r.at(-1)]:r.slice(Math.max(0,r.length-s),Math.min(r.length,s)+1);{const a=Math.max(1,r.length-t.length),u=r.slice(r.length-a,r.length);return[...t.slice(0,Math.min(t.length,s-1)),...u]}case"older":return[...t,...r].slice(i);default:throw new Error(`Unknown overflow policy ${o}`)}},de=(e,t,...r)=>{if(e===void 0)throw new Error("opts parameter undefined");const n=t.length+r.length,s=e.capacity&&n>e.capacity,i=s?et(e,t,r):[...t,...r];if(e.capacity&&i.length!==e.capacity&&s)throw new Error(`Bug! Expected return to be at capacity. Return len: ${i.length} capacity: ${e.capacity} opts: ${JSON.stringify(e)}`);if(!e.capacity&&i.length!==n)throw new Error(`Bug! Return length not expected. Return len: ${i.length} expected: ${n} opts: ${JSON.stringify(e)}`);return i},he=(e,t)=>{if(t.length===0)throw new Error("Queue is empty");return t.slice(1)},$=(e,t)=>t[0],pe=(e,t)=>t.length===0,ye=(e,t)=>e.capacity?t.length>=e.capacity:!1;var V=class extends X{options;data;eq;constructor(e={},t=[]){if(super(),e===void 0)throw new Error("opts parameter undefined");this.options=e,this.data=t,this.eq=e.eq??f}clear(){const e=[...this.data];this.data=[],this.fireEvent("removed",{finalData:this.data,removed:e}),this.onClear()}onClear(){}at(e){if(e>=this.data.length)throw new Error("Index outside bounds of queue");const t=this.data.at(e);if(t===void 0)throw new Error("Index appears to be outside range of queue");return t}enqueue(...e){this.data=de(this.options,this.data,...e);const t=this.data.length;return this.onEnqueue(this.data,e),t}onEnqueue(e,t){this.fireEvent("enqueue",{added:t,finalData:e})}dequeue(){const e=$(this.options,this.data);if(e!==void 0)return this.data=he(this.options,this.data),this.fireEvent("dequeue",{removed:e,finalData:this.data}),this.onRemoved([e],this.data),e}onRemoved(e,t){this.fireEvent("removed",{removed:e,finalData:t})}removeWhere(e){const t=this.data.length,r=this.data.filter(n=>e(n));return r.length===0?0:(this.data=this.data.filter(n=>!e(n)),this.onRemoved(r,this.data),t-this.data.length)}toArray(){return[...this.data]}get isEmpty(){return pe(this.options,this.data)}get isFull(){return ye(this.options,this.data)}get length(){return this.data.length}get peek(){return $(this.options,this.data)}};function Ur(e={},...t){return new V({...e},[...t])}const tt=(e,t,r)=>{const n=t.length+r.length,s=e.discardPolicy??"additions",i=e.capacity??n,o=n-i;switch(e.debug&&console.log(`Stack.push: stackLen: ${t.length} potentialLen: ${n} toRemove: ${o} policy: ${s}`),s){case"additions":return e.debug&&console.log(`Stack.push:DiscardAdditions: stackLen: ${t.length} slice: ${n-i} toAddLen: ${r.length}`),t.length===e.capacity?t:[...t,...r.slice(0,r.length-o)];case"newer":return o>=t.length?r.slice(Math.max(0,r.length-i),Math.min(r.length,i)+1):(e.debug&&console.log(` from orig: ${JSON.stringify(t.slice(0,t.length-o))}`),[...t.slice(0,t.length-o),...r.slice(0,Math.min(r.length,i-o+1))]);case"older":return[...t,...r].slice(o);default:throw new Error(`Unknown discard policy ${s}`)}},ve=(e,t,...r)=>{const n=t.length+r.length;return e.capacity&&n>e.capacity?tt(e,t,r):[...t,...r]},ge=(e,t)=>{if(t.length===0)throw new Error("Stack is empty");return t.slice(0,-1)},z=(e,t)=>t.at(-1),me=(e,t)=>t.length===0,we=(e,t)=>e.capacity?t.length>=e.capacity:!1;var B=class{opts;data;constructor(e={},t=[]){this.opts=e,this.data=t}push(...e){return e.length===0?this.data.length:(this.data=ve(this.opts,this.data,...e),this.data.length)}forEach(e){this.data.forEach(e)}forEachFromTop(e){[...this.data].reverse().forEach(e)}pop(){const e=z(this.opts,this.data);return this.data=ge(this.opts,this.data),e}get isEmpty(){return me(this.opts,this.data)}get isFull(){return we(this.opts,this.data)}get peek(){return z(this.opts,this.data)}get length(){return this.data.length}};const Qr=(e={},...t)=>new B({...e},[...t]),be=(e,t,r=Je,n)=>{const s=rt(e,t,r),i=Xr(e,t,r),o={valueChanged:!s,a:e,b:t,added:i.added,removed:i.removed,childChanged:!1},a={value:o,childrenStore:[],parent:n},u=i.identical.map(h=>be(h[0],h[1],r,a)),c=_e(o)||u.some(h=>_e(h.value));return pt(a,u),a.toString=()=>nt(a,0),a.value.childChanged=c,it(a),a},_e=e=>e===void 0?!1:!!(e.valueChanged||e.childChanged||e.added.length>0||e.removed.length>0),Xr=(e,t,r=Je)=>{const n=[...e.children()],s=[...t.children()],i=[],o=[];for(const u of n){let c=-1;for(const[h,m]of s.entries())if(rt(u,m,r)){i.push([u,m]),c=h;break}c===-1?o.push(u):s.splice(c,1)}return{added:[...s],identical:i,removed:o}},rt=(e,t,r)=>!!(e.getIdentity()===t.getIdentity()||r(e.getValue(),t.getValue())),K=e=>JSON.stringify(e.getValue()),nt=(e,t=0)=>{if(e===void 0)return"(undefined)";let r=Hr(e.value,t);for(const n of e.childrenStore)r+=nt(n,t+2);return r},Hr=(e,t)=>{const r=" ".repeat(t);if(e===void 0)return`${r}(undefined)`;const n=[];if(n.push(`a: ${K(e.a)} b: ${K(e.b)}`),e.valueChanged?n.push(`Value changed. Child changed: ${e.childChanged}`):n.push(`Value unchanged. Child changed: ${e.childChanged}`),e.added.length>0){n.push("Added:");for(const s of e.added)n.push(" - "+K(s))}if(e.removed.length>0){n.push(`Removed: ${e.removed.length}`);for(const s of e.removed)n.push(" - "+K(s))}return n.push(`----
`),n.map(s=>r+s).join(`
`)};var st={};y(st,{add:()=>ke,addValue:()=>J,asDynamicTraversable:()=>A,breadthFirst:()=>Se,children:()=>tn,childrenLength:()=>ln,childrenValues:()=>rn,compare:()=>Zr,computeMaxDepth:()=>an,createNode:()=>q,depthFirst:()=>en,findAnyChildByValue:()=>on,findChildByValue:()=>sn,findParentsValue:()=>lt,followValue:()=>yt,fromPlainObject:()=>dt,getRoot:()=>xe,hasAnyChild:()=>H,hasAnyParent:()=>W,hasChild:()=>ot,hasParent:()=>ct,nodeDepth:()=>nn,parents:()=>F,parentsValues:()=>ut,queryByValue:()=>at,queryParentsValue:()=>Pe,remove:()=>Ve,root:()=>Z,rootWrapped:()=>un,setChildren:()=>pt,stripParentage:()=>Ee,throwTreeTest:()=>it,toStringDeep:()=>Ce,treeTest:()=>Me,value:()=>cn,wrap:()=>w});const Zr=(e,t,r)=>be(A(e),A(t),r),Ee=e=>({value:e.value,childrenStore:e.childrenStore.map(r=>Ee(r))}),E=e=>"wraps"in e?e.wraps:e,Yr=e=>"wraps"in e?e:w(e),w=e=>({*children(){for(const t of e.childrenStore)yield w(t)},getValue:()=>e.value,getIdentity:()=>e,*queryValue(t){for(const r of at(t,E(e)))yield w(r)},*queryParentsValue(t,r,n){for(const s of Pe(E(t),r,n))yield w(s)},*parentsValues(t){yield*ut(E(t))},findParentsValue(t,r,n){const s=lt(t,r,n);if(s!==void 0)return w(s)},getParent:()=>e.parent===void 0?void 0:w(e.parent),hasParent:t=>ct(e,E(t)),hasAnyParent:t=>W(e,E(t)),hasChild:t=>ot(E(t),e),hasAnyChild:t=>H(E(t),e),remove:()=>{Ve(e)},addValue:t=>{const r=J(t,e);return w(r)},add:t=>(ke(E(t),e),Yr(t)),wraps:e}),Ve=e=>{const t=e.parent;t!==void 0&&(e.parent=void 0,t.childrenStore=ce(t.childrenStore,e))};function*en(e){if(!Z)return;const t=new B;t.push(...e.childrenStore);let r=t.pop();for(;r&&(yield r,r&&t.push(...r.childrenStore),!t.isEmpty);)r=t.pop()}function*Se(e){if(!e)return;const t=new V;t.enqueue(...e.childrenStore);let r=t.dequeue();for(;r&&(yield r,r&&t.enqueue(...r.childrenStore),!t.isEmpty);)r=t.dequeue()}function Me(e,t=[]){if(e.parent===e)return[!1,"Root has itself as parent",e];if(t.includes(e))return[!1,"Same node instance is appearing further in tree",e];if(t.push(e),gr(e.childrenStore))return[!1,"Children list contains duplicates",e];for(const r of e.childrenStore){if(r.parent!==e)return[!1,"Member of childrenStore does not have .parent set",r];if(H(e,r))return[!1,"Child has parent as its own child",r];const n=Me(r,t);if(!n[0])return n}return[!0,"",e]}function it(e){const t=Me(e);if(!t[0])throw new Error(`${t[1]} Node: ${_(t[2].value,30)}`,{cause:t[2]})}function*tn(e){for(const t of e.childrenStore)yield t}function*rn(e){for(const t of e.childrenStore)typeof t.value<"u"&&(yield t.value)}function*F(e){let t=e.parent;for(;t;)yield t,t=t.parent}function nn(e){return[...F(e)].length}const ot=(e,t)=>{for(const r of t.childrenStore)if(r===e)return!0;return!1},sn=(e,t,r=f)=>{for(const n of t.childrenStore)if(r(e,n.value))return n};function*at(e,t,r=f){for(const n of t.childrenStore)r(e,n.value)&&(yield n)}const H=(e,t)=>{for(const r of Se(t))if(r===e)return!0;return!1},on=(e,t,r=f)=>{for(const n of Se(t))if(r(n.value,e))return n},xe=e=>e.parent?xe(e.parent):e,W=(e,t)=>{for(const r of F(e))if(r===t)return!0;return!1};function*ut(e){for(const t of F(e))typeof t.value<"u"&&(yield t.value);return!1}function*Pe(e,t,r=f){for(const n of F(e))typeof n.value<"u"&&r(n.value,t)&&(yield n);return!1}function lt(e,t,r=f){for(const n of Pe(e,t,r))return n}const ct=(e,t)=>e.parent===t,an=e=>ft(e,0),ft=(e,t=0)=>{let r=t;for(const n of e.childrenStore)r=Math.max(r,ft(n,t+1));return r},ke=(e,t)=>{ht(e,t);const r=e.parent;t.childrenStore=[...t.childrenStore,e],e.parent=t,r&&(r.childrenStore=ce(r.childrenStore,e))},J=(e,t)=>q(e,t),Z=e=>q(e),dt=(e,t="",r,n=[])=>{const s=Object.entries(e);r=r===void 0?Z():J({label:t,value:e},r);for(const i of s){const o=i[1];n.includes(o)||(n.push(o),typeof i[1]=="object"?dt(o,i[0],r,n):J({label:i[0],value:o},r))}return r},un=e=>w(q(e)),q=(e,t)=>{const r={childrenStore:[],parent:t,value:e};return t!==void 0&&(t.childrenStore=[...t.childrenStore,r]),r},ln=e=>e.childrenStore.length,cn=e=>e.value,A=e=>({*children(){for(const r of e.childrenStore)yield A(r)},getParent(){if(e.parent!==void 0)return A(e.parent)},getValue(){return e.value},getIdentity(){return e}}),ht=(e,t)=>{if(t===e)throw new Error("Cannot add self as child");if(e.parent!==t){if(W(t,e))throw new Error("Child contains parent (1)",{cause:e});if(W(e,t))throw new Error("Parent already contains child",{cause:e});if(H(t,e))throw new Error("Child contains parent (2)",{cause:e})}},pt=(e,t)=>{for(const r of t)ht(r,e);e.childrenStore=[...t];for(const r of t)r.parent=e},Ce=(e,t=0)=>{const r=`${"  ".repeat(t)} + ${e.value?JSON.stringify(e.value):"-"}`;return e.childrenStore.length>0?r+`
`+e.childrenStore.map(n=>Ce(n,t+1)).join(`
`):r};function*yt(e,t,r=1){for(const n of e.childrenStore){const s=n.value;s!==void 0&&t(s,r)&&(yield n.value,yield*yt(n,t,r+1))}}var vt={};y(vt,{asDynamicTraversable:()=>Ae,children:()=>L,create:()=>Be,createSimplified:()=>yn,createWrapped:()=>pn,depthFirst:()=>wt,getByPath:()=>hn,prettyPrint:()=>gt,prettyPrintEntries:()=>fn,toStringDeep:()=>mt,traceByPath:()=>bt});function fn(e){if(e.length===0)return"(empty)";let t="";for(const[r,n]of e.entries())t+="  ".repeat(r),t+=n.name+" = "+JSON.stringify(n.leafValue)+`
`;return t}const gt=(e,t=0,r={})=>{l(G(e,"node"));const n=r.name??"node",s=vn(e,n),i=`${"  ".repeat(t)} + name: ${s.name} value: ${JSON.stringify(s.leafValue)}`,o=[...L(e,r)];return o.length>0?i+`
`+o.map(a=>gt(a.leafValue,t+1,{...r,name:a.name})).join(`
`):i},mt=(e,t=0)=>{let r=" ".repeat(t)+` ${e.value?.name}`;if(e.value!==void 0){if("sourceValue"in e.value&&"leafValue"in e.value){let n=_(e.value.sourceValue,20);const s=_(e.value.leafValue,20);n=n===s?"":"source: "+n,r+=` = ${s} ${n}`}else"sourceValue"in e.value&&e.value.sourceValue!==void 0&&(r+=` = ${e.value.sourceValue}`);"ancestors"in e.value&&(r+=` (ancestors: ${e.value.ancestors.join(", ")})`)}r+=`
`;for(const n of e.childrenStore)r+=mt(n,t+1);return r};function*L(e,t={}){l(G(e,"node"));const r=t.filter??"none",n=s=>r==="none"?[!0,T(s)]:r==="leaves"&&T(s)?[!0,!0]:r==="branches"&&!T(s)?[!0,!1]:[!1,T(s)];if(Array.isArray(e))for(const[s,i]of e.entries()){const o=n(i);o[0]&&(yield{name:s.toString(),_kind:"entry",sourceValue:i,leafValue:o[1]?i:void 0})}else if(typeof e=="object"){const s="entries"in e?e.entries():Object.entries(e);for(const[i,o]of s){const[a,u]=n(o);a&&(yield{name:i,_kind:"entry",sourceValue:o,leafValue:u?o:void 0})}}}function*wt(e,t={},r=[]){for(const n of L(e,t))yield{...n,ancestors:[...r],_kind:"entry-ancestors"},yield*wt(n.sourceValue,t,[...r,n.name])}function dn(e,t){for(const r of L(t))if(r.name===e)return r}function hn(e,t,r={}){const n=br(bt(e,t,r));if(!n)throw new Error(`Could not trace path: ${e} `);return n}function*bt(e,t,r={}){l(G(e,"path"),G(t,"node"));const n=r.separator??".",s=e.split(n),i=[];for(const o of s){const a=dn(o,t);if(!a){yield{name:o,sourceValue:void 0,leafValue:void 0,ancestors:i,_kind:"entry-ancestors"};return}t=a.sourceValue,yield{...a,ancestors:[...i],_kind:"entry-ancestors"},i.push(o)}}const Ae=(e,t={},r=[],n)=>{const s=t.name??"object",i={*children(){for(const{name:o,sourceValue:a,leafValue:u}of L(e,t))yield Ae(a,{...t,name:o},[...r,s],i)},getParent(){return n},getValue(){return{name:s,sourceValue:e,ancestors:r,_kind:"entry-static"}},getIdentity(){return e}};return i},pn=(e,t)=>w(Be(e,t)),Be=(e,t={})=>{const n=t.valuesAtLeaves??!1?s=>{if(T(s))return s}:s=>s;return Et(e,n(e),t,[])},Et=(e,t,r={},n)=>{const s=r.name??"object_ci",i=Z({name:s,sourceValue:t,ancestors:[...n],_kind:"entry-static"});n=[...n,s];for(const o of L(e,r)){const a=r.valuesAtLeaves?o.leafValue:o.sourceValue;ke(Et(o.sourceValue,a,{...r,name:o.name},n),i)}return i},yn=(e,t={})=>Ee(Be(e,t));function vn(e,t=""){return"name"in e&&"leafValue"in e&&"sourceValue"in e?{name:e.name,_kind:"entry",leafValue:e.leafValue,sourceValue:e.sourceValue}:"name"in e?{name:e.name,leafValue:e,sourceValue:e,_kind:"entry"}:{name:t,leafValue:e,sourceValue:e,_kind:"entry"}}var Vt={};y(Vt,{addValueByPath:()=>St,childrenLengthByPath:()=>mn,clearValuesByPath:()=>xt,create:()=>gn,removeByPath:()=>Mt,valueByPath:()=>Pt,valuesByPath:()=>Ie});const gn=(e={})=>{let t;return{getRoot:()=>t,add:(p,P)=>{const yr=St(p,P,t,e);t===void 0&&(t=xe(yr))},prettyPrint:()=>t===void 0?"(empty)":Ce(t),remove:p=>t===void 0?!1:Mt(p,t,e),getValue:p=>{if(t!==void 0)return Pt(p,t,e)},getValues:p=>t===void 0?[]:Ie(p,t,e),hasPath:p=>t===void 0?!1:k(p,t,e)!==void 0,childrenLength:p=>{if(t===void 0)return 0;const P=k(p,t,e);return P===void 0?0:P.childrenStore.length},getNode:p=>t===void 0?void 0:k(p,t,e),clearValues:p=>t===void 0?!1:xt(p,t,e)}},St=(e,t,r,n={})=>{const s=n.separator??".",i=n.duplicates??"overwrite",o=t.split(s);let a=0;for(const u of o){const c=a===o.length-1,h=Le(u,r);if(h===void 0)r=q({value:c?e:void 0,label:u},r);else if(r=h,c)switch(i){case"ignore":break;case"allow":{const m=kt(r);r.value={values:[...m,e],label:u};break}case"overwrite":{r.value={value:e,label:u};break}}else r=h;a++}if(r===void 0)throw new Error("Could not create tree");return r},Mt=(e,t,r={})=>{if(t===void 0)return!1;const n=k(e,t,r);return n===void 0?!1:(Ve(n),!0)},xt=(e,t,r={})=>{if(t===void 0)return!1;const n=k(e,t,r);return n===void 0?!1:(n.value={label:n.value?.label??"",value:void 0},!0)},mn=(e,t,r={})=>{if(t===void 0)return 0;const n=k(e,t,r);return n===void 0?0:n.childrenStore.length},Le=(e,t)=>{if(t!==void 0){if(e===void 0)throw new Error("Parameter 'label' cannot be undefined");if(t.value?.label===e)return t;for(const r of t.childrenStore)if(r.value?.label===e)return r}},Pt=(e,t,r={})=>{const n=Ie(e,t,r);if(n.length!==0){if(n.length>1)throw new Error("Multiple values at path. Use getValues instead");return n[0]}},kt=e=>e.value===void 0?[]:"values"in e.value?e.value.values:"value"in e.value?e.value.value===void 0?[]:[e.value.value]:[],k=(e,t,r={})=>{const n=r.separator??".",s=e.split(n);let i=t;for(const o of s)if(i=Le(o,i),i===void 0)return;return i},Ie=(e,t,r={})=>{const n=r.separator??".",s=e.split(n);let i=t;for(const o of s)if(i=Le(o,i),i===void 0)return[];return kt(i)};var Ct={};y(Ct,{breadthFirst:()=>I,childrenLength:()=>wn,couldAddChild:()=>Sn,depthFirst:()=>je,find:()=>Cn,findAnyChildByValue:()=>kn,findAnyParentByValue:()=>Vn,findByValue:()=>An,findChildByValue:()=>Lt,findParentByValue:()=>De,followValue:()=>It,hasAnyChild:()=>ne,hasAnyChildValue:()=>Mn,hasAnyParent:()=>bn,hasAnyParentValue:()=>En,hasChild:()=>At,hasChildValue:()=>Bt,hasParent:()=>Re,hasParentValue:()=>Te,parents:()=>Pn,siblings:()=>xn,toString:()=>Bn,toStringDeep:()=>Rt});const wn=e=>[...e.children()].length,bn=(e,t,r)=>Re(e,t,r,Number.MAX_SAFE_INTEGER),En=(e,t,r)=>{if(typeof e>"u")throw new TypeError("Param 'child' is undefined");return Te(e,t,r,Number.MAX_SAFE_INTEGER)},Vn=(e,t,r)=>De(e,t,r,Number.MAX_SAFE_INTEGER),Re=(e,t,r=f,n=0)=>{if(n<0)return!1;const s=S(e),i=S(t),o=s?e.getParent():e.parent;if(typeof o>"u")return!1;if(r(o,t))return!0;const a=s?o.getIdentity():o.value,u=i?t.getIdentity():t.value;return r(a,u)?!0:Re(o,t,r,n-1)},Te=(e,t,r=f,n=0)=>{if(e===void 0)throw new Error("Param 'child' is undefined");if(n<0)return!1;const s="getParent"in e?e.getParent():e.parent;if(s===void 0)return!1;const i="getValue"in s?s.getValue():s.value;return r(i,t)?!0:Te(s,t,r,n-1)},De=(e,t,r=f,n=0)=>{if(n<0)return;const s="getParent"in e?e.getParent():e.parent;if(s===void 0)return;const i="getValue"in s?s.getValue():s.value;return r(i,t)?s:De(s,t,r,n-1)},Sn=(e,t,r=f)=>{if(r(e,t))throw new Error("Child equals parent");if(ne(e,t,r))throw new Error("Circular. Parent already has child");if(ne(t,e,r))throw new Error("Prospective child has parent as child relation")},ne=(e,t,r=f)=>At(e,t,r,Number.MAX_SAFE_INTEGER),Mn=(e,t,r=f)=>Bt(e,t,r,Number.MAX_SAFE_INTEGER),At=(e,t,r=f,n=0)=>{if(n<0)return!1;if(r(e,t))return!0;const s="getIdentity"in e?e.getIdentity():e.value,i="getIdentity"in t?t.getIdentity():t.value;if(r(s,i))return!0;for(const o of I(e,n)){const a="getIdentity"in o?o.getIdentity():o.value;if(r(o,t)||r(a,i))return!0}return!1},Bt=(e,t,r=f,n=0)=>{if(n<0)return!1;if(r(e.getValue(),t))return!0;for(const s of I(e,n)){const i=s.getValue();if(r(i,t))return!0}return!1};function*xn(e){const t=e.getParent();if(t!==void 0)for(const r of t.children())r!==e&&(yield r)}function*Pn(e){if(S(e)){let t=e.getParent();for(;t!==void 0;)yield t,t=t.getParent()}else{let t=e.parent;for(;t!==void 0;)yield t,t=t.parent}}function kn(e,t,r=f){return Lt(e,t,r,Number.MAX_SAFE_INTEGER)}function Lt(e,t,r=f,n=0){if(n<0)return;const s=S(e);if(s){if(r(e.getValue(),t))return e}else if(r(e.value,t))return e;for(const i of I(e,n))if(s){if(r(i.getValue(),t))return i}else if(r(i.value,t))return i}function*je(e){if(!e)return;const t=new B;let r=e;for(;r;){const n=S(r)?[...r.children()]:[...r.childrenStore];if(t.push(...n),t.isEmpty)break;r=t.pop(),r&&(yield r)}}function*I(e,t=Number.MAX_SAFE_INTEGER){if(!e)return;const n=S(e)?new V:new V;let s=e;for(;s;){if(t<0)return;if(s!==void 0){const i="childrenStore"in s?s.childrenStore:s.children();for(const o of i)yield o,n.enqueue(o)}s=n.dequeue(),t--}}function Cn(e,t,r="breadth"){if(t(e))return e;const n=r==="breadth"?I:je;for(const s of n(e))if(t(s))return s}function An(e,t,r="breadth"){if(t(e.getValue()))return e;const n=r==="breadth"?I:je;for(const s of n(e))if(t(s.getValue()))return s}function*It(e,t,r=1){for(const n of e.children())t(n.getValue(),r)&&(yield n.getValue(),yield*It(n,t,r+1))}function Rt(e,t=0){if(e===void 0)return"(undefined)";if(e===null)return"(null)";const r=e.getValue();let n=typeof r;Array.isArray(r)&&(n="array");let s="  ".repeat(t)+`value: ${JSON.stringify(r)} (${n})
`;for(const i of e.children())s+=Rt(i,t+1);return s}function Bn(...e){let t="";for(const r of e){const n=r.getValue(),s=_(n),i=[...r.children()],o=r.getParent();let a=typeof n;Array.isArray(n)&&(a="array"),t+=`value: ${s} (${a}) kids: ${i.length} parented: ${o?"y":"n"}
`}return t}var Ln={};y(Ln,{FromObject:()=>vt,Mutable:()=>st,Pathed:()=>Vt,Traverse:()=>Ct,compare:()=>be,isTraversable:()=>S,isTreeNode:()=>Tt,toTraversable:()=>In});const In=e=>{if(S(e))return e;if(Tt(e))return A(e);if(typeof e=="object")return Ae(e);throw new Error("Parameter 'node' not convertible")},Tt=e=>!!("parent"in e&&"childrenStore"in e&&"value"in e&&Array.isArray(e.childrenStore)),S=e=>"children"in e&&"getParent"in e&&"getValue"in e&&"getIdentity"in e;var Dt=class se{opts;data;constructor(t={},r=[]){this.opts=t,this.data=r}push(...t){return new se(this.opts,ve(this.opts,this.data,...t))}pop(){return new se(this.opts,ge(this.opts,this.data))}forEach(t){this.data.forEach(t)}forEachFromTop(t){[...this.data].reverse().forEach(t)}get isEmpty(){return me(this.opts,this.data)}get isFull(){return we(this.opts,this.data)}get peek(){return z(this.opts,this.data)}get length(){return this.data.length}};const Rn=(e={},...t)=>new Dt({...e},[...t]);var jt={};y(jt,{StackImmutable:()=>Dt,StackMutable:()=>B,immutable:()=>Rn,isEmpty:()=>me,isFull:()=>we,mutable:()=>Qr,peek:()=>z,pop:()=>ge,push:()=>ve,trimStack:()=>tt});const Tn=e=>new Nt(e);var Nt=class extends X{store=new Map;keyString;constructor(e){super(),this.keyString=e??N}get size(){return this.store.size}add(...e){let t=!1;for(const r of e){const n=this.has(r);this.store.set(this.keyString(r),r),super.fireEvent("add",{value:r,updated:n}),n||(t=!0)}return t}values(){return this.store.values()}clear(){this.store.clear(),super.fireEvent("clear",!0)}delete(e){const t=this.store.delete(this.keyString(e));return t&&super.fireEvent("delete",e),t}has(e){return this.store.has(this.keyString(e))}toArray(){return[...this.store.values()]}},Ft=class ie{store;keyString;constructor(t,r){this.store=r??new Map,this.keyString=t??N}get size(){return this.store.size}add(...t){const r=new Map(this.store);for(const n of t){const s=this.keyString(n);r.set(s,n)}return new ie(this.keyString,r)}delete(t){const r=new Map(this.store),n=this.keyString(t);return r.delete(n)?new ie(this.keyString,r):this}has(t){const r=this.keyString(t);return this.store.has(r)}toArray(){return[...this.store.values()]}*values(){yield*this.store.values()}};const Dn=(e=fe)=>new Ft(e);var jn=class qt{#e;#t;children=new Map;values=[];constructor(t=1,r=0){this.#e=r,this.#t=t}sizeLocal(){return this.values.length}sizeChildren(){return[...this.children.values()].length}sizeChildrenDeep(){let t=this.sizeChildren();for(const r of this.children.values())t+=r.sizeChildrenDeep();return t}size(){let t=this.values.length;for(const r of this.children.values())t+=r.size();return t}add(t){if(typeof t!="string")throw new Error(`Param 'value' must be a string. Got: ${typeof t}`);if(t.length===0)throw new Error("Param 'value' is empty");const r=this.#n(t,!0);if(r===this){this.hasLocal(t)||this.values.push(t);return}if(!r)throw new Error(`Could not create child set for: ${t}`);r.add(t)}remove(t){if(typeof t!="string")throw new Error(`Param 'value' must be a string. Got: ${typeof t}`);if(t.length===0)throw new Error("Param 'value' is empty");const r=this.#n(t,!1);return r===void 0?!1:r===this?this.hasLocal(t)?(this.values=this.values.filter(n=>n!==t),!0):!1:r.remove(t)}debugDump(){const t=this.#r();for(const r of t)console.log(r)}#r(t=0){const r=[];r.push(`Depth: ${this.#e} Max: ${this.#t}`);for(const[n,s]of this.children.entries()){const i=s.#r(t+1);r.push(` key: ${n}`);for(const o of i)r.push(" ".repeat(t+1)+o)}r.push(`Values: (${this.values.length})`);for(const n of this.values)r.push(` ${n}`);return r.map(n=>" ".repeat(t)+n)}#n(t,r){if(t===void 0)throw new Error("Param 'value' undefined");if(this.#e===this.#t)return this;if(t.length<=this.#e)return this;const n=t[this.#e];if(n===void 0)throw new Error(`Logic error. Depth: ${this.#e} Len: ${t.length}`);let s=this.children.get(n);return s===void 0&&r&&(s=new qt(this.#t,this.#e+1),this.children.set(n,s)),s}hasLocal(t){for(const r of this.values)if(r===t)return!0;return!1}has(t){if(typeof t!="string")return!1;const r=this.#n(t,!1);return r===void 0?!1:r===this?this.hasLocal(t):r.has(t)}},Nn={};y(Nn,{MassiveSet:()=>jn,SetStringImmutable:()=>Ft,SetStringMutable:()=>Nt,immutable:()=>Dn,mutable:()=>Tn});var Ne=class extends V{constructor(e={}){e.eq===void 0&&(e={...e,eq:(t,r)=>f(t.item,r.item)}),super(e)}enqueueWithPriority(e,t){l(wr(t,"positive")),super.enqueue({item:e,priority:t})}changePriority(e,t,r=!1,n){if(e===void 0)throw new Error("Item cannot be undefined");let s;for(const i of this.data)if(n){if(n(i.item,e)){s=i;break}}else if(this.eq(i,{item:e,priority:0})){s=i;break}if(s===void 0&&!r)throw new Error(`Item not found in priority queue. Item: ${JSON.stringify(e)}`);s!==void 0&&this.removeWhere(i=>s===i),this.enqueueWithPriority(e,t)}dequeueMax(){const e=O(te(this.data,(t,r)=>t.priority>=r.priority));if(e!==void 0)return this.removeWhere(t=>t===e),e.item}dequeueMin(){const e=O(te(this.data,(t,r)=>t.priority>=r.priority));if(e!==void 0)return this.removeWhere(t=>t.item===e),e.item}peekMax(){const e=O(te(this.data,(t,r)=>t.priority>=r.priority));if(e!==void 0)return e.item}peekMin(){const e=O(_r(this.data,(t,r)=>t.priority>=r.priority));if(e!==void 0)return e.item}};function Fn(e={}){return new Ne(e)}var Ot=class oe{opts;#e;constructor(t={},r=[]){if(t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.#e=r}forEach(t){for(let r=this.#e.length-1;r>=0;r--)t(this.#e[r])}forEachFromFront(t){this.#e.forEach(r=>{t(r)})}enqueue(...t){return new oe(this.opts,de(this.opts,this.#e,...t))}dequeue(){return new oe(this.opts,he(this.opts,this.#e))}get isEmpty(){return pe(this.opts,this.#e)}get isFull(){return ye(this.opts,this.#e)}get length(){return this.#e.length}get peek(){return $(this.opts,this.#e)}toArray(){return[...this.#e]}};const qn=(e={},...t)=>(e={...e},new Ot(e,[...t]));var On={};y(On,{PriorityMutable:()=>Ne,QueueImmutable:()=>Ot,QueueMutable:()=>V,debug:()=>Jr,dequeue:()=>he,enqueue:()=>de,immutable:()=>qn,isEmpty:()=>pe,isFull:()=>ye,mutable:()=>Ur,peek:()=>$,priority:()=>Fn,trimQueue:()=>et});const Kn=(e={})=>new Kt(e);var Kt=class extends X{capacity;store;evictPolicy;autoDeleteElapsedMs;autoDeletePolicy;autoDeleteTimer;disposed=!1;constructor(e={}){if(super(),this.capacity=e.capacity??-1,l(We(this.capacity,"nonZero","capacity")),this.store=new Map,e.evictPolicy&&this.capacity<=0)throw new Error("evictPolicy is set, but no capacity limit is set");this.evictPolicy=e.evictPolicy??"none",this.autoDeleteElapsedMs=e.autoDeleteElapsedMs??-1,this.autoDeletePolicy=e.autoDeletePolicy??"none",this.autoDeleteElapsedMs>0&&(this.autoDeleteTimer=setInterval(()=>{this.#e()},Math.max(1e3,this.autoDeleteElapsedMs*2)))}dispose(){this.disposed||(this.disposed=!0,this.autoDeleteTimer&&(clearInterval(this.autoDeleteTimer),this.autoDeleteTimer=void 0))}get keyLength(){return this.store.size}*entries(){for(const e of this.store.entries())yield[e[0],e[1].value]}*values(){for(const e of this.store.values())yield e.value}*keys(){yield*this.store.keys()}elapsedSet(e){const t=this.store.get(e);if(!(typeof t>"u"))return Date.now()-t.lastSet}elapsedGet(e){const t=this.store.get(e);if(!(typeof t>"u"))return Date.now()-t.lastGet}has(e){return this.store.has(e)}get(e){const t=this.store.get(e);if(t)return(this.autoDeletePolicy==="either"||this.autoDeletePolicy==="get")&&this.store.set(e,{...t,lastGet:performance.now()}),t.value}delete(e){const t=this.store.get(e);if(!t)return!1;const r=this.store.delete(e);return this.fireEvent("removed",{key:e,value:t.value}),r}clear(){this.store.clear()}touch(e){const t=this.store.get(e);return t?(this.store.set(e,{...t,lastSet:Date.now(),lastGet:Date.now()}),!0):!1}findEvicteeKey(){if(this.evictPolicy==="none")return;let e="";if(this.evictPolicy==="oldestGet")e="lastGet";else if(this.evictPolicy==="oldestSet")e="lastSet";else throw new Error(`Unknown eviction policy ${this.evictPolicy}`);return Ue(this.store,e)[0][0]}#e(){this.autoDeletePolicy!=="none"&&this.deleteWithElapsed(this.autoDeleteElapsedMs,this.autoDeletePolicy)}deleteWithElapsed(e,t){const r=[...this.store.entries()],n=[],s=$r(e,1e3),i=performance.now();for(const o of r){const a=i-o[1].lastGet,u=i-o[1].lastSet;(t==="get"?a:t==="set"?u:Math.max(a,u))>=s&&n.push([o[0],o[1].value])}for(const o of n){this.store.delete(o[0]);const a={key:o[0],value:o[1]};this.fireEvent("expired",a),this.fireEvent("removed",a)}return n}set(e,t){const r=this.store.get(e);if(r){this.store.set(e,{...r,lastSet:performance.now()});return}if(this.keyLength===this.capacity&&this.capacity>0){const n=this.findEvicteeKey();if(!n)throw new Error(`ExpiringMap full (capacity: ${this.capacity})`);const s=this.store.get(n);if(this.store.delete(n),s){const i={key:n,value:s.value};this.fireEvent("expired",i),this.fireEvent("removed",i)}}this.store.set(e,{lastGet:0,lastSet:performance.now(),value:t}),this.fireEvent("newKey",{key:e,value:t})}};const Gn=(e,t)=>{for(const r of e.entries()){const n=r[1];for(const s of n)if(t(s,r[0]))return r}},_n=e=>{let t=["",0];for(const r of e.keysAndCounts())r[1]>t[1]&&(t=r);return t[1]},Gt=(e,t,r=f)=>{for(const n of e.entries()){const s=n[1];for(const i of s)if(r(i,t))return n}};var _t=class{map;groupBy;valueEq;constructor(e=N,t=f,r=[]){this.groupBy=e,this.valueEq=t,this.map=new Map(r)}has(e){return this.map.has(e)}hasKeyValue(e,t){const r=this.map.get(e);if(!r)return!1;for(const n of r)if(this.valueEq(n,t))return!0;return!1}debugString(){let e="";return[...this.map.keys()].every(r=>{const n=this.map.get(r);n!==void 0&&(e+=r+` (${n.length}) = ${JSON.stringify(n)}\r
`)}),e}count(e){const t=this.map.get(e);return t?t.length:0}firstKeyByValue(e,t=f){const r=Gt(this,e,t);if(r)return r[0]}*entriesFlat(){for(const e of this.map.keys())for(const t of this.map.get(e))yield[e,t]}*entries(){for(const[e,t]of this.map.entries())yield[e,[...t]]}*get(e){const t=this.map.get(e);t&&(yield*t.values())}*keys(){yield*this.map.keys()}*valuesFlat(){for(const e of this.map)yield*e[1]}*values(){for(const e of this.map)yield e[1]}*keysAndCounts(){for(const e of this.map)yield[e[0],e[1].length]}get lengthKeys(){return this.map.size}get isEmpty(){return this.map.size===0}},$t=class extends _t{addKeyedValues(e,...t){const r=this.map.get(e);r===void 0?this.map.set(e,t):this.map.set(e,[...r,...t])}setValues(e,t){this.map.set(e,t)}addValue(...e){for(const t of e){const r=this.groupBy(t);this.addKeyedValues(r,t)}}deleteKeyValue(e,t){const r=this.map.get(e);if(r===void 0)return!1;const n=r.filter(s=>!this.valueEq(s,t));return this.map.set(e,n),n.length<r.length}deleteByValue(e){let t=!1;const r=[...this.map.entries()];for(const n of r)for(const s of n[1])this.valueEq(s,e)&&(t=!0,this.deleteKeyValue(n[0],e));return t}delete(e){const t=this.map.get(e);return!t||t.length===0?!1:(this.map.delete(e),!0)}clear(){this.map.clear()}};const $e=(e=N,t=f)=>new $t(e,t),$n=(e,t)=>{const r=new Map(e.entries());for(const n of t){if(n[0]===void 0)throw new Error("key cannot be undefined");if(n[1]===void 0)throw new Error("value cannot be undefined");r.set(n[0],n[1])}return r},zn=(e,t)=>{const r=new Map(e.entries());for(const n of t){if(n.key===void 0)throw new Error("key cannot be undefined");if(n.value===void 0)throw new Error("value cannot be undefined");r.set(n.key,n.value)}return r},Wn=(e,t)=>e.has(t),j=(e,...t)=>{if(e===void 0)throw new Error("map parameter is undefined");if(t===void 0)throw new Error("data parameter i.s undefined");if(t.length===0)return e;const r=t[0];return typeof r.key<"u"&&typeof r.value<"u"?zn(e,t):$n(e,t)},zt=(e,t,r)=>{const n=new Map(e.entries());return n.set(t,r),n},Wt=(e,t)=>{const r=new Map(e.entries());return r.delete(t),r},v=e=>{if(e===void 0)return v([]);if(Array.isArray(e))return v(j(new Map,...e));const t=e;return{add:(...r)=>{const n=j(t,...r);return v(n)},set:(r,n)=>{const s=zt(t,r,n);return v(s)},get:r=>t.get(r),delete:r=>v(Wt(t,r)),clear:()=>v(),has:r=>t.has(r),entries:()=>t.entries(),values:()=>t.values(),isEmpty:()=>t.size===0}},Jn=(...e)=>{let t=j(new Map,...e);return{add:(...r)=>{t=j(t,...r)},delete:r=>{t=Wt(t,r)},clear:()=>{t=j(new Map)},set:(r,n)=>{t=zt(t,r,n)},get:r=>t.get(r),entries:()=>t.entries(),values:()=>t.values(),isEmpty:()=>t.size===0,has:r=>Wn(t,r)}};var Y=class extends X{#e=new Map;groupBy;type;constructor(e,t={}){super(),this.type=e,this.groupBy=t.groupBy??fe}get typeName(){return this.type.name}get lengthKeys(){return this.#e.size}get lengthMax(){let e=0;for(const t of this.#e.values())e=Math.max(e,this.type.count(t));return e}debugString(){const e=[...this.#e.keys()];let t=`Keys: ${e.join(", ")}\r
`;for(const r of e){const n=this.#e.get(r);if(n===void 0)t+=` - ${r} (undefined)\r
`;else{const s=this.type.toArray(n);s!==void 0&&(t+=` - ${r} (${this.type.count(n)}) = ${JSON.stringify(s)}\r
`)}}return t}get isEmpty(){return this.#e.size===0}clear(){this.#e.clear(),super.fireEvent("clear",!0)}addKeyedValues(e,...t){const r=this.#e.get(e);r===void 0?(this.#e.set(e,this.type.addKeyedValues(void 0,t)),super.fireEvent("addedKey",{key:e}),super.fireEvent("addedValues",{values:t})):(this.#e.set(e,this.type.addKeyedValues(r,t)),super.fireEvent("addedValues",{values:t}))}set(e,t){return this.addKeyedValues(e,...t),this}addValue(...e){for(const t of e)this.addKeyedValues(this.groupBy(t),t)}hasKeyValue(e,t,r){const n=this.#e.get(e);return n===void 0?!1:this.type.has(n,t,r)}has(e){return this.#e.has(e)}deleteKeyValue(e,t){const r=this.#e.get(e);return r===void 0?!1:this.deleteKeyValueFromMap(r,e,t)}deleteKeyValueFromMap(e,t,r){const n=this.type.count(e),s=this.type.without(e,r),i=s.length;return this.#e.set(t,this.type.addKeyedValues(void 0,s)),n>i}deleteByValue(e){let t=!1;return[...this.#e.keys()].filter(r=>{const n=this.#e.get(r);if(!n)throw new Error("Bug: map could not be accessed");this.deleteKeyValueFromMap(n,r,e)&&(t=!0,this.count(r)===0&&this.delete(r))}),t}delete(e){return this.#e.get(e)===void 0?!1:(this.#e.delete(e),this.fireEvent("deleteKey",{key:e}),!0)}firstKeyByValue(e,t=f){return[...this.#e.keys()].find(s=>{const i=this.#e.get(s);if(i===void 0)throw new Error("Bug: map could not be accessed");return this.type.has(i,e,t)})}count(e){const t=this.#e.get(e);return t===void 0?0:this.type.count(t)}*get(e){const t=this.#e.get(e);t!==void 0&&(yield*this.type.iterable(t))}*valuesFor(e){const t=this.#e.get(e);t!==void 0&&(yield*this.type.iterable(t))}getSource(e){return this.#e.get(e)}*keys(){yield*this.#e.keys()}*entriesFlat(){for(const e of this.#e.entries())for(const t of this.type.iterable(e[1]))yield[e[0],t]}*valuesFlat(){for(const e of this.#e.entries())yield*this.type.iterable(e[1])}*entries(){for(const[e,t]of this.#e.entries()){const r=[...this.type.iterable(t)];yield[e,r]}}*keysAndCounts(){for(const e of this.keys())yield[e,this.count(e)]}merge(e){for(const t of e.keys()){const r=e.get(t);this.addKeyedValues(t,...r)}}get size(){return this.#e.size}get[Symbol.toStringTag](){return this.#e[Symbol.toStringTag]}};const Un=e=>{const t=e?.hash??fe,r=(i,o)=>t(i)===t(o),n={get name(){return"set"},iterable:i=>i.values(),addKeyedValues:(i,o)=>Ze(i,t,"skip",...o),count:i=>i.size,find:(i,o)=>Xe(i,o),filter:(i,o)=>He(i,o),toArray:i=>re(i),has:(i,o)=>Qe(i,o,r),without:(i,o)=>ce(re(i),o,r)};return new Y(n,e)},Qn=e=>{const t=f,r={get name(){return"circular"},addKeyedValues:(n,s)=>{let i=n??new Wr(e.capacity);for(const o of s)i=i.add(o);return i},count:n=>n.length,find:(n,s)=>n.find(s),filter:(n,s)=>n.filter(s),toArray:n=>n,iterable:n=>n.values(),has:(n,s)=>n.find(i=>t(i,s))!==void 0,without:(n,s)=>n.filter(i=>!t(i,s))};return new Y(r,e)};var Jt=class extends Map{defaultValue;constructor(e=0){super(),this.defaultValue=e}get(e){const t=super.get(e);return t===void 0?this.defaultValue:t}reset(e){return super.set(e,this.defaultValue),this.defaultValue}multiply(e,t){let n=super.get(e)??this.defaultValue;return n*=t,super.set(e,n),n}add(e,t=1){let n=super.get(e)??this.defaultValue;return n+=t,super.set(e,n),n}subtract(e,t=1){let n=super.get(e)??this.defaultValue;return n-=t,super.set(e,n),n}};const Xn=(e={})=>{const t=e.convertToString,r=typeof t>"u"?f:(o,a)=>t(o)===t(a),n=e.comparer??r,s={get name(){return"array"},addKeyedValues:(o,a)=>o===void 0?[...a]:[...o,...a],iterable:o=>o.values(),count:o=>o.length,find:(o,a)=>o.find(u=>a(u)),filter:(o,a)=>o.filter(u=>a(u)),toArray:o=>o,has:(o,a)=>o.some(u=>n(u,a)),without:(o,a)=>o.filter(u=>!n(u,a))};return new Y(s,e)};var Ut=class D extends _t{addKeyedValues(t,...r){return this.addBatch([[t,r]])}addValue(...t){const r=t.map(n=>[this.groupBy(n),n]);return this.addBatch(r)}addBatch(t){const r=new Map([...this.map.entries()].map(n=>[n[0],[...n[1]]]));for(const[n,s]of t){const i=r.get(n);typeof i>"u"?r.set(n,s):i.push(...s)}return new D(this.groupBy,this.valueEq,[...r.entries()])}clear(){return new D(this.groupBy,this.valueEq)}deleteKeyValue(t,r){throw new Error("Method not implemented.")}deleteByValue(t,r){const n=[...this.map.entries()],s=r??this.valueEq,i=n.map(o=>{const a=o[0],u=o[1].filter(c=>!s(c,t));return[a,u]});return new D(this.groupBy,this.valueEq,i)}delete(t){const r=[...this.map.entries()].filter(n=>n[0]!==t);return new D(this.groupBy,this.valueEq,r)}};const Hn=(e=N,t=f)=>new Ut(e,t);var Zn={};y(Zn,{ExpiringMap:()=>Kt,MapOfMutableImpl:()=>Y,MapOfSimple:()=>Ut,MapOfSimpleMutable:()=>$t,NumberMap:()=>Jt,addObjectEntriesMutate:()=>Kr,addValue:()=>Ze,addValueMutate:()=>Or,addValueMutator:()=>qr,deleteByValueCompareMutate:()=>Fr,expiringMap:()=>Kn,filterValues:()=>He,findBySomeKey:()=>Nr,findEntryByPredicate:()=>jr,findEntryByValue:()=>Dr,findValue:()=>Xe,firstEntry:()=>Gn,firstEntryByValue:()=>Gt,fromIterable:()=>Tr,fromObject:()=>Rr,getClosestIntegerKey:()=>Ir,getOrGenerate:()=>Lr,getOrGenerateSync:()=>Br,hasAnyValue:()=>Qe,hasKeyValue:()=>Ar,immutable:()=>v,lengthMax:()=>_n,mapOfSimpleMutable:()=>$e,mapToArray:()=>Cr,mapToObjectTransform:()=>kr,mergeByKey:()=>Pr,mutable:()=>Jn,ofArrayMutable:()=>Xn,ofCircularMutable:()=>Qn,ofSetMutable:()=>Un,ofSimple:()=>Hn,ofSimpleMutable:()=>$e,some:()=>xr,sortByValue:()=>Mr,sortByValueProperty:()=>Ue,toArray:()=>re,toObject:()=>Sr,transformMap:()=>Vr,zipKeyValue:()=>Er});var Qt=class{rows=[];rowLabels=[];colLabels=[];columnMaxLength=0;getColumnLabelIndex(e){for(const[t,r]of this.colLabels.entries())if(r===e)return t}getRowLabelIndex(e){for(const[t,r]of this.rowLabels.entries())if(r===e)return t}print(){console.table([...this.rowsWithLabelsObject()])}asArray(){const e=[];for(const t of this.rows)t===void 0?e.push([]):e.push([...t]);return e}get rowCount(){return this.rows.length}get columnCount(){return this.columnMaxLength}*rowsWithLabelsObject(){for(let e=0;e<this.rows.length;e++)yield this.getRowWithLabelsObject(e)}*rowsWithLabelsArray(){for(let e=0;e<this.rows.length;e++)yield this.getRowWithLabelsArray(e)}labelColumns(...e){this.colLabels=e}labelColumn(e,t){this.colLabels[e]=t}labelRows(...e){this.rowLabels=e}labelRow(e,t){this.rowLabels[e]=t}appendRow(...e){return this.columnMaxLength=Math.max(this.columnMaxLength,e.length),this.rows.push(e),e}getRowWithLabelsArray(e){const t=this.rows.at(e);if(t!==void 0)return t.map((r,n)=>[this.colLabels.at(n),r])}getRowWithLabelsObject(e){const t=this.rows.at(e);if(t===void 0)return;const r={};for(let n=0;n<this.colLabels.length;n++){const s=this.colLabels.at(n)??n.toString();r[s]=t[n]}return r}#e(e){const t=typeof e=="number"?e:this.getRowLabelIndex(e);if(t===void 0)return{success:!1,error:"row-label-notfound"};if(t<0)return{success:!1,error:"row-index-invalid"};if(t<this.rows.length)return{success:!0,value:this.rows[t]};const r=[];return this.rows[t]=r,{success:!0,value:r}}row(e){const t=this.#t(e);if(R(t))throw new Error(t.error);return[...t.value]}set(e,t,r){const n=this.#e(e);if(R(n))throw new Error(n.error);const s=n.value,i=typeof t=="number"?t:this.getColumnLabelIndex(t);if(typeof i>"u")throw new Error(`Column label '${t}' not found or is invalid`);if(i<0)throw new Error("Column index invalid (less than zero)");s[i]=r}get(e,t){const r=this.#t(e);if(R(r))throw new Error(r.error);const n=this.#r(r.value,t);if(R(n))throw new Error(n.error);return n.value.value}#t(e){let t=0;if(typeof e=="number")t=e;else if(t=this.getRowLabelIndex(e),typeof t!="number")return{error:"row-label-notfound",success:!1};return typeof t!="number"?{error:"row-invalid",success:!1}:t<0||t>=this.rows.length?{error:"row-index-out-of-range",success:!1}:{success:!0,value:this.rows[t]}}#r(e,t){const r=typeof t=="number"?t:this.getColumnLabelIndex(t);return typeof r!="number"?{success:!1,error:"col-label-notfound"}:r<0||r>=e.length?{success:!1,error:"col-index-out-of-range"}:{success:!0,value:{index:r,value:e[r]}}}setRow(e,t,r){const n=this.#e(e);if(R(n))throw new Error(n.error);const s=n.value,i=typeof r=="number"?r:this.columnMaxLength;for(let o=0;o<i;o++)s[o]=t;return s}},Xt={};y(Xt,{adjacentVertices:()=>qe,areAdjacent:()=>cs,bfs:()=>fs,clone:()=>hs,connect:()=>tr,connectTo:()=>ue,connectWithEdges:()=>rr,createVertex:()=>Ht,dfs:()=>nr,disconnect:()=>er,distance:()=>Zt,distanceDefault:()=>us,dumpGraph:()=>rs,edges:()=>Yt,get:()=>es,getCycles:()=>ir,getOrCreate:()=>ae,getOrFail:()=>as,graph:()=>ps,graphFromVertices:()=>sr,hasKey:()=>Yn,hasNoOuts:()=>is,hasOnlyOuts:()=>os,hasOut:()=>x,isAcyclic:()=>ys,pathDijkstra:()=>ds,toAdjacencyMatrix:()=>ts,topologicalSort:()=>vs,transitiveReduction:()=>or,updateGraphVertex:()=>ee,vertexHasOut:()=>ss,vertices:()=>Fe});const Ht=e=>({id:e,out:[]});function Yn(e,t){return l(d(e)),e.vertices.has(t)}function es(e,t){return l(d(e)),l(mr(t,"non-empty","key")),e.vertices.get(t)}function ts(e){l(d(e));const t=[...e.vertices.values()],r=new Qt;r.labelColumns(...t.map(n=>n.id)),r.labelRows(...t.map(n=>n.id));for(let n=0;n<t.length;n++){r.setRow(n,!1,t.length);const s=t[n];for(const[i,o]of t.entries())s.out.some(a=>a.id===o.id)&&r.set(n,i,!0)}return r}const rs=e=>ns(e).join(`
`),ns=e=>{const t=[],r="vertices"in e?e.vertices.values():e;for(const n of r){const s=ls(n);t.push(...s.map(i=>` ${i}`))}return t},Zt=(e,t)=>t.weight!==void 0?t.weight:1;function*Yt(e){l(d(e));const t=[...e.vertices.values()];for(const r of t)for(const n of r.out)yield n}function*Fe(e){l(d(e));const t=[...e.vertices.values()];for(const r of t)yield r}function d(e,t="graph"){if(e===void 0)return{success:!1,error:`Param '${t}' is undefined. Expected Graph`};if(e===null)return{success:!1,error:`Param '${t}' is null. Expected Graph`};if(typeof e=="object"){if(!("vertices"in e))return{success:!1,error:`Param '${t}.vertices' does not exist. Is it a Graph type?`}}else return{success:!1,error:`Param '${t} is type '${typeof e}'. Expected an object Graph`};return{success:!0,value:e}}function*qe(e,t){if(l(d(e)),t===void 0)return;const r=typeof t=="string"?e.vertices.get(t):t;if(r===void 0)throw new Error(`Vertex not found ${JSON.stringify(t)}`);for(const n of r.out){const s=e.vertices.get(n.id);if(s===void 0)throw new Error(`Could not find vertex: ${n.id}`);yield s}}const ss=(e,t)=>{if(e===void 0)return!1;const r=typeof t=="string"?t:t.id;return e.out.some(n=>n.id===r)},is=(e,t)=>{l(d(e));const r=typeof t=="string"?e.vertices.get(t):t;return r===void 0?!1:r.out.length===0},os=(e,t,...r)=>{l(d(e));const n=b(e,t),s=r.map(i=>b(e,i));if(s.length!==n.out.length)return!1;for(const i of s)if(!x(e,n,i))return!1;return!0},x=(e,t,r)=>{l(d(e));const n=b(e,t),s=typeof r=="string"?r:r.id;return n.out.some(i=>i.id===s)},ae=(e,t)=>{l(d(e));const r=e.vertices.get(t);if(r!==void 0)return{graph:e,vertex:r};const n=Ht(t);return{graph:ee(e,n),vertex:n}},as=(e,t)=>{l(d(e));const r=e.vertices.get(t);if(r===void 0)throw new Error(`Vertex '${t}' not found in graph`);return r},ee=(e,t)=>(l(d(e)),{...e,vertices:e.vertices.set(t.id,t)}),us=(e,t)=>t.weight!==void 0?t.weight:1;function er(e,t,r){l(d(e));const n=b(e,t),s=b(e,r);return x(e,n,s)?ee(e,{...n,out:n.out.filter(i=>i.id!==s.id)}):e}function ue(e,t,r,n){l(d(e));const s=ae(e,t);e=s.graph;const i=ae(e,r);e=i.graph;const o={id:r,weight:n};return x(e,s.vertex,i.vertex)||(e=ee(e,{...s.vertex,out:[...s.vertex.out,o]})),{graph:e,edge:o}}function tr(e,t){if(typeof e!="object")throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${typeof e}`);if(typeof t!="object")throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${typeof t}`);return rr(e,t).graph}function rr(e,t){l(d(e));const{to:r,weight:n,from:s}=t,i=t.bidi??!1,o=Array.isArray(r)?r:[r],a=[];for(const u of o){const c=ue(e,s,u,n);e=c.graph,a.push(c.edge)}if(!i)return{graph:e,edges:a};for(const u of o){const c=ue(e,u,s,n);e=c.graph,a.push(c.edge)}return{graph:e,edges:a}}const ls=e=>{const t=[e.id],r=n=>n.weight===void 0?n.id:`${n.id} (${n.weight})`;for(const n of e.out)t.push(` -> ${r(n)}`);return e.out.length===0&&(t[0]+=" (terminal)"),t};function cs(e,t,r){if(l(d(e)),x(e,t,r.id)||x(e,r,t.id))return!0}function b(e,t){if(l(d(e)),t===void 0)throw new Error("Param 'idOrVertex' is undefined. Expected string or Vertex");const r=typeof t=="string"?e.vertices.get(t):t;if(r===void 0)throw new Error(`Id not found ${t}`);return r}function*fs(e,t,r){l(d(e));const n=b(e,t),s=r===void 0?void 0:b(e,r),i=new V,o=new Set;for(i.enqueue(n);!i.isEmpty;){const a=i.dequeue();if(yield a,s!==void 0&&s===a)return;for(const u of qe(e,a))o.has(u.id)||(o.add(u.id),i.enqueue(b(e,u.id)))}}function*nr(e,t){l(d(e));const r=b(e,t),n=new B,s=new Set;for(n.push(r);!n.isEmpty;){const i=n.pop();if(i!==void 0&&!s.has(i.id)){s.add(i.id),yield i;for(const o of i.out){const a=e.vertices.get(o.id);a&&n.push(a)}}}}const ds=(e,t)=>{l(d(e));const r=typeof t=="string"?e.vertices.get(t):t;if(r===void 0)throw new Error("source vertex not found");const n=new Map,s=new Map;n.set(r.id,0);const i=new Ne,o=[...e.vertices.values()];for(const u of o)u.id!==r.id&&(n.set(u.id,Number.MAX_SAFE_INTEGER),s.set(u.id,null)),i.enqueueWithPriority(u.id,Number.MAX_SAFE_INTEGER);for(;!i.isEmpty;){const u=i.dequeueMin();if(u===void 0)throw new Error("Bug. Queue unexpectedly empty");const c=e.vertices.get(u);for(const h of c.out){const m=n.get(u)+Zt(e,h);m<n.get(h.id)&&(n.set(h.id,m),s.set(h.id,c),i.changePriority(h.id,m,!0))}}return{distances:n,previous:s,pathTo:u=>{const c=[];for(;u!==r.id;){const h=s.get(u);if(h==null)throw new Error(`Id not present: ${u}`);c.push({id:u,weight:n.get(u)}),u=h.id}return c}}},hs=e=>(l(d(e)),{vertices:v([...e.vertices.entries()])}),ps=(...e)=>{let t={vertices:v()};for(const r of e)t=tr(t,r);return t};function ys(e){return l(d(e)),ir(e).length===0}function vs(e){l(d(e));const t=new Jt(0);for(const i of Yt(e))t.add(i.id,1);const r=new V;let n=0;for(const i of Fe(e))t.get(i.id)===0&&r.enqueue(i),n++;const s=[];for(;!r.isEmpty;){const i=r.dequeue();s.push(i);for(const o of i.out)t.subtract(o.id,1)===0&&r.enqueue(e.vertices.get(o.id))}if(s.length!==n)throw new Error("Graph contains cycles");return sr(s)}function sr(e){const t=Gr(e,n=>[n.id,n]);return{vertices:v([...t])}}function ir(e){l(d(e));let t=0;const r=new B,n=new Map,s=[];for(const o of e.vertices.values())n.set(o.id,{...o,lowlink:NaN,index:NaN,onStack:!1});const i=o=>{o.index=t,o.lowlink=t,t++,r.push(o),o.onStack=!0;for(const a of o.out){const u=n.get(a.id);Number.isNaN(u.index)?(i(u),o.lowlink=Math.min(o.lowlink,u.lowlink)):u.onStack&&(o.lowlink=Math.min(o.lowlink,u.lowlink))}if(o.lowlink===o.index){const a=[];let u;for(;o!==u;)u=r.pop(),u.onStack=!1,a.push({id:u.id,out:u.out});a.length>1&&s.push(a)}};for(const o of n.values())Number.isNaN(o.index)&&i(o);return s}function or(e){l(d(e));for(const t of Fe(e))for(const r of qe(e,t))for(const n of nr(e,r))if(r.id!==n.id&&x(e,t,n)){const s=er(e,t,n);return or(s)}return e}var ar={};y(ar,{adjacentVertices:()=>Vs,connect:()=>dr,connectTo:()=>fr,connectWithEdges:()=>hr,createVertex:()=>ur,dumpGraph:()=>ws,edgesForVertex:()=>Ss,getConnection:()=>Oe,getOrCreate:()=>le,graph:()=>gs,hasConnection:()=>cr,toAdjacencyMatrix:()=>ms,updateGraphVertex:()=>lr});const ur=e=>({id:e}),lr=(e,t)=>({...e,vertices:e.vertices.set(t.id,t)}),le=(e,t)=>{const r=e.vertices.get(t);if(r!==void 0)return{graph:e,vertex:r};const n=ur(t);return{graph:lr(e,n),vertex:n}};function U(e,t){if(t===void 0)throw new Error("Param 'idOrVertex' is undefined. Expected string or Vertex");if(e===void 0)throw new Error("Param 'graph' is undefined. Expected Graph");const r=typeof t=="string"?e.vertices.get(t):t;if(r===void 0)throw new Error(`Id not found ${t}`);return r}const cr=(e,t,r)=>Oe(e,t,r)!==void 0,Oe=(e,t,r)=>{if(t===void 0)throw new Error("Param 'a' is undefined. Expected string or Vertex");if(r===void 0)throw new Error("Param 'b' is undefined. Expected string or Vertex");if(e===void 0)throw new Error("Param 'graph' is undefined. Expected Graph");const n=U(e,t),s=U(e,r);for(const i of e.edges)if(i.a==n.id&&i.b===s.id||i.a==s.id&&i.b===n.id)return i};function fr(e,t,r,n){e=le(e,t).graph,e=le(e,r).graph;let o=Oe(e,t,r);return o!==void 0?{graph:e,edge:o}:(o={a:t,b:r,weight:n},{graph:{...e,edges:[...e.edges,o]},edge:o})}function dr(e,t){return hr(e,t).graph}function hr(e,t){const{a:r,weight:n,b:s}=t,i=Array.isArray(s)?s:[s],o=[];for(const a of i){const u=fr(e,r,a,n);e=u.graph,o.push(u.edge)}return{graph:e,edges:o}}const gs=(...e)=>{let t={vertices:v(),edges:[]};for(const r of e)t=dr(t,r);return t};function ms(e){const t=[...e.vertices.values()],r=new Qt;r.labelColumns(...t.map(n=>n.id)),r.labelRows(...t.map(n=>n.id));for(let n=0;n<t.length;n++){r.setRow(n,!1,t.length);const s=t[n];for(const[i,o]of t.entries())cr(e,s,o)&&r.set(n,i,!0)}return r}const ws=e=>bs(e).join(`
`),bs=e=>{const t=[];t.push(`Vertices: ${[...e.vertices.values()].map(r=>r.id).join(", ")}`),t.push("Edges:");for(const r of e.edges)t.push(Es(r));return t},Es=e=>{const t=e.weight?` (${e.weight})`:"";return`${e.a} <-> ${e.b}${t}`};function*Vs(e,t){if(t===void 0)return;if((typeof t=="string"?e.vertices.get(t):t)===void 0)throw new Error(`Vertex not found ${JSON.stringify(t)}`);for(const n of e.edges)n.a===t?yield U(e,n.b):n.b===t&&(yield U(e,n.a))}function*Ss(e,t){if(t===void 0)return;if((typeof t=="string"?e.vertices.get(t):t)===void 0)throw new Error(`Vertex not found ${JSON.stringify(t)}`);for(const n of e.edges)n.a===t?yield n:n.b===t&&(yield n)}var Ms={};y(Ms,{Directed:()=>Xt,Undirected:()=>ar});const M=Object.freeze({log:vr("#log",{css:`
    .recv { color: hsl(var(--hue-primary), 88%, 96%);}
    .meta { color: hsl(var(--hue-secondary), 0%, 76%);}
    `,reverse:!0}),txtInput:document.querySelector("#txtInput"),selBoard:document.querySelector("#board")});let g=Object.freeze({board:"puck",espruino:void 0,history:jt.mutable(),historyIndex:0});const pr=()=>{const{txtInput:e}=M;e.focus(),e.setSelectionRange(0,e.value.length)},xs=e=>{const{txtInput:t}=M;t.value=e,t.setSelectionRange(0,t.value.length)},Q=e=>{const{txtInput:t}=M;e?(document.body.classList.add("disconnected"),t.setAttribute("disabled","true"),document.querySelector("#btnSend")?.setAttribute("disabled","true"),document.querySelector("#btnConnect")?.removeAttribute("disabled"),document.querySelector("#btnDisconnect")?.setAttribute("disabled","true")):(document.body.classList.remove("disconnected"),t.removeAttribute("disabled"),document.querySelector("#btnSend")?.removeAttribute("disabled"),document.querySelector("#btnConnect")?.setAttribute("disabled","true"),document.querySelector("#btnDisconnect")?.removeAttribute("disabled"),pr())},Ke=async e=>{const{log:t,txtInput:r}=M,{espruino:n,history:s}=g;if(n===void 0){console.warn("No Espruino instance");return}e===void 0&&(e=r.value),e.endsWith(";")&&(e=e.slice(0,Math.max(0,e.length-1))),s.peek!==e&&s.push(e),C({history:s,historyIndex:s.data.length-1}),t.log(`> ${e}`)?.classList.add("sent");try{const i=await n.eval(e,{timeoutMs:2e3,assumeExclusive:!0,debug:!1});t.log(`< ${i}`)?.classList.add("recv")}catch(i){console.log(i),t.error(i)}pr()};document.querySelector("#btnDemo")?.addEventListener("click",async()=>{const{log:e}=M,{espruino:t}=g,s=g.board==="pico"?`
  // http://www.espruino.com/Pico
  // LED on/off
  LED1.set()
  LED1.reset()
  // Read analog pin 5
  analogRead(A5)
  // Read button state
  digitalRead(BTN)
  `:`
  // https://www.espruino.com/Puck.js
  // LED on/off
  LED1.set()
  LED1.reset()
  // Read button state
  BTN.read()
  // Read magnetometer
  Puck.mag()
  // Read accelerometer
  Puck.accel()
  // Read light sensor
  Puck.light()
  // Read temperature
  E.getTemperature()`,i=!(t===void 0||!t.isConnected);i||e.log("// Connect to an Espruino to run this for real");const o=async a=>{if(a)if(a=a.trim(),a.startsWith("//")||t===void 0||!t.isConnected)e.log(a)?.classList.add("meta");else return Ke(a+`
`)};for await(const a of s.trim().split(`
`))await o(a),await zr(i?1e3:400)});document.querySelector("#btnSend")?.addEventListener("click",()=>Ke());document.querySelector("#btnDisconnect")?.addEventListener("click",()=>{const{espruino:e}=g;e!==void 0&&e.disconnect()});document.querySelector("#btnConnect")?.addEventListener("click",async()=>{const{log:e,selBoard:t}=M,r=t.value;(r==="pico"||r==="puck")&&(C({board:r}),localStorage.setItem("board",r));try{if(g.board==="puck"){const n=await Ge.connectBle({debug:!1});C({espruino:n})}else if(g.board==="pico"){const n=await Ge.serial();C({espruino:n})}}catch(n){e.error(n)}});const Ps=()=>{const{txtInput:e,selBoard:t}=M;Q(!0),e.addEventListener("keyup",n=>{const{history:s}=g;let{historyIndex:i}=g;n.key==="ArrowUp"||n.key==="ArrowDown"?(n.key==="ArrowUp"?i=Math.max(0,i-1):n.key==="ArrowDown"&&(i=Math.min(s.data.length-1,i+1)),C({historyIndex:i}),xs(s.data[i]),n.preventDefault()):n.key==="Enter"&&(Ke(),n.preventDefault())});const r=localStorage.getItem("board");(r==="pico"||r==="puck")&&(t.value=r,C({board:r}))};Ps();function ze(e){const{log:t}=M;t.log(`State: ${e.newState}`)?.classList.add("meta"),e.newState==="connected"?Q(!1):Q(!0)}function C(e){const t=g.espruino;g=Object.freeze({...g,...e}),e.espruino&&(t&&t.removeEventListener("change",ze),e.espruino.addEventListener("change",ze),Q(!1))}
