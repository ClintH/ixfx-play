var le=Object.create,_=Object.defineProperty,pe=Object.getOwnPropertyDescriptor,D=Object.getOwnPropertyNames,me=Object.getPrototypeOf,he=Object.prototype.hasOwnProperty,ut=(e,r)=>function(){return r||(0,e[D(e)[0]])((r={exports:{}}).exports,r),r.exports},P=(e,r)=>{for(var t in r)_(e,t,{get:r[t],enumerable:!0})},ye=(e,r,t,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(var s=D(r),o=0,i=s.length,c;o<i;o++)c=s[o],!he.call(e,c)&&c!==t&&_(e,c,{get:(l=>r[l]).bind(null,c),enumerable:!(n=pe(r,c))||n.enumerable});return e},ft=(e,r,t)=>(t=e!=null?le(me(e)):{},ye(_(t,"default",{value:e,enumerable:!0}),e));const B=e=>typeof e=="string"?e:e instanceof Error?e.message:e,I=(...e)=>{const r=e.filter(n=>G(n));if(r.length===0)return;const t=r.map(n=>W(n));throw new Error(t.join(", "))};function a(...e){for(const r of e){const t=typeof r=="object"?r:r();if(t!==void 0&&!t.success)throw x(t)}return!0}function ge(e){if(e.success)return!0;throw x(e)}const we=(...e)=>{for(const r of e){const t=typeof r=="object"?r:r();if(t!==void 0&&!t.success)return t}};function G(e){return typeof e!="object"?!1:!e.success}function k(e){return typeof e!="object"?!1:e.success}function x(e){if(typeof e.error=="string")throw new Error(e.error,{cause:e.info});if(e.error instanceof Error)throw e.error;return new Error(JSON.stringify(e.error),{cause:e.info})}function be(e){if(k(e))return e.value;throw x(e)}function W(e){return e.error instanceof Error?B(e.error):typeof e.error=="string"?e.error:JSON.stringify(e.error)}function de(e,r){return{success:!1,error:e,info:r}}const S=(...e)=>{let r;for(const t of e)if(r=typeof t=="object"?t:t(),r!==void 0&&!r.success)return r;if(!r)throw new Error("No results");return r},Ee=(e,r)=>{G(e)&&r(e)},Ne=e=>Math.log2(e)%1===0,Pe=(e,r)=>{if(typeof e!="number")throw new TypeError(`v is not a number. Got: ${typeof e}`);return Number.isNaN(e)?r:e},Ae=(e,r="",t=NaN)=>{if(typeof e>"u"||e===null)return t;try{const n=Number.parseInt(typeof e=="number"?e.toString():e);return y(n,r,"parsed").success?n:t}catch{return t}},f=(e,r="",t="?",n)=>{if(e===null)return{success:!1,error:`Parameter '${t}' is null`,info:n};if(typeof e>"u")return{success:!1,error:`Parameter '${t}' is undefined`,info:n};if(Number.isNaN(e))return{success:!1,error:`Parameter '${t}' is NaN`,info:n};if(typeof e!="number")return{success:!1,error:`Parameter '${t}' is not a number (${JSON.stringify(e)})`,info:n};switch(r){case"finite":{if(!Number.isFinite(e))return{success:!1,error:`Parameter '${t} must be finite (Got: ${e})`,info:n};break}case"positive":{if(e<0)return{success:!1,error:`Parameter '${t}' must be at least zero (${e})`,info:n};break}case"negative":{if(e>0)return{success:!1,error:`Parameter '${t}' must be zero or lower (${e})`,info:n};break}case"aboveZero":{if(e<=0)return{success:!1,error:`Parameter '${t}' must be above zero (${e})`,info:n};break}case"belowZero":{if(e>=0)return{success:!1,error:`Parameter '${t}' must be below zero (${e})`,info:n};break}case"percentage":{if(e>1||e<0)return{success:!1,error:`Parameter '${t}' must be in percentage range (0 to 1). (${e})`,info:n};break}case"nonZero":{if(e===0)return{success:!1,error:`Parameter '${t}' must non-zero. (${e})`,info:n};break}case"bipolar":{if(e>1||e<-1)return{success:!1,error:`Parameter '${t}' must be in bipolar percentage range (-1 to 1). (${e})`,info:n};break}}return{success:!0,value:e,info:n}},Te=(e,r,t=3)=>{if(t===0)return e=Math.floor(e),r=Math.floor(r),e===r?{success:!0,value:e}:{success:!1,error:"A is not identical to B"};const n=Math.pow(10,t),s=Math.floor(e*n),o=Math.floor(r*n);return s!==o?{success:!1,error:`A is not close enough to B. A: ${e} B: ${r} Decimals: ${t}`}:{success:!0,value:e}},Ie=(e,r="?",t)=>f(e,"percentage",r,t),y=(e,r="",t="?")=>S(f(e,r,t),()=>Number.isInteger(e)?{success:!0,value:e}:{success:!1,error:`Param '${t}' is not an integer`}),C=e=>{for(const r of e)if(Math.abs(r)%1!==0)return{success:!1,error:`Value is not an integer: ${r}`};return{success:!0,value:e}},xe=e=>(typeof e=="string"&&(e=Number.parseFloat(e)),y(e).success),L=(e,r,t,n="?")=>typeof e!="number"?{success:!1,error:`Param '${n}' is not a number type. Got type: '${typeof e}' value: '${JSON.stringify(e)}'`}:Number.isNaN(e)?{success:!1,error:`Param '${n}' is not within range ${r}-${t}. Got: NaN`}:Number.isFinite(e)?e<r?{success:!1,error:`Param '${n}' is below range ${r}-${t}. Got: ${e}`}:e>t?{success:!1,error:`Param '${n}' is above range ${r}-${t}. Got: ${e}`}:{success:!0,value:e}:{success:!1,error:`Param '${n}' is not within range ${r}-${t}. Got: infinite`},h=(e,r="?")=>Array.isArray(e)?{success:!0,value:e}:{success:!1,error:`Parameter '${r}' is expected to be an array'`},N=(e,r,t="index")=>S(h(e),y(r,"positive",t),L(r,0,e.length-1,t)),Se=e=>Array.isArray(e)?e.some(r=>typeof r!="string")?{success:!1,error:"Contains something not a string"}:{success:!0,value:e}:{success:!1,error:"Value is not an array"},Me=(e,r="?")=>typeof e>"u"?{success:!1,error:`${r} param is undefined`}:e===null?{success:!1,error:`${r} param is null`}:{success:!0,value:e},Fe=e=>e!==void 0,$e=e=>e instanceof Function,_e=(e,r="?")=>e===void 0?{success:!1,error:`Param '${r}' is undefined. Expected: function.`}:e===null?{success:!1,error:`Param '${r}' is null. Expected: function.`}:typeof e!="function"?{success:!1,error:`Param '${r}' is type '${typeof e}'. Expected: function`}:{success:!0,value:e},z=e=>{if(typeof e!="object"||e===null)return{success:!1,error:"Value is null or not object type"};const r=Object.getPrototypeOf(e);return(r===null||r===Object.prototype||Object.getPrototypeOf(r)===null)&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)?{success:!0,value:e}:{success:!1,error:"Fancy object"}},Ge=e=>{const r=typeof e;return r==="symbol"?{success:!1,error:"Symbol type"}:r==="function"?{success:!1,error:"Function type"}:r==="bigint"?{success:!0,value:e}:r==="number"?{success:!0,value:e}:r==="string"?{success:!0,value:e}:r==="boolean"?{success:!0,value:e}:z(e)},Oe=(e,r)=>S(Z(e,r),C(e)),Z=(e,r)=>{for(const t of e){if(r.minExclusive!==void 0&&t<=r.minExclusive)return{success:!1,error:`Value '${t}' must be higher than minExclusive: '${r.minExclusive}'`};if(r.minInclusive!==void 0&&t<r.minInclusive)return{success:!1,error:`Value '${t}' must be equal or higher than minInclusive: '${r.minInclusive}'`};if(r.maxExclusive!==void 0&&t>=r.maxExclusive)return{success:!1,error:`Value '${t}' must be less than maxExclusive: '${r.maxExclusive}'`};if(r.maxInclusive!==void 0&&t>r.maxInclusive)return{success:!1,error:`Value '${t}' must be equal or less than maxInclusive: '${r.maxInclusive}'`}}return{success:!0,value:e}},ve=(e,r="",t="?")=>{if(typeof e!="string")return{success:!1,error:`Param '${t} is not type string. Got: ${typeof e}`};switch(r){case"non-empty":if(e.length===0)return{success:!1,error:`Param '${t} is empty`};break}return{success:!0,value:e}};var je={};P(je,{arrayIndexTest:()=>N,arrayStringsTest:()=>Se,arrayTest:()=>h,errorResult:()=>de,functionTest:()=>_e,getErrorMessage:()=>B,ifNaN:()=>Pe,integerArrayTest:()=>C,integerParse:()=>Ae,integerTest:()=>y,isDefined:()=>Fe,isFunction:()=>$e,isInteger:()=>xe,isPowerOfTwo:()=>Ne,nullUndefTest:()=>Me,numberDecimalTest:()=>Te,numberInclusiveRangeTest:()=>L,numberTest:()=>f,percentTest:()=>Ie,rangeIntegerTest:()=>Oe,rangeTest:()=>Z,resultErrorToString:()=>W,resultFirstFail_:()=>we,resultIsError:()=>G,resultIsOk:()=>k,resultThrow:()=>a,resultThrowSingle:()=>ge,resultToError:()=>x,resultToValue:()=>be,resultWithFail:()=>Ee,resultsCollate:()=>S,stringTest:()=>ve,testPlainObject:()=>z,testPlainObjectOrPrimitive:()=>Ge,throwIfFailed:()=>I});const Re=e=>{I(h(e,"options"));const r=[...e];let t=0;const n=()=>(t++,t===r.length&&(t=0),o()),s=()=>(t--,t===-1&&(t=r.length-1),o()),o=()=>r.at(t);return{toArray:()=>[...r],next:n,prev:s,get current(){return o()},select:l=>{if(typeof l=="number")t=l;else{const p=r.indexOf(l);if(p===-1)throw new Error("Could not find value");t=p}}}},qe=(e,r)=>{if(a(f(r,"","index")),!Array.isArray(e))throw new Error("Param 'array' is not an array");return r=r%e.length,e.at(r)};function De(e,r){I(y(r,"aboveZero","size"),h(e,"array"));const t=[];for(let n=0;n<e.length;n+=r)t.push(e.slice(n,n+r));return t}const T=e=>typeof e=="string"?e:JSON.stringify(e),A=(e,r)=>e===r,Be=(e,r)=>e===r?!0:T(e)===T(r),ke=(e,r,t=A)=>{if(!Array.isArray(e))throw new TypeError("Expects haystack parameter to be an array");if(!Array.isArray(r))throw new TypeError(`Expects needles parameter to be an array. Got: ${typeof r}`);for(const n of r){let s=!1;for(const o of e)if(t(n,o)){s=!0;break}if(!s)return!1}return!0},We=(e,r=T)=>{if(typeof e!="object")throw new Error(`Param 'data' is expected to be an Iterable. Got type: ${typeof e}`);const t=new Set;for(const n of e){const s=r(n);if(t.has(s))return!0;t.add(s)}return!1},Ce=e=>{if(!Array.isArray(e))throw new Error("Parameter needs to be an array");for(let r=0;r<e.length;r++)for(let t=0;t<e.length;t++)if(r!==t&&e[r]===e[t])return!0;return!1};function Le(e,r,t="undefined"){if(e===void 0)throw new Error("Data undefined");if(!Array.isArray(e))throw new Error("data is not an array");if(e.length===r)return[...e];if(e.length>r)return e.slice(0,r);const n=[...e],s=r-n.length;for(let o=0;o<s;o++)switch(t){case"undefined":{n.push(void 0);break}case"repeat":{n.push(e[o%e.length]);break}case"first":{n.push(e[0]);break}case"last":{n.push(e.at(-1));break}}return n}const ze=(e,r,t=A)=>{if(a(h(e,"arrayA"),h(r,"arrayB")),e.length!==r.length)return!1;for(let n=0;n<e.length;n++)if(!t(e[n],r[n]))return!1;return!0},O=(e,r)=>{if(!Array.isArray(e))throw new Error("Param 'array' is not an array.");if(e.length===0)return!0;const t=r??Be,n=e[0];return!e.some(o=>!t(n,o))},Ze=(e,r)=>{const t=[],n=[];for(const s of e)r(s)?t.push(s):n.push(s);return[t,n]};function*Ue(e,r,t,n){a(h(e,"array")),typeof t>"u"&&(t=0),typeof n>"u"&&(n=e.length),a(N(e,t,"startIndex")),a(N(e,n-1,"endIndex"));for(let s=t;s<n;s++)r(e[s],s,e)&&(yield e[s])}const Je=e=>[...e].flat(),Xe=(e,r,t)=>typeof e!="object"||!Array.isArray(e)||e.length===0?Array.isArray(t)?t:[t]:e.map(r),Ke=(e,r)=>{if(!Array.isArray(r))throw new TypeError(`Param 'array' is expected to be an array. Got type: '${typeof r}'`);const t=new Map;for(const n of r){const s=e(n);if(typeof s!="string"&&typeof s!="number")throw new TypeError(`groupBy function is expected to return type string or number. Got type: '${typeof s}' for value: '${n}'`);let o=t.get(s);o??=0,o++,t.set(s,o)}return t},Qe=(e,r)=>{const t=new Map;for(const n of e){const s=r(n);let o=t.get(s);o||(o=[],t.set(s,o)),o.push(n)}return t},Ve=(e,r=A)=>{const t=[],n=o=>{for(const i of t)if(r(i,o))return!0;return!1},s=e.flat(10);for(const o of s)n(o)||t.push(o);return t},He=(e,r=T)=>{const t=new Set,n=[],s=e.flat(10);for(const o of s){const i=r(o);t.has(i)||(t.add(i),n.push(o))}return n},Ye=(e,r,...t)=>(I(h(e,"data"),N(e,r,"index")),r===e.length-1?[...e,...t]:r===0?[...t,...e]:[...e.slice(0,r),...t,...e.slice(r)]),er=(...e)=>{if(e.some(s=>!Array.isArray(s)))throw new Error("All parameters must be an array");const r=e.map(s=>s.length);if(!O(r))throw new Error("Arrays must be of same length");const t=[],n=r[0];for(let s=0;s<n;s++)for(const o of e)t.push(o[s]);return t},rr=(e,r,t=A)=>e.filter(n=>r.some(s=>t(n,s))),tr=(e,r,...t)=>{const n=new Map;for(const s of t)for(const o of s){if(o===void 0)continue;const i=e(o);let c=n.get(i);c=c?r(c,o):o,n.set(i,c)}return[...n.values()]};function*nr(e){if(a(h(e,"values")),e.length<2)throw new Error(`Array needs to have at least two entries. Length: ${e.length}`);for(let r=1;r<e.length;r++)yield[e[r-1],e[r]]}const sr=(e,r,t)=>{if(a(h(e,"arr")),e.length<2)return t;for(let n=0;n<e.length-1;n++)t=r(t,e[n],e[n+1]);return t},or=(e,r=Math.random)=>{a(h(e,"dataToShuffle"));const t=[...e];for(let n=t.length-1;n>0;n--){const s=Math.floor(r()*(n+1));[t[n],t[s]]=[t[s],t[n]]}return t},ir=(e,r=Math.random)=>(a(h(e,"array")),e[Math.floor(r()*e.length)]),cr=(e,r=Math.random)=>Math.floor(r()*e.length),ur=(e,r)=>{if(!Array.isArray(e))throw new TypeError("'data' parameter should be an array");return a(N(e,r,"index")),[...e.slice(0,r),...e.slice(r+1)]},fr=(e,r)=>{if(!Array.isArray(e))throw new TypeError(`Param 'array' is not actually an array. Got type: ${typeof e}`);let t=1;if(r<=1){const s=e.length*r;t=Math.round(e.length/s)}else t=r;if(a(y(t,"positive","amount")),t>e.length-1)throw new Error("Subsample steps exceeds array length");const n=[];for(let s=t-1;s<e.length;s+=t)n.push(e[s]);return n},ar=(e,r)=>[...e].sort((t,n)=>{a(h(e,"data"));const s=t[r],o=n[r];return s<o?-1:s>o?1:0}),lr=(e,r,t)=>[...e].sort((n,s)=>{a(h(e,"data"));const o=n[r],i=s[r];return t===void 0?o<i?-1:o>i?1:0:t(o,i)});function*pr(e,r,t){let n=t;for(const s of e){const o=r(s,n);if(typeof o=="boolean"){if(o)break}else{const[i,c]=o;if(i)break;n=c}yield s}}const mr=e=>e.filter(r=>r!==void 0),hr=(e,r,t=A)=>{if(Array.isArray(r)){const n=[];for(const s of e)r.some(o=>t(s,o))||n.push(s);return n}else return e.filter(n=>!t(n,r))},U=(...e)=>{if(e.some(s=>!Array.isArray(s)))throw new Error("All parameters must be an array");const r=e.map(s=>s.length);if(!O(r))throw new Error("Arrays must be of same length");const t=[],n=r[0];for(let s=0;s<n;s++)t.push(e.map(o=>o[s]));return t};var yr={};P(yr,{atWrap:()=>qe,chunks:()=>De,contains:()=>ke,containsDuplicateInstances:()=>Ce,containsDuplicateValues:()=>We,containsIdenticalValues:()=>O,cycle:()=>Re,ensureLength:()=>Le,filterAB:()=>Ze,filterBetween:()=>Ue,flatten:()=>Je,frequencyByGroup:()=>Ke,groupBy:()=>Qe,insertAt:()=>Ye,interleave:()=>er,intersection:()=>rr,isEqual:()=>ze,mapWithEmptyFallback:()=>Xe,mergeByKey:()=>tr,pairwise:()=>nr,pairwiseReduce:()=>sr,randomElement:()=>ir,randomIndex:()=>cr,remove:()=>ur,sample:()=>fr,shuffle:()=>or,sortByNumericProperty:()=>ar,sortByProperty:()=>lr,unique:()=>He,uniqueDeep:()=>Ve,until:()=>pr,without:()=>hr,withoutUndefined:()=>mr,zip:()=>U});const gr=(e,r)=>{const t={...e};for(const[n,s]of Object.entries(e))typeof s=="number"?t[n]=r(s):t[n]=s;return t},J=(e,r)=>{if(!Array.isArray(e))throw new TypeError(`Param 'data' is expected to be an array. Got type: ${typeof e}`);const t=r??(n=>n);return e.map((n,s)=>{if(typeof n!="number")throw new TypeError(`Param 'data' contains non-number at index: '${s}'. Type: '${typeof n}' value: '${n}'`);const o=s/(e.length-1),i=t(o);if(typeof i!="number")throw new TypeError(`Weighting function returned type '${typeof i}' rather than number for input: '${o}'`);return n*i})},M=e=>e.filter(r=>typeof r=="number"&&!Number.isNaN(r)),wr=e=>{let r=0;const t=e[0].length;for(let n=0;n<t;n++){let s=0;for(const[o,i]of e.entries())o===0?s=i[n]:s*=i[n];r+=s}return r},X=e=>{if(e===void 0)throw new Error("data parameter is undefined");const r=M(e);return r.reduce((n,s)=>n+s,0)/r.length},br=e=>Math.min(...M(e)),dr=e=>e.reduce((r,t,n,s)=>t>s[r]?n:r,0),Er=(...e)=>e.reduce((r,t,n,s)=>t<s[r]?n:r,0),Nr=e=>Math.max(...M(e)),Pr=e=>e.reduce((r,t)=>typeof t!="number"||Number.isNaN(t)||!Number.isFinite(t)?r:r+t,0),Ar=e=>{let r=Number.MIN_SAFE_INTEGER;for(const t of e)r=Math.max(r,t);return r},Tr=e=>{let r=0;for(const t of e)r+=t;return r},Ir=e=>{let r=Number.MIN_SAFE_INTEGER;for(const t of e)r=Math.min(r,t);return r},K=(e,r)=>{typeof r=="function"&&(r=J(e,r));const t=U(e,r),[n,s]=t.reduce((o,i)=>[o[0]+i[0]*i[1],o[1]+i[1]],[0,0]);return n/s},F=(e,r=0,t=1)=>{if(Number.isNaN(e))throw new Error("Param 'value' is NaN");if(Number.isNaN(r))throw new Error("Param 'min' is NaN");if(Number.isNaN(t))throw new Error("Param 'max' is NaN");return e<r?r:e>t?t:e},Q=(e=0,r=1)=>{if(Number.isNaN(e))throw new Error("Param 'min' is NaN");if(Number.isNaN(r))throw new Error("Param 'max' is NaN");return t=>t>r?r:t<e?e:t},xr=(e,r)=>{if(!Number.isInteger(e))throw new TypeError(`v parameter must be an integer (${e})`);const t=Array.isArray(r)?r.length:r;if(!Number.isInteger(t))throw new TypeError(`length parameter must be an integer (${t}, ${typeof t})`);return e=Math.round(e),e<0?0:e>=t?t-1:e},Sr=(...e)=>{let r=-1,t=Number.MIN_SAFE_INTEGER;for(let n=0;n<e.length;n++){const s=Math.abs(e[n]);s>t&&(t=s,r=n)}return e[r]};function*Mr(e,r=0){if(a(y(e,"","amount"),y(r,"","offset")),e===0)return;let t=0;do yield e<0?-t+r:t+r;while(t++<Math.abs(e)-1)}const Fr=(e,r="absolute")=>t=>V(r,t,e),$r=(e="absolute",r=NaN)=>{let t=r;return n=>{const s=V(e,n,t);return t=n,s}},V=(e="absolute",r,t)=>{if(Number.isNaN(t))return 0;const n=r-t;let s=0;if(e==="absolute")s=Math.abs(n);else if(e==="numerical")s=n;else if(e==="relative")s=Math.abs(n/t);else if(e==="relativeSigned")s=n/t;else throw new TypeError(`Unknown kind: '${e}' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);return s},H=e=>!(typeof e!="number"||Number.isNaN(e));function*_r(e){for(const r of e)H(r)&&(yield r)}const Gr=e=>r=>r>=e,Or=(e,r)=>t=>t>=e&&t<=r,vr=e=>(typeof e=="function"&&(e=e()),a(f(e,"percentage","v")),1-e),jr=function*(e,r=0,t,n=!1){if(e<=0)throw new Error("Interval is expected to be above zero");typeof t>"u"&&(t=Number.MAX_SAFE_INTEGER);let s=r;do for(;s<t;)yield s,s+=e;while(n)},Y=function*(e,r=0,t,n=!1,s){a(f(e,"nonZero"));const o=e<0;if(t!==void 0){if(o&&r<t)throw new Error(`Interval of ${e.toString()} will never go from ${r.toString()} to ${t.toString()}`);if(!o&&r>t)throw new Error(`Interval of ${e.toString()} will never go from ${r.toString()} to ${t.toString()}`)}s=s??1e3,t===void 0?t=Number.MAX_SAFE_INTEGER:t*=s,e=e*s;do{let i=r*s;for(;!o&&i<=t||o&&i>=t;)yield i/s,i+=e}while(n)},Rr=function(e=.01,r=!1,t=0,n=1){return a(f(e,"percentage","interval"),f(t,"percentage","start"),f(n,"percentage","end")),Y(e,t,n,r)};function ee(e,r,t){a(y(e,"positive","decimalPlaces"));const n=typeof r=="boolean"?r:t??!1;let s;if(e===0)s=Math.round;else{const o=Math.pow(10,e);n?s=i=>Math.ceil(i*o)/o:s=i=>Math.floor(i*o)/o}return typeof r=="number"?s(r):s}function qr(e,r,t){a(f(e,"percentage","rangePercent"));const n=Math.floor(e*100),s=(o,i)=>{try{if(typeof i!="number"||Number.isNaN(i)||!Number.isFinite(i))return!1;const c=Math.abs(i-o);return Math.floor(o===0?c*100:c/o*100)<=n}catch{return!1}};return r===void 0?s:(a(f(r,"","baseValue")),t===void 0?o=>s(r,o):s(r,t))}const Dr=(e,...r)=>{const t=r.map(s=>s-e),n=r.map(s=>s+e);return(...s)=>{for(const o of s)for(let i=0;i<r.length;i++)if(o>=t[i]&&o<=n[i])return!0;return!1}};var re={};P(re,{clamp:()=>E,fromScalar:()=>Br,immutable:()=>b,scale:()=>kr,scaleUnclamped:()=>Wr,toScalar:()=>te,towardZero:()=>ne});const b=(e=0)=>{if(typeof e>"u")throw new Error("Start value is undefined");const r=typeof e=="number"?e:e.value;if(r>1)throw new Error("Start value cannot be larger than 1");if(r<-1)throw new Error("Start value cannot be smaller than -1");if(Number.isNaN(r))throw new Error("Start value is NaN");const t=r;return{[Symbol.toPrimitive](n){return n==="number"?t:n==="string"?t.toString():!0},value:t,towardZero:n=>b(ne(t,n)),add:n=>b(E(t+n)),multiply:n=>b(E(t*n)),inverse:()=>b(-t),interpolate:(n,s)=>b(E($(n,t,s))),asScalar:(n=1,s=0)=>te(t,n,s)}},te=(e,r=1,t=0)=>{if(typeof e!="number")throw new Error(`Expected v to be a number. Got: ${typeof e}`);if(Number.isNaN(e))throw new Error("Parameter is NaN");return w(e,-1,1,t,r)},Br=e=>(a(f(e,"percentage","v")),e*2-1),kr=(e,r,t)=>E(d(r,t,-1,1)(e)),Wr=(e,r,t)=>d(r,t,-1,1)(e),E=e=>{if(typeof e!="number")throw new Error(`Param 'bipolarValue' must be a number. Got: ${typeof e}`);if(Number.isNaN(e))throw new Error("Param 'bipolarValue' is NaN");return e>1?1:e<-1?-1:e},ne=(e,r)=>{if(typeof e!="number")throw new Error(`Parameter 'v' must be a number. Got: ${typeof e}`);if(typeof r!="number")throw new Error(`Parameter 'amt' must be a number. Got: ${typeof r}`);if(r<0)throw new Error("Parameter 'amt' must be positive");return e<0?(e+=r,e>0&&(e=0)):e>0&&(e-=r,e<0&&(e=0)),e},se=(e,r=0,t=360)=>(a(y(e,void 0,"v"),y(r,void 0,"min"),y(t,void 0,"max")),e===r||e===t?r:(e>0&&e<r&&(e+=r),e-=r,t-=r,e=e%t,e<0&&(e=t-Math.abs(e)+r),e+r)),oe=(e,r=0,t=1)=>{if(a(f(e,"","min"),f(r,"","min"),f(t,"","max")),e===r||e===t)return r;for(;(e<=r||e>=t)&&!(e===t||e===r);)e>t?e=r+(e-t):e<r&&(e=t-(r-e));return e},Cr=(e,r,t,n,s)=>{let o=0;const i=Math.abs(s-n),c=Math.abs(r-n+s),l=Math.abs(n+(360-s)),p=Math.min(i,c,l);return p===l?o=n-t(p):p===c?o=n+t(p):n>s?o=n-t(p):o=n+t(p),se(o,e,r)},j=Math.PI*2;function $(e,r,t,n){let s,o="clamp";const i=u=>(s&&(u=s(u)),o===void 0||o==="clamp"?u=F(u):o==="wrap"&&(u>1?u=u%1:u<0&&(u=1+u%1)),u),c=(u,m,g)=>(a(f(m,"","a"),f(g,"","b"),f(u,"","amount")),u=i(u),(1-u)*m+u*g),l=(u={})=>{if(u.transform){if(typeof u.transform!="function")throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof u.transform}`);s=u.transform}o=u.limits??"clamp"},p=(u,m,g)=>(1-u)*m+u*g;if(typeof e!="number")throw new TypeError(`First param is expected to be a number. Got: ${typeof e}`);if(typeof r=="number"){let u,m;if(t===void 0||typeof t=="object")return u=e,m=r,l(t),g=>c(g,u,m);if(typeof t=="number")return u=r,m=t,l(n),c(e,u,m);throw new Error("Values for 'a' and 'b' not defined")}else if(r===void 0||typeof r=="object"){const u=i(e);return l(r),a(f(u,"","amount")),(m,g)=>p(u,m,g)}}const Lr=(e,r=0,t=1,n=0,s)=>{let o=n;return(i,c)=>{if(i!==void 0&&(t=i),c!==void 0&&(r=c),o>=1)return t;const l=$(o,r,t,s);return o+=e,l}},zr=(e,r,t,n)=>{const s=oe(t-r,0,j);return $(e,r,r+(s>Math.PI?s-j:s),n)};function*Zr(e,r,t,n){a(f(e,"","start"),f(r,"","end"),f(t,"","steps"));const s=n?ee(n):i=>i,o=(r-e)/(t-1);if(a(f(o,"","step")),!Number.isFinite(o))throw new TypeError("Calculated step value is infinite");for(let i=0;i<t;i++){const c=e+o*i;yield s(c)}}var Ur=class{#e=[];enqueue(e){this.#e.push(e)}dequeue(){return this.#e.shift()}get data(){return this.#e}get size(){return this.#e.length}};const Jr=Math.PI*2,Xr=(e=3)=>{a(f(e,"aboveZero","scaling"));let r=0,t=0;return n=>(f(n,"","v").success&&n!==void 0&&(t++,r=r+(n-r)/Math.min(t,e)),r)},Kr=(e=100,r)=>{const t=new Ur;return n=>{if(f(n).success&&n!==void 0)for(t.enqueue(n);t.size>e;)t.dequeue();return r===void 0?X(t.data):K(t.data,r)}},R=(e,r)=>{const t=Jr*r*e;return t/(t+1)},q=(e,r,t)=>e*r+(1-e)*t,Qr=(e=1,r=0,t=1)=>{let n=0,s=0,o=0;return(c,l)=>{l??=performance.now();const p=l-o,u=R(p,t),m=(c-n)/p,g=q(u,m,s),fe=e+r*Math.abs(g),ae=R(p,fe),v=q(ae,c,n);return n=v,s=g,o=l,v}},w=(e,r,t,n,s,o)=>d(r,t,n,s,o)(e),d=(e,r,t,n,s,o)=>{a(f(e,"finite","inMin"),f(r,"finite","inMax"));const i=n??1,c=t??0,l=o?Q(t,n):void 0;return p=>{if(e===r)return i;let u=(p-e)/(r-e);s!==void 0&&(u=s(u));const m=u*(i-c)+c;return l?l(m):m}},Vr=()=>e=>e,Hr=(e,r,t,n,s,o)=>{if(typeof s>"u"&&(s=1),typeof n>"u"&&(n=0),r===t)return s;const i=w(e,r,t,n,s,o);return F(i,n,s)},Yr=(e,r,t=1)=>(a(f(e,"percentage","v"),f(r,"percentage","outMin"),f(t,"percentage","outMax")),w(e,0,1,r,t)),et=(e,r,t)=>ie(r,t)(e),ie=(e,r)=>t=>(a(f(t,"percentage","v")),w(t,0,1,e,r)),rt=(e,r,t=0,n=1,s=!1,o)=>{const i=d(e,r,t,n,o,s),c=d(t,n,e,r,o,s);return{out:i,in:c}},ce=(e,r={})=>{if(e.length===0)return{total:NaN,min:NaN,max:NaN,avg:NaN,count:NaN};const t=r.nonNumbers??"throw";let n=0,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;for(let c=0;c<e.length;c++){let l=e[c];if(typeof l!="number"){if(t==="ignore")continue;if(t==="throw")throw new Error(`Param 'data' contains a non-number at index: ${c.toString()}`);t==="nan"&&(l=NaN)}Number.isNaN(l)||(s=Math.min(s,l),o=Math.max(o,l),n+=l,i++)}return{total:n,max:o,min:s,count:i,avg:n/i}};var ue={};P(ue,{array:()=>nt,stream:()=>tt});const tt=(e,r)=>{let t=e??Number.MAX_SAFE_INTEGER,n=r??Number.MIN_SAFE_INTEGER;return a(f(t),f(n)),s=>(a(f(s)),t=Math.min(t,s),n=Math.max(n,s),w(s,t,n))},nt=(e,r,t)=>{if(!Array.isArray(e))throw new TypeError(`Param 'values' should be an array. Got: ${typeof e}`);const n=ce(e),s=r??n.min,o=t??n.max;return e.map(i=>F(w(i,s,o)))},st=(e,r)=>(typeof e=="function"&&(e=e()),typeof r=="function"&&(r=r()),a(f(e,"percentage","v"),f(r,"percentage","t")),e*r),ot=(e,r,t=!0)=>{const n=r.toString(),s=n.indexOf(".");let o=1;s>=0&&(o=10*n.substring(s+1).length,r=Math.floor(o*r),e=e*o),a(f(e,"","v"),y(r,"","every"));let i=e/r;const c=i%1;return i=Math.floor(i),(c===.5&&t||c>.5)&&i++,r*i/o},it=e=>{const r=e.reduce((s,o)=>Math.max(s,o),Number.NEGATIVE_INFINITY),t=e.map(s=>Math.exp(s-r)),n=t.reduce((s,o)=>s+o);return t.map(s=>s/n)};var ct={};P(ct,{Bipolar:()=>re,Normalise:()=>ue,applyToValues:()=>gr,average:()=>X,averageWeighted:()=>K,clamp:()=>F,clampIndex:()=>xr,clamper:()=>Q,count:()=>Mr,differenceFromFixed:()=>Fr,differenceFromLast:()=>$r,dotProduct:()=>wr,filterIterable:()=>_r,flip:()=>vr,interpolate:()=>$,interpolateAngle:()=>zr,interpolatorStepped:()=>Lr,isApprox:()=>qr,isCloseToAny:()=>Dr,isValid:()=>H,linearSpace:()=>Zr,max:()=>Nr,maxAbs:()=>Sr,maxFast:()=>Ar,maxIndex:()=>dr,min:()=>br,minFast:()=>Ir,minIndex:()=>Er,movingAverage:()=>Kr,movingAverageLight:()=>Xr,noiseFilter:()=>Qr,numberArrayCompute:()=>ce,numericPercent:()=>Rr,numericRange:()=>Y,numericRangeRaw:()=>jr,proportion:()=>st,quantiseEvery:()=>ot,rangeInclusive:()=>Or,round:()=>ee,scale:()=>w,scaleClamped:()=>Hr,scalePercent:()=>et,scalePercentages:()=>Yr,scaler:()=>d,scalerNull:()=>Vr,scalerPercent:()=>ie,scalerTwoWay:()=>rt,softmax:()=>it,thresholdAtLeast:()=>Gr,total:()=>Pr,totalFast:()=>Tr,validNumbers:()=>M,weight:()=>J,wrap:()=>oe,wrapInteger:()=>se,wrapRange:()=>Cr});export{Tr as A,ft as B,ee as C,d as D,He as E,ir as F,de as G,ar as H,Zr as I,Ie as J,Er as K,xr as L,wr as M,ot as N,Xr as O,L as P,h as Q,E as R,nr as S,rt as T,W as U,ut as V,P as _,x as a,ur as b,a as c,F as d,zr as e,$ as f,y as g,w as h,Ye as i,_e as j,or as k,ze as l,hr as m,f as n,Ce as o,Me as p,Ar as q,G as r,ve as s,Ge as t,Ne as u,Nr as v,oe as w,ce as x,Xe as y,Ir as z};
