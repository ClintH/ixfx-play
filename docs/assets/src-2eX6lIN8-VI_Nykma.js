var me=Object.create,$=Object.defineProperty,pe=Object.getOwnPropertyDescriptor,D=Object.getOwnPropertyNames,he=Object.getPrototypeOf,ge=Object.prototype.hasOwnProperty,gt=(e,r)=>function(){return r||(0,e[D(e)[0]])((r={exports:{}}).exports,r),r.exports},P=(e,r)=>{for(var t in r)$(e,t,{get:r[t],enumerable:!0})},ye=(e,r,t,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(var s=D(r),o=0,i=s.length,c;o<i;o++)c=s[o],!ge.call(e,c)&&c!==t&&$(e,c,{get:(l=>r[l]).bind(null,c),enumerable:!(n=pe(r,c))||n.enumerable});return e},yt=(e,r,t)=>(t=e!=null?me(he(e)):{},ye($(t,"default",{value:e,enumerable:!0}),e));const k=e=>typeof e=="string"?e:e instanceof Error?e.message:e,I=(...e)=>{const r=e.filter(n=>G(n));if(r.length===0)return;const t=r.map(n=>C(n));throw new Error(t.join(", "))};function f(...e){for(const r of e){const t=typeof r=="object"?r:r();if(t!==void 0&&!t.success)throw x(t)}return!0}function be(e){if(e.success)return!0;throw x(e)}const we=(...e)=>{for(const r of e){const t=typeof r=="object"?r:r();if(t!==void 0&&!t.success)return t}};function G(e){return typeof e!="object"?!1:!e.success}function B(e){return typeof e!="object"?!1:e.success}function x(e){if(typeof e.error=="string")throw new Error(e.error,{cause:e.info});if(e.error instanceof Error)throw e.error;return new Error(JSON.stringify(e.error),{cause:e.info})}function de(e){if(B(e))return e.value;throw x(e)}function C(e){return e.error instanceof Error?k(e.error):typeof e.error=="string"?e.error:JSON.stringify(e.error)}function Ne(e,r){return{success:!1,error:e,info:r}}const M=(...e)=>{let r;for(const t of e)if(r=typeof t=="object"?t:t(),r!==void 0&&!r.success)return r;if(!r)throw new Error("No results");return r},Ee=(e,r)=>{G(e)&&r(e)},Pe=e=>Math.log2(e)%1===0,Ae=(e,r)=>{if(typeof e!="number")throw new TypeError(`v is not a number. Got: ${typeof e}`);return Number.isNaN(e)?r:e},Te=(e,r="",t=NaN)=>{if(typeof e>"u"||e===null)return t;try{const n=Number.parseInt(typeof e=="number"?e.toString():e);return g(n,r,"parsed").success?n:t}catch{return t}},a=(e,r="",t="?",n)=>{if(e===null)return{success:!1,error:`Parameter '${t}' is null`,info:n};if(typeof e>"u")return{success:!1,error:`Parameter '${t}' is undefined`,info:n};if(Number.isNaN(e))return{success:!1,error:`Parameter '${t}' is NaN`,info:n};if(typeof e!="number")return{success:!1,error:`Parameter '${t}' is not a number (${JSON.stringify(e)})`,info:n};switch(r){case"finite":{if(!Number.isFinite(e))return{success:!1,error:`Parameter '${t} must be finite (Got: ${e})`,info:n};break}case"positive":{if(e<0)return{success:!1,error:`Parameter '${t}' must be at least zero (${e})`,info:n};break}case"negative":{if(e>0)return{success:!1,error:`Parameter '${t}' must be zero or lower (${e})`,info:n};break}case"aboveZero":{if(e<=0)return{success:!1,error:`Parameter '${t}' must be above zero (${e})`,info:n};break}case"belowZero":{if(e>=0)return{success:!1,error:`Parameter '${t}' must be below zero (${e})`,info:n};break}case"percentage":{if(e>1||e<0)return{success:!1,error:`Parameter '${t}' must be in percentage range (0 to 1). (${e})`,info:n};break}case"nonZero":{if(e===0)return{success:!1,error:`Parameter '${t}' must non-zero. (${e})`,info:n};break}case"bipolar":{if(e>1||e<-1)return{success:!1,error:`Parameter '${t}' must be in bipolar percentage range (-1 to 1). (${e})`,info:n};break}}return{success:!0,value:e,info:n}},Ie=(e,r,t=3)=>{if(t===0)return e=Math.floor(e),r=Math.floor(r),e===r?{success:!0,value:e}:{success:!1,error:"A is not identical to B"};const n=Math.pow(10,t),s=Math.floor(e*n),o=Math.floor(r*n);return s!==o?{success:!1,error:`A is not close enough to B. A: ${e} B: ${r} Decimals: ${t}`}:{success:!0,value:e}},xe=(e,r="?",t)=>a(e,"percentage",r,t),g=(e,r="",t="?")=>M(a(e,r,t),()=>Number.isInteger(e)?{success:!0,value:e}:{success:!1,error:`Param '${t}' is not an integer`}),W=e=>{for(const r of e)if(Math.abs(r)%1!==0)return{success:!1,error:`Value is not an integer: ${r}`};return{success:!0,value:e}},Me=e=>(typeof e=="string"&&(e=Number.parseFloat(e)),g(e).success),L=(e,r,t,n="?")=>typeof e!="number"?{success:!1,error:`Param '${n}' is not a number type. Got type: '${typeof e}' value: '${JSON.stringify(e)}'`}:Number.isNaN(e)?{success:!1,error:`Param '${n}' is not within range ${r}-${t}. Got: NaN`}:Number.isFinite(e)?e<r?{success:!1,error:`Param '${n}' is below range ${r}-${t}. Got: ${e}`}:e>t?{success:!1,error:`Param '${n}' is above range ${r}-${t}. Got: ${e}`}:{success:!0,value:e}:{success:!1,error:`Param '${n}' is not within range ${r}-${t}. Got: infinite`},h=(e,r="?")=>Array.isArray(e)?{success:!0,value:e}:{success:!1,error:`Parameter '${r}' is expected to be an array'`},E=(e,r,t="index")=>M(h(e),g(r,"positive",t),L(r,0,e.length-1,t)),Se=e=>Array.isArray(e)?e.some(r=>typeof r!="string")?{success:!1,error:"Contains something not a string"}:{success:!0,value:e}:{success:!1,error:"Value is not an array"},Fe=(e,r="?")=>typeof e>"u"?{success:!1,error:`${r} param is undefined`}:e===null?{success:!1,error:`${r} param is null`}:{success:!0,value:e},_e=e=>e!==void 0,$e=e=>e instanceof Function,Ge=(e,r="?")=>e===void 0?{success:!1,error:`Param '${r}' is undefined. Expected: function.`}:e===null?{success:!1,error:`Param '${r}' is null. Expected: function.`}:typeof e!="function"?{success:!1,error:`Param '${r}' is type '${typeof e}'. Expected: function`}:{success:!0,value:e},z=e=>{if(typeof e!="object"||e===null)return{success:!1,error:"Value is null or not object type"};const r=Object.getPrototypeOf(e);return(r===null||r===Object.prototype||Object.getPrototypeOf(r)===null)&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)?{success:!0,value:e}:{success:!1,error:"Fancy object"}},Oe=e=>{const r=typeof e;return r==="symbol"?{success:!1,error:"Symbol type"}:r==="function"?{success:!1,error:"Function type"}:r==="bigint"?{success:!0,value:e}:r==="number"?{success:!0,value:e}:r==="string"?{success:!0,value:e}:r==="boolean"?{success:!0,value:e}:z(e)},je=(e,r)=>M(Z(e,r),W(e)),Z=(e,r)=>{for(const t of e){if(r.minExclusive!==void 0&&t<=r.minExclusive)return{success:!1,error:`Value '${t}' must be higher than minExclusive: '${r.minExclusive}'`};if(r.minInclusive!==void 0&&t<r.minInclusive)return{success:!1,error:`Value '${t}' must be equal or higher than minInclusive: '${r.minInclusive}'`};if(r.maxExclusive!==void 0&&t>=r.maxExclusive)return{success:!1,error:`Value '${t}' must be less than maxExclusive: '${r.maxExclusive}'`};if(r.maxInclusive!==void 0&&t>r.maxInclusive)return{success:!1,error:`Value '${t}' must be equal or less than maxInclusive: '${r.maxInclusive}'`}}return{success:!0,value:e}},qe=(e,r="",t="?")=>{if(typeof e!="string")return{success:!1,error:`Param '${t} is not type string. Got: ${typeof e}`};switch(r){case"non-empty":if(e.length===0)return{success:!1,error:`Param '${t} is empty`};break}return{success:!0,value:e}};var Re={};P(Re,{arrayIndexTest:()=>E,arrayStringsTest:()=>Se,arrayTest:()=>h,errorResult:()=>Ne,functionTest:()=>Ge,getErrorMessage:()=>k,ifNaN:()=>Ae,integerArrayTest:()=>W,integerParse:()=>Te,integerTest:()=>g,isDefined:()=>_e,isFunction:()=>$e,isInteger:()=>Me,isPowerOfTwo:()=>Pe,nullUndefTest:()=>Fe,numberDecimalTest:()=>Ie,numberInclusiveRangeTest:()=>L,numberTest:()=>a,percentTest:()=>xe,rangeIntegerTest:()=>je,rangeTest:()=>Z,resultErrorToString:()=>C,resultFirstFail_:()=>we,resultIsError:()=>G,resultIsOk:()=>B,resultThrow:()=>f,resultThrowSingle:()=>be,resultToError:()=>x,resultToValue:()=>de,resultWithFail:()=>Ee,resultsCollate:()=>M,stringTest:()=>qe,testPlainObject:()=>z,testPlainObjectOrPrimitive:()=>Oe,throwIfFailed:()=>I});const ve=e=>{I(h(e,"options"));const r=[...e];let t=0;const n=()=>(t++,t===r.length&&(t=0),o()),s=()=>(t--,t===-1&&(t=r.length-1),o()),o=()=>r.at(t);return{toArray:()=>[...r],next:n,prev:s,get current(){return o()},select:l=>{if(typeof l=="number")t=l;else{const m=r.indexOf(l);if(m===-1)throw new Error("Could not find value");t=m}}}},De=(e,r)=>{if(f(a(r,"","index")),!Array.isArray(e))throw new Error("Param 'array' is not an array");return r=r%e.length,e.at(r)};function ke(e,r){I(g(r,"aboveZero","size"),h(e,"array"));const t=[];for(let n=0;n<e.length;n+=r)t.push(e.slice(n,n+r));return t}const T=e=>typeof e=="string"?e:JSON.stringify(e),A=(e,r)=>e===r,Be=(e,r)=>e===r?!0:T(e)===T(r),Ce=(e,r,t=A)=>{if(!Array.isArray(e))throw new TypeError("Expects haystack parameter to be an array");if(!Array.isArray(r))throw new TypeError(`Expects needles parameter to be an array. Got: ${typeof r}`);for(const n of r){let s=!1;for(const o of e)if(t(n,o)){s=!0;break}if(!s)return!1}return!0},We=(e,r=T)=>{if(typeof e!="object")throw new Error(`Param 'data' is expected to be an Iterable. Got type: ${typeof e}`);const t=new Set;for(const n of e){const s=r(n);if(t.has(s))return!0;t.add(s)}return!1},Le=e=>{if(!Array.isArray(e))throw new Error("Parameter needs to be an array");for(let r=0;r<e.length;r++)for(let t=0;t<e.length;t++)if(r!==t&&e[r]===e[t])return!0;return!1};function ze(e,r,t="undefined",n="from-end"){if(e===void 0)throw new Error("Data undefined");if(!Array.isArray(e))throw new Error("data is not an array");if(e.length===r)return[...e];if(e.length>r)return n==="from-end"?e.slice(0,r):e.slice(e.length-r);const s=[...e],o=r-s.length;for(let i=0;i<o;i++)switch(t){case"undefined":{s.push(void 0);break}case"repeat":{s.push(e[i%e.length]);break}case"first":{s.push(e[0]);break}case"last":{s.push(e.at(-1));break}}return s}const Ze=(e,r,t=A)=>{if(f(h(e,"arrayA"),h(r,"arrayB")),e.length!==r.length)return!1;for(let n=0;n<e.length;n++)if(!t(e[n],r[n]))return!1;return!0},O=(e,r)=>{if(!Array.isArray(e))throw new Error("Param 'array' is not an array.");if(e.length===0)return!0;const t=r??Be,n=e[0];return!e.some(o=>!t(n,o))},Ue=(e,r)=>{const t=[],n=[];for(const s of e)r(s)?t.push(s):n.push(s);return[t,n]};function*Je(e,r,t,n){f(h(e,"array")),typeof t>"u"&&(t=0),typeof n>"u"&&(n=e.length),f(E(e,t,"startIndex")),f(E(e,n-1,"endIndex"));for(let s=t;s<n;s++)r(e[s],s,e)&&(yield e[s])}const Xe=e=>[...e].flat(),Ve=(e,r,t)=>typeof e!="object"||!Array.isArray(e)||e.length===0?Array.isArray(t)?t:[t]:e.map(r),Ke=(e,r)=>{if(!Array.isArray(r))throw new TypeError(`Param 'array' is expected to be an array. Got type: '${typeof r}'`);const t=new Map;for(const n of r){const s=e(n);if(typeof s!="string"&&typeof s!="number")throw new TypeError(`groupBy function is expected to return type string or number. Got type: '${typeof s}' for value: '${n}'`);let o=t.get(s);o??=0,o++,t.set(s,o)}return t},Qe=(e,r)=>{const t=new Map;for(const n of e){const s=r(n);let o=t.get(s);o||(o=[],t.set(s,o)),o.push(n)}return t},He=(e,r=A)=>{const t=[],n=o=>{for(const i of t)if(r(i,o))return!0;return!1},s=e.flat(10);for(const o of s)n(o)||t.push(o);return t},Ye=(e,r=T)=>{const t=new Set,n=[],s=e.flat(10);for(const o of s){const i=r(o);t.has(i)||(t.add(i),n.push(o))}return n},er=(e,r,...t)=>(I(h(e,"data"),E(e,r,"index")),r===e.length-1?[...e,...t]:r===0?[...t,...e]:[...e.slice(0,r),...t,...e.slice(r)]),rr=(...e)=>{if(e.some(s=>!Array.isArray(s)))throw new Error("All parameters must be an array");const r=e.map(s=>s.length);if(!O(r))throw new Error("Arrays must be of same length");const t=[],n=r[0];for(let s=0;s<n;s++)for(const o of e)t.push(o[s]);return t},tr=(e,r,t=A)=>e.filter(n=>r.some(s=>t(n,s))),nr=(e,r,...t)=>{const n=new Map;for(const s of t)for(const o of s){if(o===void 0)continue;const i=e(o);let c=n.get(i);c=c?r(c,o):o,n.set(i,c)}return[...n.values()]};function*sr(e){if(f(h(e,"values")),e.length<2)throw new Error(`Array needs to have at least two entries. Length: ${e.length}`);for(let r=1;r<e.length;r++)yield[e[r-1],e[r]]}const or=(e,r,t)=>{if(f(h(e,"arr")),e.length<2)return t;for(let n=0;n<e.length-1;n++)t=r(t,e[n],e[n+1]);return t},ir=(e,r=Math.random)=>{f(h(e,"dataToShuffle"));const t=[...e];for(let n=t.length-1;n>0;n--){const s=Math.floor(r()*(n+1));[t[n],t[s]]=[t[s],t[n]]}return t},cr=(e,r=Math.random)=>(f(h(e,"array")),e[Math.floor(r()*e.length)]),ur=(e,r=Math.random)=>Math.floor(r()*e.length),ar=(e,r)=>{if(!Array.isArray(e))throw new TypeError("'data' parameter should be an array");return f(E(e,r,"index")),[...e.slice(0,r),...e.slice(r+1)]},fr=(e,r)=>{if(!Array.isArray(e))throw new TypeError(`Param 'array' is not actually an array. Got type: ${typeof e}`);let t=1;if(r<=1){const s=e.length*r;t=Math.round(e.length/s)}else t=r;if(f(g(t,"positive","amount")),t>e.length-1)throw new Error("Subsample steps exceeds array length");const n=[];for(let s=t-1;s<e.length;s+=t)n.push(e[s]);return n},lr=(e,r)=>[...e].sort((t,n)=>{f(h(e,"data"));const s=t[r],o=n[r];return s<o?-1:s>o?1:0}),mr=(e,r,t)=>[...e].sort((n,s)=>{f(h(e,"data"));const o=n[r],i=s[r];return t===void 0?o<i?-1:o>i?1:0:t(o,i)});function*pr(e,r,t){let n=t;for(const s of e){const o=r(s,n);if(typeof o=="boolean"){if(o)break}else{const[i,c]=o;if(i)break;n=c}yield s}}const hr=e=>e.filter(r=>r!==void 0),gr=(e,r,t=A)=>{if(Array.isArray(r)){const n=[];for(const s of e)r.some(o=>t(s,o))||n.push(s);return n}else return e.filter(n=>!t(n,r))},U=(...e)=>{if(e.some(s=>!Array.isArray(s)))throw new Error("All parameters must be an array");const r=e.map(s=>s.length);if(!O(r))throw new Error("Arrays must be of same length");const t=[],n=r[0];for(let s=0;s<n;s++)t.push(e.map(o=>o[s]));return t};var yr={};P(yr,{atWrap:()=>De,chunks:()=>ke,contains:()=>Ce,containsDuplicateInstances:()=>Le,containsDuplicateValues:()=>We,containsIdenticalValues:()=>O,cycle:()=>ve,ensureLength:()=>ze,filterAB:()=>Ue,filterBetween:()=>Je,flatten:()=>Xe,frequencyByGroup:()=>Ke,groupBy:()=>Qe,insertAt:()=>er,interleave:()=>rr,intersection:()=>tr,isEqual:()=>Ze,mapWithEmptyFallback:()=>Ve,mergeByKey:()=>nr,pairwise:()=>sr,pairwiseReduce:()=>or,randomElement:()=>cr,randomIndex:()=>ur,remove:()=>ar,sample:()=>fr,shuffle:()=>ir,sortByNumericProperty:()=>lr,sortByProperty:()=>mr,unique:()=>Ye,uniqueDeep:()=>He,until:()=>pr,without:()=>gr,withoutUndefined:()=>hr,zip:()=>U});const br=(e,r)=>{const t={...e};for(const[n,s]of Object.entries(e))typeof s=="number"?t[n]=r(s):t[n]=s;return t},J=(e,r)=>{if(!Array.isArray(e))throw new TypeError(`Param 'data' is expected to be an array. Got type: ${typeof e}`);const t=r??(n=>n);return e.map((n,s)=>{if(typeof n!="number")throw new TypeError(`Param 'data' contains non-number at index: '${s}'. Type: '${typeof n}' value: '${n}'`);const o=s/(e.length-1),i=t(o);if(typeof i!="number")throw new TypeError(`Weighting function returned type '${typeof i}' rather than number for input: '${o}'`);return n*i})},S=e=>e.filter(r=>typeof r=="number"&&!Number.isNaN(r)),wr=e=>{let r=0;const t=e[0].length;for(let n=0;n<t;n++){let s=0;for(const[o,i]of e.entries())o===0?s=i[n]:s*=i[n];r+=s}return r},X=e=>{if(e===void 0)throw new Error("data parameter is undefined");const r=S(e);return r.reduce((n,s)=>n+s,0)/r.length},dr=e=>Math.min(...S(e)),Nr=e=>e.reduce((r,t,n,s)=>t>s[r]?n:r,0),Er=(...e)=>e.reduce((r,t,n,s)=>t<s[r]?n:r,0),Pr=e=>Math.max(...S(e)),Ar=e=>e.reduce((r,t)=>typeof t!="number"||Number.isNaN(t)||!Number.isFinite(t)?r:r+t,0),Tr=e=>{let r=Number.MIN_SAFE_INTEGER;for(const t of e)r=Math.max(r,t);return r},Ir=e=>{let r=0;for(const t of e)r+=t;return r},xr=e=>{let r=Number.MIN_SAFE_INTEGER;for(const t of e)r=Math.min(r,t);return r},V=(e,r)=>{typeof r=="function"&&(r=J(e,r));const t=U(e,r),[n,s]=t.reduce((o,i)=>[o[0]+i[0]*i[1],o[1]+i[1]],[0,0]);return n/s},F=(e,r=0,t=1)=>{if(Number.isNaN(e))throw new Error("Param 'value' is NaN");if(Number.isNaN(r))throw new Error("Param 'min' is NaN");if(Number.isNaN(t))throw new Error("Param 'max' is NaN");return e<r?r:e>t?t:e},K=(e=0,r=1)=>{if(Number.isNaN(e))throw new Error("Param 'min' is NaN");if(Number.isNaN(r))throw new Error("Param 'max' is NaN");return t=>t>r?r:t<e?e:t},Mr=(e,r)=>{if(!Number.isInteger(e))throw new TypeError(`v parameter must be an integer (${e})`);const t=Array.isArray(r)?r.length:r;if(!Number.isInteger(t))throw new TypeError(`length parameter must be an integer (${t}, ${typeof t})`);return e=Math.round(e),e<0?0:e>=t?t-1:e},Sr=(...e)=>{let r=-1,t=Number.MIN_SAFE_INTEGER;for(let n=0;n<e.length;n++){const s=Math.abs(e[n]);s>t&&(t=s,r=n)}return e[r]};function*Fr(e,r=0){if(f(g(e,"","amount"),g(r,"","offset")),e===0)return;let t=0;do yield e<0?-t+r:t+r;while(t++<Math.abs(e)-1)}const _r=(e,r="absolute")=>t=>Q(r,t,e),$r=(e="absolute",r=NaN)=>{let t=r;return n=>{const s=Q(e,n,t);return t=n,s}},Q=(e="absolute",r,t)=>{if(Number.isNaN(t))return 0;const n=r-t;let s=0;if(e==="absolute")s=Math.abs(n);else if(e==="numerical")s=n;else if(e==="relative")s=Math.abs(n/t);else if(e==="relativeSigned")s=n/t;else throw new TypeError(`Unknown kind: '${e}' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);return s},H=e=>!(typeof e!="number"||Number.isNaN(e));function*Gr(e){for(const r of e)H(r)&&(yield r)}const Or=e=>r=>r>=e,jr=(e,r)=>t=>t>=e&&t<=r,qr=e=>(typeof e=="function"&&(e=e()),f(a(e,"percentage","v")),1-e),Rr=function*(e,r=0,t,n=!1){if(e<=0)throw new Error("Interval is expected to be above zero");typeof t>"u"&&(t=Number.MAX_SAFE_INTEGER);let s=r;do for(;s<t;)yield s,s+=e;while(n)},Y=function*(e,r=0,t,n=!1,s){f(a(e,"nonZero"));const o=e<0;if(t!==void 0){if(o&&r<t)throw new Error(`Interval of ${e.toString()} will never go from ${r.toString()} to ${t.toString()}`);if(!o&&r>t)throw new Error(`Interval of ${e.toString()} will never go from ${r.toString()} to ${t.toString()}`)}s=s??1e3,t===void 0?t=Number.MAX_SAFE_INTEGER:t*=s,e=e*s;do{let i=r*s;for(;!o&&i<=t||o&&i>=t;)yield i/s,i+=e}while(n)},vr=function(e=.01,r=!1,t=0,n=1){return f(a(e,"percentage","interval"),a(t,"percentage","start"),a(n,"percentage","end")),Y(e,t,n,r)};function ee(e,r,t){f(g(e,"positive","decimalPlaces"));const n=typeof r=="boolean"?r:t??!1;let s;if(e===0)s=Math.round;else{const o=Math.pow(10,e);n?s=i=>Math.ceil(i*o)/o:s=i=>Math.floor(i*o)/o}return typeof r=="number"?s(r):s}function Dr(e,r,t){f(a(e,"percentage","rangePercent"));const n=Math.floor(e*100),s=(o,i)=>{try{if(typeof i!="number"||Number.isNaN(i)||!Number.isFinite(i))return!1;const c=Math.abs(i-o);return Math.floor(o===0?c*100:c/o*100)<=n}catch{return!1}};return r===void 0?s:(f(a(r,"","baseValue")),t===void 0?o=>s(r,o):s(r,t))}const kr=(e,...r)=>{const t=r.map(s=>s-e),n=r.map(s=>s+e);return(...s)=>{for(const o of s)for(let i=0;i<r.length;i++)if(o>=t[i]&&o<=n[i])return!0;return!1}};var re={};P(re,{clamp:()=>N,fromScalar:()=>Br,immutable:()=>d,scale:()=>Cr,scaleUnclamped:()=>Wr,toScalar:()=>te,towardZero:()=>ne});const d=(e=0)=>{if(typeof e>"u")throw new Error("Start value is undefined");const r=typeof e=="number"?e:e.value;if(r>1)throw new Error("Start value cannot be larger than 1");if(r<-1)throw new Error("Start value cannot be smaller than -1");if(Number.isNaN(r))throw new Error("Start value is NaN");const t=r;return{[Symbol.toPrimitive](n){return n==="number"?t:n==="string"?t.toString():!0},value:t,towardZero:n=>d(ne(t,n)),add:n=>d(N(t+n)),multiply:n=>d(N(t*n)),inverse:()=>d(-t),interpolate:(n,s)=>d(N(_(n,t,s))),asScalar:(n=1,s=0)=>te(t,n,s)}},te=(e,r=1,t=0)=>{if(typeof e!="number")throw new Error(`Expected v to be a number. Got: ${typeof e}`);if(Number.isNaN(e))throw new Error("Parameter is NaN");return w(e,-1,1,t,r)},Br=e=>(f(a(e,"percentage","v")),e*2-1),Cr=(e,r,t)=>N(b(r,t,-1,1)(e)),Wr=(e,r,t)=>b(r,t,-1,1)(e),N=e=>{if(typeof e!="number")throw new Error(`Param 'bipolarValue' must be a number. Got: ${typeof e}`);if(Number.isNaN(e))throw new Error("Param 'bipolarValue' is NaN");return e>1?1:e<-1?-1:e},ne=(e,r)=>{if(typeof e!="number")throw new Error(`Parameter 'v' must be a number. Got: ${typeof e}`);if(typeof r!="number")throw new Error(`Parameter 'amt' must be a number. Got: ${typeof r}`);if(r<0)throw new Error("Parameter 'amt' must be positive");return e<0?(e+=r,e>0&&(e=0)):e>0&&(e-=r,e<0&&(e=0)),e},se=(e,r=0,t=360)=>(f(g(e,void 0,"v"),g(r,void 0,"min"),g(t,void 0,"max")),e===r||e===t?r:(e>0&&e<r&&(e+=r),e-=r,t-=r,e=e%t,e<0&&(e=t-Math.abs(e)+r),e+r)),oe=(e,r=0,t=1)=>{if(f(a(e,"","min"),a(r,"","min"),a(t,"","max")),e===r||e===t)return r;for(;(e<=r||e>=t)&&!(e===t||e===r);)e>t?e=r+(e-t):e<r&&(e=t-(r-e));return e},Lr=(e,r,t,n,s)=>{let o=0;const i=Math.abs(s-n),c=Math.abs(r-n+s),l=Math.abs(n+(360-s)),m=Math.min(i,c,l);return m===l?o=n-t(m):m===c?o=n+t(m):n>s?o=n-t(m):o=n+t(m),se(o,e,r)},q=Math.PI*2;function _(e,r,t,n){let s,o="clamp";const i=u=>(s&&(u=s(u)),o===void 0||o==="clamp"?u=F(u):o==="wrap"&&(u>1?u=u%1:u<0&&(u=1+u%1)),u),c=(u,p,y)=>(f(a(p,"","a"),a(y,"","b"),a(u,"","amount")),u=i(u),(1-u)*p+u*y),l=(u={})=>{if(u.transform){if(typeof u.transform!="function")throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof u.transform}`);s=u.transform}o=u.limits??"clamp"},m=(u,p,y)=>(1-u)*p+u*y;if(typeof e!="number")throw new TypeError(`First param is expected to be a number. Got: ${typeof e}`);if(typeof r=="number"){let u,p;if(t===void 0||typeof t=="object")return u=e,p=r,l(t),y=>c(y,u,p);if(typeof t=="number")return u=r,p=t,l(n),c(e,u,p);throw new Error("Values for 'a' and 'b' not defined")}else if(r===void 0||typeof r=="object"){const u=i(e);return l(r),f(a(u,"","amount")),(p,y)=>m(u,p,y)}}const zr=(e,r=0,t=1,n=0,s)=>{let o=n;return(i,c)=>{if(i!==void 0&&(t=i),c!==void 0&&(r=c),o>=1)return t;const l=_(o,r,t,s);return o+=e,l}},Zr=(e,r,t,n)=>{const s=oe(t-r,0,q);return _(e,r,r+(s>Math.PI?s-q:s),n)};function*Ur(e,r,t,n){f(a(e,"","start"),a(r,"","end"),a(t,"","steps"));const s=n?ee(n):i=>i,o=(r-e)/(t-1);if(f(a(o,"","step")),!Number.isFinite(o))throw new TypeError("Calculated step value is infinite");for(let i=0;i<t;i++){const c=e+o*i;yield s(c)}}var Jr=class{#e=[];enqueue(e){this.#e.push(e)}dequeue(){return this.#e.shift()}get data(){return this.#e}get size(){return this.#e.length}};const Xr=Math.PI*2,Vr=(e=3)=>{f(a(e,"aboveZero","scaling"));let r=0,t=0;return n=>(a(n,"","v").success&&n!==void 0&&(t++,r=r+(n-r)/Math.min(t,e)),r)},Kr=(e=100,r)=>{const t=new Jr;return n=>{if(a(n).success&&n!==void 0)for(t.enqueue(n);t.size>e;)t.dequeue();return r===void 0?X(t.data):V(t.data,r)}},R=(e,r)=>{const t=Xr*r*e;return t/(t+1)},v=(e,r,t)=>e*r+(1-e)*t,Qr=(e=1,r=0,t=1)=>{let n=0,s=0,o=0;return(c,l)=>{l??=performance.now();const m=l-o,u=R(m,t),p=(c-n)/m,y=v(u,p,s),fe=e+r*Math.abs(y),le=R(m,fe),j=v(le,c,n);return n=j,s=y,o=l,j}},w=(e,r,t,n,s,o)=>b(r,t,n,s,o)(e),b=(e,r,t,n,s,o)=>{f(a(e,"finite","inMin"),a(r,"finite","inMax"));const i=n??1,c=t??0,l=o?K(t,n):void 0;return m=>{if(e===r)return i;let u=(m-e)/(r-e);s!==void 0&&(u=s(u));const p=u*(i-c)+c;return l?l(p):p}},Hr=()=>e=>e,Yr=(e,r,t,n,s,o)=>{if(typeof s>"u"&&(s=1),typeof n>"u"&&(n=0),r===t)return s;const i=w(e,r,t,n,s,o);return F(i,n,s)},et=(e,r,t=1)=>(f(a(e,"percentage","v"),a(r,"percentage","outMin"),a(t,"percentage","outMax")),w(e,0,1,r,t)),rt=(e,r,t)=>ie(r,t)(e),ie=(e,r)=>t=>(f(a(t,"percentage","v")),w(t,0,1,e,r)),tt=(e,r,t=0,n=1,s=!1,o)=>{const i=b(e,r,t,n,o,s),c=b(t,n,e,r,o,s);return{out:i,in:c}},ce=(e,r={})=>{if(e.length===0)return{total:NaN,min:NaN,max:NaN,avg:NaN,count:NaN};const t=r.nonNumbers??"throw";let n=0,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;for(let c=0;c<e.length;c++){let l=e[c];if(typeof l!="number"){if(t==="ignore")continue;if(t==="throw")throw new Error(`Param 'data' contains a non-number at index: ${c.toString()}`);t==="nan"&&(l=NaN)}Number.isNaN(l)||l!==void 0&&(s=Math.min(s,l),o=Math.max(o,l),n+=l,i++)}return{total:n,max:o,min:s,count:i,avg:n/i}};var ue={};P(ue,{array:()=>st,stream:()=>nt});const nt=(e,r)=>{let t=e??Number.MAX_SAFE_INTEGER,n=r??Number.MIN_SAFE_INTEGER;return f(a(t),a(n)),s=>(f(a(s)),t=Math.min(t,s),n=Math.max(n,s),w(s,t,n))},st=(e,r,t)=>{if(!Array.isArray(e))throw new TypeError(`Param 'values' should be an array. Got: ${typeof e}`);const n=ce(e),s=r??n.min,o=t??n.max;return e.map(i=>F(w(i,s,o)))},ot=(e,r)=>(typeof e=="function"&&(e=e()),typeof r=="function"&&(r=r()),f(a(e,"percentage","v"),a(r,"percentage","t")),e*r),it=(e,r,t=!0)=>{const n=r.toString(),s=n.indexOf(".");let o=1;s>=0&&(o=10*n.substring(s+1).length,r=Math.floor(o*r),e=e*o),f(a(e,"","v"),g(r,"","every"));let i=e/r;const c=i%1;return i=Math.floor(i),(c===.5&&t||c>.5)&&i++,r*i/o};function ct(e,r,t="skip"){if(typeof e=="number"){if(Number.isNaN(e)||!Number.isFinite(e)){if(t==="error")throw new TypeError("Param 'value' is NaN or infinite, and nonNumberHandling is set to 'error'");return r}return e>=r.min&&e<=r.max?r:{min:Math.min(e,r.min),max:Math.max(e,r.max)}}else if(t==="error")throw new TypeError(`Param 'value' is not a number (type: '${typeof e}') and nonNumberHandling is set to 'error'`);return r}function ut(e,r=1,t=0,n,s=!0){return b(e.min,e.max,t,r,n,s)}function at(e,r){return e.max<=r.max&&e.min>=r.min?r:{min:Math.min(e.min,r.min),max:Math.max(e.max,r.max)}}const ae=()=>({min:Number.MAX_SAFE_INTEGER,max:Number.MIN_SAFE_INTEGER}),ft=(e,r)=>e.max===r.max&&e.min===r.min,lt=(e=ae())=>{let{min:r,max:t}=e;return{seen:o=>{typeof o=="number"&&!Number.isNaN(o)&&Number.isFinite(o)&&(r=Math.min(r,o),t=Math.max(t,o))},reset:()=>{r=Number.MAX_SAFE_INTEGER,t=Number.MIN_SAFE_INTEGER},get range(){return{min:r,max:t}},get min(){return r},get max(){return t}}};function mt(e,r="skip"){let t=Number.MAX_SAFE_INTEGER,n=Number.MIN_SAFE_INTEGER,s=0;for(const o of e){if(typeof o=="number"){if(Number.isNaN(o)||!Number.isFinite(o)){if(r==="error")throw new Error(`Value NaN or infinite at position: ${s}`);continue}}else{if(r==="error")throw new Error(`Contains non number value. Type: '${typeof o}' Position: ${s}`);continue}o<t&&(t=o),o>n&&(n=o),s++}return{min:t,max:n}}const pt=e=>{const r=e.reduce((s,o)=>Math.max(s,o),Number.NEGATIVE_INFINITY),t=e.map(s=>Math.exp(s-r)),n=t.reduce((s,o)=>s+o);return t.map(s=>s/n)};var ht={};P(ht,{Bipolar:()=>re,Normalise:()=>ue,applyToValues:()=>br,average:()=>X,averageWeighted:()=>V,clamp:()=>F,clampIndex:()=>Mr,clamper:()=>K,count:()=>Fr,differenceFromFixed:()=>_r,differenceFromLast:()=>$r,dotProduct:()=>wr,filterIterable:()=>Gr,flip:()=>qr,interpolate:()=>_,interpolateAngle:()=>Zr,interpolatorStepped:()=>zr,isApprox:()=>Dr,isCloseToAny:()=>kr,isValid:()=>H,linearSpace:()=>Ur,max:()=>Pr,maxAbs:()=>Sr,maxFast:()=>Tr,maxIndex:()=>Nr,min:()=>dr,minFast:()=>xr,minIndex:()=>Er,movingAverage:()=>Kr,movingAverageLight:()=>Vr,noiseFilter:()=>Qr,numberArrayCompute:()=>ce,numericPercent:()=>vr,numericRange:()=>Y,numericRangeRaw:()=>Rr,proportion:()=>ot,quantiseEvery:()=>it,rangeCompute:()=>mt,rangeInclusive:()=>jr,rangeInit:()=>ae,rangeIsEqual:()=>ft,rangeMergeRange:()=>at,rangeMergeValue:()=>ct,rangeScaler:()=>ut,rangeStream:()=>lt,round:()=>ee,scale:()=>w,scaleClamped:()=>Yr,scalePercent:()=>rt,scalePercentages:()=>et,scaler:()=>b,scalerNull:()=>Hr,scalerPercent:()=>ie,scalerTwoWay:()=>tt,softmax:()=>pt,thresholdAtLeast:()=>Or,total:()=>Ar,totalFast:()=>Ir,validNumbers:()=>S,weight:()=>J,wrap:()=>oe,wrapInteger:()=>se,wrapRange:()=>Lr});export{Ir as A,yt as B,ee as C,U as D,b as E,Ye as F,cr as G,Ne as H,lr as I,Ur as J,xe as K,Er as L,Mr as M,wr as N,it as O,Vr as P,L as Q,h as R,N as S,sr as T,tt as U,C as V,gt as W,P as _,x as a,ar as b,f as c,g as d,Ze as e,Pe as f,Pr as g,ce as h,er as i,Ve as j,F as k,qe as l,Tr as m,a as n,Zr as o,_ as p,Ge as q,G as r,w as s,Oe as t,ir as u,gr as v,oe as w,Le as x,Fe as y,xr as z};
