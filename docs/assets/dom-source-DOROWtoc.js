import{i as I}from"./interval-type-CIaujdcR.js";import{c as J,i as G,t as E,e as W}from"./state-machine-ROMMoZIR.js";import{s as K}from"./sleep-DwDBk_RX.js";import{a as T,i as H,g as R,w as X}from"./error-message-BtgnhF27.js";import{n as Y}from"./async-Dr__bS9h.js";import{t as Z}from"./element-sizing-Blh1KTfT.js";import{b as Q,c as ee}from"./result-aflA1LW7.js";import{r as _}from"./resolve-el-BUhvOf7L.js";import{b as te,a as D,f as ne}from"./conversion-CGf7QoDW.js";const re=(e,t)=>oe(Object.keys(e),Object.keys(t));function F(e){return typeof e=="number"||typeof e=="string"||typeof e=="bigint"||typeof e=="boolean"}const j=(e,t)=>{if(e===void 0)throw new Error("Param 'target' is undefined");if(e===null)throw new Error("Param 'target' is null");if(typeof e!="object")throw new Error(`Param 'target' is not an object (got: ${typeof e})`);if(t){const n=[];for(const r in e){const o=e[r];Z(o)&&n.push([r,o])}return n}else return Object.entries(e)};function*x(e,t,n={}){if(typeof e>"u"){yield{path:n.pathPrefix??"",value:t,state:"added"};return}if(typeof t>"u"){yield{path:n.pathPrefix??"",previous:e,value:void 0,state:"removed"};return}const r=n.asPartial??!1,o=n.skipInstances??new WeakSet,p=n.undefinedValueMeansRemoved??!1,s=n.pathPrefix??"",u=n.deepEntries??!1,d=n.eq??T,l=n.includeMissingFromA??!1,g=n.includeParents??!1;if(F(e)&&F(t)){e!==t&&(yield{path:s,value:t,previous:e,state:"change"});return}if(F(t)){yield{path:s,value:t,previous:e,state:"change"};return}const m=j(e,u),b=new Set;for(const[y,a]of m){b.add(y);const c=y in t,f=t[y];if(typeof a=="object"&&a!==null){if(o.has(a))continue;if(o.add(a),c){if(f===void 0)throw new Error(`Pathed.compareData Value for key ${y} is undefined`);{const i=[...x(a,f,{...n,skipInstances:o,pathPrefix:s+y+"."})];if(i.length>0){for(const h of i)yield h;g&&(yield{path:s+y,value:t[y],previous:a,state:"change"})}}}else{if(r)continue;yield{path:s+y,value:void 0,previous:a,state:"removed"}}}else{const i=s+y;if(c)f===void 0&&p?yield{path:i,previous:a,value:void 0,state:"removed"}:d(a,f,i)||(yield{path:i,previous:a,value:f,state:"change"});else{if(r)continue;yield{path:i,previous:a,value:void 0,state:"removed"}}}}if(l){const y=j(t,u);for(const[a,c]of y)b.has(a)||(yield{path:s+a,previous:void 0,value:c,state:"added"})}}const se=(e,t,n,r=!1)=>{if(t===void 0)throw new Error("Parameter 'path' is undefined");if(typeof t!="string")throw new Error(`Parameter 'path' should be a string. Got: ${typeof t}`);if(e===void 0)throw new Error("Parameter 'target' is undefined");if(e===null)throw new Error("Parameter 'target' is null");const o=t.split(".");return N(e,o,n,r)},N=(e,t,n,r)=>{if(t.length===0){if(r)return n;if(Array.isArray(e)&&!Array.isArray(n))throw new Error(`Expected array value, got: '${JSON.stringify(n)}'. Set allowShapeChange=true to ignore.`);if(!Array.isArray(e)&&Array.isArray(n))throw new Error(`Unexpected array value, got: '${JSON.stringify(n)}'. Set allowShapeChange=true to ignore.`);if(typeof e!=typeof n)throw new Error(`Cannot reassign object type. (${typeof e} -> ${typeof n}). Set allowShapeChange=true to ignore.`);if(typeof e=="object"&&!Array.isArray(e)){const s=re(e,n);if(s.a.length>0)throw new Error(`New value is missing key(s): ${s.a.join(",")}`);if(s.b.length>0)throw new Error(`New value cannot add new key(s): ${s.b.join(",")}`)}return n}const o=t.shift();if(!o)return n;if(z(o)&&Array.isArray(e)){const s=Number.parseInt(o);if(s>=e.length&&!r)throw new Error(`Array index ${s.toString()} is outside of the existing length of ${e.length.toString()}. Use allowShapeChange=true to permit this.`);const u=[...e];return u[s]=N(u[s],t,n,r),u}else if(o in e){const s={...e};return s[o]=N(s[o],t,n,r),s}else throw new Error(`Path ${o} not found in data`)},ie=(e,t,n=".")=>{if(typeof t!="string")throw new Error(`Param 'path' ought to be a string. Got: '${typeof t}'`);if(t.length===0)throw new Error("Param string 'path' is empty");if(e===void 0)throw new Error("Param 'object' is undefined");if(e===null)throw new Error("Param 'object' is null");const r=t.split(n);return P(e,r,t)},P=(e,t,n)=>{if(e===void 0)return{success:!1,error:`Param 'object' is undefined. Position: ${n}`};if(t.length===0)return{success:!1,error:`Path has been exhausted. position: ${n}`};const r=t.shift();if(!r)return{success:!1,error:`Unexpected empty split path. Position: ${n}`};if(z(r)&&Array.isArray(e)){const p=Number.parseInt(r);return typeof e[p]>"u"?{success:!1,error:`Index '${p}' does not exist. Length: ${e.length}. Position: ${n}`}:t.length===0?{value:e[p],success:!0}:P(e[p],t,t.join("."))}else return typeof e=="object"&&r in e?t.length===0?{value:e[r],success:!0}:P(e[r],t,t.join(".")):{success:!1,error:`Path '${r}' not found. Position: ${n}`}},Ie=e=>typeof e=="string"?e:JSON.stringify(e),z=e=>{if(e===void 0)return!1;if(typeof e=="string"){const t=Number.parseInt(e);return Number.isNaN(t)?!1:t.toString()===e.toString()}return typeof e=="number"?Number.isNaN(e)||!Number.isFinite(e)?!1:Math.round(e)===e:!1},oe=(e,t,n=H)=>{const r=[],o=[],p=[];for(const u of e){let d=!1;for(const l of t)if(n(u,l)){d=!0;break}d?r.push(u):o.push(u)}for(const u of t){let d=!1;for(const l of e)n(u,l)&&(d=!0);d||p.push(u)}const s=o.length===0&&p.length===0;return{shared:r,isSame:s,a:o,b:p}};class C{#e;#t=0;#n=Math.floor(Math.random()*100);constructor(){this.#e=[]}isEmpty(){return this.#e.length===0}add(t,n={}){this.#t++;const r=n.once??!1,o={id:`${this.#n} - ${this.#t}`,handler:t,once:r};return this.#e.push(o),o.id}remove(t){const n=this.#e.length;return this.#e=this.#e.filter(r=>r.id!==t),this.#e.length!==n}notify(t){for(const n of this.#e)n.handler(t),n.once&&this.remove(n.id)}clear(){this.#e=[]}}const V=e=>typeof e!="object"||e===null?!1:Symbol.asyncIterator in e,ae=e=>typeof e!="object"||e===null?!1:Symbol.iterator in e;function le(e){return e.value!==void 0?!1:"signal"in e&&e.signal!==void 0}function Ae(e){return e.value!==void 0?!1:"signal"in e&&e.signal==="done"}function M(e){return e.value!==void 0}const U=e=>O(e)?"last"in e&&e.last()!==void 0:!1,O=e=>typeof e!="object"||e===null?!1:"on"in e&&"onValue"in e,Fe=e=>O(e)?"set"in e:!1,fe=e=>!(typeof e!="object"||!("source"in e)||!("annotate"in e));function ue(e,t={}){const n=t.maximumRepeats??Number.MAX_SAFE_INTEGER,r=t.closeOnError??!0,o=t.interval?I(t.interval):-1;let p=t.manual??!1;if(t.interval===void 0&&t.manual===void 0&&(p=!0),p&&t.interval)throw new Error("If option 'manual' is set, option 'interval' cannot be used");const s=I(t.predelay,0),u=t.lazy??"very",d=t.signal,l=new AbortController,g=i=>{l.abort(i)};let m=0,b=!1;const y=i=>{f.dispose(i),b=!1,c&&c.cancel()},a=async()=>{if(!b)return!1;if(s&&await K(s),m>=n)return y(`Maximum repeats reached ${n.toString()}`),!1;try{if(d?.aborted)return y(`Signal (${d.aborted})`),!1;const i=await e(g);return m++,f.set(i),!0}catch(i){return r?(y(`Function error: ${R(i)}`),!1):(f.signal("warn",R(i)),!0)}},c=p?void 0:J(async()=>{if(!await a())return!1;if(l.signal.aborted)return y(`callback function aborted (${l.signal.reason})`),!1},o),f=A({lazy:u,onStart(){b=!0,c&&c.start()},onStop(){b=!1,c&&c.cancel()}});return u==="never"&&c&&c.start(),{...f,ping:a}}function q(e,t={}){const n=t.lazy??"very",r=t.traceLifecycle?y=>{console.log(`Rx.From.iterator ${y}`)}:y=>{},o=I(t.readInterval,5),p=I(t.readTimeout,300*1e3),s=t.whenStopped??"continue";let u,d,l=G({idle:["wait_for_next"],wait_for_next:["processing_result","stopping","disposed"],processing_result:["queued","disposed","stopping"],queued:["wait_for_next","disposed","stopping"],stopping:"idle",disposed:null},"idle");const g=()=>{r("onExternalSignal"),d?.abort(t.signal?.reason)};t.signal&&t.signal.addEventListener("abort",g,{once:!0});const m=async()=>{r(`read. State: ${l.value}`),d=new AbortController;try{l=E(l,"wait_for_next");const y=await Y(u,{signal:d.signal,millis:p});if(l=E(l,"processing_result"),d.abort("nextWithTimeout completed"),y.done&&(r("read v.done true"),b.dispose("Generator complete"),l=E(l,"disposed")),l.value==="stopping"){r("read. sm.value = stopping"),l=E(l,"idle");return}if(l.value==="disposed"){r("read. sm.value = disposed");return}b.set(y.value)}catch(y){b.dispose(`Generator error: ${y.toString()}`);return}l.value==="processing_result"?(l=E(l,"queued"),r(`scheduling read. State: ${l.value}`),setTimeout(m,o)):l=E(l,"idle")},b=A({...t,lazy:n,onStart(){r(`onStart state: ${l.value} whenStopped: ${s}`),l.value==="idle"&&((l.value==="idle"&&s==="reset"||u===void 0)&&(u=V(e)?e[Symbol.asyncIterator]():e[Symbol.iterator]()),m())},onStop(){r(`onStop state: ${l.value} whenStopped: ${s}`),l=E(l,"stopping"),s==="reset"&&(r("onStop reiniting iterator"),u=V(e)?e[Symbol.asyncIterator]():e[Symbol.iterator]())},onDispose(y){r(`onDispose (${y})`),d?.abort(`Rx.From.iterator disposed (${y})`),t.signal&&t.signal.removeEventListener("abort",g)}});return b}const ce=(e,t={})=>{if(O(e))return e;const n=t.generator??{lazy:"initial",interval:5},r=t.function??{lazy:"very"};if(Array.isArray(e))return q(e.values(),n);if(typeof e=="function")return ue(e,r);if(typeof e=="object"){if(fe(e))return e.source;if(ae(e)||V(e))return q(e,n)}throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${typeof e}`)};function de(e,t){const n=t.lazy??"initial",r=t.disposeIfSourceDone??!0,o=t.onValue??(m=>{}),p=ce(e);let s;const u=t.debugLabel?`[${t.debugLabel}]`:"",d=()=>{s!==void 0&&(s(),s=void 0,t.onStop&&t.onStop())},g=A({...t,lazy:n,onStart:()=>{s===void 0&&(t.onStart&&t.onStart(),s=p.on(m=>{le(m)?m.signal==="done"?(d(),g.signal(m.signal,m.context),r&&g.dispose(`Upstream source ${u} has completed (${m.context??""})`)):g.signal(m.signal,m.context):M(m)&&o(m.value)}))},onStop:d});return g}function A(e){const t=e.lazy??"initial",n=e.onStop??(()=>{}),r=e.onStart??(()=>{});e.debugLabel&&`${e.debugLabel}`;const o=L({...e,onFirstSubscribe(){t!=="never"&&r()},onNoSubscribers(){t==="very"&&n()}});return t==="never"&&r(),o}function L(e={}){let t,n=!1,r=!1,o=!0;const p=e.onFirstSubscribe??void 0,s=e.onNoSubscribers??void 0,u=e.debugLabel?`[${e.debugLabel}]`:"",d=()=>{t!==void 0&&t.isEmpty&&(o||(o=!0,r=!1,s&&s()))},l=g=>{if(n)throw new Error(`Disposed, cannot subscribe ${u}`);t===void 0&&(t=new C);const m=t.add(g);return o=!1,r||(r=!0,p&&p()),()=>{t?.remove(m),d()}};return{dispose:g=>{n||(t?.notify({value:void 0,signal:"done",context:`Disposed: ${g}`}),n=!0,e.onDispose&&e.onDispose(g))},isDisposed:()=>n,removeAllSubscribers:()=>{t?.clear(),d()},set:g=>{if(n)throw new Error(`${u} Disposed, cannot set`);t?.notify({value:g})},signal:(g,m)=>{if(n)throw new Error(`${u} Disposed, cannot signal`);t?.notify({signal:g,value:void 0,context:m})},on:g=>l(g),onValue:g=>l(b=>{M(b)&&g(b.value)})}}const ge=e=>({on:e.on,dispose:e.dispose,isDisposed:e.isDisposed,onValue:e.onValue});function k(e,t,n={}){const r=n.traceInput??!1,o=n.traceOutput??!1,p=de(e,{lazy:"initial",...n,onValue(s){const u=t(s);r&&o?console.log(`Rx.Ops.transform input: ${JSON.stringify(s)} output: ${JSON.stringify(u)}`):r?console.log(`Rx.Ops.transform input: ${JSON.stringify(s)}`):o&&console.log(`Rx.Ops.transform output: ${JSON.stringify(u)}`),p.set(u)}});return ge(p)}function pe(e,t={}){const n=t.eq??T,r=L(),o=L(),p=[];let s=e,u=!1;const d=a=>{const c=[...x(s??{},a,{...t,includeMissingFromA:!0})];c.length!==0&&(s=a,r.set(a),o.set(c))},l=(a,c)=>{for(const[f,i,h]of p)f(a)&&h.notify({fieldName:a,pattern:i,value:c})},g={asPartial:!0,includeParents:!0},m=a=>{if(s===void 0){s=a,r.set(s);for(const[c,f]of Object.entries(a))l(c,f);return s}else{const c=[...x(s,a,g)];if(c.length===0)return s;s={...s,...a},r.set(s),o.set(c);for(const f of c)l(f.path,f.value);return s}};return{dispose:a=>{u||(o.dispose(a),r.dispose(a),u=!0)},isDisposed(){return u},updateField:(a,c)=>{if(s===void 0)throw new Error("Cannot update value when it has not already been set");const f=ie(s,a);if(Q(f))throw ee(f);if(n(f.value,c,a))return;let i=[...x(f.value,c,{...t,includeMissingFromA:!0})];i=i.map(w=>w.path.length>0?{...w,path:a+"."+w.path}:{...w,path:a});const h=se(s,a,c,!0);s=h,r.set(h),o.set(i),l(a,c)},last:()=>s,on:r.on,onValue:r.onValue,onDiff:o.onValue,onField(a,c){const f=X(a),i=new C;p.push([f,a,i]);const h=i.add(c);return()=>i.remove(h)},set:d,update:m}}function Ne(e,t,n,r={}){let o;if(typeof e=="string"){if(o=document.querySelector(e),o===null)throw new Error(`Target query did not resolve to an element. Query: '${e}'`)}else o=e;if(o===null)throw new Error("Param 'targetOrQuery' is null");const p=r.debugLifecycle??!1,s=r.debugFiring??!1;r.diff;const u=r.lazy??!1;n===void 0&&(n={});const d=pe(n,{deepEntries:!0});let l=!1,g=!1;const m=a=>{s&&console.log(`Reactive.event '${t}' firing '${JSON.stringify(a)}`),d.set(a)},b=()=>{l&&(l=!1,o.removeEventListener(t,m),p&&console.log(`Rx.From.event remove '${t}'`))},y=()=>{l||(l=!0,o.addEventListener(t,m),p&&console.log(`Rx.From.event add '${t}'`))};return u||y(),{last:()=>(u&&y(),d.last()),dispose:a=>{g||(g=!0,b(),d.dispose(a))},isDisposed(){return g},on:a=>(u&&y(),d.on(a)),onValue:a=>(u&&y(),d.onValue(a))}}function B(e,t,n={}){let r;if(typeof e=="string"){if(r=document.querySelector(e),r===null)throw new Error(`Target query did not resolve to an element. Query: '${e}'`)}else r=e;if(r===null)throw new Error("Param 'targetOrQuery' is null");const o=n.debugLifecycle??!1,p=n.debugFiring??!1,s=n.fireInitial??!1;let u=0;const d=W(),l=A({lazy:n.lazy??"very",onStart(){r.addEventListener(t,g),o&&console.log(`Rx.From.eventTrigger add '${t}'`),s&&u===0&&((o||p)&&console.log("Rx.From.eventTrigger: firing initial"),g())},onStop(){r.removeEventListener(t,g),o&&console.log(`Rx.From.eventTrigger remove '${t}'`)}}),g=m=>{p&&console.log(`Rx.From.eventTrigger '${t}' triggered'`),l.set({sinceLast:d(),total:++u})};return l}function Pe(e,t={}){const n=me(e,t),r=n.el,o=t.relative??!1,p=t.inverted??!1,s=k(n,d=>Number.parseFloat(d));return o&&(r.max=p?"0":"1",r.min=p?"1":"0",r.hasAttribute("step")||(r.step="0.1")),r.getAttribute("type")===null&&(r.type="range"),{...s,last(){return Number.parseFloat(n.last())},set:d=>{n.set(d.toString())}}}function me(e,t={}){const n=typeof e=="string"?document.querySelector(e):e;if(n===null&&typeof e=="string")throw new Error(`Element query could not be resolved '${e}'`);if(n===null)throw new Error("targetOrQuery is null");const r=_(e),p=(t.when??"changed")==="changed"?"change":"input",s=t.emitInitialValue??!1,u=t.fallbackValue??"",d=t.upstreamSource;let l=()=>{},g=t.attributeName,m=t.fieldName;m===void 0&&g===void 0&&(g=m="value");const b=()=>{let i;return g&&(i=r.getAttribute(g)),m&&(i=r[m]),i==null&&(i=u),i},y=i=>{g&&r.setAttribute(g,i),m&&(r[m]=i)},a=i=>{i=t.upstreamFilter?t.upstreamFilter(i):i,y(i)};d&&(l=d.onValue(a),U(d)&&a(d.last()));const c=B(r,p,{fireInitial:s,debugFiring:t.debugFiring??!1,debugLifecycle:t.debugLifecycle??!1}),f=k(c,i=>b());return{...f,el:r,last(){return b()},set(i){y(i)},dispose(i){l(),f.dispose(i),c.dispose(i)}}}function Ve(e,t={}){const n=_(e),o=(t.when??"changed")==="changed"?"change":"input",p=t.emitInitialValue??!1,s=t.upstreamSource,u=new Map;let d=()=>{};const l=()=>{const c=new FormData(n),f=[];for(const[h,w]of c.entries()){const $=w.toString();let v=u.get(h);if(!v){const S=g(h,$);S&&(S.type==="range"||S.type==="number"?v="number":S.type==="color"?v="colour":S.type==="checkbox"&&(w==="true"||w==="on")?v="boolean":v="string",u.set(h,v))}if(v==="number")f.push([h,Number.parseFloat($)]);else if(v==="boolean"){const S=$==="true";f.push([h,S])}else if(v==="colour"){const S=D($);f.push([h,ne(S,{scalar:!1})])}else f.push([h,w.toString()])}for(const h of n.querySelectorAll('input[type="checkbox"]'))!h.checked&&h.value==="true"&&f.push([h.name,!1]);return Object.fromEntries(f)},g=(c,f)=>{const i=n.querySelector(`[name="${c}"]`);if(!i){console.warn(`Form does not contain an element with name="${c}"`);return}if(i.type==="radio"){const h=n.querySelector(`[name="${c}"][value="${f}"]`);if(!h){console.warn(`Form does not contain radio option for name=${c} value=${f}`);return}return h}return i},m=(c,f)=>{const i=g(c,f);if(i&&(i.nodeName==="INPUT"||i.nodeName==="SELECT")){if(i.type==="color")typeof f=="object"&&(f=D(f));else if(i.type==="checkbox")if(typeof f=="boolean"){i.checked=f;return}else console.warn(`Rx.Sources.domForm: Trying to set non boolean type to a checkbox. Name: ${c} Value: ${f} (${typeof f})`);else if(i.type==="radio"){i.checked=!0;return}i.value=f}},b=c=>{for(const[f,i]of Object.entries(c)){let h=u.get(f);h||(h=typeof i,h==="object"&&(te(i),h="colour"),u.set(f,h));const w=t.upstreamFilter?t.upstreamFilter(f,i):i;m(f,w)}};s&&(d=s.onValue(b),U(s)&&b(s.last()));const y=B(n,o,{fireInitial:p,debugFiring:t.debugFiring??!1,debugLifecycle:t.debugLifecycle??!1}),a=k(y,c=>l());return{...a,el:n,last(){return l()},set:b,setNamedValue:m,dispose(c){d(),a.dispose(c),y.dispose(c)}}}export{Ie as a,Fe as b,M as c,Pe as d,de as e,Ne as f,Ve as g,L as i,Ae as m,pe as o,ce as r,ge as t};
