import{_ as v,v as oe,x as ar,c as l,y as O,l as ur,n as lr,d as Oe,r as B}from"./src-2eX6lIN8-VI_Nykma.js";import{au as f,B as Ke,av as K,aw as cr,q as ae,as as fr,ax as dr,ay as hr,az as Z,aA as Ge,aB as yr,s as vr,aC as L,aD as pr,aE as gr,aF as mr,aG as wr,aH as qe,aI as br,aJ as Er,aK as Vr,aL as Sr,aM as Mr,aN as _e,aO as Pr,aP as xr,m as Cr,aQ as $e,aR as kr,aS as Ar,aT as Br,aU as ze,aV as Tr,aW as Rr,S as W,T,aX as D,aY as H,aZ as Ir,c as Lr}from"./src-CURfSkGx-Bgs9tt00.js";var Nr=class We extends Array{#e;#t;constructor(t=0){super(),l(Oe(t,"positive","capacity")),this.#e=t,this.#t=0}add(t){const r=We.from(this);return r[this.#t]=t,r.#e=this.#e,this.#e>0?r.#t=this.#t+1===this.#e?0:this.#t+1:r.#t=this.#t+1,r}get pointer(){return this.#t}get isFull(){return this.#e===0?!1:this.length===this.#e}};const jr=(e,t)=>{e.debug&&console.log(`queue:${t}`)},Je=(e,t,r)=>{const n=t.length+r.length,s=e.capacity??n,i=n-s,o=e.discardPolicy??"additions";switch(o){case"additions":return t.length===0?r.slice(0,r.length-i):t.length===e.capacity?t:[...t,...r.slice(0,i-1)];case"newer":if(i>=t.length)return t.length===0?[...r.slice(0,s-1),r.at(-1)]:r.slice(Math.max(0,r.length-s),Math.min(r.length,s)+1);{const a=Math.max(1,r.length-t.length),u=r.slice(r.length-a,r.length);return[...t.slice(0,Math.min(t.length,s-1)),...u]}case"older":return[...t,...r].slice(i);default:throw new Error(`Unknown overflow policy ${o}`)}},ue=(e,t,...r)=>{if(e===void 0)throw new Error("opts parameter undefined");const n=t.length+r.length,s=e.capacity&&n>e.capacity,i=s?Je(e,t,r):[...t,...r];if(e.capacity&&i.length!==e.capacity&&s)throw new Error(`Bug! Expected return to be at capacity. Return len: ${i.length} capacity: ${e.capacity} opts: ${JSON.stringify(e)}`);if(!e.capacity&&i.length!==n)throw new Error(`Bug! Return length not expected. Return len: ${i.length} expected: ${n} opts: ${JSON.stringify(e)}`);return i},le=(e,t)=>{if(t.length===0)throw new Error("Queue is empty");return t.slice(1)},G=(e,t)=>t[0],ce=(e,t)=>t.length===0,fe=(e,t)=>e.capacity?t.length>=e.capacity:!1;var E=class extends W{options;data;eq;constructor(e={},t=[]){if(super(),e===void 0)throw new Error("opts parameter undefined");this.options=e,this.data=t,this.eq=e.eq??f}clear(){const e=[...this.data];this.data=[],this.fireEvent("removed",{finalData:this.data,removed:e}),this.onClear()}onClear(){}at(e){if(e>=this.data.length)throw new Error("Index outside bounds of queue");const t=this.data.at(e);if(t===void 0)throw new Error("Index appears to be outside range of queue");return t}enqueue(...e){this.data=ue(this.options,this.data,...e);const t=this.data.length;return this.onEnqueue(this.data,e),t}onEnqueue(e,t){this.fireEvent("enqueue",{added:t,finalData:e})}dequeue(){const e=G(this.options,this.data);if(e!==void 0)return this.data=le(this.options,this.data),this.fireEvent("dequeue",{removed:e,finalData:this.data}),this.onRemoved([e],this.data),e}onRemoved(e,t){this.fireEvent("removed",{removed:e,finalData:t})}removeWhere(e){const t=this.data.length,r=this.data.filter(n=>e(n));return r.length===0?0:(this.data=this.data.filter(n=>!e(n)),this.onRemoved(r,this.data),t-this.data.length)}toArray(){return[...this.data]}get isEmpty(){return ce(this.options,this.data)}get isFull(){return fe(this.options,this.data)}get length(){return this.data.length}get peek(){return G(this.options,this.data)}};function Dr(e={},...t){return new E({...e},[...t])}const Qe=(e,t,r)=>{const n=t.length+r.length,s=e.discardPolicy??"additions",i=e.capacity??n,o=n-i;switch(e.debug&&console.log(`Stack.push: stackLen: ${t.length} potentialLen: ${n} toRemove: ${o} policy: ${s}`),s){case"additions":return e.debug&&console.log(`Stack.push:DiscardAdditions: stackLen: ${t.length} slice: ${n-i} toAddLen: ${r.length}`),t.length===e.capacity?t:[...t,...r.slice(0,r.length-o)];case"newer":return o>=t.length?r.slice(Math.max(0,r.length-i),Math.min(r.length,i)+1):(e.debug&&console.log(` from orig: ${JSON.stringify(t.slice(0,t.length-o))}`),[...t.slice(0,t.length-o),...r.slice(0,Math.min(r.length,i-o+1))]);case"older":return[...t,...r].slice(o);default:throw new Error(`Unknown discard policy ${s}`)}},de=(e,t,...r)=>{const n=t.length+r.length;return e.capacity&&n>e.capacity?Qe(e,t,r):[...t,...r]},he=(e,t)=>{if(t.length===0)throw new Error("Stack is empty");return t.slice(0,-1)},q=(e,t)=>t.at(-1),ye=(e,t)=>t.length===0,ve=(e,t)=>e.capacity?t.length>=e.capacity:!1;var C=class{opts;data;constructor(e={},t=[]){this.opts=e,this.data=t}push(...e){return e.length===0?this.data.length:(this.data=de(this.opts,this.data,...e),this.data.length)}forEach(e){this.data.forEach(e)}forEachFromTop(e){[...this.data].reverse().forEach(e)}pop(){const e=q(this.opts,this.data);return this.data=he(this.opts,this.data),e}get isEmpty(){return ye(this.opts,this.data)}get isFull(){return ve(this.opts,this.data)}get peek(){return q(this.opts,this.data)}get length(){return this.data.length}};const Fr=(e={},...t)=>new C({...e},[...t]),pe=(e,t,r=Ke,n)=>{const s=Xe(e,t,r),i=Or(e,t,r),o={valueChanged:!s,a:e,b:t,added:i.added,removed:i.removed,childChanged:!1},a={value:o,childrenStore:[],parent:n},u=i.identical.map(h=>pe(h[0],h[1],r,a)),c=De(o)||u.some(h=>De(h.value));return at(a,u),a.toString=()=>Ue(a,0),a.value.childChanged=c,Ze(a),a},De=e=>e===void 0?!1:!!(e.valueChanged||e.childChanged||e.added.length>0||e.removed.length>0),Or=(e,t,r=Ke)=>{const n=[...e.children()],s=[...t.children()],i=[],o=[];for(const u of n){let c=-1;for(const[h,g]of s.entries())if(Xe(u,g,r)){i.push([u,g]),c=h;break}c===-1?o.push(u):s.splice(c,1)}return{added:[...s],identical:i,removed:o}},Xe=(e,t,r)=>!!(e.getIdentity()===t.getIdentity()||r(e.getValue(),t.getValue())),F=e=>JSON.stringify(e.getValue()),Ue=(e,t=0)=>{if(e===void 0)return"(undefined)";let r=Kr(e.value,t);for(const n of e.childrenStore)r+=Ue(n,t+2);return r},Kr=(e,t)=>{const r=" ".repeat(t);if(e===void 0)return`${r}(undefined)`;const n=[];if(n.push(`a: ${F(e.a)} b: ${F(e.b)}`),e.valueChanged?n.push(`Value changed. Child changed: ${e.childChanged}`):n.push(`Value unchanged. Child changed: ${e.childChanged}`),e.added.length>0){n.push("Added:");for(const s of e.added)n.push(" - "+F(s))}if(e.removed.length>0){n.push(`Removed: ${e.removed.length}`);for(const s of e.removed)n.push(" - "+F(s))}return n.push(`----
`),n.map(s=>r+s).join(`
`)};var He={};v(He,{add:()=>Se,addValue:()=>$,asDynamicTraversable:()=>x,breadthFirst:()=>we,children:()=>$r,childrenLength:()=>Hr,childrenValues:()=>zr,compare:()=>Gr,computeMaxDepth:()=>Xr,createNode:()=>j,depthFirst:()=>_r,findAnyChildByValue:()=>Qr,findChildByValue:()=>Jr,findParentsValue:()=>rt,followValue:()=>ut,fromPlainObject:()=>it,getRoot:()=>Ee,hasAnyChild:()=>J,hasAnyParent:()=>_,hasChild:()=>Ye,hasParent:()=>nt,nodeDepth:()=>Wr,parents:()=>N,parentsValues:()=>tt,queryByValue:()=>et,queryParentsValue:()=>Ve,remove:()=>me,root:()=>Q,rootWrapped:()=>Ur,setChildren:()=>at,stripParentage:()=>ge,throwTreeTest:()=>Ze,toStringDeep:()=>Me,treeTest:()=>be,value:()=>Zr,wrap:()=>m});const Gr=(e,t,r)=>pe(x(e),x(t),r),ge=e=>({value:e.value,childrenStore:e.childrenStore.map(r=>ge(r))}),b=e=>"wraps"in e?e.wraps:e,qr=e=>"wraps"in e?e:m(e),m=e=>({*children(){for(const t of e.childrenStore)yield m(t)},getValue:()=>e.value,getIdentity:()=>e,*queryValue(t){for(const r of et(t,b(e)))yield m(r)},*queryParentsValue(t,r,n){for(const s of Ve(b(t),r,n))yield m(s)},*parentsValues(t){yield*tt(b(t))},findParentsValue(t,r,n){const s=rt(t,r,n);if(s!==void 0)return m(s)},getParent:()=>e.parent===void 0?void 0:m(e.parent),hasParent:t=>nt(e,b(t)),hasAnyParent:t=>_(e,b(t)),hasChild:t=>Ye(b(t),e),hasAnyChild:t=>J(b(t),e),remove:()=>{me(e)},addValue:t=>{const r=$(t,e);return m(r)},add:t=>(Se(b(t),e),qr(t)),wraps:e}),me=e=>{const t=e.parent;t!==void 0&&(e.parent=void 0,t.childrenStore=oe(t.childrenStore,e))};function*_r(e){if(!Q)return;const t=new C;t.push(...e.childrenStore);let r=t.pop();for(;r&&(yield r,r&&t.push(...r.childrenStore),!t.isEmpty);)r=t.pop()}function*we(e){if(!e)return;const t=new E;t.enqueue(...e.childrenStore);let r=t.dequeue();for(;r&&(yield r,r&&t.enqueue(...r.childrenStore),!t.isEmpty);)r=t.dequeue()}function be(e,t=[]){if(e.parent===e)return[!1,"Root has itself as parent",e];if(t.includes(e))return[!1,"Same node instance is appearing further in tree",e];if(t.push(e),ar(e.childrenStore))return[!1,"Children list contains duplicates",e];for(const r of e.childrenStore){if(r.parent!==e)return[!1,"Member of childrenStore does not have .parent set",r];if(J(e,r))return[!1,"Child has parent as its own child",r];const n=be(r,t);if(!n[0])return n}return[!0,"",e]}function Ze(e){const t=be(e);if(!t[0])throw new Error(`${t[1]} Node: ${K(t[2].value,30)}`,{cause:t[2]})}function*$r(e){for(const t of e.childrenStore)yield t}function*zr(e){for(const t of e.childrenStore)typeof t.value<"u"&&(yield t.value)}function*N(e){let t=e.parent;for(;t;)yield t,t=t.parent}function Wr(e){return[...N(e)].length}const Ye=(e,t)=>{for(const r of t.childrenStore)if(r===e)return!0;return!1},Jr=(e,t,r=f)=>{for(const n of t.childrenStore)if(r(e,n.value))return n};function*et(e,t,r=f){for(const n of t.childrenStore)r(e,n.value)&&(yield n)}const J=(e,t)=>{for(const r of we(t))if(r===e)return!0;return!1},Qr=(e,t,r=f)=>{for(const n of we(t))if(r(n.value,e))return n},Ee=e=>e.parent?Ee(e.parent):e,_=(e,t)=>{for(const r of N(e))if(r===t)return!0;return!1};function*tt(e){for(const t of N(e))typeof t.value<"u"&&(yield t.value);return!1}function*Ve(e,t,r=f){for(const n of N(e))typeof n.value<"u"&&r(n.value,t)&&(yield n);return!1}function rt(e,t,r=f){for(const n of Ve(e,t,r))return n}const nt=(e,t)=>e.parent===t,Xr=e=>st(e,0),st=(e,t=0)=>{let r=t;for(const n of e.childrenStore)r=Math.max(r,st(n,t+1));return r},Se=(e,t)=>{ot(e,t);const r=e.parent;t.childrenStore=[...t.childrenStore,e],e.parent=t,r&&(r.childrenStore=oe(r.childrenStore,e))},$=(e,t)=>j(e,t),Q=e=>j(e),it=(e,t="",r,n=[])=>{const s=Object.entries(e);r=r===void 0?Q():$({label:t,value:e},r);for(const i of s){const o=i[1];n.includes(o)||(n.push(o),typeof i[1]=="object"?it(o,i[0],r,n):$({label:i[0],value:o},r))}return r},Ur=e=>m(j(e)),j=(e,t)=>{const r={childrenStore:[],parent:t,value:e};return t!==void 0&&(t.childrenStore=[...t.childrenStore,r]),r},Hr=e=>e.childrenStore.length,Zr=e=>e.value,x=e=>({*children(){for(const r of e.childrenStore)yield x(r)},getParent(){if(e.parent!==void 0)return x(e.parent)},getValue(){return e.value},getIdentity(){return e}}),ot=(e,t)=>{if(t===e)throw new Error("Cannot add self as child");if(e.parent!==t){if(_(t,e))throw new Error("Child contains parent (1)",{cause:e});if(_(e,t))throw new Error("Parent already contains child",{cause:e});if(J(t,e))throw new Error("Child contains parent (2)",{cause:e})}},at=(e,t)=>{for(const r of t)ot(r,e);e.childrenStore=[...t];for(const r of t)r.parent=e},Me=(e,t=0)=>{const r=`${"  ".repeat(t)} + ${e.value?JSON.stringify(e.value):"-"}`;return e.childrenStore.length>0?r+`
`+e.childrenStore.map(n=>Me(n,t+1)).join(`
`):r};function*ut(e,t,r=1){for(const n of e.childrenStore){const s=n.value;s!==void 0&&t(s,r)&&(yield n.value,yield*ut(n,t,r+1))}}var lt={};v(lt,{asDynamicTraversable:()=>Pe,children:()=>k,create:()=>xe,createSimplified:()=>nn,createWrapped:()=>rn,depthFirst:()=>dt,getByPath:()=>tn,prettyPrint:()=>ct,prettyPrintEntries:()=>Yr,toStringDeep:()=>ft,traceByPath:()=>ht});function Yr(e){if(e.length===0)return"(empty)";let t="";for(const[r,n]of e.entries())t+="  ".repeat(r),t+=n.name+" = "+JSON.stringify(n.leafValue)+`
`;return t}const ct=(e,t=0,r={})=>{l(O(e,"node"));const n=r.name??"node",s=sn(e,n),i=`${"  ".repeat(t)} + name: ${s.name} value: ${JSON.stringify(s.leafValue)}`,o=[...k(e,r)];return o.length>0?i+`
`+o.map(a=>ct(a.leafValue,t+1,{...r,name:a.name})).join(`
`):i},ft=(e,t=0)=>{let r=" ".repeat(t)+` ${e.value?.name}`;if(e.value!==void 0){if("sourceValue"in e.value&&"leafValue"in e.value){let n=K(e.value.sourceValue,20);const s=K(e.value.leafValue,20);n=n===s?"":"source: "+n,r+=` = ${s} ${n}`}else"sourceValue"in e.value&&e.value.sourceValue!==void 0&&(r+=` = ${e.value.sourceValue}`);"ancestors"in e.value&&(r+=` (ancestors: ${e.value.ancestors.join(", ")})`)}r+=`
`;for(const n of e.childrenStore)r+=ft(n,t+1);return r};function*k(e,t={}){l(O(e,"node"));const r=t.filter??"none",n=s=>r==="none"?[!0,T(s)]:r==="leaves"&&T(s)?[!0,!0]:r==="branches"&&!T(s)?[!0,!1]:[!1,T(s)];if(Array.isArray(e))for(const[s,i]of e.entries()){const o=n(i);o[0]&&(yield{name:s.toString(),_kind:"entry",sourceValue:i,leafValue:o[1]?i:void 0})}else if(typeof e=="object"){const s="entries"in e?e.entries():Object.entries(e);for(const[i,o]of s){const[a,u]=n(o);a&&(yield{name:i,_kind:"entry",sourceValue:o,leafValue:u?o:void 0})}}}function*dt(e,t={},r=[]){for(const n of k(e,t))yield{...n,ancestors:[...r],_kind:"entry-ancestors"},yield*dt(n.sourceValue,t,[...r,n.name])}function en(e,t){for(const r of k(t))if(r.name===e)return r}function tn(e,t,r={}){const n=cr(ht(e,t,r));if(!n)throw new Error(`Could not trace path: ${e} `);return n}function*ht(e,t,r={}){l(O(e,"path"),O(t,"node"));const n=r.separator??".",s=e.split(n),i=[];for(const o of s){const a=en(o,t);if(!a){yield{name:o,sourceValue:void 0,leafValue:void 0,ancestors:i,_kind:"entry-ancestors"};return}t=a.sourceValue,yield{...a,ancestors:[...i],_kind:"entry-ancestors"},i.push(o)}}const Pe=(e,t={},r=[],n)=>{const s=t.name??"object",i={*children(){for(const{name:o,sourceValue:a,leafValue:u}of k(e,t))yield Pe(a,{...t,name:o},[...r,s],i)},getParent(){return n},getValue(){return{name:s,sourceValue:e,ancestors:r,_kind:"entry-static"}},getIdentity(){return e}};return i},rn=(e,t)=>m(xe(e,t)),xe=(e,t={})=>{const n=t.valuesAtLeaves??!1?s=>{if(T(s))return s}:s=>s;return yt(e,n(e),t,[])},yt=(e,t,r={},n)=>{const s=r.name??"object_ci",i=Q({name:s,sourceValue:t,ancestors:[...n],_kind:"entry-static"});n=[...n,s];for(const o of k(e,r)){const a=r.valuesAtLeaves?o.leafValue:o.sourceValue;Se(yt(o.sourceValue,a,{...r,name:o.name},n),i)}return i},nn=(e,t={})=>ge(xe(e,t));function sn(e,t=""){return"name"in e&&"leafValue"in e&&"sourceValue"in e?{name:e.name,_kind:"entry",leafValue:e.leafValue,sourceValue:e.sourceValue}:"name"in e?{name:e.name,leafValue:e,sourceValue:e,_kind:"entry"}:{name:t,leafValue:e,sourceValue:e,_kind:"entry"}}var vt={};v(vt,{addValueByPath:()=>pt,childrenLengthByPath:()=>an,clearValuesByPath:()=>mt,create:()=>on,removeByPath:()=>gt,valueByPath:()=>wt,valuesByPath:()=>ke});const on=(e={})=>{let t;return{getRoot:()=>t,add:(y,M)=>{const or=pt(y,M,t,e);t===void 0&&(t=Ee(or))},prettyPrint:()=>t===void 0?"(empty)":Me(t),remove:y=>t===void 0?!1:gt(y,t,e),getValue:y=>{if(t!==void 0)return wt(y,t,e)},getValues:y=>t===void 0?[]:ke(y,t,e),hasPath:y=>t===void 0?!1:P(y,t,e)!==void 0,childrenLength:y=>{if(t===void 0)return 0;const M=P(y,t,e);return M===void 0?0:M.childrenStore.length},getNode:y=>t===void 0?void 0:P(y,t,e),clearValues:y=>t===void 0?!1:mt(y,t,e)}},pt=(e,t,r,n={})=>{const s=n.separator??".",i=n.duplicates??"overwrite",o=t.split(s);let a=0;for(const u of o){const c=a===o.length-1,h=Ce(u,r);if(h===void 0)r=j({value:c?e:void 0,label:u},r);else if(r=h,c)switch(i){case"ignore":break;case"allow":{const g=bt(r);r.value={values:[...g,e],label:u};break}case"overwrite":{r.value={value:e,label:u};break}}else r=h;a++}if(r===void 0)throw new Error("Could not create tree");return r},gt=(e,t,r={})=>{if(t===void 0)return!1;const n=P(e,t,r);return n===void 0?!1:(me(n),!0)},mt=(e,t,r={})=>{if(t===void 0)return!1;const n=P(e,t,r);return n===void 0?!1:(n.value={label:n.value?.label??"",value:void 0},!0)},an=(e,t,r={})=>{if(t===void 0)return 0;const n=P(e,t,r);return n===void 0?0:n.childrenStore.length},Ce=(e,t)=>{if(t!==void 0){if(e===void 0)throw new Error("Parameter 'label' cannot be undefined");if(t.value?.label===e)return t;for(const r of t.childrenStore)if(r.value?.label===e)return r}},wt=(e,t,r={})=>{const n=ke(e,t,r);if(n.length!==0){if(n.length>1)throw new Error("Multiple values at path. Use getValues instead");return n[0]}},bt=e=>e.value===void 0?[]:"values"in e.value?e.value.values:"value"in e.value?e.value.value===void 0?[]:[e.value.value]:[],P=(e,t,r={})=>{const n=r.separator??".",s=e.split(n);let i=t;for(const o of s)if(i=Ce(o,i),i===void 0)return;return i},ke=(e,t,r={})=>{const n=r.separator??".",s=e.split(n);let i=t;for(const o of s)if(i=Ce(o,i),i===void 0)return[];return bt(i)};var Et={};v(Et,{breadthFirst:()=>A,childrenLength:()=>un,couldAddChild:()=>dn,depthFirst:()=>Re,find:()=>gn,findAnyChildByValue:()=>pn,findAnyParentByValue:()=>fn,findByValue:()=>mn,findChildByValue:()=>Mt,findParentByValue:()=>Te,followValue:()=>Pt,hasAnyChild:()=>Y,hasAnyChildValue:()=>hn,hasAnyParent:()=>ln,hasAnyParentValue:()=>cn,hasChild:()=>Vt,hasChildValue:()=>St,hasParent:()=>Ae,hasParentValue:()=>Be,parents:()=>vn,siblings:()=>yn,toString:()=>wn,toStringDeep:()=>xt});const un=e=>[...e.children()].length,ln=(e,t,r)=>Ae(e,t,r,Number.MAX_SAFE_INTEGER),cn=(e,t,r)=>{if(typeof e>"u")throw new TypeError("Param 'child' is undefined");return Be(e,t,r,Number.MAX_SAFE_INTEGER)},fn=(e,t,r)=>Te(e,t,r,Number.MAX_SAFE_INTEGER),Ae=(e,t,r=f,n=0)=>{if(n<0)return!1;const s=V(e),i=V(t),o=s?e.getParent():e.parent;if(typeof o>"u")return!1;if(r(o,t))return!0;const a=s?o.getIdentity():o.value,u=i?t.getIdentity():t.value;return r(a,u)?!0:Ae(o,t,r,n-1)},Be=(e,t,r=f,n=0)=>{if(e===void 0)throw new Error("Param 'child' is undefined");if(n<0)return!1;const s="getParent"in e?e.getParent():e.parent;if(s===void 0)return!1;const i="getValue"in s?s.getValue():s.value;return r(i,t)?!0:Be(s,t,r,n-1)},Te=(e,t,r=f,n=0)=>{if(n<0)return;const s="getParent"in e?e.getParent():e.parent;if(s===void 0)return;const i="getValue"in s?s.getValue():s.value;return r(i,t)?s:Te(s,t,r,n-1)},dn=(e,t,r=f)=>{if(r(e,t))throw new Error("Child equals parent");if(Y(e,t,r))throw new Error("Circular. Parent already has child");if(Y(t,e,r))throw new Error("Prospective child has parent as child relation")},Y=(e,t,r=f)=>Vt(e,t,r,Number.MAX_SAFE_INTEGER),hn=(e,t,r=f)=>St(e,t,r,Number.MAX_SAFE_INTEGER),Vt=(e,t,r=f,n=0)=>{if(n<0)return!1;if(r(e,t))return!0;const s="getIdentity"in e?e.getIdentity():e.value,i="getIdentity"in t?t.getIdentity():t.value;if(r(s,i))return!0;for(const o of A(e,n)){const a="getIdentity"in o?o.getIdentity():o.value;if(r(o,t)||r(a,i))return!0}return!1},St=(e,t,r=f,n=0)=>{if(n<0)return!1;if(r(e.getValue(),t))return!0;for(const s of A(e,n)){const i=s.getValue();if(r(i,t))return!0}return!1};function*yn(e){const t=e.getParent();if(t!==void 0)for(const r of t.children())r!==e&&(yield r)}function*vn(e){if(V(e)){let t=e.getParent();for(;t!==void 0;)yield t,t=t.getParent()}else{let t=e.parent;for(;t!==void 0;)yield t,t=t.parent}}function pn(e,t,r=f){return Mt(e,t,r,Number.MAX_SAFE_INTEGER)}function Mt(e,t,r=f,n=0){if(n<0)return;const s=V(e);if(s){if(r(e.getValue(),t))return e}else if(r(e.value,t))return e;for(const i of A(e,n))if(s){if(r(i.getValue(),t))return i}else if(r(i.value,t))return i}function*Re(e){if(!e)return;const t=new C;let r=e;for(;r;){const n=V(r)?[...r.children()]:[...r.childrenStore];if(t.push(...n),t.isEmpty)break;r=t.pop(),r&&(yield r)}}function*A(e,t=Number.MAX_SAFE_INTEGER){if(!e)return;const n=V(e)?new E:new E;let s=e;for(;s;){if(t<0)return;if(s!==void 0){const i="childrenStore"in s?s.childrenStore:s.children();for(const o of i)yield o,n.enqueue(o)}s=n.dequeue(),t--}}function gn(e,t,r="breadth"){if(t(e))return e;const n=r==="breadth"?A:Re;for(const s of n(e))if(t(s))return s}function mn(e,t,r="breadth"){if(t(e.getValue()))return e;const n=r==="breadth"?A:Re;for(const s of n(e))if(t(s.getValue()))return s}function*Pt(e,t,r=1){for(const n of e.children())t(n.getValue(),r)&&(yield n.getValue(),yield*Pt(n,t,r+1))}function xt(e,t=0){if(e===void 0)return"(undefined)";if(e===null)return"(null)";const r=e.getValue();let n=typeof r;Array.isArray(r)&&(n="array");let s="  ".repeat(t)+`value: ${JSON.stringify(r)} (${n})
`;for(const i of e.children())s+=xt(i,t+1);return s}function wn(...e){let t="";for(const r of e){const n=r.getValue(),s=K(n),i=[...r.children()],o=r.getParent();let a=typeof n;Array.isArray(n)&&(a="array"),t+=`value: ${s} (${a}) kids: ${i.length} parented: ${o?"y":"n"}
`}return t}var bn={};v(bn,{FromObject:()=>lt,Mutable:()=>He,Pathed:()=>vt,Traverse:()=>Et,compare:()=>pe,isTraversable:()=>V,isTreeNode:()=>Ct,toTraversable:()=>En});const En=e=>{if(V(e))return e;if(Ct(e))return x(e);if(typeof e=="object")return Pe(e);throw new Error("Parameter 'node' not convertible")},Ct=e=>!!("parent"in e&&"childrenStore"in e&&"value"in e&&Array.isArray(e.childrenStore)),V=e=>"children"in e&&"getParent"in e&&"getValue"in e&&"getIdentity"in e;var kt=class ee{opts;data;constructor(t={},r=[]){this.opts=t,this.data=r}push(...t){return new ee(this.opts,de(this.opts,this.data,...t))}pop(){return new ee(this.opts,he(this.opts,this.data))}forEach(t){this.data.forEach(t)}forEachFromTop(t){[...this.data].reverse().forEach(t)}get isEmpty(){return ye(this.opts,this.data)}get isFull(){return ve(this.opts,this.data)}get peek(){return q(this.opts,this.data)}get length(){return this.data.length}};const Vn=(e={},...t)=>new kt({...e},[...t]);var Sn={};v(Sn,{StackImmutable:()=>kt,StackMutable:()=>C,immutable:()=>Vn,isEmpty:()=>ye,isFull:()=>ve,mutable:()=>Fr,peek:()=>q,pop:()=>he,push:()=>de,trimStack:()=>Qe});const Mn=e=>new At(e);var At=class extends W{store=new Map;keyString;constructor(e){super(),this.keyString=e??L}get size(){return this.store.size}add(...e){let t=!1;for(const r of e){const n=this.has(r);this.store.set(this.keyString(r),r),super.fireEvent("add",{value:r,updated:n}),n||(t=!0)}return t}values(){return this.store.values()}clear(){this.store.clear(),super.fireEvent("clear",!0)}delete(e){const t=this.store.delete(this.keyString(e));return t&&super.fireEvent("delete",e),t}has(e){return this.store.has(this.keyString(e))}toArray(){return[...this.store.values()]}},Bt=class te{store;keyString;constructor(t,r){this.store=r??new Map,this.keyString=t??L}get size(){return this.store.size}add(...t){const r=new Map(this.store);for(const n of t){const s=this.keyString(n);r.set(s,n)}return new te(this.keyString,r)}delete(t){const r=new Map(this.store),n=this.keyString(t);return r.delete(n)?new te(this.keyString,r):this}has(t){const r=this.keyString(t);return this.store.has(r)}toArray(){return[...this.store.values()]}*values(){yield*this.store.values()}};const Pn=(e=ae)=>new Bt(e);var xn=class Tt{#e;#t;children=new Map;values=[];constructor(t=1,r=0){this.#e=r,this.#t=t}sizeLocal(){return this.values.length}sizeChildren(){return[...this.children.values()].length}sizeChildrenDeep(){let t=this.sizeChildren();for(const r of this.children.values())t+=r.sizeChildrenDeep();return t}size(){let t=this.values.length;for(const r of this.children.values())t+=r.size();return t}add(t){if(typeof t!="string")throw new Error(`Param 'value' must be a string. Got: ${typeof t}`);if(t.length===0)throw new Error("Param 'value' is empty");const r=this.#n(t,!0);if(r===this){this.hasLocal(t)||this.values.push(t);return}if(!r)throw new Error(`Could not create child set for: ${t}`);r.add(t)}remove(t){if(typeof t!="string")throw new Error(`Param 'value' must be a string. Got: ${typeof t}`);if(t.length===0)throw new Error("Param 'value' is empty");const r=this.#n(t,!1);return r===void 0?!1:r===this?this.hasLocal(t)?(this.values=this.values.filter(n=>n!==t),!0):!1:r.remove(t)}debugDump(){const t=this.#r();for(const r of t)console.log(r)}#r(t=0){const r=[];r.push(`Depth: ${this.#e} Max: ${this.#t}`);for(const[n,s]of this.children.entries()){const i=s.#r(t+1);r.push(` key: ${n}`);for(const o of i)r.push(" ".repeat(t+1)+o)}r.push(`Values: (${this.values.length})`);for(const n of this.values)r.push(` ${n}`);return r.map(n=>" ".repeat(t)+n)}#n(t,r){if(t===void 0)throw new Error("Param 'value' undefined");if(this.#e===this.#t)return this;if(t.length<=this.#e)return this;const n=t[this.#e];if(n===void 0)throw new Error(`Logic error. Depth: ${this.#e} Len: ${t.length}`);let s=this.children.get(n);return s===void 0&&r&&(s=new Tt(this.#t,this.#e+1),this.children.set(n,s)),s}hasLocal(t){for(const r of this.values)if(r===t)return!0;return!1}has(t){if(typeof t!="string")return!1;const r=this.#n(t,!1);return r===void 0?!1:r===this?this.hasLocal(t):r.has(t)}},Cn={};v(Cn,{MassiveSet:()=>xn,SetStringImmutable:()=>Bt,SetStringMutable:()=>At,immutable:()=>Pn,mutable:()=>Mn});var Ie=class extends E{constructor(e={}){e.eq===void 0&&(e={...e,eq:(t,r)=>f(t.item,r.item)}),super(e)}enqueueWithPriority(e,t){l(lr(t,"positive")),super.enqueue({item:e,priority:t})}changePriority(e,t,r=!1,n){if(e===void 0)throw new Error("Item cannot be undefined");let s;for(const i of this.data)if(n){if(n(i.item,e)){s=i;break}}else if(this.eq(i,{item:e,priority:0})){s=i;break}if(s===void 0&&!r)throw new Error(`Item not found in priority queue. Item: ${JSON.stringify(e)}`);s!==void 0&&this.removeWhere(i=>s===i),this.enqueueWithPriority(e,t)}dequeueMax(){const e=D(H(this.data,(t,r)=>t.priority>=r.priority));if(e!==void 0)return this.removeWhere(t=>t===e),e.item}dequeueMin(){const e=D(H(this.data,(t,r)=>t.priority>=r.priority));if(e!==void 0)return this.removeWhere(t=>t.item===e),e.item}peekMax(){const e=D(H(this.data,(t,r)=>t.priority>=r.priority));if(e!==void 0)return e.item}peekMin(){const e=D(Ir(this.data,(t,r)=>t.priority>=r.priority));if(e!==void 0)return e.item}};function kn(e={}){return new Ie(e)}var Rt=class re{opts;#e;constructor(t={},r=[]){if(t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.#e=r}forEach(t){for(let r=this.#e.length-1;r>=0;r--)t(this.#e[r])}forEachFromFront(t){this.#e.forEach(r=>{t(r)})}enqueue(...t){return new re(this.opts,ue(this.opts,this.#e,...t))}dequeue(){return new re(this.opts,le(this.opts,this.#e))}get isEmpty(){return ce(this.opts,this.#e)}get isFull(){return fe(this.opts,this.#e)}get length(){return this.#e.length}get peek(){return G(this.opts,this.#e)}toArray(){return[...this.#e]}};const An=(e={},...t)=>(e={...e},new Rt(e,[...t]));var Bn={};v(Bn,{PriorityMutable:()=>Ie,QueueImmutable:()=>Rt,QueueMutable:()=>E,debug:()=>jr,dequeue:()=>le,enqueue:()=>ue,immutable:()=>An,isEmpty:()=>ce,isFull:()=>fe,mutable:()=>Dr,peek:()=>G,priority:()=>kn,trimQueue:()=>Je});const Tn=(e={})=>new It(e);var It=class extends W{capacity;store;evictPolicy;autoDeleteElapsedMs;autoDeletePolicy;autoDeleteTimer;disposed=!1;constructor(e={}){if(super(),this.capacity=e.capacity??-1,l(Oe(this.capacity,"nonZero","capacity")),this.store=new Map,e.evictPolicy&&this.capacity<=0)throw new Error("evictPolicy is set, but no capacity limit is set");this.evictPolicy=e.evictPolicy??"none",this.autoDeleteElapsedMs=e.autoDeleteElapsedMs??-1,this.autoDeletePolicy=e.autoDeletePolicy??"none",this.autoDeleteElapsedMs>0&&(this.autoDeleteTimer=setInterval(()=>{this.#e()},Math.max(1e3,this.autoDeleteElapsedMs*2)))}dispose(){this.disposed||(this.disposed=!0,this.autoDeleteTimer&&(clearInterval(this.autoDeleteTimer),this.autoDeleteTimer=void 0))}get keyLength(){return this.store.size}*entries(){for(const e of this.store.entries())yield[e[0],e[1].value]}*values(){for(const e of this.store.values())yield e.value}*keys(){yield*this.store.keys()}elapsedSet(e){const t=this.store.get(e);if(!(typeof t>"u"))return Date.now()-t.lastSet}elapsedGet(e){const t=this.store.get(e);if(!(typeof t>"u"))return Date.now()-t.lastGet}has(e){return this.store.has(e)}get(e){const t=this.store.get(e);if(t)return(this.autoDeletePolicy==="either"||this.autoDeletePolicy==="get")&&this.store.set(e,{...t,lastGet:performance.now()}),t.value}delete(e){const t=this.store.get(e);if(!t)return!1;const r=this.store.delete(e);return this.fireEvent("removed",{key:e,value:t.value}),r}clear(){this.store.clear()}touch(e){const t=this.store.get(e);return t?(this.store.set(e,{...t,lastSet:Date.now(),lastGet:Date.now()}),!0):!1}findEvicteeKey(){if(this.evictPolicy==="none")return;let e="";if(this.evictPolicy==="oldestGet")e="lastGet";else if(this.evictPolicy==="oldestSet")e="lastSet";else throw new Error(`Unknown eviction policy ${this.evictPolicy}`);return Ge(this.store,e)[0][0]}#e(){this.autoDeletePolicy!=="none"&&this.deleteWithElapsed(this.autoDeleteElapsedMs,this.autoDeletePolicy)}deleteWithElapsed(e,t){const r=[...this.store.entries()],n=[],s=Lr(e,1e3),i=performance.now();for(const o of r){const a=i-o[1].lastGet,u=i-o[1].lastSet;(t==="get"?a:t==="set"?u:Math.max(a,u))>=s&&n.push([o[0],o[1].value])}for(const o of n){this.store.delete(o[0]);const a={key:o[0],value:o[1]};this.fireEvent("expired",a),this.fireEvent("removed",a)}return n}set(e,t){const r=this.store.get(e);if(r){this.store.set(e,{...r,lastSet:performance.now()});return}if(this.keyLength===this.capacity&&this.capacity>0){const n=this.findEvicteeKey();if(!n)throw new Error(`ExpiringMap full (capacity: ${this.capacity})`);const s=this.store.get(n);if(this.store.delete(n),s){const i={key:n,value:s.value};this.fireEvent("expired",i),this.fireEvent("removed",i)}}this.store.set(e,{lastGet:0,lastSet:performance.now(),value:t}),this.fireEvent("newKey",{key:e,value:t})}};const Rn=(e,t)=>{for(const r of e.entries()){const n=r[1];for(const s of n)if(t(s,r[0]))return r}},In=e=>{let t=["",0];for(const r of e.keysAndCounts())r[1]>t[1]&&(t=r);return t[1]},Lt=(e,t,r=f)=>{for(const n of e.entries()){const s=n[1];for(const i of s)if(r(i,t))return n}};var Nt=class{map;groupBy;valueEq;constructor(e=L,t=f,r=[]){this.groupBy=e,this.valueEq=t,this.map=new Map(r)}has(e){return this.map.has(e)}hasKeyValue(e,t){const r=this.map.get(e);if(!r)return!1;for(const n of r)if(this.valueEq(n,t))return!0;return!1}debugString(){let e="";return[...this.map.keys()].every(r=>{const n=this.map.get(r);n!==void 0&&(e+=r+` (${n.length}) = ${JSON.stringify(n)}\r
`)}),e}count(e){const t=this.map.get(e);return t?t.length:0}firstKeyByValue(e,t=f){const r=Lt(this,e,t);if(r)return r[0]}*entriesFlat(){for(const e of this.map.keys())for(const t of this.map.get(e))yield[e,t]}*entries(){for(const[e,t]of this.map.entries())yield[e,[...t]]}*get(e){const t=this.map.get(e);t&&(yield*t.values())}*keys(){yield*this.map.keys()}*valuesFlat(){for(const e of this.map)yield*e[1]}*values(){for(const e of this.map)yield e[1]}*keysAndCounts(){for(const e of this.map)yield[e[0],e[1].length]}get lengthKeys(){return this.map.size}get isEmpty(){return this.map.size===0}},jt=class extends Nt{addKeyedValues(e,...t){const r=this.map.get(e);r===void 0?this.map.set(e,t):this.map.set(e,[...r,...t])}setValues(e,t){this.map.set(e,t)}addValue(...e){for(const t of e){const r=this.groupBy(t);this.addKeyedValues(r,t)}}deleteKeyValue(e,t){const r=this.map.get(e);if(r===void 0)return!1;const n=r.filter(s=>!this.valueEq(s,t));return this.map.set(e,n),n.length<r.length}deleteByValue(e){let t=!1;const r=[...this.map.entries()];for(const n of r)for(const s of n[1])this.valueEq(s,e)&&(t=!0,this.deleteKeyValue(n[0],e));return t}delete(e){const t=this.map.get(e);return!t||t.length===0?!1:(this.map.delete(e),!0)}clear(){this.map.clear()}};const Fe=(e=L,t=f)=>new jt(e,t),Ln=(e,t)=>{const r=new Map(e.entries());for(const n of t){if(n[0]===void 0)throw new Error("key cannot be undefined");if(n[1]===void 0)throw new Error("value cannot be undefined");r.set(n[0],n[1])}return r},Nn=(e,t)=>{const r=new Map(e.entries());for(const n of t){if(n.key===void 0)throw new Error("key cannot be undefined");if(n.value===void 0)throw new Error("value cannot be undefined");r.set(n.key,n.value)}return r},jn=(e,t)=>e.has(t),I=(e,...t)=>{if(e===void 0)throw new Error("map parameter is undefined");if(t===void 0)throw new Error("data parameter i.s undefined");if(t.length===0)return e;const r=t[0];return typeof r.key<"u"&&typeof r.value<"u"?Nn(e,t):Ln(e,t)},Dt=(e,t,r)=>{const n=new Map(e.entries());return n.set(t,r),n},Ft=(e,t)=>{const r=new Map(e.entries());return r.delete(t),r},p=e=>{if(e===void 0)return p([]);if(Array.isArray(e))return p(I(new Map,...e));const t=e;return{add:(...r)=>{const n=I(t,...r);return p(n)},set:(r,n)=>{const s=Dt(t,r,n);return p(s)},get:r=>t.get(r),delete:r=>p(Ft(t,r)),clear:()=>p(),has:r=>t.has(r),entries:()=>t.entries(),values:()=>t.values(),isEmpty:()=>t.size===0}},Dn=(...e)=>{let t=I(new Map,...e);return{add:(...r)=>{t=I(t,...r)},delete:r=>{t=Ft(t,r)},clear:()=>{t=I(new Map)},set:(r,n)=>{t=Dt(t,r,n)},get:r=>t.get(r),entries:()=>t.entries(),values:()=>t.values(),isEmpty:()=>t.size===0,has:r=>jn(t,r)}};var X=class extends W{#e=new Map;groupBy;type;constructor(e,t={}){super(),this.type=e,this.groupBy=t.groupBy??ae}get typeName(){return this.type.name}get lengthKeys(){return this.#e.size}get lengthMax(){let e=0;for(const t of this.#e.values())e=Math.max(e,this.type.count(t));return e}debugString(){const e=[...this.#e.keys()];let t=`Keys: ${e.join(", ")}\r
`;for(const r of e){const n=this.#e.get(r);if(n===void 0)t+=` - ${r} (undefined)\r
`;else{const s=this.type.toArray(n);s!==void 0&&(t+=` - ${r} (${this.type.count(n)}) = ${JSON.stringify(s)}\r
`)}}return t}get isEmpty(){return this.#e.size===0}clear(){this.#e.clear(),super.fireEvent("clear",!0)}addKeyedValues(e,...t){const r=this.#e.get(e);r===void 0?(this.#e.set(e,this.type.addKeyedValues(void 0,t)),super.fireEvent("addedKey",{key:e}),super.fireEvent("addedValues",{values:t})):(this.#e.set(e,this.type.addKeyedValues(r,t)),super.fireEvent("addedValues",{values:t}))}set(e,t){return this.addKeyedValues(e,...t),this}addValue(...e){for(const t of e)this.addKeyedValues(this.groupBy(t),t)}hasKeyValue(e,t,r){const n=this.#e.get(e);return n===void 0?!1:this.type.has(n,t,r)}has(e){return this.#e.has(e)}deleteKeyValue(e,t){const r=this.#e.get(e);return r===void 0?!1:this.deleteKeyValueFromMap(r,e,t)}deleteKeyValueFromMap(e,t,r){const n=this.type.count(e),s=this.type.without(e,r),i=s.length;return this.#e.set(t,this.type.addKeyedValues(void 0,s)),n>i}deleteByValue(e){let t=!1;return[...this.#e.keys()].filter(r=>{const n=this.#e.get(r);if(!n)throw new Error("Bug: map could not be accessed");this.deleteKeyValueFromMap(n,r,e)&&(t=!0,this.count(r)===0&&this.delete(r))}),t}delete(e){return this.#e.get(e)===void 0?!1:(this.#e.delete(e),this.fireEvent("deleteKey",{key:e}),!0)}firstKeyByValue(e,t=f){return[...this.#e.keys()].find(s=>{const i=this.#e.get(s);if(i===void 0)throw new Error("Bug: map could not be accessed");return this.type.has(i,e,t)})}count(e){const t=this.#e.get(e);return t===void 0?0:this.type.count(t)}*get(e){const t=this.#e.get(e);t!==void 0&&(yield*this.type.iterable(t))}*valuesFor(e){const t=this.#e.get(e);t!==void 0&&(yield*this.type.iterable(t))}getSource(e){return this.#e.get(e)}*keys(){yield*this.#e.keys()}*entriesFlat(){for(const e of this.#e.entries())for(const t of this.type.iterable(e[1]))yield[e[0],t]}*valuesFlat(){for(const e of this.#e.entries())yield*this.type.iterable(e[1])}*entries(){for(const[e,t]of this.#e.entries()){const r=[...this.type.iterable(t)];yield[e,r]}}*keysAndCounts(){for(const e of this.keys())yield[e,this.count(e)]}merge(e){for(const t of e.keys()){const r=e.get(t);this.addKeyedValues(t,...r)}}get size(){return this.#e.size}get[Symbol.toStringTag](){return this.#e[Symbol.toStringTag]}};const Fn=e=>{const t=e?.hash??ae,r=(i,o)=>t(i)===t(o),n={get name(){return"set"},iterable:i=>i.values(),addKeyedValues:(i,o)=>ze(i,t,"skip",...o),count:i=>i.size,find:(i,o)=>_e(i,o),filter:(i,o)=>$e(i,o),toArray:i=>Z(i),has:(i,o)=>qe(i,o,r),without:(i,o)=>oe(Z(i),o,r)};return new X(n,e)},On=e=>{const t=f,r={get name(){return"circular"},addKeyedValues:(n,s)=>{let i=n??new Nr(e.capacity);for(const o of s)i=i.add(o);return i},count:n=>n.length,find:(n,s)=>n.find(s),filter:(n,s)=>n.filter(s),toArray:n=>n,iterable:n=>n.values(),has:(n,s)=>n.find(i=>t(i,s))!==void 0,without:(n,s)=>n.filter(i=>!t(i,s))};return new X(r,e)};var Ot=class extends Map{defaultValue;constructor(e=0){super(),this.defaultValue=e}get(e){const t=super.get(e);return t===void 0?this.defaultValue:t}reset(e){return super.set(e,this.defaultValue),this.defaultValue}multiply(e,t){let n=super.get(e)??this.defaultValue;return n*=t,super.set(e,n),n}add(e,t=1){let n=super.get(e)??this.defaultValue;return n+=t,super.set(e,n),n}subtract(e,t=1){let n=super.get(e)??this.defaultValue;return n-=t,super.set(e,n),n}};const Kn=(e={})=>{const t=e.convertToString,r=typeof t>"u"?f:(o,a)=>t(o)===t(a),n=e.comparer??r,s={get name(){return"array"},addKeyedValues:(o,a)=>o===void 0?[...a]:[...o,...a],iterable:o=>o.values(),count:o=>o.length,find:(o,a)=>o.find(u=>a(u)),filter:(o,a)=>o.filter(u=>a(u)),toArray:o=>o,has:(o,a)=>o.some(u=>n(u,a)),without:(o,a)=>o.filter(u=>!n(u,a))};return new X(s,e)};var Kt=class R extends Nt{addKeyedValues(t,...r){return this.addBatch([[t,r]])}addValue(...t){const r=t.map(n=>[this.groupBy(n),n]);return this.addBatch(r)}addBatch(t){const r=new Map([...this.map.entries()].map(n=>[n[0],[...n[1]]]));for(const[n,s]of t){const i=r.get(n);typeof i>"u"?r.set(n,s):i.push(...s)}return new R(this.groupBy,this.valueEq,[...r.entries()])}clear(){return new R(this.groupBy,this.valueEq)}deleteKeyValue(t,r){throw new Error("Method not implemented.")}deleteByValue(t,r){const n=[...this.map.entries()],s=r??this.valueEq,i=n.map(o=>{const a=o[0],u=o[1].filter(c=>!s(c,t));return[a,u]});return new R(this.groupBy,this.valueEq,i)}delete(t){const r=[...this.map.entries()].filter(n=>n[0]!==t);return new R(this.groupBy,this.valueEq,r)}};const Gn=(e=L,t=f)=>new Kt(e,t);var qn={};v(qn,{ExpiringMap:()=>It,MapOfMutableImpl:()=>X,MapOfSimple:()=>Kt,MapOfSimpleMutable:()=>jt,NumberMap:()=>Ot,addObjectEntriesMutate:()=>Tr,addValue:()=>ze,addValueMutate:()=>Br,addValueMutator:()=>Ar,deleteByValueCompareMutate:()=>kr,expiringMap:()=>Tn,filterValues:()=>$e,findBySomeKey:()=>Cr,findEntryByPredicate:()=>xr,findEntryByValue:()=>Pr,findValue:()=>_e,firstEntry:()=>Rn,firstEntryByValue:()=>Lt,fromIterable:()=>Mr,fromObject:()=>Sr,getClosestIntegerKey:()=>Vr,getOrGenerate:()=>Er,getOrGenerateSync:()=>br,hasAnyValue:()=>qe,hasKeyValue:()=>wr,immutable:()=>p,lengthMax:()=>In,mapOfSimpleMutable:()=>Fe,mapToArray:()=>mr,mapToObjectTransform:()=>gr,mergeByKey:()=>pr,mutable:()=>Dn,ofArrayMutable:()=>Kn,ofCircularMutable:()=>On,ofSetMutable:()=>Fn,ofSimple:()=>Gn,ofSimpleMutable:()=>Fe,some:()=>vr,sortByValue:()=>yr,sortByValueProperty:()=>Ge,toArray:()=>Z,toObject:()=>hr,transformMap:()=>dr,zipKeyValue:()=>fr});var Gt=class{rows=[];rowLabels=[];colLabels=[];columnMaxLength=0;getColumnLabelIndex(e){for(const[t,r]of this.colLabels.entries())if(r===e)return t}getRowLabelIndex(e){for(const[t,r]of this.rowLabels.entries())if(r===e)return t}print(){console.table([...this.rowsWithLabelsObject()])}asArray(){const e=[];for(const t of this.rows)t===void 0?e.push([]):e.push([...t]);return e}get rowCount(){return this.rows.length}get columnCount(){return this.columnMaxLength}*rowsWithLabelsObject(){for(let e=0;e<this.rows.length;e++)yield this.getRowWithLabelsObject(e)}*rowsWithLabelsArray(){for(let e=0;e<this.rows.length;e++)yield this.getRowWithLabelsArray(e)}labelColumns(...e){this.colLabels=e}labelColumn(e,t){this.colLabels[e]=t}labelRows(...e){this.rowLabels=e}labelRow(e,t){this.rowLabels[e]=t}appendRow(...e){return this.columnMaxLength=Math.max(this.columnMaxLength,e.length),this.rows.push(e),e}getRowWithLabelsArray(e){const t=this.rows.at(e);if(t!==void 0)return t.map((r,n)=>[this.colLabels.at(n),r])}getRowWithLabelsObject(e){const t=this.rows.at(e);if(t===void 0)return;const r={};for(let n=0;n<this.colLabels.length;n++){const s=this.colLabels.at(n)??n.toString();r[s]=t[n]}return r}#e(e){const t=typeof e=="number"?e:this.getRowLabelIndex(e);if(t===void 0)return{success:!1,error:"row-label-notfound"};if(t<0)return{success:!1,error:"row-index-invalid"};if(t<this.rows.length)return{success:!0,value:this.rows[t]};const r=[];return this.rows[t]=r,{success:!0,value:r}}row(e){const t=this.#t(e);if(B(t))throw new Error(t.error);return[...t.value]}set(e,t,r){const n=this.#e(e);if(B(n))throw new Error(n.error);const s=n.value,i=typeof t=="number"?t:this.getColumnLabelIndex(t);if(typeof i>"u")throw new Error(`Column label '${t}' not found or is invalid`);if(i<0)throw new Error("Column index invalid (less than zero)");s[i]=r}get(e,t){const r=this.#t(e);if(B(r))throw new Error(r.error);const n=this.#r(r.value,t);if(B(n))throw new Error(n.error);return n.value.value}#t(e){let t=0;if(typeof e=="number")t=e;else if(t=this.getRowLabelIndex(e),typeof t!="number")return{error:"row-label-notfound",success:!1};return typeof t!="number"?{error:"row-invalid",success:!1}:t<0||t>=this.rows.length?{error:"row-index-out-of-range",success:!1}:{success:!0,value:this.rows[t]}}#r(e,t){const r=typeof t=="number"?t:this.getColumnLabelIndex(t);return typeof r!="number"?{success:!1,error:"col-label-notfound"}:r<0||r>=e.length?{success:!1,error:"col-index-out-of-range"}:{success:!0,value:{index:r,value:e[r]}}}setRow(e,t,r){const n=this.#e(e);if(B(n))throw new Error(n.error);const s=n.value,i=typeof r=="number"?r:this.columnMaxLength;for(let o=0;o<i;o++)s[o]=t;return s}},qt={};v(qt,{adjacentVertices:()=>Ne,areAdjacent:()=>es,bfs:()=>ts,clone:()=>ns,connect:()=>Jt,connectTo:()=>se,connectWithEdges:()=>Qt,createVertex:()=>_t,dfs:()=>Xt,disconnect:()=>Wt,distance:()=>$t,distanceDefault:()=>Zn,dumpGraph:()=>Wn,edges:()=>zt,get:()=>$n,getCycles:()=>Ht,getOrCreate:()=>ne,getOrFail:()=>Hn,graph:()=>ss,graphFromVertices:()=>Ut,hasKey:()=>_n,hasNoOuts:()=>Xn,hasOnlyOuts:()=>Un,hasOut:()=>S,isAcyclic:()=>is,pathDijkstra:()=>rs,toAdjacencyMatrix:()=>zn,topologicalSort:()=>os,transitiveReduction:()=>Zt,updateGraphVertex:()=>U,vertexHasOut:()=>Qn,vertices:()=>Le});const _t=e=>({id:e,out:[]});function _n(e,t){return l(d(e)),e.vertices.has(t)}function $n(e,t){return l(d(e)),l(ur(t,"non-empty","key")),e.vertices.get(t)}function zn(e){l(d(e));const t=[...e.vertices.values()],r=new Gt;r.labelColumns(...t.map(n=>n.id)),r.labelRows(...t.map(n=>n.id));for(let n=0;n<t.length;n++){r.setRow(n,!1,t.length);const s=t[n];for(const[i,o]of t.entries())s.out.some(a=>a.id===o.id)&&r.set(n,i,!0)}return r}const Wn=e=>Jn(e).join(`
`),Jn=e=>{const t=[],r="vertices"in e?e.vertices.values():e;for(const n of r){const s=Yn(n);t.push(...s.map(i=>` ${i}`))}return t},$t=(e,t)=>t.weight!==void 0?t.weight:1;function*zt(e){l(d(e));const t=[...e.vertices.values()];for(const r of t)for(const n of r.out)yield n}function*Le(e){l(d(e));const t=[...e.vertices.values()];for(const r of t)yield r}function d(e,t="graph"){if(e===void 0)return{success:!1,error:`Param '${t}' is undefined. Expected Graph`};if(e===null)return{success:!1,error:`Param '${t}' is null. Expected Graph`};if(typeof e=="object"){if(!("vertices"in e))return{success:!1,error:`Param '${t}.vertices' does not exist. Is it a Graph type?`}}else return{success:!1,error:`Param '${t} is type '${typeof e}'. Expected an object Graph`};return{success:!0,value:e}}function*Ne(e,t){if(l(d(e)),t===void 0)return;const r=typeof t=="string"?e.vertices.get(t):t;if(r===void 0)throw new Error(`Vertex not found ${JSON.stringify(t)}`);for(const n of r.out){const s=e.vertices.get(n.id);if(s===void 0)throw new Error(`Could not find vertex: ${n.id}`);yield s}}const Qn=(e,t)=>{if(e===void 0)return!1;const r=typeof t=="string"?t:t.id;return e.out.some(n=>n.id===r)},Xn=(e,t)=>{l(d(e));const r=typeof t=="string"?e.vertices.get(t):t;return r===void 0?!1:r.out.length===0},Un=(e,t,...r)=>{l(d(e));const n=w(e,t),s=r.map(i=>w(e,i));if(s.length!==n.out.length)return!1;for(const i of s)if(!S(e,n,i))return!1;return!0},S=(e,t,r)=>{l(d(e));const n=w(e,t),s=typeof r=="string"?r:r.id;return n.out.some(i=>i.id===s)},ne=(e,t)=>{l(d(e));const r=e.vertices.get(t);if(r!==void 0)return{graph:e,vertex:r};const n=_t(t);return{graph:U(e,n),vertex:n}},Hn=(e,t)=>{l(d(e));const r=e.vertices.get(t);if(r===void 0)throw new Error(`Vertex '${t}' not found in graph`);return r},U=(e,t)=>(l(d(e)),{...e,vertices:e.vertices.set(t.id,t)}),Zn=(e,t)=>t.weight!==void 0?t.weight:1;function Wt(e,t,r){l(d(e));const n=w(e,t),s=w(e,r);return S(e,n,s)?U(e,{...n,out:n.out.filter(i=>i.id!==s.id)}):e}function se(e,t,r,n){l(d(e));const s=ne(e,t);e=s.graph;const i=ne(e,r);e=i.graph;const o={id:r,weight:n};return S(e,s.vertex,i.vertex)||(e=U(e,{...s.vertex,out:[...s.vertex.out,o]})),{graph:e,edge:o}}function Jt(e,t){if(typeof e!="object")throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${typeof e}`);if(typeof t!="object")throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${typeof t}`);return Qt(e,t).graph}function Qt(e,t){l(d(e));const{to:r,weight:n,from:s}=t,i=t.bidi??!1,o=Array.isArray(r)?r:[r],a=[];for(const u of o){const c=se(e,s,u,n);e=c.graph,a.push(c.edge)}if(!i)return{graph:e,edges:a};for(const u of o){const c=se(e,u,s,n);e=c.graph,a.push(c.edge)}return{graph:e,edges:a}}const Yn=e=>{const t=[e.id],r=n=>n.weight===void 0?n.id:`${n.id} (${n.weight})`;for(const n of e.out)t.push(` -> ${r(n)}`);return e.out.length===0&&(t[0]+=" (terminal)"),t};function es(e,t,r){if(l(d(e)),S(e,t,r.id)||S(e,r,t.id))return!0}function w(e,t){if(l(d(e)),t===void 0)throw new Error("Param 'idOrVertex' is undefined. Expected string or Vertex");const r=typeof t=="string"?e.vertices.get(t):t;if(r===void 0)throw new Error(`Id not found ${t}`);return r}function*ts(e,t,r){l(d(e));const n=w(e,t),s=r===void 0?void 0:w(e,r),i=new E,o=new Set;for(i.enqueue(n);!i.isEmpty;){const a=i.dequeue();if(yield a,s!==void 0&&s===a)return;for(const u of Ne(e,a))o.has(u.id)||(o.add(u.id),i.enqueue(w(e,u.id)))}}function*Xt(e,t){l(d(e));const r=w(e,t),n=new C,s=new Set;for(n.push(r);!n.isEmpty;){const i=n.pop();if(i!==void 0&&!s.has(i.id)){s.add(i.id),yield i;for(const o of i.out){const a=e.vertices.get(o.id);a&&n.push(a)}}}}const rs=(e,t)=>{l(d(e));const r=typeof t=="string"?e.vertices.get(t):t;if(r===void 0)throw new Error("source vertex not found");const n=new Map,s=new Map;n.set(r.id,0);const i=new Ie,o=[...e.vertices.values()];for(const u of o)u.id!==r.id&&(n.set(u.id,Number.MAX_SAFE_INTEGER),s.set(u.id,null)),i.enqueueWithPriority(u.id,Number.MAX_SAFE_INTEGER);for(;!i.isEmpty;){const u=i.dequeueMin();if(u===void 0)throw new Error("Bug. Queue unexpectedly empty");const c=e.vertices.get(u);for(const h of c.out){const g=n.get(u)+$t(e,h);g<n.get(h.id)&&(n.set(h.id,g),s.set(h.id,c),i.changePriority(h.id,g,!0))}}return{distances:n,previous:s,pathTo:u=>{const c=[];for(;u!==r.id;){const h=s.get(u);if(h==null)throw new Error(`Id not present: ${u}`);c.push({id:u,weight:n.get(u)}),u=h.id}return c}}},ns=e=>(l(d(e)),{vertices:p([...e.vertices.entries()])}),ss=(...e)=>{let t={vertices:p()};for(const r of e)t=Jt(t,r);return t};function is(e){return l(d(e)),Ht(e).length===0}function os(e){l(d(e));const t=new Ot(0);for(const i of zt(e))t.add(i.id,1);const r=new E;let n=0;for(const i of Le(e))t.get(i.id)===0&&r.enqueue(i),n++;const s=[];for(;!r.isEmpty;){const i=r.dequeue();s.push(i);for(const o of i.out)t.subtract(o.id,1)===0&&r.enqueue(e.vertices.get(o.id))}if(s.length!==n)throw new Error("Graph contains cycles");return Ut(s)}function Ut(e){const t=Rr(e,n=>[n.id,n]);return{vertices:p([...t])}}function Ht(e){l(d(e));let t=0;const r=new C,n=new Map,s=[];for(const o of e.vertices.values())n.set(o.id,{...o,lowlink:NaN,index:NaN,onStack:!1});const i=o=>{o.index=t,o.lowlink=t,t++,r.push(o),o.onStack=!0;for(const a of o.out){const u=n.get(a.id);Number.isNaN(u.index)?(i(u),o.lowlink=Math.min(o.lowlink,u.lowlink)):u.onStack&&(o.lowlink=Math.min(o.lowlink,u.lowlink))}if(o.lowlink===o.index){const a=[];let u;for(;o!==u;)u=r.pop(),u.onStack=!1,a.push({id:u.id,out:u.out});a.length>1&&s.push(a)}};for(const o of n.values())Number.isNaN(o.index)&&i(o);return s}function Zt(e){l(d(e));for(const t of Le(e))for(const r of Ne(e,t))for(const n of Xt(e,r))if(r.id!==n.id&&S(e,t,n)){const s=Wt(e,t,n);return Zt(s)}return e}var Yt={};v(Yt,{adjacentVertices:()=>ds,connect:()=>sr,connectTo:()=>nr,connectWithEdges:()=>ir,createVertex:()=>er,dumpGraph:()=>ls,edgesForVertex:()=>hs,getConnection:()=>je,getOrCreate:()=>ie,graph:()=>as,hasConnection:()=>rr,toAdjacencyMatrix:()=>us,updateGraphVertex:()=>tr});const er=e=>({id:e}),tr=(e,t)=>({...e,vertices:e.vertices.set(t.id,t)}),ie=(e,t)=>{const r=e.vertices.get(t);if(r!==void 0)return{graph:e,vertex:r};const n=er(t);return{graph:tr(e,n),vertex:n}};function z(e,t){if(t===void 0)throw new Error("Param 'idOrVertex' is undefined. Expected string or Vertex");if(e===void 0)throw new Error("Param 'graph' is undefined. Expected Graph");const r=typeof t=="string"?e.vertices.get(t):t;if(r===void 0)throw new Error(`Id not found ${t}`);return r}const rr=(e,t,r)=>je(e,t,r)!==void 0,je=(e,t,r)=>{if(t===void 0)throw new Error("Param 'a' is undefined. Expected string or Vertex");if(r===void 0)throw new Error("Param 'b' is undefined. Expected string or Vertex");if(e===void 0)throw new Error("Param 'graph' is undefined. Expected Graph");const n=z(e,t),s=z(e,r);for(const i of e.edges)if(i.a==n.id&&i.b===s.id||i.a==s.id&&i.b===n.id)return i};function nr(e,t,r,n){e=ie(e,t).graph,e=ie(e,r).graph;let o=je(e,t,r);return o!==void 0?{graph:e,edge:o}:(o={a:t,b:r,weight:n},{graph:{...e,edges:[...e.edges,o]},edge:o})}function sr(e,t){return ir(e,t).graph}function ir(e,t){const{a:r,weight:n,b:s}=t,i=Array.isArray(s)?s:[s],o=[];for(const a of i){const u=nr(e,r,a,n);e=u.graph,o.push(u.edge)}return{graph:e,edges:o}}const as=(...e)=>{let t={vertices:p(),edges:[]};for(const r of e)t=sr(t,r);return t};function us(e){const t=[...e.vertices.values()],r=new Gt;r.labelColumns(...t.map(n=>n.id)),r.labelRows(...t.map(n=>n.id));for(let n=0;n<t.length;n++){r.setRow(n,!1,t.length);const s=t[n];for(const[i,o]of t.entries())rr(e,s,o)&&r.set(n,i,!0)}return r}const ls=e=>cs(e).join(`
`),cs=e=>{const t=[];t.push(`Vertices: ${[...e.vertices.values()].map(r=>r.id).join(", ")}`),t.push("Edges:");for(const r of e.edges)t.push(fs(r));return t},fs=e=>{const t=e.weight?` (${e.weight})`:"";return`${e.a} <-> ${e.b}${t}`};function*ds(e,t){if(t===void 0)return;if((typeof t=="string"?e.vertices.get(t):t)===void 0)throw new Error(`Vertex not found ${JSON.stringify(t)}`);for(const n of e.edges)n.a===t?yield z(e,n.b):n.b===t&&(yield z(e,n.a))}function*hs(e,t){if(t===void 0)return;if((typeof t=="string"?e.vertices.get(t):t)===void 0)throw new Error(`Vertex not found ${JSON.stringify(t)}`);for(const n of e.edges)n.a===t?yield n:n.b===t&&(yield n)}var ys={};v(ys,{Directed:()=>qt,Undirected:()=>Yt});export{Sn as s,bn as t};
