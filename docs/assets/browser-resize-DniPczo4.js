import{a as W,i as G,b as K}from"./guard-RzpFIjKH.js";import{c as w}from"./clamp-ClLuI7HB.js";import{r as E,a as q}from"./resolve-el-BUhvOf7L.js";import{P as z,s as O}from"./subtract-BmiCoi7k.js";import{g as X,a as H,i as U,b as J}from"./guard-BPeP3-pA.js";import{P as j}from"./placeholder-DHFnYwCJ.js";import{E as Z,t as Q}from"./timeout-BR7pLkQL.js";import{i as L}from"./error-message-BtgnhF27.js";import{a as tt,o as et,r as A,b as st,m as it,c as _,e as nt,t as ot,i as rt,f as at}from"./dom-source-CE_2PbT_.js";import{s as N,a as ht}from"./scale-KzsViUdl.js";import{r as ct,a as lt}from"./result-aflA1LW7.js";import{t as ut,s as dt,a as C}from"./conversion-CGf7QoDW.js";import{n as k}from"./numbers-SvRH5ijj.js";import{E as $,a as ft}from"./element-sizing-Bsx-rrC3.js";import{r as gt}from"./round-CDFh2_Rm.js";import{s as xt}from"./maps-CLnHBw0l.js";import{i as yt}from"./interval-type-CIaujdcR.js";const mt=(a,t)=>(X(a),t===void 0&&W(a)?t=a:t===void 0&&(t={x:0,y:0}),H(a,t),Object.freeze({x:t.x+a.width/2,y:t.y+a.height/2}));function wt(a,t,e){const s=typeof t=="number"?t:t.width,i=typeof t=="number"?e:t.height;if(i===void 0)throw new Error("Expected height as third parameter");return{...a,width:a.width-s,height:a.height-i}}function Jt(a,t=0,e=1){return G(a)?Object.freeze({x:w(a.x,t,e),y:w(a.y,t,e),z:w(a.z,t,e)}):Object.freeze({x:w(a.x,t,e),y:w(a.y,t,e)})}const pt=(a,t,e=L)=>{for(const s of a.entries()){const i=s[1];for(const n of i)if(e(n,t))return s}};class vt{map;groupBy;valueEq;constructor(t=tt,e=L,s=[]){this.groupBy=t,this.valueEq=e,this.map=new Map(s)}has(t){return this.map.has(t)}hasKeyValue(t,e){const s=this.map.get(t);if(!s)return!1;for(const i of s)if(this.valueEq(i,e))return!0;return!1}debugString(){let t="";return[...this.map.keys()].every(s=>{const i=this.map.get(s);i!==void 0&&(t+=s+` (${i.length}) = ${JSON.stringify(i)}\r
`)}),t}count(t){const e=this.map.get(t);return e?e.length:0}firstKeyByValue(t,e=L){const s=pt(this,t,e);if(s)return s[0]}*entriesFlat(){for(const t of this.map.keys())for(const e of this.map.get(t))yield[t,e]}*entries(){for(const[t,e]of this.map.entries())yield[t,[...e]]}*get(t){const e=this.map.get(t);e&&(yield*e.values())}*keys(){yield*this.map.keys()}*valuesFlat(){for(const t of this.map)yield*t[1]}*values(){for(const t of this.map)yield t[1]}*keysAndCounts(){for(const t of this.map)yield[t[0],t[1].length]}get lengthKeys(){return this.map.size}get isEmpty(){return this.map.size===0}}class bt extends vt{addKeyedValues(t,...e){const s=this.map.get(t);s===void 0?this.map.set(t,e):this.map.set(t,[...s,...e])}setValues(t,e){this.map.set(t,e)}addValue(...t){for(const e of t){const s=this.groupBy(e);this.addKeyedValues(s,e)}}deleteKeyValue(t,e){const s=this.map.get(t);if(s===void 0)return!1;const i=s.filter(n=>!this.valueEq(n,e));return this.map.set(t,i),i.length<s.length}deleteByValue(t){let e=!1;const s=[...this.map.entries()];for(const i of s)for(const n of i[1])this.valueEq(n,t)&&(e=!0,this.deleteKeyValue(i[0],t));return e}delete(t){const e=this.map.get(t);return!e||e.length===0?!1:(this.map.delete(t),!0)}clear(){this.map.clear()}}const Zt=(a,t,e={})=>{const s=E(a);let i=z,n;const o=e.autoTranslate??!1,r=e.quickDrag??!1,d=e.fence?E(e.fence):void 0,h=e.fenceViewport;let f=j;const b=window.getComputedStyle(s).position==="relative",R=()=>{s.classList.contains("drag-sel")&&s.classList.remove("drag-sel")},P=g=>{s.classList.contains("drag-sel")?s.classList.remove("drag-sel"):s.classList.add("drag-sel"),g.stopPropagation()};s.ownerDocument.addEventListener("click",R),s.addEventListener("click",P);const c=()=>{s.classList.remove("drag-progress"),s.ownerDocument.removeEventListener("pointermove",T),s.ownerDocument.removeEventListener("pointerup",M),s.ownerDocument.removeEventListener("pointercancel",I)},l=()=>{s.classList.contains("drag-progress")?I(void 0,"dispose"):c(),s.ownerDocument.removeEventListener("click",R),s.removeEventListener("click",P)},u=(g,x,y)=>(U(f)||(g={x:w(g.x,f.x,f.width),y:w(g.y,f.y,f.height)},h&&(x=w(x,h.x,h.x+h.width),y=w(y,h.y,h.y+h.height))),[g,{x,y}]);let v=Z;const T=g=>{g.preventDefault(),g.stopPropagation();const{x,y}=g;let m=K(i)?{x:g.offsetX,y:g.offsetY}:{x:x-i.x,y:y-i.y};const p=u(m,x,y);m=p[0];const V={delta:m,initial:i,token:n,viewport:p[1]};if(typeof t.progress<"u"){const S=t.progress(V);if(S.abort){I(void 0,"discontinued");return}S.viewport&&(m={x:S.viewport.x-i.x,y:S.viewport.y-i.y})}if(v=m,o){const S=m.x,Y=m.y;s.style.translate=`${S}px ${Y}px`}},M=g=>{const x=s.getBoundingClientRect();c();const{x:y,y:m}=g,p=u(v,y,m),V={initial:i,token:n,delta:p[0],viewport:p[1]};if(o)if(s.style.translate="none",b){const S=s.parentElement?.getBoundingClientRect();s.style.left=`${x.x-S.left}px`,s.style.top=`${x.y-S.top}px`}else s.style.left=`${x.x}px`,s.style.top=`${x.y}px`;typeof t.success<"u"&&t.success(V)},I=(g,x="pointercancel")=>{c();let y=z;g&&"x"in g&&"y"in g&&(y={x:g.x,y:g.y});const m={token:n,initial:i,delta:{x:-1,y:-1},viewport:y};typeof t.abort<"u"&&t.abort(x,m)};return s.addEventListener("pointerdown",g=>{if(!s.classList.contains("drag-sel")&&!r)return;const y=g;i={x:y.x,y:y.y};const m=typeof t.start>"u"?{allow:!0,token:n}:t.start();if(m.allow){if(n=m.token,d){const p=d.getBoundingClientRect();f={x:p.x-i.x,y:p.y-i.y,width:p.x+p.width-i.x,height:p.y+p.height-i.y}}else h&&(f={x:h.x-i.x,y:h.y-i.y,width:h.width+h.x-i.x,height:h.height+h.y-i.y});s.classList.add("drag-progress"),s.ownerDocument.addEventListener("pointermove",T),s.ownerDocument.addEventListener("pointerup",M),s.ownerDocument.addEventListener("pointercancel",I)}}),l},St=(a,t=.5,e=.75,s=1)=>{ct(k(a,"positive","index"),k(t,"percentage","saturation"),k(e,"percentage","lightness"),k(s,"percentage","alpha"));const n=a*137.508%360/360;return ut(dt(n,t,e,s))},B=a=>{const t=a.map(h=>h.x),e=a.map(h=>h.y),s=Math.min(...t),i=Math.max(...t),n=Math.min(...e),o=Math.max(...e),r=i-s,d=o-n;return{min:{x:s,y:n},max:{x:i,y:o},width:r,height:d,minDim:Math.min(r,d),maxDim:Math.max(r,d)}},Tt=a=>{if(!Number.isFinite(a.height))return s=>s;const t=N(a.min.x,a.max.x),e=N(a.min.y,a.max.y);return s=>({x:t(s.x),y:e(s.y)})},Rt=a=>{const t=N(0,1,a.min.x,a.max.x),e=N(0,1,a.min.y,a.max.y);return s=>({x:t(s.x),y:e(s.y)})},Pt=(a,t,e)=>{const s=[];let i=0;for(let o=a.min.x;o<a.max.x;o+=t){const r=i%e===0;s.push({x:o,y:0,major:r}),i++}i=0;const n=[];for(let o=a.min.y;o<a.max.y;o+=t){const r=i%e===0;n.push({x:0,y:o,major:r}),i++}return{x:s,y:n}};class Et{#e;#t;lastChange;constructor(){this.lastChange=performance.now(),this.#e=new bt,this.#t=new Map}get metaCount(){return this.#t.size}clear(){this.#e.clear(),this.lastChange=performance.now()}set(t,e){this.#e.setValues(t,e)}deleteBySeries(t){const e=this.#e.delete(t);return e&&(this.lastChange=performance.now()),e}setMeta(t,e){this.#t.set(t,e)}hasMeta(t){return this.#t.has(t)}getMeta(t){return this.#t.get(t)}*getValues(){yield*this.#e.valuesFlat()}*getEntries(){yield*this.#e.entries()}*getSeries(){yield*this.#e.values()}add(t,e="default"){this.#e.addKeyedValues(e,t),this.lastChange=performance.now()}}const It=Math.PI*2;class Ct{#e;#t;#s;#n;#o;#i;#r=[];constructor(t,e="min"){this.#e=E(t),this.#s=e,this.#i=window.devicePixelRatio||1,this.#n=this.#c(),this.#o=this.setLogicalSize({width:this.#e.width,height:this.#e.height})}setLogicalSize(t){this.#o=t;const e=this.#e;return e.width=t.width*this.#i,e.height=t.height*this.#i,e.style.width=`${t.width.toString()}px`,e.style.height=`${t.height.toString()}px`,this.#n=this.#c(),this.invalidateContext(),t}#c(){let t=1;switch(this.#s){case"min":t=Math.min(this.#e.width,this.#e.height);break;case"max":t=Math.max(this.#e.width,this.#e.height);break}const e=ht(0,t,0,1);return{abs:e.in,rel:e.out}}invalidateContext(){this.#t=void 0}#a(t){if(!t)throw new Error("Param 'region' is undefined/null");if(this.#r.includes(t))throw new Error("Region already exists");return this.#r.push(t),t}toAbsPoint(t,e="independent"){let{x:s,y:i}=t;switch(e){case"independent":s*=this.width,i*=this.height}return{x:s,y:i}}get offset(){const t=this.#e.getBoundingClientRect();return{x:t.left,y:t.top}}toRelPoint(t,e,s="independent",i=!0){let{x:n,y:o}=t;if(e==="screen"){const r=this.#e.getBoundingClientRect();n-=r.x,o-=r.y}switch(s){case"independent":n/=this.width,o/=this.height;break}return i&&(n=w(n),o=w(o)),{x:n,y:o}}toAbsRect(t,e="independent"){let{width:s,height:i}=t;switch(e){case"independent":if(s*=this.width,i*=this.height,J(t))return{...this.toAbsPoint(t),width:s,height:i}}return{width:s,height:i}}createRegion(t){const e=t.marginPx??0,s=e*2;if("absPositioned"in t){const i=wt(t.absPositioned,e,e);return this.#a(new D(this,()=>i))}if("relativePositioned"in t){let i;const n=t.relativePositioned;switch(t.scale){case"independent":i=o=>({x:n.x*o.width+e,y:n.y*o.height+e,width:n.width*o.width-s,height:n.height*o.height-s});break;default:throw new Error(`Param 'kind' unknown (${t.scale})`)}return this.#a(new D(this,i))}if("relativeSize"in t){let i;const n=t.relativeSize,o=t.position;switch(t.scale){case"independent":i=r=>{const d=n.width*r.width-s,h=n.height*r.height-s;let f=r.width/2-d/2,b=r.height/2-h/2;switch(o){case"n":b=0;break;case"s":b=r.height-h;break}return f+=e,b+=e,{width:d,height:h,x:f,y:b}};break;default:throw new Error(`Param 'kind' unknown (${t.scale})`)}return this.#a(new D(this,i))}if("match"in t){const i=q(t.match);if(!i.success)throw new Error(`Could not resolve match element. ${lt(i)}`);const n=o=>{const r=i.value.getBoundingClientRect();return{x:r.x+e,y:r.y+e,width:r.width-s,height:r.height-s}};return this.#a(new D(this,n))}throw new Error("Spec doesn't seem valid")}clear(){this.context.clearRect(0,0,this.width,this.height)}get context(){if(this.#t)return this.#t;const t=this.#e.getContext("2d");if(!t)throw new Error("Could not create 2d context");t.setTransform(1,0,0,1,0,0),t.scale(this.#i,this.#i),this.#t=t;for(const e of this.#r)e.recomputeRegion();return this.#t}get sizeScaler(){return this.#n}get width(){return this.#o.width}get height(){return this.#o.height}}class D{source;#e;#t;constructor(t,e){this.source=t,this.#e=e,this.#t=e(t)}recomputeRegion(){this.#t=this.#e(this.source)}toAbsRegion(t,e="both"){switch(e){case"both":return{x:t.x*this.#t.width,y:t.y*this.#t.height}}}applyRegionOffset(t){return{x:t.x+this.#t.x,y:t.y+this.#t.y}}drawConnectedPointsRelative(t,e,s=1){const i=t.map(n=>this.toAbsRegion(n));this.drawConnectedPoints(i,e,s)}drawConnectedPoints(t,e,s=1){const i=this.context;i.save(),i.translate(this.#t.x,this.#t.y),i.beginPath(),i.strokeStyle=e,i.lineWidth=s;for(let n=0;n<t.length;n++)n===0?i.moveTo(t[n].x,t[n].y):i.lineTo(t[n].x,t[n].y);i.stroke(),i.restore()}fillTextRelative(t,e,s="black",i,n="alphabetic",o="start"){const r=this.toAbsRegion(e);this.fillTextRelative(t,r,s,i,n,o)}fillText(t,e,s="black",i,n="alphabetic",o="start"){const r=this.context;r.save(),r.translate(this.#t.x,this.#t.y),i.length>0&&(r.font=i),r.textBaseline=n,r.textAlign=o,r.fillStyle=s,r.fillText(t,e.x,e.y),r.restore()}drawCircles(t,e,s="",i=1){const n=t.map(r=>({...this.toAbsRegion(r),radius:this.source.sizeScaler.abs(r.radius)})),o=this.context;o.save(),o.translate(this.#t.x,this.#t.y),o.fillStyle=e,o.strokeStyle=s,o.lineWidth=i;for(const r of n)o.beginPath(),o.arc(r.x,r.y,r.radius,0,It),o.closePath(),e.length>0&&o.fill(),s.length>0&&o.stroke();o.restore()}clear(){this.context.clearRect(this.#t.x,this.#t.y,this.#t.width,this.#t.height)}fill(t="white"){const e=this.context;e.fillStyle=t,e.fillRect(this.#t.x,this.#t.y,this.#t.width,this.#t.height)}drawBounds(t,e=1){this.drawConnectedPointsRelative([{x:0,y:0},{x:1,y:0},{x:1,y:1},{x:0,y:1},{x:0,y:0}],t,e),this.drawConnectedPointsRelative([{x:0,y:1},{x:1,y:0}],t,e),this.drawConnectedPointsRelative([{x:0,y:0},{x:1,y:1}],t,e)}toRelPoint(t,e="screen",s="independent",i=!0){t=this.source.toRelPoint(t,e,"skip",!1);let{x:n,y:o}=t;switch(n-=this.x,o-=this.y,s){case"independent":n/=this.width,o/=this.height}return i&&(n=w(n),o=w(o)),{x:n,y:o}}absToRegionPoint(t,e,s){e==="screen"&&(t=O(t,this.source.offset));let{x:i,y:n}=t;return i-=this.x,n-=this.y,s&&(i<0&&(i=0),n<0&&(n=0),i>this.width+this.x&&(i=this.x+this.width),n>this.height+this.y&&(n=this.y+this.height)),{x:i,y:n}}get center(){return mt(this.#t)}get context(){return this.source.context}set region(t){this.#t=t}get region(){return this.#t}get width(){return this.#t.width}get height(){return this.#t.height}get x(){return this.#t.x}get y(){return this.#t.y}get dimensionMin(){return Math.min(this.#t.width,this.#t.height)}}const Qt=(a,t={})=>{const e=a.parent===void 0?document.body:E(a.parent),s=document.createElement("canvas");e.prepend(s);const i=new Et,n=new Ct(s,"min"),o=a.region??{relativePositioned:{x:0,y:0,width:1,height:1}},r=n.createRegion(o),d=new kt(r,i,t);return a.canvasResizeTo==="viewport"?$.canvasViewport(s,{onSizeChanging:(h,f)=>{n.setLogicalSize(h),d.invalidateRange(),d.draw()}}):$.canvasParent(s,{onSizeChanging:(h,f)=>{n.setLogicalSize(h),d.invalidateRange(),d.draw()}}),d};class kt{#e;#t;#s;actualDataRange=ft;visibleRange=j;show;whiskerLength;axisRounder=gt(1,!0);onInvalidated;overlayLines=[];#n;#o;#i;#r;#c;#a;#f;#h;#d;#g;constructor(t,e,s={}){if(!e)throw new TypeError("Param 'data' is undefined");if(typeof e!="object")throw new TypeError(`Param 'data' is not an object. Got: ${typeof e}`);this.onInvalidated=s.onInvalidated,this.#e=e,this.#s=t,this.#t=0,this.#g=s.clear??"region",this.#o=s.range??"auto",this.#c=s.valueStyle??"dot",this.#a=s.connectStyle??"",this.whiskerLength=s.whiskerLength??5,this.#d=s.visualPadding??20,this.show={axes:!0,axisValues:!0,grid:!0,whiskers:!0,...s.show},this.#r={colour:"black",width:2,...s.axisStyle},this.#h={colour:"black",size:"1em",font:"system-ui",...s.textStyle},this.#n={increments:.1,major:5,colour:"whitesmoke",width:1,...s.grid}}getCurrentRange(){if(this.#e.lastChange===this.#t&&this.#i)return this.#i;this.#t=this.#e.lastChange;const t=this.#m();return this.#i=t,this.onInvalidated&&this.onInvalidated(),t}invalidateRange(){this.#i=void 0}#m(){const t=this.getDataRange(),e=Tt(t),s=Rt(t),i=this.#s,n=this.#d;let o=i.x+n,r=i.y+n;const d=i.height-n*2,h=i.width-n*2,f=Math.min(d,h);return h>=d?o+=h/2-f/2:r+=d/2-f/2,{absDataToRelative:e,relDataToCanvas:c=>{let{x:l,y:u}=c;return l===Number.NEGATIVE_INFINITY?l=0:l===Number.POSITIVE_INFINITY&&(l=1),u===Number.NEGATIVE_INFINITY?u=0:u===Number.POSITIVE_INFINITY&&(u=1),l=l*f,u=(1-u)*f,l+=o,u+=r,{x:l,y:u}},canvasToRelData:c=>{let{x:l,y:u}=c;return l-=o,u-=r,l=l/f,u=1-u/f,{x:l,y:u}},regionSpaceToRelative:c=>{let{x:l,y:u}=c;return l=l-i.x+this.#d,u=f+this.#d-u,l/=f,u=u/f,{x:l,y:u}},relDataToAbs:s,range:t}}positionElementAt(t,e,s="middle",i){const n=E(e);let{x:o,y:r}=this.valueToScreenSpace(t);if(s==="middle"){const d=n.getBoundingClientRect();o-=d.width/2,r-=d.height/2}else if(s!=="top-left")throw new Error("Param 'by' expected to be 'middle' or 'top-left'.");if(i){const h=E(i).getBoundingClientRect();o-=h.x,r-=h.y}n.style.left=`${o}px`,n.style.top=`${r}px`}getDataRange(){return this.#o==="auto"?B([...this.#e.getValues()]):(this.#f||(this.#f=B([this.#o.max,this.#o.min])),this.#f)}valueToScreenSpace(t){const e=this.valueToRegionSpace(t),s=this.canvasSource.offset;return{x:e.x+s.x,y:e.y+s.y}}valueToRegionSpace(t,e=!1){const s=this.getCurrentRange(),i=s.absDataToRelative(t),n=s.relDataToCanvas(i);return e&&console.log(`orig: ${t.x}x${t.y} rel: ${i.x}x${i.y} region: ${n.x}x${n.y}`),{...t,x:n.x,y:n.y}}pointToValue(t,e){const s=this.getCurrentRange(),i=O(t,this.canvasSource.offset),n=s.canvasToRelData(i);return s.relDataToAbs(n)}#l(t,e,s=!1){return t=this.valueToRegionSpace(t,s),e=this.valueToRegionSpace(e,s),{a:t,b:e}}getDefaultMeta(){return{colour:St(this.#e.metaCount),lineWidth:2,dotRadius:5}}draw(){this.#g==="region"?this.#s.clear():this.canvasSource.clear(),this.#b(),this.show.axes&&this.#w();for(const[t,e]of this.#e.getEntries()){let s=this.#e.getMeta(t);s||(s=this.getDefaultMeta(),this.#e.setMeta(t,s)),this.#S(t,e,s)}for(const t of this.overlayLines)this.drawLine(t,t.colour,t.width)}drawLine(t,e,s){const i=this.#l(t.a,t.b);this.#u(i,e,s)}setMeta(t,e){this.#e.setMeta(t,{...this.getDefaultMeta(),...e})}#w(){const{colour:t,width:e}=this.#r,s=this.#l({x:0,y:Number.NEGATIVE_INFINITY},{x:0,y:Number.POSITIVE_INFINITY},!1),i=this.#l({x:Number.NEGATIVE_INFINITY,y:0},{x:Number.POSITIVE_INFINITY,y:0},!1);this.#u(i,t,e,!1),this.#u(s,t,e,!1)}#p(t){const e=this.#s.context;e.font=this.#h.size+" "+this.#h.font,e.fillStyle=this.#h.colour,e.textBaseline="middle";for(const s of t){if(s.x===0&&s.y===0)continue;const i=this.valueToRegionSpace(s,!1),o=this.axisRounder(s.y).toString(),r=e.measureText(o),d=i.x-r.width-this.whiskerLength/2-5,h=i.y;e.fillText(o,d,h)}}#v(t){const e=this.#s.context;e.font=this.#h.size+" "+this.#h.font,e.fillStyle=this.#h.colour,e.textBaseline="top";for(const s of t){const i=this.valueToRegionSpace(s,!1),o=this.axisRounder(s.x).toString(),r=e.measureText(o),d=i.x-r.width/2,h=i.y+r.actualBoundingBoxAscent+r.actualBoundingBoxDescent+this.whiskerLength/2;e.fillText(o,d,h)}}#x(t,e){const s=this.whiskerLength/2,i=e?{x:t.x,y:0}:{y:t.y,x:0},n=this.valueToRegionSpace(i,!1),o=e?{a:{x:n.x,y:n.y-s},b:{x:n.x,y:n.y+s}}:{a:{y:n.y,x:n.x-s},b:{y:n.y,x:n.x+s}};this.#u(o,this.#r.colour,this.#r.width,!1)}#y(t,e){const s=e?this.#l({x:t.x,y:Number.NEGATIVE_INFINITY},{x:t.x,y:Number.POSITIVE_INFINITY}):this.#l({y:t.y,x:Number.NEGATIVE_INFINITY},{y:t.y,x:Number.POSITIVE_INFINITY},!1);this.#u(s,this.#n.colour,t.major?this.#n.width*2:this.#n.width)}#b(){const t=this.#n,e=this.show.grid,s=this.show.whiskers,i=this.show.axisValues,n=this.getCurrentRange().range,{increments:o,major:r}=t,d=Pt(n,o,r);for(const h of d.x)e&&this.#y(h,!0),s&&h.major&&this.#x(h,!0);for(const h of d.y)e&&this.#y(h,!1),s&&h.major&&this.#x(h,!1);i&&(this.#v(d.x.filter(h=>h.major)),this.#p(d.y.filter(h=>h.major)))}#S(t,e,s){if(this.#a==="line"&&this.#T(e,s.colour,s.lineWidth),this.#c==="dot")for(const i of e)this.#R(i,s.colour,s.dotRadius)}#T(t,e,s){const i=this.#s.context;i.beginPath();for(const[n,o]of t.entries()){const r=this.valueToRegionSpace(o,!1);n===0&&i.moveTo(r.x,r.y),i.lineTo(r.x,r.y)}i.strokeStyle=C(e),i.lineWidth=s,i.stroke(),i.closePath()}#R(t,e,s){const i=C(t.fillStyle??e),n=this.valueToRegionSpace(t),o=t.radius??s;this.#s.drawCircles([{...n,radius:o}],i)}#u(t,e,s,i=!1){i&&console.log(t);const n=this.#s.context;e=C(e),n.beginPath(),n.moveTo(t.a.x,t.a.y),n.lineTo(t.b.x,t.b.y),n.strokeStyle=C(e),n.lineWidth=s,n.stroke(),n.closePath()}get dataSet(){return this.#e}get canvasRegion(){return this.#s}get canvasSource(){return this.#s.source}}function te(a,t={}){const e=t.disposeSources??!0,s=et(void 0),i=t.onSourceDone??"break",n=t.emitInitial??!0;let o=!1;const r=new Map;for(const[c,l]of Object.entries(a)){const u="last"in l?l.last():void 0,v={source:A(l),done:!1,data:u,off:()=>{}};r.set(c,v)}const d=Object.fromEntries(Object.entries(r).map(c=>[c[0],c[1].source])),h=()=>xt(r,c=>!c.done),f=()=>{for(const c of r.values())c.off()},b=()=>{const c={};for(const[l,u]of r)u.data!==void 0&&(c[l]=u.data);return c},R=()=>{o=!0;const c=b();s.set(c)},P=c=>{c.off=c.source.on(l=>{if(it(l)){if(c.done=!0,c.off(),c.off=()=>{},i==="break"){f(),s.dispose("Source has completed and 'break' is behaviour");return}h()||(f(),s.dispose("All sources completed"))}else _(l)&&(c.data=l.value,R())})};for(const c of r.values())P(c);return!o&&n&&R(),{...s,hasSource(c){return r.has(c)},replaceSource(c,l){const u=r.get(c);if(u===void 0)throw new Error(`Field does not exist: '${c}'`);u.off();const v=A(l);u.source=v,P(u)},setWith(c){const l={};for(const[u,v]of Object.entries(c)){const T=r.get(u);T!==void 0&&(st(T.source)&&(T.source.set(v),l[u]=v),T.data=v)}return l},sources:d,last(){return b()},dispose(c){if(f(),s.dispose(c),e)for(const l of r.values())l.source.dispose("Part of disposed mergeToObject")}}}function Dt(a,t={}){const e=yt(t.elapsed,50);let s;const i=Q(()=>{const o=s;o&&(n.set(o),s=void 0)},e),n=nt(a,{...t,onValue(o){s=o,i.start()}});return ot(n)}function F(a){return t=>Dt(t,a)}function Nt(a){const t=Vt(a);return{dispose:t.dispose,isDisposed:t.isDisposed,on:t.on,onValue:t.onValue}}function Vt(a){let t=()=>{};const e=Lt({onFirstSubscribe(){t=a(e)},onNoSubscribers(){t&&t()}});return{...e,onValue:s=>e.on(i=>{_(i)&&s(i.value)})}}function Lt(a={}){const t=rt(a);return{dispose:t.dispose,isDisposed:t.isDisposed,set(e){t.set(e)},on:t.on,onValue:t.onValue}}const ee=(a,t)=>{if(a===null)throw new Error("Param 'elem' is null. Expected element to observe");if(a===void 0)throw new Error("Param 'elem' is undefined. Expected element to observe");const e=Nt(s=>{const i=new ResizeObserver(n=>{s.set(n)});return i.observe(a),()=>{i.unobserve(a)}});return F({elapsed:100})(e)},se=a=>F({elapsed:a})(at(window,"resize",{innerWidth:0,innerHeight:0}));export{Jt as a,ee as b,te as c,Zt as d,Qt as i,se as w};
