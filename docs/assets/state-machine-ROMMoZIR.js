import{i as b}from"./interval-type-CIaujdcR.js";import{r as j}from"./result-aflA1LW7.js";import{i as $}from"./numbers-SvRH5ijj.js";const C=e=>typeof e=="string"?e:JSON.stringify(e),P=(e,n=C)=>{const t=new Set,r=[],s=e.flat(10);for(const o of s){const i=n(o);t.has(i)||(t.add(i),r.push(o))}return r},W=(e,n,t={})=>{let r=b(n,0);j($(r,"positive","interval"));const s=t.fireBeforeWait??!1,o=t.onStartCalled,i=t.signal;let h=!1,f="idle",l=0,m=0,u=performance.now(),v=n??0,c=!1,d;const x=()=>{d!==void 0&&(globalThis.clearTimeout(d),d=void 0,l=0,u=Number.NaN)},y=a=>{r===0?typeof requestAnimationFrame>"u"?d=globalThis.setTimeout(a,0):(d=void 0,requestAnimationFrame(a)):d=globalThis.setTimeout(a,r)},p=()=>{c||(c=!0,f!=="idle"&&(f="idle",x()))},g=async()=>{if(i?.aborted&&(f="idle"),f==="idle")return;f="running",l++,m++;const a=e(l,performance.now()-u),w=typeof a=="object"?await a:a;if(!c){if(f="scheduled",w!==void 0&&!w){p();return}c||y(g)}},E=()=>{if(h)throw new Error("Disposed");if(c=!1,o!==void 0)switch(o(l,performance.now()-u)){case"cancel":{p();return}case"reset":{T();return}case"dispose":{h=!0,p();return}}f==="idle"&&(l=0,u=performance.now(),f="scheduled",s?g():y(g))},T=()=>{if(h)throw new Error("Disposed");c=!1,l=0,u=Number.NaN,f!=="idle"&&p(),E()};return{start:E,reset:T,cancel:p,get interval(){return v},get runState(){return f},get startCountTotal(){return m},get startCount(){return l},set interval(a){const w=b(a,0);j($(w,"positive","interval")),r=w,v=a},get isDisposed(){return h},get elapsedMs(){return performance.now()-u}}},q=()=>{const e=performance.now();return()=>performance.now()-e},V=()=>{let e=performance.now();return()=>{const n=performance.now(),t=n-e;return e=n,t}},B=()=>()=>Number.POSITIVE_INFINITY,G=e=>Object.freeze({value:e.value,visited:[...e.visited],machine:e.machine}),R=(e,n)=>{const[t,r]=A(e);if(!t)throw new Error(r);const s=n??Object.keys(t.states)[0];if(typeof t.states[s]>"u")throw new TypeError(`Initial state ('${s}') not found`);const o=O(t.states);if(o===void 0)throw new Error("Could not normalise transitions");return Object.freeze({value:s,visited:[],machine:Object.freeze(Object.fromEntries(o))})},A=e=>typeof e>"u"?[void 0,"Parameter undefined"]:e===null?[void 0,"Parameter null"]:"states"in e?[e,""]:typeof e=="object"?[{states:e},""]:[void 0,`Unexpected type: ${typeof e}. Expected object`],F=e=>S(e).length===0,D=e=>{N(e);const n=e.machine[e.value];return n.length===1&&n[0].state===null?[]:n},S=e=>D(e).map(t=>t.state),M=e=>{const n=t=>{if(t===null)return{state:null};if(typeof t=="string")return{state:t};if(typeof t=="object"&&"state"in t){const r=t.state;if(typeof r!="string")throw new TypeError(`Target 'state' field is not a string. Got: ${typeof r}`);return"preconditions"in t?{state:r,preconditions:t.preconditions}:{state:r}}else throw new Error(`Unexpected type: ${typeof t}. Expected string or object with 'state' field.`)};if(Array.isArray(e)){let t=!1;const r=e.map(s=>{const o=n(s);if(!o)throw new Error("Invalid target");return t=t||o.state===null,o});if(t&&r.length>1)throw new Error("Cannot have null as an possible state");return r}else{const t=n(e);return t?[t]:void 0}},O=e=>{const n=new Map;for(const[t,r]of Object.entries(e)){if(typeof t>"u")throw new TypeError("Top-level undefined state");if(typeof r>"u")throw new TypeError(`Undefined target state for ${t}`);if(n.has(t))throw new Error(`State defined twice: ${t}`);if(t.includes(" "))throw new Error("State names cannot contain spaces");n.set(t,[])}for(const[t,r]of Object.entries(e)){const s=M(r);if(s===void 0)throw new Error("Could not normalise target");if(s!==null){const o=new Set;for(const i of s){if(o.has(i.state))throw new Error(`Target state '${i.state}' already exists for '${t}'`);if(o.add(i.state),i.state!==null&&!n.has(i.state))throw new Error(`Target state '${i.state}' is not defined as a top-level state. Defined under: '${t}'`)}n.set(t,s)}}return n},N=e=>{if(typeof e>"u")throw new TypeError("Param 'state' is undefined");if(typeof e.value!="string")throw new TypeError("Existing state is not a string")},J=(e,n)=>(N(e),I(e,n),Object.freeze({value:n,machine:e.machine,visited:P([e.visited,[e.value]])})),Y=(e,n)=>{try{return I(e,n),!0}catch{return!1}},I=(e,n)=>{if(n===null)throw new Error("Cannot transition to null state");if(typeof n>"u")throw new Error("Cannot transition to undefined state");if(typeof n!="string")throw new TypeError(`Parameter 'toState' should be a string. Got: ${typeof n}`);const t=S(e);if(t.length===0)throw new Error("Machine is in terminal state");if(!t.includes(n))throw new Error(`Target state '${n}' not available at current state '${e.value}'. Possible states: ${t.join(", ")}`)};export{q as a,B as b,W as c,G as d,V as e,F as f,Y as g,R as i,S as p,J as t,I as v};
