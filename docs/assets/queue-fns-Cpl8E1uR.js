const h=(n,t,e)=>{const i=t.length+e.length,r=n.capacity??i,c=i-r,a=n.discardPolicy??"additions";switch(a){case"additions":return t.length===0?e.slice(0,e.length-c):t.length===n.capacity?t:[...t,...e.slice(0,c-1)];case"newer":{if(c>=t.length)return t.length===0?[...e.slice(0,r-1),e.at(-1)]:e.slice(Math.max(0,e.length-r),Math.min(e.length,r)+1);{const l=Math.max(1,e.length-t.length),s=e.slice(e.length-l,e.length);return[...t.slice(0,Math.min(t.length,r-1)),...s]}}case"older":return[...t,...e].slice(c);default:throw new Error(`Unknown overflow policy ${a}`)}},p=(n,t,...e)=>{if(n===void 0)throw new Error("opts parameter undefined");const i=t.length+e.length,r=n.capacity&&i>n.capacity,c=r?h(n,t,e):[...t,...e];if(n.capacity&&c.length!==n.capacity&&r)throw new Error(`Bug! Expected return to be at capacity. Return len: ${c.length} capacity: ${n.capacity} opts: ${JSON.stringify(n)}`);if(!n.capacity&&c.length!==i)throw new Error(`Bug! Return length not expected. Return len: ${c.length} expected: ${i} opts: ${JSON.stringify(n)}`);return c},y=(n,t)=>{if(t.length===0)throw new Error("Queue is empty");return t.slice(1)},f=(n,t)=>t[0],w=(n,t)=>t.length===0,m=(n,t)=>n.capacity?t.length>=n.capacity:!1;export{m as a,y as d,p as e,w as i,f as p};
