import{r as C}from"./resolve-el-BUhvOf7L.js";import{p as W,b as I,i as M,c as $,a as R}from"./StackFns-BOj2Sa9A.js";import{g as T}from"./guard-RzpFIjKH.js";import{r as L}from"./result-aflA1LW7.js";import{a as P,i as z}from"./guard-DHhxSbUy.js";import{a as O}from"./guard-BPeP3-pA.js";import{b as q,w as F,e as H,g as N,a as J}from"./conversion-CGf7QoDW.js";import{c as U}from"./clamp-ClLuI7HB.js";import{i as _}from"./guard-DRLb5kU_.js";import{a as j}from"./arrays-Dsf3vC8Q.js";const G=(e,n)=>{const i=O(e,n);return[{x:i.x,y:i.y},{x:i.x+i.width,y:i.y},{x:i.x+i.width,y:i.y+i.height},{x:i.x,y:i.y+i.height}]};class g{opts;data;constructor(n={},i=[]){this.opts=n,this.data=i}push(...n){return new g(this.opts,W(this.opts,this.data,...n))}pop(){return new g(this.opts,I(this.opts,this.data))}forEach(n){this.data.forEach(n)}forEachFromTop(n){[...this.data].reverse().forEach(n)}get isEmpty(){return M(this.opts,this.data)}get isFull(){return $(this.opts,this.data)}get peek(){return R(this.opts,this.data)}get length(){return this.data.length}}const K=Math.PI*2,V=e=>{if(e===null)throw new Error("canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element");if(e===void 0)throw new Error("canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element");const n=e instanceof CanvasRenderingContext2D?e:e instanceof HTMLCanvasElement?e.getContext("2d"):typeof e=="string"?C(e).getContext("2d"):e;if(n===null)throw new Error("Could not create 2d context for canvas");return n},ce=(e,n)=>{const i=V(e);return{ctx:i,paths(o,r){Q(i,o,r)},line(o,r){B(i,o,r)},rect(o,r){ie(i,o,r)},bezier(o,r){D(i,o,r)},connectedPoints(o,r){A(i,o,r)},pointLabels(o,r){v(i,o,r)},dot(o,r){h(i,o,r)},circle(o,r){x(i,o,r)},arc(o,r){X(i,o,r)},textBlock(o,r){r.bounds===void 0&&n!==void 0&&(r={...r,bounds:{...n,x:0,y:0}}),ne(i,o,r)}}},b=e=>Y(e.strokeStyle,e.fillStyle),f=(e,n={},...i)=>{if(e===void 0)throw new Error("ctx undefined");const o=c(e).push(b(n),...i);return o.apply(),o},X=(e,n,i={})=>{f(e,i);const o=t=>{e.beginPath(),e.arc(t.x,t.y,t.radius,t.startRadian,t.endRadian),e.stroke()},r=Array.isArray(n)?n:[n];for(const t of r)o(t)},Y=(e,n)=>o=>{n&&(o.fillStyle=n),e&&(o.strokeStyle=e)},Z=(e,n,i)=>r=>{e&&(r.lineWidth=e),n&&(r.lineJoin=n),i&&(r.lineCap=i)},c=(e,n)=>(n??=new g,{push:(...t)=>{n??=new g;const s=n.push(...t);for(const l of t)l(e);return c(e,s)},pop:()=>{const t=n?.pop();return c(e,t)},apply:()=>{if(n===void 0)return c(e);for(const t of n.data)t(e);return c(e,n)}}),x=(e,n,i={})=>{f(e,i);const o=r=>{e.beginPath(),e.arc(r.x,r.y,r.radius,0,K),i.strokeStyle&&e.stroke(),i.fillStyle&&e.fill()};if(Array.isArray(n))for(const r of n)o(r);else o(n)},Q=(e,n,i={})=>{f(e,i);const o=r=>{if(P(r))E(e,r,i);else if(_(r))B(e,r,i);else throw new Error(`Unknown path type ${JSON.stringify(r)}`)};if(Array.isArray(n))for(const r of n)o(r);else o(n)},A=(e,n,i={})=>{const o=i.loop??!1;if(L(j(n,"pts")),n.length!==0){for(const[r,t]of n.entries())T(t,`Index ${r}`);f(e,i),i.lineWidth&&(e.lineWidth=i.lineWidth),e.beginPath(),e.moveTo(n[0].x,n[0].y);for(const r of n)e.lineTo(r.x,r.y);o&&e.lineTo(n[0].x,n[0].y),(i.strokeStyle||i.strokeStyle===void 0&&i.fillStyle===void 0)&&e.stroke(),i.fillStyle&&e.fill()}},v=(e,n,i={},o)=>{if(n.length!==0){for(const[r,t]of n.entries())T(t,`Index ${r}`);f(e,i);for(const[r,t]of n.entries()){const s=o!==void 0&&r<o.length?o[r]:r.toString();e.fillText(s.toString(),t.x,t.y)}}},h=(e,n,i)=>{i??={};const o=i.radius??10,r=Array.isArray(n)?n:[n],t=i.stroke?i.stroke:i.strokeStyle!==void 0;let s=i.filled?i.filled:i.fillStyle!==void 0;!t&&!s&&(s=!0),f(e,i);for(const l of r)e.beginPath(),"radius"in l?e.arc(l.x,l.y,l.radius,0,2*Math.PI):e.arc(l.x,l.y,o,0,2*Math.PI),s&&e.fill(),t&&e.stroke()},D=(e,n,i)=>{P(n)?E(e,n,i):z(n)&&ee(e,n,i)},ee=(e,n,i={})=>{let o=f(e,i);const{a:r,b:t,cubic1:s,cubic2:l}=n,a=i.debug??!1;e.beginPath(),e.moveTo(r.x,r.y),e.bezierCurveTo(s.x,s.y,l.x,l.y,t.x,t.y),e.stroke(),a&&(o=o.push(b({...i,strokeStyle:p(i.strokeStyle??"silver",.6),fillStyle:p(i.fillStyle??"yellow",.4)})),o.apply(),e.moveTo(r.x,r.y),e.lineTo(s.x,s.y),e.stroke(),e.moveTo(t.x,t.y),e.lineTo(l.x,l.y),e.stroke(),e.fillText("a",r.x+5,r.y),e.fillText("b",t.x+5,t.y),e.fillText("c1",s.x+5,s.y),e.fillText("c2",l.x+5,l.y),h(e,s,{radius:3}),h(e,l,{radius:3}),h(e,r,{radius:3}),h(e,t,{radius:3}),o=o.pop(),o.apply())},E=(e,n,i={})=>{const{a:o,b:r,quadratic:t}=n,s=i.debug??!1;let l=f(e,i);e.beginPath(),e.moveTo(o.x,o.y),e.quadraticCurveTo(t.x,t.y,r.x,r.y),e.stroke(),s&&(l=l.push(b({...i,strokeStyle:p(i.strokeStyle??"silver",.6),fillStyle:p(i.fillStyle??"yellow",.4)})),A(e,[o,t,r]),e.fillText("a",o.x+5,o.y),e.fillText("b",r.x+5,r.y),e.fillText("h",t.x+5,t.y),h(e,t,{radius:3}),h(e,o,{radius:3}),h(e,r,{radius:3}),l=l.pop(),l.apply())},B=(e,n,i={})=>{const o=i.debug??!1,r=Z(i.lineWidth,i.lineJoin,i.lineCap);f(e,i,r);const t=s=>{const{a:l,b:a}=s;e.beginPath(),e.moveTo(l.x,l.y),e.lineTo(a.x,a.y),o&&(e.fillText("a",l.x,l.y),e.fillText("b",a.x,a.y),h(e,l,{radius:5,strokeStyle:"black"}),h(e,a,{radius:5,strokeStyle:"black"})),e.stroke()};if(Array.isArray(n))for(const s of n)t(s);else t(n)},ie=(e,n,i={})=>{f(e,i);const o=i.filled??i.fillStyle!==void 0,r=i.stroke??i.strokeStyle!==void 0,t=s=>{const l="x"in s?s.x:0,a="y"in s?s.y:0;o&&e.fillRect(l,a,s.width,s.height),r&&(i.strokeWidth&&(e.lineWidth=i.strokeWidth),e.strokeRect(l,a,s.width,s.height)),i.crossed&&(e.beginPath(),e.moveTo(l,a),e.lineTo(s.width,s.height),e.stroke(),e.moveTo(0,s.height),e.lineTo(s.width,0),e.stroke()),i.debug&&v(e,G(s),void 0,["NW","NE","SE","SW"])};if(Array.isArray(n))for(const s of n)t(s);else t(n)},ne=(e,n,i)=>{f(e,i);const o=i.anchorPadding??0,r=i.align??"top",t=i.anchor,s=i.bounds??{x:0,y:0,width:1e6,height:1e6},l=n.map(d=>e.measureText(d)),a=l.map(d=>d.width),w=l.map(d=>d.actualBoundingBoxAscent+d.actualBoundingBoxDescent+3),m=Math.max(...a),S=w.reduce((d,k)=>d+k,0);let{x:y,y:u}=t;t.x+m>s.width?y=s.width-(m+o):y-=o,y<s.x&&(y=s.x+o),t.y+S>s.height?u=s.height-(S+o):u-=o,u<s.y&&(u=s.y+o),r==="top"?e.textBaseline="top":e.textBaseline="middle";for(const[d,k]of n.entries())e.fillText(k,y,u),u+=w[d]};function p(e,n){return re(e,i=>U(i*n))}function re(e,n){const i=q(e);let o;switch(i.space){case"hsl":o=N(i,n);break;case"srgb":o=H(i,n);break;case"oklch":o=F(i,n);break;default:throw new Error(`Unknown space: '${i.space}'. Expected hsl, srgb, oklch`)}if(!o)throw new Error("Is colour in correct form?");return typeof e=="string"?J(o):o}export{ce as a,x as c,p as m,ie as r};
