import{b as u}from"./clamp-ClLuI7HB.js";const t=(o,n)=>!(n.x<0||n.y<0||n.x>=o.cols||n.y>=o.rows),w=(o,n="Param",s)=>{if(o===void 0)throw new Error(n+" is undefined. Expecting {x,y}");if(o.x===void 0)throw new Error(n+".x is undefined");if(o.y===void 0)throw new Error(n+".y is undefined");if(Number.isNaN(o.x))throw new Error(n+".x is NaN");if(Number.isNaN(o.y))throw new Error(n+".y is NaN");if(!Number.isInteger(o.x))throw new TypeError(n+".x is non-integer");if(!Number.isInteger(o.y))throw new TypeError(n+".y is non-integer");if(s!==void 0&&!t(s,o))throw new Error(`${n} is outside of grid. Cell: ${o.x},${o.y} Grid: ${s.cols}, ${s.rows}`)},i=(o,n="Param")=>{if(o===void 0)throw new Error(`${n} is undefined. Expecting grid.`);if(!("rows"in o))throw new Error(`${n}.rows is undefined`);if(!("cols"in o))throw new Error(`${n}.cols is undefined`);if(!Number.isInteger(o.rows))throw new TypeError(`${n}.rows is not an integer`);if(!Number.isInteger(o.cols))throw new TypeError(`${n}.cols is not an integer`)},d=function(o,n,s="undefined"){i(o,"grid"),w(n,"cell");let r=n.x,e=n.y;switch(s){case"wrap":{r=r%o.cols,e=e%o.rows,r<0?r=o.cols+r:r>=o.cols&&(r-=o.cols),e<0?e=o.rows+e:e>=o.rows&&(e-=o.rows),r=Math.abs(r),e=Math.abs(e);break}case"stop":{r=u(r,o.cols),e=u(e,o.rows);break}case"undefined":{if(r<0||e<0||r>=o.cols||e>=o.rows)return;break}case"unbounded":break;default:throw new Error(`Unknown BoundsLogic '${s}'. Expected: wrap, stop, undefined or unbounded`)}return Object.freeze({x:r,y:e})},f=function(o,n,s,r="undefined"){return d(o,{x:n.x+s.x,y:n.y+s.y},r)},x=(o,n,s)=>{if(i(o,"grid"),n.x<0)switch(s){case"stop":{n={...n,x:0};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{n=f(o,{x:0,y:n.y},{x:n.x,y:0},"wrap");break}}if(n.y<0)switch(s){case"stop":{n={...n,y:0};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{n={...n,y:o.rows+n.y};break}}if(n.x>=o.cols)switch(s){case"stop":{n={...n,x:o.cols-1};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{n={...n,x:n.x%o.cols};break}}if(n.y>=o.rows)switch(s){case"stop":{n={...n,y:o.rows-1};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{n={...n,y:n.y%o.rows};break}}return n.y*o.cols+n.x};export{w as a,t as b,i as g,x as i,f as o};
