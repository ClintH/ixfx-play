import{t as dt,_ as V,c as k,l as Un,k as J,o as Cn,p as we,d as pt,n as x,s as ee,q as re,w as Gn,r as Xn,a as Jn,i as Hn,b as Kn,u as Yn}from"./src-2eX6lIN8-VI_Nykma.js";import{a as Zn,r as Qn,m as it,c as Q}from"./records-Cei7yF1D-C5ys4Q3F.js";import{i as ht,T as de,U as z,V as er,W as tr,X as q,Y as nr,Z as at,_ as ct,$ as S,a0 as R,a1 as M,a2 as Se,a3 as Ee,a4 as se,a5 as rr,a6 as mt,a7 as sr,a8 as vt,a9 as or,aa as ir,ab as ar,r as yt,u as gt,v as bt,x as wt,y as St,A as Et,c as P,ac as pe,ad as cr,ae as lr,af as ur,ag as $e,ah as $t,ai as At,aj as Tt,ak as fr,al as dr,S as pr,G as hr,am as he,an as me,ao as mr,ap as vr,aq as yr,ar as It,w as gr,D as kt,h as br,a as Pt,b as ve,d as wr,t as N,e as Ae,n as Sr,f as Er,g as lt,j as xt,as as $r,at as Ar,Q as Tr,s as Ir}from"./src-CURfSkGx-Bgs9tt00.js";import{i as Dt}from"./is-integer-BmMnD0ra-CbN5m7X_.js";import{s as kr}from"./src-CtUbQWIP-Vt_fnXRn.js";var Pr={};V(Pr,{applyChanges:()=>xr,compareData:()=>X,getField:()=>Vt,getPaths:()=>Dr,getPathsAndData:()=>Vr,updateByPath:()=>Te});const ut=(e,t)=>{if(e===void 0)throw new Error("Param 'target' is undefined");if(e===null)throw new Error("Param 'target' is null");if(typeof e!="object")throw new Error(`Param 'target' is not an object (got: ${typeof e})`);if(t){const n=[];for(const r in e){const s=e[r];dt(s)&&n.push([r,s])}return n}else return Object.entries(e)};function*X(e,t,n={}){if(typeof e>"u"){yield{path:n.pathPrefix??"",value:t,state:"added"};return}if(typeof t>"u"){yield{path:n.pathPrefix??"",previous:e,value:void 0,state:"removed"};return}const r=n.asPartial??!1,s=n.skipInstances??new WeakSet,o=n.undefinedValueMeansRemoved??!1,i=n.pathPrefix??"",a=n.deepEntries??!1,c=n.eq??ht,u=n.includeMissingFromA??!1,l=n.includeParents??!1;if(de(e)&&de(t)){e!==t&&(yield{path:i,value:t,previous:e,state:"change"});return}if(de(t)){yield{path:i,value:t,previous:e,state:"change"};return}const d=ut(e,a),m=new Set;for(const[v,f]of d){m.add(v);const h=v in t,p=t[v];if(typeof f=="object"&&f!==null){if(s.has(f))continue;if(s.add(f),h){if(p===void 0)throw new Error(`Pathed.compareData Value for key ${v} is undefined`);{const y=[...X(f,p,{...n,skipInstances:s,pathPrefix:i+v+"."})];if(y.length>0){for(const w of y)yield w;l&&(yield{path:i+v,value:t[v],previous:f,state:"change"})}}}else{if(r)continue;yield{path:i+v,value:void 0,previous:f,state:"removed"}}}else{const y=i+v;if(h)p===void 0&&o?yield{path:y,previous:f,value:void 0,state:"removed"}:c(f,p,y)||(yield{path:y,previous:f,value:p,state:"change"});else{if(r)continue;yield{path:y,previous:f,value:void 0,state:"removed"}}}}if(u){const v=ut(t,a);for(const[f,h]of v)m.has(f)||(yield{path:i+f,previous:void 0,value:h,state:"added"})}}const xr=(e,t)=>{for(const n of t)e=Te(e,n.path,n.value);return e},Te=(e,t,n,r=!1)=>{if(t===void 0)throw new Error("Parameter 'path' is undefined");if(typeof t!="string")throw new Error(`Parameter 'path' should be a string. Got: ${typeof t}`);if(e===void 0)throw new Error("Parameter 'target' is undefined");if(e===null)throw new Error("Parameter 'target' is null");const s=t.split(".");return ye(e,s,n,r)},ye=(e,t,n,r)=>{if(t.length===0){if(r)return n;if(Array.isArray(e)&&!Array.isArray(n))throw new Error(`Expected array value, got: '${JSON.stringify(n)}'. Set allowShapeChange=true to ignore.`);if(!Array.isArray(e)&&Array.isArray(n))throw new Error(`Unexpected array value, got: '${JSON.stringify(n)}'. Set allowShapeChange=true to ignore.`);if(typeof e!=typeof n)throw new Error(`Cannot reassign object type. (${typeof e} -> ${typeof n}). Set allowShapeChange=true to ignore.`);if(typeof e=="object"&&!Array.isArray(e)){const i=Zn(e,n);if(i.a.length>0)throw new Error(`New value is missing key(s): ${i.a.join(",")}`);if(i.b.length>0)throw new Error(`New value cannot add new key(s): ${i.b.join(",")}`)}return n}const s=t.shift();if(!s)return n;if(Dt(s)&&Array.isArray(e)){const i=Number.parseInt(s);if(i>=e.length&&!r)throw new Error(`Array index ${i.toString()} is outside of the existing length of ${e.length.toString()}. Use allowShapeChange=true to permit this.`);const a=[...e];return a[i]=ye(a[i],t,n,r),a}else if(s in e){const i={...e};return i[s]=ye(i[s],t,n,r),i}else throw new Error(`Path ${s} not found in data`)},Vt=(e,t,n=".")=>{if(typeof t!="string")throw new Error(`Param 'path' ought to be a string. Got: '${typeof t}'`);if(t.length===0)throw new Error("Param string 'path' is empty");if(e===void 0)throw new Error("Param 'object' is undefined");if(e===null)throw new Error("Param 'object' is null");const r=t.split(n);return ge(e,r,t)},ge=(e,t,n)=>{if(e===void 0)return{success:!1,error:`Param 'object' is undefined. Position: ${n}`};if(t.length===0)return{success:!1,error:`Path has been exhausted. position: ${n}`};const r=t.shift();if(!r)return{success:!1,error:`Unexpected empty split path. Position: ${n}`};if(Dt(r)&&Array.isArray(e)){const o=Number.parseInt(r);return typeof e[o]>"u"?{success:!1,error:`Index '${o}' does not exist. Length: ${e.length}. Position: ${n}`}:t.length===0?{value:e[o],success:!0}:ge(e[o],t,t.join("."))}else return typeof e=="object"&&r in e?t.length===0?{value:e[r],success:!0}:ge(e[r],t,t.join(".")):{success:!1,error:`Path '${r}' not found. Position: ${n}`}};function*Dr(e,t=!1){if(e==null)return;const n=Qn(e);for(const r of n){if(r.nodeValue===void 0&&t)continue;let s=r.name;r.ancestors.length>0&&(s=r.ancestors.join(".")+"."+s),yield s}}function*Vr(e,t=!1,n=Number.MAX_SAFE_INTEGER,r=""){e!==null&&e!==void 0&&(yield*Lt(e,r,t,n))}function*Lt(e,t,n=!1,r){if(!(r<=0)&&typeof e=="object")for(const s of Object.entries(e)){const o=(t.length>0?t+".":"")+s[0],i=s[1];(n&&typeof i!="object"||!n)&&(yield{path:o,value:i}),yield*Lt(i,o,n,r-1)}}function Ot(e,t={}){k(pt(e,"aboveZero","totalTicks"));const n=t.exclusiveStart??!1,r=t.exclusiveEnd??!1,s=t.cycleLimit??Number.MAX_SAFE_INTEGER,o=n?1:0,i=r?e-1:e;let a=0,c=t.startAt??o;if(t.startAtRelative){let u=e;n&&u--,r&&u--,c=Math.round(t.startAtRelative*u)}return u=>{if(u&&(u.resetAt!==void 0&&(c=u.resetAt),u.resetAtRelative!==void 0&&(c=Math.floor(u.resetAtRelative*e))),a>=s)return 1;const l=c/e;return c++,c>i&&(a++,c=o),l}}function _(e,t={}){const n=t.cycleLimit??Number.MAX_SAFE_INTEGER,r=1;let s=t.startAt??performance.now(),o=0;const i=P(e,1e3);return t.startAtRelative&&(k(x(t.startAtRelative,"percentage","startAtRelative")),s=performance.now()-i*t.startAtRelative),a=>{if(a&&(a.resetAt!==void 0&&(s=a.resetAt,s===0&&(s=performance.now())),a.resetAtRelative!==void 0&&(k(x(a.resetAtRelative,"percentage","resetAtRelative")),s=performance.now()-i*a.resetAtRelative)),o>=n)return r;const c=performance.now(),u=c-s;return u>=i&&(o+=Math.floor(u/i),s=c,o>=n)?r:u%i/i}}function Mt(e,t={}){const n=6e4/e;return _(n,t)}function Ie(e,t={}){const n=1e3/e;return _(n,t)}const Ft=(e,t={})=>{const n=e/1e3;let r=t.min??Number.MIN_SAFE_INTEGER,s=t.max??Number.MAX_SAFE_INTEGER;const o=t.clamp??!1;if(o&&t.max)throw new Error("Use either 'max' or 'clamp', not both.");o&&(s=e);let i=performance.now();return()=>{const a=performance.now(),c=a-i;i=a;const u=n*c;return u>s?s:u<r?r:u}},Lr=(e,t={})=>Ft(e/60,t);var Nt={};V(Nt,{bpm:()=>Mt,elapsed:()=>_,hertz:()=>Ie,perMinute:()=>Lr,perSecond:()=>Ft,ticks:()=>Ot});var jt={};V(jt,{saw:()=>Nr,sine:()=>Or,sineBipolar:()=>Mr,square:()=>jr,triangle:()=>Fr});const Rt=Math.PI*2;function*Or(e){if(e===void 0)throw new TypeError("Parameter 'timerOrFreq' is undefined");for(typeof e=="number"&&(e=z(e));;)yield(Math.sin(e.elapsed*Rt)+1)/2}function*Mr(e){if(e===void 0)throw new TypeError("Parameter 'timerOrFreq' is undefined");for(typeof e=="number"&&(e=z(e));;)yield Math.sin(e.elapsed*Rt)}function*Fr(e){for(typeof e=="number"&&(e=z(e));;){let t=e.elapsed;t<.5?t*=2:t=2-t*2,yield t}}function*Nr(e){if(e===void 0)throw new TypeError("Parameter 'timerOrFreq' is undefined");for(typeof e=="number"&&(e=z(e));;)yield e.elapsed}function*jr(e){for(typeof e=="number"&&(e=z(e));;)yield e.elapsed<.5?0:1}const Rr=Math.pow,_r=1/Math.sqrt(2*Math.PI),_t=(e=.4)=>n=>{const r=_r/e;let s=-2.5,o=(n-.5)/e;o*=o,s*=o;const i=r*Rr(Math.E,s);return i>1?1:i<0?0:i};var ke={};V(ke,{arch:()=>Br,backIn:()=>as,backInOut:()=>us,backOut:()=>cs,bell:()=>hs,bounceIn:()=>ps,bounceInOut:()=>vs,bounceOut:()=>ne,circIn:()=>os,circInOut:()=>ls,circOut:()=>is,cubicIn:()=>Yr,cubicOut:()=>Zr,elasticIn:()=>fs,elasticInOut:()=>ms,elasticOut:()=>ds,expoIn:()=>ts,expoInOut:()=>ss,expoOut:()=>ns,quadIn:()=>Xr,quadInOut:()=>Kr,quadOut:()=>Jr,quartIn:()=>Qr,quartOut:()=>es,quintIn:()=>zr,quintInOut:()=>rs,quintOut:()=>qr,sineIn:()=>Cr,sineInOut:()=>Hr,sineOut:()=>Gr,smootherstep:()=>Ur,smoothstep:()=>Wr});const te=Math.sqrt,E=Math.pow,zt=Math.cos,B=Math.PI,H=Math.sin,ne=e=>e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375,zr=e=>e*e*e*e*e,qr=e=>1-E(1-e,5),Br=e=>e*(1-e)*4,Wr=e=>e*e*(3-2*e),Ur=e=>(e*(e*6-15)+10)*e*e*e,Cr=e=>1-zt(e*B/2),Gr=e=>H(e*B/2),Xr=e=>e*e,Jr=e=>1-(1-e)*(1-e),Hr=e=>-(zt(B*e)-1)/2,Kr=e=>e<.5?2*e*e:1-E(-2*e+2,2)/2,Yr=e=>e*e*e,Zr=e=>1-E(1-e,3),Qr=e=>e*e*e*e,es=e=>1-E(1-e,4),ts=e=>e===0?0:E(2,10*e-10),ns=e=>e===1?1:1-E(2,-10*e),rs=e=>e<.5?16*e*e*e*e*e:1-E(-2*e+2,5)/2,ss=e=>e===0?0:e===1?1:e<.5?E(2,20*e-10)/2:(2-E(2,-20*e+10))/2,os=e=>1-te(1-E(e,2)),is=e=>te(1-E(e-1,2)),as=e=>2.70158*e*e*e-1.70158*e*e,cs=e=>1+2.70158*E(e-1,3)+1.70158*E(e-1,2),ls=e=>e<.5?(1-te(1-E(2*e,2)))/2:(te(1-E(-2*e+2,2))+1)/2,us=e=>{const n=2.5949095;return e<.5?E(2*e,2)*((n+1)*2*e-n)/2:(E(2*e-2,2)*((n+1)*(e*2-2)+n)+2)/2},fs=e=>{const t=2*B/3;return e===0?0:e===1?1:-E(2,10*e-10)*H((e*10-10.75)*t)},ds=e=>{const t=2*B/3;return e===0?0:e===1?1:E(2,-10*e)*H((e*10-.75)*t)+1},ps=e=>1-ne(1-e),hs=_t(),ms=e=>{const t=2*B/4.5;return e===0?0:e===1?1:e<.5?-(E(2,20*e-10)*H((20*e-11.125)*t))/2:E(2,-20*e+10)*H((20*e-11.125)*t)/2+1},vs=e=>e<.5?(1-ne(1-2*e))/2:(1+ne(2*e-1))/2,ys=(e=0,t=0)=>{const r={x:ee(e,-1,1,0,1),y:ee(e,-1,1,1,0)};let s=pe(Math.abs(e),S,r);e!==0&&t>0&&(e>0?s=pe(t,s,{x:0,y:r.x*2}):s=pe(t,s,{x:r.y*2,y:0}));const o=cr(S,lr,s,r),i=ur(o);return a=>i(a)},qt=(e,t)=>{k(re(e,"fn"));let n;return()=>(typeof n>"u"&&(n=Tt(t,{clampValue:!0})),e(n()))},Bt=(e,t)=>{k(re(e,"fn"));const n=$e(),r=P(t);if(r===void 0)throw new Error("Param 'duration' not provided");const s=$t(r,{timer:n,clampValue:!0});return At(e,s)},Wt=(e,t)=>{k(re(e,"fn"));let n;return()=>(typeof n>"u"&&(n=fr(t,{clampValue:!0})),e(n()))},Ut=(e,t)=>{k(re(e,"fn"));const n=dr(),r=$t(t,{timer:n,clampValue:!0});return At(e,r)};var Ct={};V(Ct,{Named:()=>ke,create:()=>gs,get:()=>oe,getEasingNames:()=>Ss,line:()=>ys,tickEasing:()=>ws,ticks:()=>Xt,time:()=>Gt,timeEasing:()=>bs});const gs=e=>{const n=Y(e.name??"quintIn")??e.fn;if(typeof n>"u")throw new Error("Either 'name' or 'fn' must be set");if("duration"in e)return Gt(n,e.duration);if("ticks"in e)return Xt(n,e.ticks);throw new Error("Expected 'duration' or 'ticks' in options")},bs=(e,t)=>{const n=Y(e);return Bt(n,t)},Gt=(e,t)=>{const n=Y(e);return qt(n,t)},Xt=(e,t)=>{const n=Y(e);return Wt(n,t)},ws=(e,t)=>{const n=Y(e);return Ut(n,t)},Y=e=>{const t=typeof e=="function"?e:oe(e);if(typeof t>"u")throw typeof e=="string"?new Error(`Easing function not found: '${e}'`):new Error("Easing function not found");return t};let C;const oe=function(e){k(Un(e,"non-empty","easingName"));const t=Jt().get(e.toLowerCase());if(t===void 0)throw new Error(`Easing not found: '${e}'`);return t};function Jt(){if(C===void 0){C=new Map;for(const[e,t]of Object.entries(ke))C.set(e.toLowerCase(),t);return C}else return C}function*Ss(){yield*Jt().keys()}const Ht=Object.freeze({attack:["decay","release"],decay:["sustain","release"],sustain:["release"],release:["complete"],complete:null}),G=Object.freeze({attackDuration:600,decayDuration:200,releaseDuration:800,shouldLoop:!1});var Kt=class extends pr{#e;#s;#t;#r;#n;#o=!1;#i=!1;attackDuration;decayDuration;releaseDuration;decayDurationTotal;shouldLoop;constructor(e={}){super(),this.attackDuration=e.attackDuration??G.attackDuration,this.decayDuration=e.decayDuration??G.decayDuration,this.releaseDuration=e.releaseDuration??G.releaseDuration,this.shouldLoop=e.shouldLoop??G.shouldLoop,this.#e=new hr(Ht,{initial:"attack"}),this.#e.addEventListener("change",t=>{t.newState==="release"&&this.#n&&this.#t?.reset(),super.fireEvent("change",t)}),this.#e.addEventListener("stop",t=>{super.fireEvent("complete",t)}),this.#s=()=>$e(),this.#r=this.#n=!1,this.decayDurationTotal=this.attackDuration+this.decayDuration}dispose(){this.#o||this.#e.dispose()}get isDisposed(){return this.#o}switchStateIfNeeded(e){if(this.#t===void 0)return!1;let t=this.#t.elapsed;const n=this.#n&&!this.#r;let r=!1,s=this.#e.state;do switch(r=!1,s=this.#e.state,s){case"attack":{(t>this.attackDuration||n)&&(this.#e.next(),r=!0);break}case"decay":{(t>this.decayDurationTotal||n)&&(this.#e.next(),r=!0);break}case"sustain":{(!this.#r||n)&&(t=0,this.#e.next(),this.#t.reset(),r=!0);break}case"release":{t>this.releaseDuration&&(this.#e.next(),r=!0);break}case"complete":this.shouldLoop&&e&&this.trigger(this.#n)}while(r&&s!=="complete");return r}computeRaw(e=!0,t=!0){if(this.#t===void 0)return[void 0,0,this.#e.state];e&&this.switchStateIfNeeded(t);const n=this.#e.state,r=this.#t.elapsed;let s=0;const o=this.#e.state;switch(o){case"attack":{s=r/this.attackDuration;break}case"decay":{s=(r-this.attackDuration)/this.decayDuration;break}case"sustain":{s=1;break}case"release":{s=Math.min(r/this.releaseDuration,1);break}case"complete":return["complete",1,n];default:throw new Error(`State machine in unknown state: ${o}`)}return[o,s,n]}get isDone(){return this.#e.isDone}onTrigger(){}trigger(e=!1){this.onTrigger(),this.#i=!0,this.#e.reset(),this.#t=this.#s(),this.#r=e,this.#n=e}get hasTriggered(){return this.#i}compute(){}release(){this.isDone||!this.#n||(this.#r=!1,this.compute())}};const O=Object.freeze({attackBend:-1,decayBend:-.3,releaseBend:-.3,peakLevel:1,initialLevel:0,sustainLevel:.6,releaseLevel:0,retrigger:!1});var Yt=class{adsr;constructor(e){this.adsr=e}next(...e){this.adsr.hasTriggered||this.adsr.trigger();const t=this.adsr.compute();return{value:t[1],done:t[0]==="complete"}}[Symbol.toStringTag]="Generator"},Pe=class extends Kt{attackPath;decayPath;releasePath;initialLevel;peakLevel;releaseLevel;sustainLevel;attackBend;decayBend;releaseBend;initialLevelOverride;retrigger;releasedAt;constructor(e={}){super(e),this.retrigger=e.retrigger??O.retrigger,this.initialLevel=e.initialLevel??O.initialLevel,this.peakLevel=e.peakLevel??O.peakLevel,this.releaseLevel=e.releaseLevel??O.releaseLevel,this.sustainLevel=e.sustainLevel??O.sustainLevel,this.attackBend=e.attackBend??O.attackBend,this.releaseBend=e.releaseBend??O.releaseBend,this.decayBend=e.decayBend??O.decayBend;const t=1;this.attackPath=he(me({x:0,y:this.initialLevel},{x:t,y:this.peakLevel},-this.attackBend)),this.decayPath=he(me({x:0,y:this.peakLevel},{x:t,y:this.sustainLevel},-this.decayBend)),this.releasePath=he(me({x:0,y:this.sustainLevel},{x:t,y:this.releaseLevel},-this.releaseBend))}onTrigger(){if(this.initialLevelOverride=void 0,!this.retrigger){const[e,t,n]=this.compute(!0,!1);!Number.isNaN(t)&&t>0&&(this.initialLevelOverride=t)}}[Symbol.iterator](){return new Yt(this)}get value(){return this.compute(!0)[1]}compute(e=!0,t=!0){const[n,r]=super.computeRaw(e,t);if(n===void 0)return[void 0,NaN,NaN];let s;switch(n){case"attack":{s=this.attackPath.interpolate(r).y,this.initialLevelOverride!==void 0&&(s=ee(s,0,1,this.initialLevelOverride,1)),this.releasedAt=s;break}case"decay":{s=this.decayPath.interpolate(r).y,this.releasedAt=s;break}case"sustain":{s=this.sustainLevel,this.releasedAt=s;break}case"release":{s=this.releasePath.interpolate(r).y,this.releasedAt!==void 0&&(s=ee(s,0,this.sustainLevel,0,this.releasedAt));break}case"complete":{s=this.releaseLevel,this.releasedAt=void 0;break}default:throw new Error(`Unknown state: ${n}`)}return[n,s,r]}},Zt={};V(Zt,{Adsr:()=>Pe,AdsrBase:()=>Kt,AdsrIterator:()=>Yt,adsr:()=>Es,adsrIterable:()=>$s,adsrStateTransitions:()=>Ht,defaultAdsrOpts:()=>O,defaultAdsrTimingOpts:()=>G});const Es=(e={})=>{const t=new Pe(e),n=t.releaseLevel,r=t[Symbol.iterator]();return()=>er(r,{overrideWithLast:!0,value:n})};async function*$s(e){const t=new Pe(e.env),n=e.sampleRateMs??100;t.trigger();const r=tr(()=>t.value,{while:()=>!t.isDone,delay:n,signal:e.signal});for await(const s of r)yield s}var Qt={};V(Qt,{accelerationForce:()=>xs,angleFromAccelerationForce:()=>nn,angleFromVelocityForce:()=>rn,angularForce:()=>tn,apply:()=>Ps,attractionForce:()=>Is,computeAccelerationToTarget:()=>sn,computeAttractionForce:()=>en,computePositionFromAngle:()=>on,computePositionFromVelocity:()=>De,computeVelocity:()=>xe,constrainBounce:()=>Ts,guard:()=>As,magnitudeForce:()=>Ds,nullForce:()=>Vs,orientationForce:()=>js,pendulumForce:()=>Ms,springForce:()=>Os,targetForce:()=>ks,velocityForce:()=>Ls});const As=(e,t="t")=>{if(e===void 0)throw new Error(`Parameter ${t} is undefined. Expected ForceAffected`);if(e===null)throw new Error(`Parameter ${t} is null. Expected ForceAffected`);if(typeof e!="object")throw new TypeError(`Parameter ${t} is type ${typeof e}. Expected object of shape ForceAffected`)},Ts=(e,t=1)=>{e||(e={width:1,height:1});const n=at(e,"left"),r=at(e,"right"),s=ct(e,"top"),o=ct(e,"bottom");return i=>{const a=De(i.position??S,i.velocity??S);let c=i.velocity??S,{x:u,y:l}=a;return u>r?(u=r,c=R(M(c,t),"x")):u<n&&(u=n,c=R(M(c,t),"x")),l>o?(l=o,c=M(R(c,"y"),t)):a.y<s&&(l=s,c=R(M(c,t),"y")),Object.freeze({...i,position:{x:u,y:l},velocity:c})}},Is=(e,t,n={})=>r=>{let s=r.acceleration??S;for(const o of e){if(o===r)continue;const i=en(o,r,t,n);s=q(s,i)}return{...r,acceleration:s}},en=(e,t,n,r={})=>{if(e.position===void 0)throw new Error("attractor.position not set");if(t.position===void 0)throw new Error("attractee.position not set");const s=r.min??.01,o=r.max??.7,i=Se(Ee(e.position,t.position)),a=J(se(i),s,o);return M(i,n*(e.mass??1)*(t.mass??1)/(a*a))},ks=(e,t={})=>r=>{const s=sn(e,r.position??{x:.5,y:.5},t);return{...r,acceleration:q(r.acceleration??S,s)}},Ps=(e,...t)=>{if(e===void 0)throw new Error("t parameter is undefined");for(const o of t)o!=null&&(e=typeof o=="function"?o(e):{...e,acceleration:q(e.acceleration??S,o)});const n=xe(e.acceleration??S,e.velocity??S),r=De(e.position??S,n);return{...e,position:r,velocity:n,acceleration:S}},xs=(e,t="ignored")=>n=>Object.freeze({...n,acceleration:ie(e,n,t)}),ie=(e,t,n="ignored")=>{let r;switch(n){case"dampen":{r=s=>mr(e,s,s);break}case"multiply":{r=s=>vt(e,s,s);break}case"ignored":{r=s=>e;break}default:throw new Error(`Unknown 'mass' parameter '${n}. Expected 'dampen', 'multiply' or 'ignored'`)}return q(t.acceleration??S,r(t.mass??1))},Ds=(e,t="ignored")=>n=>{if(n.velocity===void 0)return n;const r=se(Se(n.velocity)),s=e*r*r,o=M(R(n.velocity),s);return Object.freeze({...n,acceleration:ie(o,n,t)})},Vs=e=>e,Ls=(e,t)=>{const n=rr(R,r=>M(r,e));return r=>{if(r.velocity===void 0)return r;const s=n(r.velocity);return Object.freeze({...r,acceleration:ie(s,r,t)})}},tn=()=>e=>{const t=e.angularAcceleration??0,n=e.angularVelocity??0,r=e.angle??0,s=n+t,o=r+s;return Object.freeze({...e,angle:o,angularVelocity:s,angularAcceleration:0})},nn=(e=20)=>t=>{const n=t.acceleration??S;return Object.freeze({...t,angularAcceleration:n.x*e})},rn=(e=1)=>t=>{const n=mt(t.velocity??S);return Object.freeze({...t,angle:e<1?Cn(e,t.angle??0,n):n})},Os=(e,t=.5,n=2e-4,r=.999)=>s=>{const o=Ee(s.position??S,e),i=se(o),a=Math.abs(t-i),c=sr(o,Se,m=>M(m,-n*a)),u=ie(c,s,"dampen"),l=xe(u??S,s.velocity??S),d=vt(l,r,r);return{...s,velocity:d,acceleration:S}},Ms=(e,t={})=>n=>{e||(e={x:0,y:0});const r=t.length??se(e,n.position??S),s=t.speed??.001,o=t.damping??.995;let i=n.angle;i===void 0&&(n.position?i=mt(e,n.position)-Math.PI/2:i=0);const a=-1*s/r*Math.sin(i),c=(n.angularVelocity??0)+a;return i+=c,Object.freeze({angularVelocity:c*o,angle:i,position:on(r,i+Math.PI/2,e)})},xe=(e,t,n)=>{const r=q(t,e);return n===void 0?r:or(r,n)},sn=(e,t,n={})=>{const r=n.diminishBy??.001,s=Ee(e,t);return n.range&&ir(ar(s),n.range)===-2?S:M(s,r)},De=(e,t)=>q(e,t),on=(e,t,n)=>nr(e,t,n),Fs=tn(),Ns=nn(),js=(e=.5)=>{const t=rn(e);return n=>(n=Fs(n),n=Ns(n),n=t(n),n)},Rs=(e,t)=>n=>{const r=1-n,s=r*r,o=n*n,i=o*n;return 3*e*s*n+3*t*r*o+i},_s=e=>{let t=performance.now();return{update:(s=1)=>{const o=performance.now()-t,i=e*o%1;return t=performance.now(),(s+i)%1},reset:()=>{t=performance.now()}}},ft=Math.PI*2;function Ve(e,t,n,r){let s,o="clamp";const i=l=>(s&&(l=s(l)),o===void 0||o==="clamp"?l=J(l):o==="wrap"&&(l>1?l=l%1:l<0&&(l=1+l%1)),l),a=(l,d,m)=>(k(x(d,"","a"),x(m,"","b"),x(l,"","amount")),l=i(l),(1-l)*d+l*m),c=(l={})=>{if(l.easing){const d=oe(l.easing);if(!d)throw new Error(`Easing function '${l.easing}' not found`);s=d}else if(l.transform){if(typeof l.transform!="function")throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof l.transform}`);s=l.transform}o=l.limits??"clamp"},u=(l,d,m)=>(1-l)*d+l*m;if(typeof e!="number")throw new TypeError(`First param is expected to be a number. Got: ${typeof e}`);if(typeof t=="number"){let l,d;if(n===void 0||typeof n=="object")return l=e,d=t,c(n),m=>a(m,l,d);if(typeof n=="number")return l=t,d=n,c(r),a(e,l,d);throw new Error("Values for 'a' and 'b' not defined")}else if(t===void 0||typeof t=="object"){const l=i(e);return c(t),k(x(l,"","amount")),(d,m)=>u(l,d,m)}}const zs=(e,t=0,n=1,r=0,s)=>{let o=r;return(i,a)=>{if(i!==void 0&&(n=i),a!==void 0&&(t=a),o>=1)return n;const c=Ve(o,t,n,s);return o+=e,c}},qs=(e,t,n,r)=>{const s=Gn(n-t,0,ft);return Ve(e,t,t+(s>Math.PI?s-ft:s),r)},Bs=(e,t=0,n=1,r)=>{const s=Tt(e,{clampValue:!0});return(o,i)=>{const a=s();return o!==void 0&&(n=o),i!==void 0&&(t=i),a>=1?n:Ve(a,t,n,r)}},Ws=e=>{const{relative:t,absolute:n}=e,r=e.clamped??!1,s=e.source??Math.random;if(n!==void 0)return o=>{const i=s()*n*2-n,a=o+i;return r?J(a,0,o):a};if(t!==void 0)return o=>{const i=o*t,a=s()*i*2-i,c=o+a;return r?J(c,0,o):c};throw new Error("Either absolute or relative fields expected")},Us=(e={})=>{const t=e.clamped??!0;let n=s=>0;if(e.absolute!==void 0){k(x(e.absolute,t?"percentage":"bipolar","opts.absolute"));const s=vr({min:-e.absolute,max:e.absolute,source:e.source});n=o=>o+s()}else{if(e.relative===void 0)throw new TypeError("Either absolute or relative jitter amount is required.");{const s=e.relative??.1;k(x(s,t?"percentage":"bipolar","opts.relative")),n=o=>o+yr({min:-Math.abs(s*o),max:Math.abs(s*o),source:e.source})}}return s=>{k(x(s,t?"percentage":"bipolar","value"));let o=n(s);return t&&(o=J(o)),o}},Cs=(e,t,n)=>{const r=n*e;return(1-e)*t+t*r},an=(e,t,n)=>r=>we(e,t(r),n(r)),Gs=(e,t)=>n=>an(n,e,t)(n),Xs=e=>e,Js=function(e=.1,t,n,r,s){return typeof t>"u"&&(t=0),typeof n>"u"&&(n=1),typeof r>"u"&&(r=t),k(x(e,"bipolar","interval"),x(n,"bipolar","end"),x(r,"bipolar","offset"),x(t,"bipolar","start")),cn(e,t,n,r,s)},cn=function*(e,t,n,r,s){if(t===void 0)throw new Error("Parameter 'lower' is undefined");if(e===void 0)throw new Error("Parameter 'interval' is undefined");if(n===void 0)throw new Error("Parameter 'upper' is undefined");if(s===void 0&&e<=1&&e>=0?s=10/e:typeof s>"u"&&(s=1234),Number.isNaN(e))throw new Error("interval parameter is NaN");if(Number.isNaN(t))throw new Error("lower parameter is NaN");if(Number.isNaN(n))throw new Error("upper parameter is NaN");if(Number.isNaN(r))throw new Error("upper parameter is NaN");if(t>=n)throw new Error("lower must be less than upper");if(e===0)throw new Error("Interval cannot be zero");const o=n-t;if(Math.abs(e)>=o)throw new Error(`Interval should be between -${o} and ${o}`);let i=e>0;if(n=Math.floor(n*s),t=Math.floor(t*s),e=Math.floor(Math.abs(e*s)),e===0)throw new Error(`Interval is zero (rounding: ${s})`);if(r=r===void 0?t:Math.floor(r*s),r>n||r<t)throw new Error(`Start (${r/s}) must be within lower (${t/s}) and upper (${n/s})`);let a=r;yield a/s;let c=!0;for(;;)a=a+(i?e:-e),i&&a>=n?(i=!1,a=n,a===n&&c&&(a=t,i=!0)):!i&&a<=t&&(i=!0,a=t,a===t&&c&&(a=n,i=!1)),yield a/s,c=!1};function*ln(e={},t){t===void 0?t=$e():typeof t=="number"&&(t=z(t));const n=un(e);let r=e.countdown??10;for(;r>0;){const s=n(t.elapsed/1e3);yield s,s===1?r--:r=100}}function Hs(e={},t){const n=ln(e,t);return()=>{const r=n.next();return r.done?1:r.value}}const un=(e={})=>{const r=e.mass??1,s=e.stiffness??100,o=e.soft??!1,i=e.damping??10,a=e.velocity??.1,c=1;if(o||1<=i/(2*Math.sqrt(s*r))){const u=-Math.sqrt(s/r),l=-u*c-a;return d=>1-(c+d*l)*Math.E**(d*u)}else{const u=Math.sqrt(4*r*s-i**2),l=(i*c-2*r*a)/u,d=.5*u/r,m=-(.5*i)/r;return v=>1-(Math.cos(v*d)*c+Math.sin(v*d)*l)*Math.E**(v*m)}},Ks=(e,t,n={})=>{switch(e){case"elapsed":return()=>_(t,n);case"bpm":return()=>Mt(t,n);case"hertz":return()=>Ie(t,n);default:throw new Error(`Unknown source '${e}'. Expected: 'elapsed', 'hertz' or 'bpm'`)}};function fn(e=1){e=1/e;const t=e/2;return n=>Math.abs(n%e-t)}function dn(e=1){e=1/e;const t=e/2;return n=>n%e<t?1:0}function pn(e=1){return e=e*(Math.PI*2),t=>(Math.sin(t*e)+1)/2}function hn(e=1){return e=e*(Math.PI*2),t=>Math.abs(Math.sin(t*e))}function mn(e=1){return e=e*(Math.PI*2),t=>Math.sin(t*e)}function Ys(e){const t=e.shape??"sine",n=e.invert??!1,r=e.period??1;let s;k(pt(r,"aboveZero","period"));const o={...e};if(e.ticks)s=Ot(e.ticks,o);else if(e.hertz)s=Ie(e.hertz,o);else if(e.millis)s=_(e.millis,o);else if(e.source)s=e.source;else{const a=e.secs??5;s=_(a*1e3,o)}let i;switch(t){case"saw":i=a=>a;break;case"sine":i=pn(r);break;case"sine-bipolar":i=mn(r);break;case"square":i=dn(r);break;case"triangle":i=fn(r);break;case"arc":i=hn(r);break;default:throw new Error(`Unknown wave shape '${t}'. Expected: sine, sine-bipolar, saw, triangle, arc or square`)}return vn(s,i,n)}function vn(e,t,n=!1){return r=>{let s=e(r?.clock);return r?.override&&(s=r.override),s=t(s),n&&(s=1-s),s}}const Zs=(e,t,n)=>(e*(n-1)+t)/n,Qs=(e="quadIn")=>yn(e)(),yn=(e="quadIn")=>{const t=typeof e=="string"?{easing:e}:e,n=t.source??Math.random,r=t.easing??"quadIn",s=oe(r);if(typeof s>"u")throw new Error(`Easing function '${r}' not found.`);return()=>{const i=n();return s(i)}};var eo={};V(eo,{Easings:()=>Ct,Envelopes:()=>Zt,Forces:()=>Qt,Oscillators:()=>jt,Sources:()=>Nt,arcShape:()=>hn,crossfade:()=>Gs,cubicBezierShape:()=>Rs,drift:()=>_s,gaussian:()=>_t,interpolate:()=>we,interpolateAngle:()=>qs,interpolatorInterval:()=>Bs,interpolatorStepped:()=>zs,jitter:()=>Us,jitterAbsolute:()=>Ws,mix:()=>Cs,mixModulators:()=>an,noop:()=>Xs,pingPong:()=>cn,pingPongPercent:()=>Js,sineBipolarShape:()=>mn,sineShape:()=>pn,spring:()=>ln,springShape:()=>un,springValue:()=>Hs,squareShape:()=>dn,tickModulator:()=>Ut,ticks:()=>Wt,time:()=>qt,timeModulator:()=>Bt,timingSourceFactory:()=>Ks,triangleShape:()=>fn,wave:()=>Ys,waveFromSource:()=>vn,weighted:()=>Qs,weightedAverage:()=>Zs,weightedSource:()=>yn});var Le=class extends Error{constructor(e){super(e),this.name="CancelError"}};function to(...e){return t=>{let n=t;for(const r of e)try{n=r(n)}catch(s){if(s instanceof Le)break;throw s}return n}}function no(e){return t=>t===void 0?t:e(t)}function ro(){return e=>{if(e===void 0)throw new Le("cancel");return e}}function so(e){return t=>t===void 0?e():t}const oo=(e,t)=>e===t,io=e=>typeof e=="string"?e:JSON.stringify(e);function ao(e){let t;return n=>{if(n!==t)return t=n,n}}function co(e){const t=[];return typeof e>"u"&&(e=oo),n=>{if(n!==void 0){for(const r of t)if(e(r,n))return;return t.push(n),n}}}function lo(e){const t=new Set;return typeof e>"u"&&(e=io),n=>{if(n===void 0)return;const r=e(n);if(!t.has(r))return t.add(r),n}}var uo={};V(uo,{CancelError:()=>Le,average:()=>Et,cancelIfUndefined:()=>ro,flow:()=>to,ifNotUndefined:()=>no,ifUndefined:()=>so,max:()=>St,min:()=>wt,rank:()=>bt,seenLastToUndefined:()=>ao,seenToUndefined:()=>co,seenToUndefinedByKey:()=>lo,sum:()=>gt,tally:()=>yt});function K(e){return e.value!==void 0?!1:"signal"in e&&e.signal!==void 0}function D(e){return e.value!==void 0?!1:"signal"in e&&e.signal==="done"}function A(e){return e.value!==void 0}const gn=e=>Z(e)?"ping"in e:!1,bn=e=>Z(e)?"last"in e&&e.last()!==void 0:!1,Z=e=>typeof e!="object"||e===null?!1:"on"in e&&"onValue"in e,Oe=e=>Z(e)?"set"in e:!1,wn=e=>!(typeof e!="object"||!("source"in e)||!("annotate"in e)),I=(e,...t)=>n=>e(n,...t),Me=e=>"value"in e,Fe=e=>"fn"in e,Ne=e=>Pt(e),Sn=e=>typeof e!="object"?!1:!!(Me(e)||Fe(e)||Ne(e));function En(e){if(Me(e))return[e.value,!1];if(Fe(e)){const t=e.fn();return t===void 0?[void 0,!0]:[t,!1]}if(Ne(e)){const t=e.gen.next();return t.done?[void 0,!0]:[t.value,!1]}throw new Error("Invalid trigger. Missing 'value' or 'fn' fields")}function $n(e,t={}){const n=t.maximumRepeats??Number.MAX_SAFE_INTEGER,r=t.closeOnError??!0,s=t.interval?P(t.interval):-1;let o=t.manual??!1;if(t.interval===void 0&&t.manual===void 0&&(o=!0),o&&t.interval)throw new Error("If option 'manual' is set, option 'interval' cannot be used");const i=P(t.predelay,0),a=t.lazy??"very",c=t.signal,u=new AbortController,l=y=>{u.abort(y)};let d=0,m=!1;const v=y=>{p.dispose(y),m=!1,h&&h.cancel()},f=async()=>{if(!m)return!1;if(i&&await Er(i),d>=n)return v(`Maximum repeats reached ${n.toString()}`),!1;try{if(c?.aborted)return v(`Signal (${c.aborted})`),!1;const y=await e(l);return d++,p.set(y),!0}catch(y){return r?(v(`Function error: ${lt(y)}`),!1):(p.signal("warn",lt(y)),!0)}},h=o?void 0:Ae(async()=>{if(!await f())return!1;if(u.signal.aborted)return v(`callback function aborted (${u.signal.reason})`),!1},s),p=F({lazy:a,onStart(){m=!0,h&&h.start()},onStop(){m=!1,h&&h.cancel()}});return a==="never"&&h&&h.start(),{...p,ping:f}}function be(e,t={}){const n=t.lazy??"very",r=t.traceLifecycle?v=>{console.log(`Rx.From.iterator ${v}`)}:v=>{},s=P(t.readInterval,5),o=P(t.readTimeout,300*1e3),i=t.whenStopped??"continue";let a,c,u=wr({idle:["wait_for_next"],wait_for_next:["processing_result","stopping","disposed"],processing_result:["queued","disposed","stopping"],queued:["wait_for_next","disposed","stopping"],stopping:"idle",disposed:null},"idle");const l=()=>{r("onExternalSignal"),c?.abort(t.signal?.reason)};t.signal&&t.signal.addEventListener("abort",l,{once:!0});const d=async()=>{r(`read. State: ${u.value}`),c=new AbortController;try{u=N(u,"wait_for_next");const v=await Sr(a,{signal:c.signal,millis:o});if(u=N(u,"processing_result"),c.abort("nextWithTimeout completed"),v.done&&(r("read v.done true"),m.dispose("Generator complete"),u=N(u,"disposed")),u.value==="stopping"){r("read. sm.value = stopping"),u=N(u,"idle");return}if(u.value==="disposed"){r("read. sm.value = disposed");return}m.set(v.value)}catch(v){m.dispose(`Generator error: ${v.toString()}`);return}u.value==="processing_result"?(u=N(u,"queued"),r(`scheduling read. State: ${u.value}`),setTimeout(d,s)):u=N(u,"idle")},m=F({...t,lazy:n,onStart(){r(`onStart state: ${u.value} whenStopped: ${i}`),u.value==="idle"&&((u.value==="idle"&&i==="reset"||a===void 0)&&(a=ve(e)?e[Symbol.asyncIterator]():e[Symbol.iterator]()),d())},onStop(){r(`onStop state: ${u.value} whenStopped: ${i}`),u=N(u,"stopping"),i==="reset"&&(r("onStop reiniting iterator"),a=ve(e)?e[Symbol.asyncIterator]():e[Symbol.iterator]())},onDispose(v){r(`onDispose (${v})`),c?.abort(`Rx.From.iterator disposed (${v})`),t.signal&&t.signal.removeEventListener("abort",l)}});return m}const b=(e,t={})=>{if(Z(e))return e;const n=t.generator??{lazy:"initial",interval:5},r=t.function??{lazy:"very"};if(Array.isArray(e))return be(e.values(),n);if(typeof e=="function")return $n(e,r);if(typeof e=="object"){if(wn(e))return e.source;if(Pt(e)||ve(e))return be(e,n)}throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${typeof e}`)};function je(e,t){let n=t;return e.onValue(r=>{n=r}),{...e,last(){return n},resetCachedValue(){n=void 0}}}function $(e,t){const n=t.lazy??"initial",r=t.disposeIfSourceDone??!0,s=t.onValue??(d=>{}),o=b(e);let i;const a=t.debugLabel?`[${t.debugLabel}]`:"",c=()=>{i!==void 0&&(i(),i=void 0,t.onStop&&t.onStop())},l=F({...t,lazy:n,onStart:()=>{i===void 0&&(t.onStart&&t.onStart(),i=o.on(d=>{K(d)?d.signal==="done"?(c(),l.signal(d.signal,d.context),r&&l.dispose(`Upstream source ${a} has completed (${d.context??""})`)):l.signal(d.signal,d.context):A(d)&&s(d.value)}))},onStop:c});return l}function fo(e){const t=F(e);return je(t,e.initialValue)}function F(e){const t=e.lazy??"initial",n=e.onStop??(()=>{}),r=e.onStart??(()=>{});e.debugLabel&&`${e.debugLabel}`;const s=T({...e,onFirstSubscribe(){t!=="never"&&r()},onNoSubscribers(){t==="very"&&n()}});return t==="never"&&r(),s}function T(e={}){let t,n=!1,r=!1,s=!0;const o=e.onFirstSubscribe??void 0,i=e.onNoSubscribers??void 0,a=e.debugLabel?`[${e.debugLabel}]`:"",c=()=>{t!==void 0&&t.isEmpty&&(s||(s=!0,r=!1,i&&i()))},u=l=>{if(n)throw new Error(`Disposed, cannot subscribe ${a}`);t===void 0&&(t=new kt);const d=t.add(l);return s=!1,r||(r=!0,o&&o()),()=>{t?.remove(d),c()}};return{dispose:l=>{n||(t?.notify({value:void 0,signal:"done",context:`Disposed: ${l}`}),n=!0,e.onDispose&&e.onDispose(l))},isDisposed:()=>n,removeAllSubscribers:()=>{t?.clear(),c()},set:l=>{if(n)throw new Error(`${a} Disposed, cannot set`);t?.notify({value:l})},signal:(l,d)=>{if(n)throw new Error(`${a} Disposed, cannot signal`);t?.notify({signal:l,value:void 0,context:d})},on:l=>u(l),onValue:l=>u(m=>{A(m)&&l(m.value)})}}const Re=(e,t)=>{let n,r;if(typeof t=="string"&&(r={query:t}),typeof t=="object"&&("nodeName"in t?r={el:t}:r=t),r===void 0)throw new TypeError("Missing element as second parameter or option");if("el"in r)n=r.el;else if("query"in r)n=document.querySelector(r.query);else throw new TypeError("Options does not include 'el' or 'query' fields");if(n==null)throw new Error("Element could not be resolved.");const s=b(e),o=kr(r.asHtml?"innerHTML":"textContent",n);return s.onValue(a=>{o(a)})},L=e=>({on:e.on,dispose:e.dispose,isDisposed:e.isDisposed,onValue:e.onValue});function _e(e,t,n={}){const r=$(e,{...n,onValue(s){const o=t(s);r.set({value:s,annotation:o})}});return L(r)}function ze(e,t){const n=b(e),r=t(n);return fe({value:n,annotation:r})}function qe(e,t={}){const n=new Tr,r=t.quantity??0,s=t.returnRemainder??!0,o={...t,onStop(){if(s&&!n.isEmpty){const u=n.toArray();n.clear(),i.set(u)}},onValue(u){n.enqueue(u),r>0&&n.length>=r&&a(),c!==void 0&&c.runState==="idle"&&c.start()}},i=$(e,o),a=()=>{if(n.isEmpty)return;c!==void 0&&c.start();const u=n.toArray();n.clear(),setTimeout(()=>{i.set(u)})},c=t.elapsed?It(a,t.elapsed):void 0;return L(i)}function W(e,t,n={}){const r=n.traceInput??!1,s=n.traceOutput??!1,o=$(e,{lazy:"initial",...n,onValue(i){const a=t(i);r&&s?console.log(`Rx.Ops.transform input: ${JSON.stringify(i)} output: ${JSON.stringify(a)}`):r?console.log(`Rx.Ops.transform input: ${JSON.stringify(i)}`):s&&console.log(`Rx.Ops.transform output: ${JSON.stringify(a)}`),o.set(a)}});return L(o)}const An=e=>W(e,t=>{const n=[];for(const r in t){const s=t[r];dt(s)&&n.push([r,s])}return Object.fromEntries(n)});function Be(e,t={}){const n=T(),r=t.onSourceDone??"break",s=[],o=e.map(l=>b(l)),i=()=>{},a=o.map(l=>i),c=o.map(l=>!1),u=()=>{for(const l of a)l()};for(const[l,d]of o.entries())s[l]=void 0,a[l]=d.on(m=>{if(D(m)){if(c[l]=!0,a[l](),a[l]=i,r==="break"){u(),n.dispose("Source has completed and 'break' is set");return}c.includes(!1)||(u(),n.dispose("All sources completed"))}else A(m)&&(s[l]=m.value,n.set([...s]))});return{dispose:n.dispose,isDisposed:n.isDisposed,on:n.on,onValue:n.onValue}}function ae(e,t={}){const n=t.eq??ht,r=T(),s=T(),o=[];let i=e,a=!1;const c=f=>{const h=[...X(i??{},f,{...t,includeMissingFromA:!0})];h.length!==0&&(i=f,r.set(f),s.set(h))},u=(f,h)=>{for(const[p,y,w]of o)p(f)&&w.notify({fieldName:f,pattern:y,value:h})},l={asPartial:!0,includeParents:!0},d=f=>{if(i===void 0){i=f,r.set(i);for(const[h,p]of Object.entries(f))u(h,p);return i}else{const h=[...X(i,f,l)];if(h.length===0)return i;i={...i,...f},r.set(i),s.set(h);for(const p of h)u(p.path,p.value);return i}};return{dispose:f=>{a||(s.dispose(f),r.dispose(f),a=!0)},isDisposed(){return a},updateField:(f,h)=>{if(i===void 0)throw new Error("Cannot update value when it has not already been set");const p=Vt(i,f);if(Xn(p))throw Jn(p);if(n(p.value,h,f))return;let y=[...X(p.value,h,{...t,includeMissingFromA:!0})];y=y.map(j=>j.path.length>0?{...j,path:f+"."+j.path}:{...j,path:f});const w=Te(i,f,h,!0);i=w,r.set(w),s.set(y),u(f,h)},last:()=>i,on:r.on,onValue:r.onValue,onDiff:s.onValue,onField(f,h){const p=gr(f),y=new kt;o.push([p,f,y]);const w=y.add(h);return()=>y.remove(w)},set:c,update:d}}function ce(e,t={}){const n=t.disposeSources??!0,r=ae(void 0),s=t.onSourceDone??"break",o=t.emitInitial??!0;let i=!1;const a=new Map;for(const[f,h]of Object.entries(e)){const p="last"in h?h.last():void 0,y={source:b(h),done:!1,data:p,off:()=>{}};a.set(f,y)}const c=Object.fromEntries(Object.entries(a).map(f=>[f[0],f[1].source])),u=()=>Ir(a,f=>!f.done),l=()=>{for(const f of a.values())f.off()},d=()=>{const f={};for(const[h,p]of a)p.data!==void 0&&(f[h]=p.data);return f},m=()=>{i=!0;const f=d();r.set(f)},v=f=>{f.off=f.source.on(h=>{if(D(h)){if(f.done=!0,f.off(),f.off=()=>{},s==="break"){l(),r.dispose("Source has completed and 'break' is behaviour");return}u()||(l(),r.dispose("All sources completed"))}else A(h)&&(f.data=h.value,m())})};for(const f of a.values())v(f);return!i&&o&&m(),{...r,hasSource(f){return a.has(f)},replaceSource(f,h){const p=a.get(f);if(p===void 0)throw new Error(`Field does not exist: '${f}'`);p.off();const y=b(h);p.source=y,v(p)},setWith(f){const h={};for(const[p,y]of Object.entries(f)){const w=a.get(p);w!==void 0&&(Oe(w.source)&&(w.source.set(y),h[p]=y),w.data=y)}return h},sources:c,last(){return d()},dispose(f){if(l(),r.dispose(f),n)for(const h of a.values())h.source.dispose("Part of disposed mergeToObject")}}}function Tn(e,t){let n,r;bn(e)&&(r=n=e.last());const s=()=>{if(n===void 0&&r!==void 0)n=r,o.set(n);else if(n!==void 0&&r!==void 0){const i=t(n,r);n=i,o.set(i)}},o=$(e,{lazy:"very",debugLabel:"computeWithPrevious",onValue(i){r=i,s()}});return r&&s(),{...L(o),ping:()=>{r!==void 0&&s()}}}function In(e,t={}){const n=P(t.elapsed,50);let r;const s=It(()=>{const i=r;i&&(o.set(i),r=void 0)},n),o=$(e,{...t,onValue(i){r=i,s.start()}});return L(o)}function po(e){return t=>In(t,e)}const kn=e=>{let t=0;return W(e,n=>{const r=t===0?0:Date.now()-t;return t=Date.now(),r})};function le(e,t,n={}){const r=n.fallbackFieldValue,s=n.fallbackObject,o=$(e,{disposeIfSourceDone:!0,...n,onValue(i){let a;t in i?a=i[t]:s&&t in s&&(a=s[t]),a===void 0&&(a=r),a!==void 0&&o.set(a)}});return L(o)}function We(e,t,n){if(typeof t!="function")throw new TypeError("Param 'predicate' should be a function");const r=$(e,{...n,onValue(s){t(s)&&r.set(s)}});return L(r)}function Pn(e,t,n){if(typeof t!="function")throw new TypeError("Param 'predicate' should be a function");const r=$(e,{...n,onValue(s){t(s)||r.set(s)}});return L(r)}function xn(e,t={}){const n=t.amount??.1,r=t.snapAt??.99,s=we(n,t);return Tn(e,(o,i)=>{const a=s(o,i);return i>o&&a/i>=r?i:a})}function Ue(e,t){const n=St();return U(n,"max",e,t)}function Ce(e,t){const n=wt();return U(n,"min",e,t)}function Ge(e,t){const n=Et();return U(n,"average",e,t)}function Xe(e,t){const n=gt();return U(n,"sum",e,t)}function Je(e,t={}){const n=t.countArrayItems??!0,r=yt(n);return U(r,"tally",e,t)}function Dn(e,t,n){const r=bt(t,n);return U(r,"rank",e,n)}function U(e,t,n,r={}){const s=r.annotate;let o;const i=r.skipUndefined??!0,a=r.skipIdentical??!0,c=$(n,{...r,onValue(u){const l=e(u);if(!(l===void 0&&i)&&!(a&&l===o))if(o=l,s){const d={value:u};d[t]=l,c.set(d)}else c.set(l)}});return L(c)}const Vn=(...e)=>{const t=T(),n=[],r=s=>{for(const o of e)o.isDisposed||o.dispose(s);for(const o of n)o();t.dispose(s)};for(let s=0;s<e.length;s++)n.push(e[s].on(o=>{const i=s===e.length-1;A(o)?i?t.set(o.value):e[s+1].set(o.value):D(o)&&r("Upstream disposed")}));return{on:t.on,onValue:t.onValue,dispose(s){r(s)},isDisposed(){return t.isDisposed()}}};function Ln(e,t={}){const n=t.order??"default";if(!t.at&&!t.predicate)throw new Error("Options must have 'predicate' or 'at' fields");let r=o=>o;n==="random"?r=Yn:typeof n=="function"&&(r=o=>o.toSorted(n));const s=$(e,{onValue(o){if(o=r(o),t.predicate)for(const i of o)t.predicate(i)&&s.set(i);else t.at&&s.set(o.at(t.at))}});return s}const He=(e,t={})=>{const n=t.quantity??2,r=[],s=b(e);for(let o=0;o<n;o++)r.push($(s,{disposeIfSourceDone:!0,lazy:"initial"}));return r},Ke=(e,t)=>{const n=b(e),r={};for(const s of t)r[s]=$(n,{lazy:"initial",disposeIfSourceDone:!0});return r},Ye=(e,t,n={})=>{const r=n.match??"first",s=b(e);let o=!1;const i={};for(const u of Object.keys(t))i[u]=T();const a=()=>{if(!o){c(),o=!0;for(const u of Object.values(i))u.dispose("switcher source dispose")}},c=s.on(u=>{if(A(u)){for(const[l,d]of Object.entries(t))if(d(u.value)&&(i[l].set(u.value),r==="first"))break}else D(u)&&a()});return i};function ue(e,t={}){const n=t.onSourceDone??"break",r=t.finalValue??"undefined",s=P(t.maximumWait,2e3);let o;const i=[],a=e.map(p=>({finalData:void 0,done:!1,source:b(p),unsub:()=>{}})),c=()=>{for(const p of a)p.unsub(),p.unsub=()=>{}},u=()=>{for(let p=0;p<i.length;p++)if(!(n==="allow"&&a[p].done)&&i[p]===void 0)return!1;return!0},l=()=>a.some(p=>!p.done),d=()=>{for(let p=0;p<i.length;p++)r==="last"&&a[p].done||(i[p]=void 0)},m=()=>{v(`Sync timeout exceeded (${s.toString()})`)},v=p=>{o&&clearTimeout(o),c(),h.dispose(p)},f=()=>{o=setTimeout(m,s);for(const[p,y]of a.entries())i[p]=void 0,y.unsub=y.source.on(w=>{if(K(w)){if(w.signal==="done"){if(y.finalData=i[p],y.unsub(),y.done=!0,y.unsub=()=>{},r==="undefined"&&(i[p]=void 0),n==="break"){v(`Source '${p.toString()}' done, and onSourceDone:'break' is set`);return}if(!l()){v("All sources done");return}}return}i[p]=w.value,u()&&(h.set([...i]),d(),o&&clearTimeout(o),o=setTimeout(m,s))})},h=T({onFirstSubscribe(){c(),f()},onNoSubscribers(){o&&clearTimeout(o),c()}});return{dispose:h.dispose,isDisposed:h.isDisposed,on:h.on,onValue:h.onValue}}function fe(e,t={}){const n=Object.keys(e),r=Object.values(e),s=ue(r,t);return W(s,i=>$r(n,i))}function Ze(e,...t){const n=b(e),r=Process.flow(...t);return n.onValue(s=>{r(s)}),n}function Qe(e,t){const n=b(e);return n.onValue(r=>{t.set(r)}),n}const et=(e,...t)=>{for(const n of t)e=n(e);return e};function tt(e,t={}){const n=P(t.elapsed,0);let r=performance.now(),s;const o=$(e,{...t,onValue(a){s=a,i()}}),i=()=>{const a=performance.now();n>0&&a-r>n&&(r=a,s!==void 0&&o.set(s))};return L(o)}function nt(e,t){let n;const r=t.immediate??!0,s=t.repeat??!1,o=P(t.interval,1e3);if(!Sn(t))throw new Error("Param 'options' does not contain trigger 'value' or 'fn' fields");const i=()=>{const[c,u]=En(t);if(u)a.dispose("Trigger completed");else{if(a.isDisposed())return;a.set(c),s&&(n=setTimeout(i,o))}},a=$(e,{disposeIfSourceDone:!0,onValue(c){n&&clearTimeout(n),n=setTimeout(i,o),a.set(c)},onDispose(){n&&clearTimeout(n)}});return r&&!n&&(n=setTimeout(i,o)),a}function rt(e,t){let n;const r=b(e),s=t.abort,o=P(t,1e3),i=()=>{if(s?.aborted||r.isDisposed()){c();return}gn(r)&&r.ping(),n=setTimeout(i,o)},a=()=>{n&&clearTimeout(n)},c=r.on(u=>{A(u)?(a(),n=setTimeout(i,o)):D(u)&&(c(),a())});return n=setTimeout(i,o),r}function ho(e,t,n={}){const r=n.lazy??"initial",s=n.signal,o=b(e),i=n.gate??(m=>!0);let a,c;s&&s.addEventListener("abort",()=>{d(`Abort signal ${s.reason}`)},{once:!0});const u=T({onFirstSubscribe(){r!=="never"&&a===void 0&&l()},onNoSubscribers(){r==="very"&&a!==void 0&&(a(),a=void 0)}}),l=()=>{a=o.on(m=>{D(m)?d("Upstream closed"):K(m)?u.signal(m.signal):A(m)&&i(m.value)&&t.ping()}),c=t.on(m=>{D(m)?d("Downstream closed"):K(m)?u.signal(m.signal,m.context):A(m)&&u.set(m.value)})},d=m=>{u.dispose(m),a&&a(),c&&c()};return r==="never"&&l(),u}function On(e,t){let n=t.initial;const r=$(e,{...t,onValue(o){n=o,r.set(o)}});return{...L(r),last(){return n}}}const mo=(e,t={})=>{if(Array.isArray(e))return Mn(e,t)},Mn=(e,t={})=>{const n=t.lazy??"initial",r=t.signal,s=t.whenStopped??"continue",o=t.debugLifecycle??!1,i=[...e];if(n!=="very"&&s==="reset")throw new Error(`whenStopped:'reset' has no effect with 'lazy:${n}'. Use lazy:'very' instead.`);const a=P(t.interval,5);let c=0,u=i[0];const l=F({...t,lazy:n,onStart(){o&&console.log("Rx.readFromArray:onStart"),d.start()},onStop(){o&&console.log(`Rx.readFromArray:onStop. whenStopped: ${s} index: ${c}`),d.cancel(),s==="reset"&&(c=0)}}),d=Ae(()=>{if(r?.aborted)return l.dispose(`Signalled (${r.reason})`),!1;if(u=i[c],c++,l.set(u),c===i.length)return l.dispose("Source array complete"),!1},a);return n||d.start(),{dispose:l.dispose,isDisposed:l.isDisposed,isDone(){return c===i.length},last(){return u},on:l.on,onValue:l.onValue}};function Fn(e=[],t={}){const n=t.eq??xt,r=T(),s=T();let o=e,i=!1;const a=h=>{Q(o,h,n),o=h,r.set([...h])},c=(h,p)=>{o[h]=p,r.set([...o])},u=h=>{o=[...o,h],r.set([...o]);const p=["add",o.length-1,h];s.set([p])},l=h=>{const p=Kn(o,h);if(p.length===o.length)return;const y=Q(o,p,n);o=p,r.set([...o]),s.set(y.summary)},d=h=>{const p=o.filter(j=>!h(j)),y=o.length-p.length,w=Q(o,p,n);return o=p,r.set([...o]),s.set(w.summary),y},m=(h,p)=>{const y=Hn(o,h,p),w=Q(o,y,n);o=y,r.set([...o]),s.set(w.summary)};return{dispose:h=>{i||(r.dispose(h),i=!0)},isDisposed(){return i},last:()=>o,on:r.on,onArray:s.on,onValue:r.onValue,setAt:c,push:u,deleteAt:l,deleteWhere:d,insertAt:m,set:a}}function vo(e){let t=e;const n=T(),r=s=>{t=s,n.set(s)};return{dispose:n.dispose,isDisposed:n.isDisposed,last:()=>t,on:n.on,onValue:n.onValue,set:r}}function yo(e={}){const t=e.lazy??"initial",n=P(e.interval,1e3),r=e.amount??1,s=e.offset??0;let o=0,i=s;const a=l=>{u.dispose(l)},c=Ae(()=>{if(e.signal?.aborted)return a(`Aborted (${e.signal.reason})`),!1;if(u.set(i),i+=1,o++,o>=r)return a("Limit reached"),!1},n),u=F({onStart(){c.start()},onStop(){c.cancel()},onDispose(){c.cancel()},lazy:t});return u}function go(e,t,n={}){const r=n.ignoreIdentical??!0,s=n.eq??xt,o=ce(t),i=u=>{const l=c.last(),d=e(u);if(d!==void 0){if(r&&l!==void 0&&s(d,l))return d;c.set(d)}return d},a=$(o,{...n,onValue(u){i(u)}}),c=je(a,e(o.last()));return c}function bo(e,t,n,r,s={}){const o={};return o[n]=r,le(Nn(e,t,o,s),n,s)}function Nn(e,t,n,r={}){let s;if(typeof e=="string"){if(s=document.querySelector(e),s===null)throw new Error(`Target query did not resolve to an element. Query: '${e}'`)}else s=e;if(s===null)throw new Error("Param 'targetOrQuery' is null");const o=r.debugLifecycle??!1,i=r.debugFiring??!1;r.diff;const a=r.lazy??!1;n===void 0&&(n={});const c=ae(n,{deepEntries:!0});let u=!1,l=!1;const d=f=>{i&&console.log(`Reactive.event '${t}' firing '${JSON.stringify(f)}`),c.set(f)},m=()=>{u&&(u=!1,s.removeEventListener(t,d),o&&console.log(`Rx.From.event remove '${t}'`))},v=()=>{u||(u=!0,s.addEventListener(t,d),o&&console.log(`Rx.From.event add '${t}'`))};return a||v(),{last:()=>(a&&v(),c.last()),dispose:f=>{l||(l=!0,m(),c.dispose(f))},isDisposed(){return l},on:f=>(a&&v(),c.on(f)),onValue:f=>(a&&v(),c.onValue(f))}}function wo(e,t,n={}){let r;if(typeof e=="string"){if(r=document.querySelector(e),r===null)throw new Error(`Target query did not resolve to an element. Query: '${e}'`)}else r=e;if(r===null)throw new Error("Param 'targetOrQuery' is null");const s=n.debugLifecycle??!1,o=n.debugFiring??!1,i=n.fireInitial??!1;let a=0;const c=br(),u=F({lazy:n.lazy??"very",onStart(){r.addEventListener(t,l),s&&console.log(`Rx.From.eventTrigger add '${t}'`),i&&a===0&&((s||o)&&console.log("Rx.From.eventTrigger: firing initial"),l())},onStop(){r.removeEventListener(t,l),s&&console.log(`Rx.From.eventTrigger remove '${t}'`)}}),l=d=>{o&&console.log(`Rx.From.eventTrigger '${t}' triggered'`),u.set({sinceLast:c(),total:++a})};return u}function So(...e){return jn(e)}function jn(e,t={}){let n=[];const r=F({...t,onStart(){for(const s of e)n.push(s.onValue(o=>{r.set(o)}))},onStop(){for(const s of n)s();n=[]}});return r}function Eo(e){let t=e;const n=T(),r=s=>{t=s,n.set(s)};return{dispose:n.dispose,isDisposed:n.isDisposed,last:()=>t,on:n.on,onValue:n.onValue,set:r}}const Rn=Symbol("Rx"),_n=e=>{const t=ae(e);return{proxy:new Proxy(e,{set(r,s,o,i){const a=Array.isArray(r);if(a&&s==="length")return!0;if(typeof s=="string"&&t.updateField(s,o),a&&typeof s=="string"){const c=Number.parseInt(s);if(!Number.isNaN(c))return r[c]=o,!0}return r[s]=o,!0}}),rx:t}},$o=e=>{const t=Fn(e);return{proxy:new Proxy(e,{set(r,s,o,i){if(s==="length")return!0;if(typeof s!="string")throw new Error(`Expected numeric index, got type: ${typeof s} value: ${JSON.stringify(s)}`);const a=Number.parseInt(s);if(Number.isNaN(a))throw new Error(`Expected numeric index, got: '${s}'`);return t.setAt(a,o),r[a]=o,!0}}),rx:t}},Ao=e=>{const{proxy:t,rx:n}=_n(e),r=t;return r[Rn]=n,r};function To(e){const t=zn(e);return{dispose:t.dispose,isDisposed:t.isDisposed,on:t.on,onValue:t.onValue}}function zn(e){let t=()=>{};const n=ot({onFirstSubscribe(){t=e(n)},onNoSubscribers(){t&&t()}});return{...n,onValue:r=>n.on(s=>{A(s)&&r(s.value)})}}function Io(e){let t=e;const n=T(),r=s=>{t=s,n.set(s)};return{dispose:n.dispose,isDisposed:n.isDisposed,last:()=>t,on:n.on,onValue:n.onValue,set:r}}var qn={};V(qn,{array:()=>Mn,arrayObject:()=>Fn,arrayProxy:()=>$o,boolean:()=>vo,count:()=>yo,derived:()=>go,event:()=>Nn,eventField:()=>bo,eventTrigger:()=>wo,func:()=>$n,iterator:()=>be,merged:()=>So,mergedWithOptions:()=>jn,number:()=>Eo,object:()=>ae,objectProxy:()=>_n,objectProxySymbol:()=>Ao,observable:()=>To,observableWritable:()=>zn,of:()=>mo,string:()=>Io});function ko(e){const t=ot({onNoSubscribers(){e.removeEventListener("removed",n),e.removeEventListener("enqueue",r)},onFirstSubscribe(){e.addEventListener("removed",n),e.addEventListener("enqueue",r),t.set(e.toArray())}}),n=o=>{t.set(o.finalData)},r=o=>{t.set(o.finalData)};return{...t,set:o=>{e.enqueue(...o)}}}var Bn={};V(Bn,{asResponsive:()=>ko});function Po(e){let t=Ar();const n=T();return{dispose:n.dispose,isDisposed:n.isDisposed,graph:t,on:n.on,onValue:n.onValue}}async function st(e,t={}){const n=t.limit??Number.MAX_SAFE_INTEGER,r=P(t.maximumWait,10*1e3),s=t.underThreshold??"partial",o=[],i=b(e);return new Promise((c,u)=>{const l=()=>{if(clearTimeout(d),m(),o.length<n&&s==="throw"){u(new Error(`Threshold not reached. Wanted: ${n} got: ${o.length}. Maximum wait: ${r}`));return}if(o.length<n&&s==="fill")for(let v=0;v<n;v++)o[v]===void 0&&(o[v]=t.fillValue);c(o)},d=setTimeout(()=>{l()},r),m=i.on(v=>{D(v)?l():A(v)&&(o.push(v.value),o.length===n&&l())})})}async function Wn(e,t={}){const n=t.limit??Number.MAX_SAFE_INTEGER,r=t.maximumWait??5*1e3,s=await st(e,{limit:n,maximumWait:r,underThreshold:"partial"});if(t.limit&&s.length<t.limit)throw new Error(`Threshold not reached. Wanted: ${t.limit}, got ${s.length}`);return s}async function*xo(e){const t=b(e);let n=a=>{},r=a=>{};const s=()=>new Promise((a,c)=>{n=a,r=c});let o=s(),i=!0;for(t.on(a=>{A(a)?(n(a.value),o=s()):D(a)&&(i=!1,r("Source has completed"))});i;)yield await o}function g(e){return{source:b(e),enacts:{setHtmlText:t=>Re(e,t)},annotate:t=>{const n=_e(e,t);return g(n)},annotateWithOp:t=>{const n=ze(e,t);return g(n)},chunk:t=>g(qe(e,t)),debounce:(t={})=>g(In(e,t)),field:(t,n={})=>{const r=le(e,t,n);return g(r)},filter:(t,n)=>g(We(e,t,n)),combineLatestToArray:(t,n={})=>{const r=[e,...t];return g(Be(r,n))},combineLatestToObject:(t,n)=>{const r=n.name??"source",s={...t};return s[r]=e,g(ce(s,n))},min:(t={})=>g(Ce(e,t)),max:(t={})=>g(Ue(e,t)),average:(t={})=>g(Ge(e,t)),sum:(t={})=>g(Xe(e,t)),tally:(t={})=>g(Je(e,t)),split:(t={})=>He(e,t).map(r=>g(r)),splitLabelled:(...t)=>{const n=Ke(e,t);return it(n,s=>g(s.value))},switcher:(t,n={})=>{const r=Ye(e,t,n);return it(r,o=>g(o.value))},syncToArray:(t,n={})=>{const r=[e,...t].map(o=>b(o)),s=ue(r,n);return g(s)},syncToObject:(t,n={})=>{const r=n.name??"source",s={...t};return s[r]=e,g(fe(s,n))},tapProcess:(...t)=>(Ze(e,...t),g(e)),tapStream:t=>(Qe(e,t),g(e)),tapOps:(t,...n)=>(et(t,...n),g(t)),throttle:(t={})=>g(tt(e,t)),transform:(t,n={})=>g(W(e,t,n)),timeoutValue:t=>g(nt(e,t)),timeoutPing:t=>g(rt(e,t)),toArray:t=>st(e,t),toArrayOrThrow:t=>Wn(e,t),onValue:t=>{b(e).on(r=>{A(r)&&t(r.value)})}}}var Do={};V(Do,{Collections:()=>Bn,From:()=>qn,Ops:()=>Mo,Sinks:()=>Oo,annotate:()=>_e,annotateWithOp:()=>ze,average:()=>Ge,cache:()=>je,chunk:()=>qe,cloneFromFields:()=>An,combineLatestToArray:()=>Be,combineLatestToObject:()=>ce,computeWithPrevious:()=>Tn,debounce:()=>po,drop:()=>Pn,elapsed:()=>kn,field:()=>le,filter:()=>We,hasLast:()=>bn,initLazyStream:()=>F,initLazyStreamWithInitial:()=>fo,initStream:()=>T,initUpstream:()=>$,interpolate:()=>xn,isPingable:()=>gn,isReactive:()=>Z,isTrigger:()=>Sn,isTriggerFunction:()=>Fe,isTriggerGenerator:()=>Ne,isTriggerValue:()=>Me,isWrapped:()=>wn,isWritable:()=>Oe,manual:()=>ot,max:()=>Ue,messageHasValue:()=>A,messageIsDoneSignal:()=>D,messageIsSignal:()=>K,min:()=>Ce,opify:()=>I,pipe:()=>Vn,prepare:()=>Po,rank:()=>Dn,resolveSource:()=>b,resolveTriggerValue:()=>En,run:()=>Vo,setHtmlText:()=>Re,singleFromArray:()=>Ln,split:()=>He,splitLabelled:()=>Ke,sum:()=>Xe,switcher:()=>Ye,symbol:()=>Rn,syncToArray:()=>ue,syncToObject:()=>fe,takeNextValue:()=>Fo,tally:()=>Je,tapOps:()=>et,tapProcess:()=>Ze,tapStream:()=>Qe,throttle:()=>tt,timeoutPing:()=>rt,timeoutValue:()=>nt,to:()=>No,toArray:()=>st,toArrayOrThrow:()=>Wn,toGenerator:()=>xo,transform:()=>W,valueToPing:()=>ho,withValue:()=>On,wrap:()=>g,writable:()=>Lo});function Vo(e,...t){let n=b(e);for(const r of t)n=r(n);return n}function Lo(e,...t){let n=b(e);const r=n;for(const o of t)n=o(n);return{...n,set(o){if(Oe(r))r.set(o);else throw new Error("Original source is not writable")}}}function ot(e={}){const t=T(e);return{dispose:t.dispose,isDisposed:t.isDisposed,set(n){t.set(n)},on:t.on,onValue:t.onValue}}const Oo={setHtmlText:e=>t=>{Re(t,e)}},Mo={annotate:e=>I(_e,e),annotateWithOp:e=>I(ze,e),chunk:e=>t=>qe(t,e),cloneFromFields:()=>e=>An(e),combineLatestToArray:(e={})=>t=>Be(t,e),combineLatestToObject:(e={})=>t=>ce(t,e),drop:e=>I(Pn,e),elapsed:()=>I(kn),field:(e,t={})=>n=>le(n,e,t),filter:e=>I(We,e),interpolate:e=>I(xn,e),min:e=>I(Ce,e),max:e=>I(Ue,e),sum:e=>I(Xe,e),average:e=>I(Ge,e),tally:e=>I(Je,e),rank:(e,t)=>I(Dn,e,t),pipe:(...e)=>t=>{const r=[b(t),...e];return Vn(...r)},singleFromArray:(e={})=>t=>Ln(t,e),split:(e={})=>t=>He(t,e),splitLabelled:e=>t=>Ke(t,e),switcher:(e,t={})=>n=>Ye(n,e,t),syncToArray:(e={})=>t=>ue(t,e),syncToObject:(e={})=>t=>fe(t,e),tapProcess:e=>t=>Ze(t,e),tapStream:e=>t=>Qe(t,e),tapOps:(...e)=>t=>et(t,...e),throttle:e=>I(tt,e),timeoutValue:e=>t=>nt(t,e),timeoutPing:e=>t=>rt(t,e),transform:(e,t={})=>n=>W(n,e,t),withValue:e=>I(On,e)};async function Fo(e,t=1e3){const n=b(e);let r=()=>{},s;return new Promise((i,a)=>{r=n.on(c=>{s&&clearTimeout(s),A(c)?(r(),i(c.value)):D(c)&&(a(new Error(`Source closed. ${c.context??""}`)),r())}),s=setTimeout(()=>{s=void 0,r(),a(new Error(`Timeout waiting for value (${JSON.stringify(t)})`))},P(t))})}const No=(e,t,n,r=!1)=>{const s=e.on(o=>{if(A(o)){const i=n?n(o.value):o.value;t.set(i)}else D(o)&&(s(),r&&t.dispose(`Source closed (${o.context??""})`))});return s};export{Vr as a,wo as b,X as c,po as d,Nn as e,To as f,Vt as g,bn as h,T as i,K as j,A as m,ae as o,Pr as p,W as t,Te as u};
