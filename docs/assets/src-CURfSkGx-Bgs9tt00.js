import{n as z,c as g,d as I,_ as x,e as Kf,h as vo,F as Xf,v as mn,x as Qf,y as Qt,l as Hf,r as Ue,u as Yf,P as Ut,G as Zf,a as ed,k as Je,R as td,z as bo,m as rd,A as nd,H as X,M as so,I as dr,s as sd,J as od,N as id,L as Eo,K as ad,w as oo,C as io,O as it}from"./src-2eX6lIN8-VI_Nykma.js";function ht(e){return typeof e=="number"||typeof e=="string"||typeof e=="bigint"||typeof e=="boolean"}const $o=(e,r=null,n=new WeakSet,s="")=>{if(e===null)return e;if(typeof e!="object")throw new TypeError(`Param 'value' must be an object. Got type: ${typeof e}`);n.add(e);const o=Object.entries(e);for(const i of o)if(i[1]!==null&&typeof i[1]=="object"){if(n.has(i[1])){i[1]=r;continue}i[1]=$o(i[1],r,n,`${i[0]}.`)}return Object.fromEntries(o)},fe=e=>typeof e=="string"?e:JSON.stringify(e),ao=e=>{if(e===null)return"null";if(typeof e=="boolean"||typeof e=="number")return e.toString();if(typeof e=="string")return e;if(typeof e=="symbol")throw new TypeError("Symbol cannot be converted to string");try{return JSON.stringify(e)}catch(r){if(typeof e=="object")return JSON.stringify($o(e,"(circular)"));throw r}},uo=e=>{if(typeof e=="string")return e;const r=new Set;return JSON.stringify(e,(n,s)=>(r.add(n),s)),JSON.stringify(e,[...r].sort())},k=(e,r)=>e===r,Qv=(e,r)=>e===r?!0:fe(e)===fe(r),pn=(e,r)=>e===r?!0:uo(e)===uo(r),Hv=(e,r,n)=>JSON.stringify(e)===JSON.stringify(r),ud=(e,r,n=k)=>{const s=[],o=[],i=[];for(const u of e){let c=!1;for(const l of r)if(n(u,l)){c=!0;break}c?s.push(u):o.push(u)}for(const u of r){let c=!1;for(const l of e)n(u,l)&&(c=!0);c||i.push(u)}const a=o.length===0&&i.length===0;return{shared:s,isSame:a,a:o,b:i}};function cd(e,r,n){g(I(e,"positive","decimalPlaces"));const s=typeof r=="boolean"?r:!1;let o;if(e===0)o=Math.round;else{const i=Math.pow(10,e);s?o=a=>Math.ceil(a*i)/i:o=a=>Math.floor(a*i)/i}return typeof r=="number"?o(r):o}function R(e,r){if(ld(e)){if(typeof e=="number")return e;let n=e.millis??0;return n+=(e.hours??0)*60*60*1e3,n+=(e.mins??0)*60*1e3,n+=(e.secs??0)*1e3,n}else{if(typeof r<"u")return r;throw new Error(`Not a valid interval: ${JSON.stringify(e)}`)}}function ld(e){if(typeof e>"u"||e===null)return!1;if(typeof e=="number")return!(Number.isNaN(e)||!Number.isFinite(e));if(typeof e!="object")return!1;const r="millis"in e,n="secs"in e,s="mins"in e,o="hours"in e;return r&&!z(e.millis).success||n&&!z(e.secs).success||s&&!z(e.mins).success||o&&!z(e.hours).success?!1:!!(r||n||o||s)}const Mo=(e,r=2)=>{let n=0;if(typeof e=="function"){const o=e();return Mo(o)}else typeof e=="number"?n=e:typeof e=="object"&&(n=R(n));let s=R(n);return typeof s>"u"?"(undefined)":s<1e3?`${cd(r,s)}ms`:(s/=1e3,s<120?`${s.toFixed(1)}secs`:(s/=60,s<60?`${s.toFixed(2)}mins`:(s/=60,`${s.toFixed(2)}hrs`)))},fd=(e,r)=>e===r?0:e>r?1:-1,dd=(e,r)=>{if(e===void 0&&r===void 0)return 0;if(e===void 0)return 1;if(r===void 0)return-1;const n=ao(e),s=ao(r);return n<s?-1:n>s?1:0},$t=(e,r)=>typeof e=="number"&&typeof r=="number"?fd(e,r):dd(e,r);var hd={};x(hd,{addObjectEntriesMutate:()=>Yt,addValue:()=>gn,addValueMutate:()=>To,addValueMutator:()=>wn,deleteByValueCompareMutate:()=>Po,filterValues:()=>bn,findBySomeKey:()=>No,findEntryByPredicate:()=>ko,findEntryByValue:()=>Ao,findValue:()=>En,fromIterable:()=>Ro,fromObject:()=>jo,getClosestIntegerKey:()=>So,getOrGenerate:()=>$n,getOrGenerateSync:()=>qo,hasAnyValue:()=>vn,hasKeyValue:()=>zo,mapToArray:()=>Oo,mapToObjectTransform:()=>_o,mergeByKey:()=>Fo,some:()=>Zt,sortByValue:()=>Vo,sortByValueProperty:()=>xn,toArray:()=>Ht,toObject:()=>Io,transformMap:()=>Co,zipKeyValue:()=>hr});const So=(e,r)=>{if(r=Math.round(r),e.has(r))return r;{let n=1;for(;n<1e3;){if(e.has(r-n))return r-n;if(e.has(r+n))return r+n;n++}throw new Error(`Could not find target ${r.toString()}`)}},No=(e,r)=>{for(const n of r)if(e.has(n))return e.get(n)},zo=(e,r,n,s=k)=>e.has(r)?[...e.values()].some(i=>s(i,n)):!1,Po=(e,r,n=k)=>{for(const s of e.entries())n(s[1],r)&&e.delete(s[0])},ko=(e,r)=>{for(const n of e.entries())if(r(n[1],n[0]))return n},Ao=(e,r,n=k)=>{for(const s of e.entries())if(n(s[1],r))return s},To=(e,r,n,...s)=>{const o=e??new Map;return wn(o,r,n)(...s),o},gn=(e,r,n,...s)=>{const o=e===void 0?new Map:new Map(e);for(const i of s){const a=r(i);if(n!=="overwrite"&&o.has(a)){if(n==="throw")throw new Error(`Key '${a}' already in map`);if(n==="skip")continue}o.set(a,i)}return o},wn=(e,r,n="overwrite")=>(...s)=>{for(const o of s){const i=r(o);if(n!=="overwrite"&&e.has(i)){if(n==="throw")throw new Error(`Key '${i}' already in map`);if(n==="skip")continue}e.set(i,o)}return e},Vo=(e,r)=>{const n=r??$t;return[...e.entries()].sort((s,o)=>n(s[1],o[1]))},xn=(e,r,n)=>{const s=typeof n>"u"?$t:n;return[...e.entries()].sort((o,i)=>{const a=o[1],u=i[1];return s(a[r],u[r])})},vn=(e,r,n)=>[...e.entries()].some(o=>n(o[1],r));function*bn(e,r){for(const n of e.values())r(n)&&(yield n)}const Ht=e=>[...e.values()],Ro=(e,r=fe,n="overwrite")=>{const s=new Map;for(const o of e){const i=r(o);if(s.has(i)){if(n==="throw")throw new Error(`Key '${i}' is already used and new data will overwrite it. `);if(n==="skip")continue}s.set(i,o)}return s},jo=e=>{const r=new Map;if(Array.isArray(e))for(const n of e)Yt(r,n);else Yt(r,e);return r},Yt=(e,r)=>{const n=Object.entries(r);for(const[s,o]of n)e.set(s,o)},En=(e,r)=>[...e.values()].find(n=>r(n)),Zt=(e,r)=>[...e.values()].some(n=>r(n)),_o=(e,r)=>[...e].reduce((n,[s,o])=>{const i=r(o);return n[s]=i,n},{}),hr=(e,r)=>{if(e.length!==r.length)throw new Error("Keys and values arrays should be same length");return Object.fromEntries(e.map((n,s)=>[n,r[s]]))},Co=(e,r)=>new Map(Array.from(e,n=>[n[0],r(n[1],n[0])])),Io=e=>[...e].reduce((r,[n,s])=>(r[n]=s,r),{}),Oo=(e,r)=>[...e.entries()].map(n=>r(n[0],n[1])),Fo=(e,...r)=>{const n=new Map;for(const s of r)for(const[o,i]of s){let a=n.get(o);a=a?e(a,i):i,n.set(o,a)}return n},qo=(e,r)=>(n,s)=>{let o=e.get(n);return o!==void 0||(o=r(n,s),e.set(n,o)),o},$n=(e,r)=>async(n,s)=>{let o=e.get(n);if(o!==void 0)return o;if(o=await r(n,s),o===void 0)throw new Error("fn returned undefined");return e.set(n,o),o},yr=(e,r=0,n={})=>{let s=R(r,0);g(I(s,"positive","interval"));const o=n.fireBeforeWait??!1,i=n.onStartCalled,a=n.signal;let u=!1,c="idle",l=0,f=0,d=performance.now(),h=r??0,y=!1,p;const w=()=>{p!==void 0&&(globalThis.clearTimeout(p),p=void 0,l=0,d=NaN)},N=v=>{s===0?typeof requestAnimationFrame>"u"?p=globalThis.setTimeout(v,0):(p=void 0,requestAnimationFrame(v)):p=globalThis.setTimeout(v,s)},$=()=>{y||(y=!0,c!=="idle"&&(c="idle",w()))},T=async()=>{if(a?.aborted&&(c="idle"),c==="idle")return;c="running",l++,f++;const v=e(l,performance.now()-d),_=typeof v=="object"?await v:v;if(!y){if(c="scheduled",_!==void 0&&!_){$();return}y||N(T)}},O=()=>{if(u)throw new Error("Disposed");if(y=!1,i!==void 0)switch(i(l,performance.now()-d)){case"cancel":{$();return}case"reset":{K();return}case"dispose":{u=!0,$();return}}c==="idle"&&(l=0,d=performance.now(),c="scheduled",o?T():N(T))},K=()=>{if(u)throw new Error("Disposed");y=!1,l=0,d=NaN,c!=="idle"&&$(),O()};return{start:O,reset:K,cancel:$,get interval(){return h},get runState(){return c},get startCountTotal(){return f},get startCount(){return l},set interval(v){const _=R(v,0);g(I(_,"positive","interval")),s=_,h=v},get isDisposed(){return u},get elapsedMs(){return performance.now()-d}}},Oe=()=>{const e=performance.now();return()=>performance.now()-e},Yv=()=>{let e=performance.now();return()=>{const r=performance.now(),n=r-e;return e=r,n}},yd=()=>()=>Number.POSITIVE_INFINITY,md=(e,r)=>new Promise(n=>{const s=(...o)=>{e.removeEventListener(r,s),Array.isArray(o)&&o.length===1?n(o[0]):n(o)};e.addEventListener(r,s)});(typeof window>"u"||!("requestAnimationFrame"in window))&&typeof window>"u"&&(globalThis.requestAnimationFrame=e=>{setTimeout(e,1)});const B=e=>{const r=R(e,1),n=e.signal,s=e.value;return g(z(r,"positive","timeoutMs")),r===0?new Promise(o=>requestAnimationFrame(i=>{o(s)})):new Promise((o,i)=>{const a=()=>{clearTimeout(u),n?(n.removeEventListener("abort",a),i(new Error(n.reason))):i(new Error("Cancelled"))};n&&n.addEventListener("abort",a);const u=setTimeout(()=>{if(n?.removeEventListener("abort",a),n?.aborted){i(new Error(n.reason));return}o(s)},r)})},pd=()=>{let e=Number.MIN_SAFE_INTEGER;return n=>{const s=Array.isArray(n)?n:[n];for(const o of s){if(typeof o!="number")break;e=Math.max(o,e)}return e}},gd=()=>{let e=Number.MAX_SAFE_INTEGER;return n=>{const s=Array.isArray(n)?n:[n];for(const o of s){if(typeof o!="number")break;e=Math.min(o,e)}return e}},wd=()=>{let e=0;return n=>{const s=Array.isArray(n)?n:[n];for(const o of s)typeof o=="number"&&(e+=o);return e}},xd=()=>{let e=0,r=0;return s=>{const o=Array.isArray(s)?s:[s];for(const i of o)typeof i=="number"&&(r++,e+=i);return e/r}},vd=e=>{let r=0;return s=>(e&&Array.isArray(s)?r+=s.length:r++,r)};function bd(e,r={}){const n=r.includeType,s=r.emitEqualRanked??!1,o=r.emitRepeatHighest??!1;let i;return a=>{if(!(n&&typeof a!==n)){if(i===void 0)return i=a,i;{const u=e(a,i);if(u=="a")return i=a,i;if(u==="eq"&&s)return i;if(o)return i}}}}const Mt=e=>typeof e=="string"?e:JSON.stringify(e);function*Zv(e,r="."){for(;e.length>0;){yield e;const n=Md(e,r);if(n===e)break;e=n}}function*e0(e,r="."){for(;e.length>0;){yield e;const n=$d(e,r,{ifNoMatch:"original",fromEnd:!0});if(n===e)break;e=n}}const Ed=(e,r=15)=>{if(g(I(r,"aboveZero","maxLength")),typeof e!="string")throw new Error("Parameter 'source' is not a string");if(e.length>r&&e.length>3){if(r>15){const n=Math.round((r-2)/2);return e.slice(0,n)+"..."+e.slice(-n)}return e.slice(0,r)+"..."}return e},er=(e,r=20)=>e===void 0?"(undefined)":e===null?"(null)":Ed(JSON.stringify(e),r),t0=(e,r,n=0,s=e.length-1)=>{for(let o=n;o<=s;o++)if(e.codePointAt(o)===r)return o;return-1},r0=(e,r,n)=>e.slice(0,r)+e.slice(r+n),n0=(e,r)=>{if(g(I(r,"aboveZero","length")),e===null)throw new Error("source parameter null");if(typeof e!="string")throw new TypeError("source parameter not a string");const n=Math.ceil(e.length/r),s=[];let o=0;for(let i=0;i<n;i++)s.push(e.slice(o,o+r)),o+=r;return s},$d=(e,r,n={})=>Lo(e,r,n)[0],Md=(e,r,n={})=>Lo(e,r,n)[1],Lo=(e,r,n={})=>{if(e===void 0)throw new Error("Param 'source' is undefined");let s=n.fallback;const o=n.ifNoMatch??(s?"fallback":"original");if(o==="original"&&(s=e),o==="fallback"&&s===void 0)throw new Error("Fallback must be provided");const i=n.startPos??void 0,u=n.fromEnd??!1?e.lastIndexOf(r,i):e.indexOf(r,i);if(u<0&&o==="throw")throw new Error(`Match '${r}' not found in source.`);return u<0&&o==="original"?[e,e]:u<0&&o==="fallback"?[s,s]:[e.slice(0,u),e.slice(Math.max(0,u+r.length))]},s0=e=>{const r=s=>s.replaceAll(/([!$()*+./:=?[\\\]^{|}])/g,"\\$1");e=e.split("*").map(s=>r(s)).join(".*"),e="^"+e+"$";const n=new RegExp(e);return s=>n.test(s)},A=e=>typeof e!="object"||e===null?!1:Symbol.asyncIterator in e,mr=e=>typeof e!="object"||e===null?!1:Symbol.iterator in e;function*Do(e,r=0,n=Number.POSITIVE_INFINITY){if(n<r)throw new Error("Param 'end' should be more than 'start'");if(r<0)throw new Error("Param 'start' should be at least 0");let s=0;for(const o of e){if(s<r){s++;continue}if(s>n)break;yield o,s++}}function Bo(e,r,n){for(const s of e)n=r(n,s);return n}var Go={};x(Go,{asCallback:()=>Jo,chunks:()=>Wo,chunksOverlapping:()=>zd,concat:()=>Ko,dropWhile:()=>Xo,equals:()=>Ho,every:()=>Yo,fill:()=>Zo,filter:()=>ti,find:()=>ri,first:()=>Nd,flatten:()=>ni,forEach:()=>ei,fromArray:()=>pr,fromIterable:()=>ui,last:()=>Mn,map:()=>Sn,max:()=>si,min:()=>oi,next:()=>Pd,reduce:()=>Bo,repeat:()=>kd,slice:()=>Do,some:()=>ii,toArray:()=>ci,unique:()=>Dr,uniqueByValue:()=>Uo,until:()=>Qo,yieldNumber:()=>Sd,zip:()=>ai});function*Uo(e,r=fe,n=new Set){for(const s of e){const o=r(s);n.has(o)||(n.add(o),yield s)}}function Jo(e,r,n){for(const s of e)r(s);n&&n()}function Sd(e,r){return()=>{const n=e.next().value;return n===void 0?r:n}}function Nd(e){for(const r of e)return r}function Mn(e){let r;for(const n of e)r=n;return r}function*zd(e,r){if(r<=1)throw new Error("Size should be at least 2");let n=[];for(const s of e)n.push(s),n.length===r&&(yield n,n=[n.at(-1)]);n.length<=1||n.length>0&&(yield n)}function*Wo(e,r){let n=[];for(const s of e)n.push(s),n.length===r&&(yield n,n=[]);n.length>0&&(yield n)}function*Ko(...e){for(const r of e)yield*r}function*Xo(e,r){for(const n of e)r(n)||(yield n)}const Qo=(e,r)=>{for(const n of e){const s=r();if(typeof s=="boolean"&&!s)break}},Pd=e=>()=>{const r=e.next();if(!r.done)return r.value};function Ho(e,r,n){for(;;){const s=e.next(),o=r.next();if(n!==void 0){if(!n(s.value,o.value))return!1}else if(s.value!==o.value)return!1;if(s.done??o.done)return s.done&&o.done}}function Yo(e,r){for(const n of e)if(!r(n))return!1;return!0}function*Zo(e,r){for(const n of e)yield r}function ei(e,r){for(const n of e){const s=r(n);if(typeof s=="boolean"&&!s)break}}function*ti(e,r){for(const n of e)r(n)&&(yield n)}function ri(e,r){for(const n of e)if(r(n))return n}function*ni(e){for(const r of e)if(typeof r=="object"){if(Array.isArray(r))for(const n of r)yield n;else if(mr(r))for(const n of r)yield n}else yield r}function*Sn(e,r){for(const n of e)yield r(n)}function*si(e,r=(n,s)=>n>s){let n;for(const s of e){if(n===void 0){n=s,yield n;continue}r(s,n)&&(n=s,yield n)}return n}function*oi(e,r=(n,s)=>n>s){let n;for(const s of e)n===void 0&&(n=s,yield n),r(n,s)&&(n=s,yield n)}function ii(e,r){for(const n of e)if(r(n))return!0;return!1}function*kd(e,r){const n=typeof r=="number"?r:Number.POSITIVE_INFINITY,s=typeof r=="number"?void 0:r;let o=n;for(;;){for(const i of e())if(yield i,s?.aborted)break;if(Number.isFinite(n)&&(o--,o===0)||s?.aborted)break}}function*Dr(e){const r=[];let n=[];n=Array.isArray(e)?e:[e];for(const s of n)for(const o of s)r.includes(o)||(r.push(o),yield o)}function*ai(...e){const r=e.map(n=>n[Symbol.iterator]());for(;;){const n=r.map(s=>s.next());if(n.some(s=>s.done))return;yield n.map(s=>s.value)}}function*ui(e){for(const r of e)yield r}function ci(e,r={}){const n=[],s=Date.now(),o=r.while,i=r.limit??Number.POSITIVE_INFINITY,a=R(r.elapsed,Number.POSITIVE_INFINITY);for(const u of e){if(o&&!o(n.length)||n.length>=i||Date.now()-s>a)break;n.push(u)}return n}function*pr(e){for(const r of e)yield r}var Ad=class{#e=new Map;get(r){const n=this.#e.get(r);return n?[...n]:[]}size(r){const n=this.#e.get(r);return n?n.length:0}*iterateKey(r){const n=this.#e.get(r);n&&(yield*n.values())}*iterateValues(){for(const r of this.#e.keys())yield*this.iterateKey(r)}*iterateKeys(){yield*this.#e.keys()}addKeyedValues(r,...n){let s=this.#e.get(r);s||(s=[],this.#e.set(r,s)),s.push(...n)}deleteKeyValue(r,n){const s=this.#e.get(r);if(!s)return!1;const o=s.filter(i=>i!==n);return o.length===s.length?!1:(this.#e.set(r,o),!0)}clear(){this.#e.clear()}},me=class{#e=new Ad;#t=!1;dispose(){this.#t||this.clearEventListeners()}get isDisposed(){return this.#t}fireEvent(e,r){if(this.#t)throw new Error("Disposed");for(const n of this.#e.iterateKey(e))n(r,this)}addEventListener(e,r){if(this.#t)throw new Error("Disposed");this.#e.addKeyedValues(e,r)}removeEventListener(e,r){this.#t||this.#e.deleteKeyValue(e,r)}clearEventListeners(){this.#t||this.#e.clear()}},Td={};x(Td,{SimpleEventEmitter:()=>me});var li={};x(li,{asCallback:()=>zi,chunks:()=>fi,concat:()=>di,dropWhile:()=>hi,equals:()=>mi,every:()=>pi,fill:()=>gi,filter:()=>wi,find:()=>xi,flatten:()=>vi,forEach:()=>bi,fromArray:()=>Nn,fromIterable:()=>zn,last:()=>Ei,map:()=>$i,max:()=>Mi,min:()=>Si,nextWithTimeout:()=>ki,reduce:()=>Ni,repeat:()=>Vd,slice:()=>Pi,some:()=>Ai,toArray:()=>gr,unique:()=>Br,uniqueByValue:()=>Ti,until:()=>yi,withDelay:()=>Rd,zip:()=>Vi});async function*Nn(e,r=1){for(const n of e)yield n,await B(r)}async function*zn(e,r=1){for await(const n of e)yield n,await B(r)}async function*fi(e,r){let n=[];for await(const s of e)n.push(s),n.length===r&&(yield n,n=[]);n.length>0&&(yield n)}async function*di(...e){for await(const r of e)yield*r}async function*hi(e,r){for await(const n of e)r(n)||(yield n)}const yi=async(e,r)=>{for await(const n of e){const s=await r();if(typeof s=="boolean"&&!s)break}},Vd=async function*(e,r){const n=typeof r=="number"?r:Number.POSITIVE_INFINITY,s=typeof r=="number"?void 0:r;let o=n;for(;;){for await(const i of e())if(yield i,s?.aborted)break;if(Number.isFinite(n)&&(o--,o===0)||s?.aborted)break}};async function mi(e,r,n){const s=e[Symbol.asyncIterator](),o=r[Symbol.asyncIterator]();for(;;){const i=await s.next(),a=await o.next();if(n!==void 0){if(!n(i.value,a.value))return!1}else if(i.value!==a.value)return!1;if(i.done??a.done)return i.done&&a.done}}async function pi(e,r){for await(const n of e)if(!await r(n))return!1;return!0}async function*gi(e,r){for await(const n of e)yield r}async function*wi(e,r){for await(const n of e)await r(n)&&(yield n)}async function xi(e,r){for await(const n of e)if(await r(n))return n}async function*vi(e){for await(const r of e)if(typeof r=="object"){if(Array.isArray(r))for(const n of r)yield n;else if(A(r))for await(const n of r)yield n;else if(mr(r))for(const n of r)yield n}else yield r}const bi=async function(e,r,n={}){const s=n.interval;if(Array.isArray(e))for(const o of e){const i=await r(o);if(typeof i=="boolean"&&!i)break;s&&await B(s)}else for await(const o of e){const i=await r(o);if(typeof i=="boolean"&&!i)break;s&&await B(s)}};async function Ei(e,r={}){const n=r.abort;let s;for await(const o of e){if(n?.aborted)return;s=o}return s}async function*$i(e,r){for await(const n of e)yield r(n)}async function*Mi(e,r=((n,s)=>n>s)){let n;for await(const s of e){if(n===void 0){n=s,yield n;continue}r(s,n)&&(n=s,yield s)}}async function*Si(e,r=(n,s)=>n>s){let n;for await(const s of e){if(n===void 0){n=s,yield n;continue}r(n,s)&&(n=s,yield s)}return n}async function Ni(e,r,n){for await(const s of e)n=r(n,s);return n}async function zi(e,r,n){for await(const s of e)r(s);n&&n()}async function*Pi(e,r=0,n=Number.POSITIVE_INFINITY){console.log(`Async slice start: ${r}`);const s=e[Symbol.asyncIterator]();if(n<r)throw new Error("Param 'end' should be more than 'start'");for(;r>0;r--,n--)await s.next();for await(const o of e)if(n-- >0)yield o;else break}async function*Rd(e,r){for(const n of e)await B(r),yield n}async function ki(e,r){const n=R(r,1e3),s=await Promise.race([(async()=>{await B({millis:n,signal:r.signal})})(),(async()=>await e.next())()]);if(s===void 0)throw new Error("Timeout");return s}async function Ai(e,r){for await(const n of e)if(await r(n))return!0;return!1}async function gr(e,r={}){const n=[],s=e[Symbol.asyncIterator](),o=Date.now(),i=r.limit??Number.POSITIVE_INFINITY,a=r.while,u=R(r.elapsed,Number.POSITIVE_INFINITY);for(;n.length<i&&Date.now()-o<u&&!(a&&!a(n.length));){const c=await s.next();if(c.done)break;n.push(c.value)}return n}async function*Br(e){const r=[],n=Array.isArray(e)?e:[e];for await(const s of n)for await(const o of s)r.includes(o)||(r.push(o),yield o)}async function*Ti(e,r=fe,n=new Set){for await(const s of e){const o=r(s);n.has(o)||(n.add(o),yield s)}}async function*Vi(...e){const r=e.map(n=>n[Symbol.asyncIterator]());for(;;){const n=await Promise.all(r.map(s=>s.next()));if(n.some(s=>s.done))return;yield n.map(s=>s.value)}}function Gr(e){return"_type"in e?e._type==="GenFactoryNoInput":!1}function*jd(e){yield e}async function*_d(e){yield e,await B(1)}function C(e){if(Array.isArray(e)){const r=e.values();return r._name="arrayInput",r}else{if(typeof e=="number"||typeof e=="boolean"||typeof e=="string")return jd(e);if(typeof e=="function")return e()}return e}function Pn(e){if(e!==void 0)return Array.isArray(e)?Nn(e):typeof e=="number"||typeof e=="boolean"||typeof e=="string"?_d(e):typeof e=="function"?e():A(e)?e:zn(e)}function Cd(e){if(typeof e=="string"){const r=document.querySelector(e);if(!r)throw new Error(`Element not found '${e}'`);return r}return e}var Ri={};x(Ri,{perValue:()=>Od,query:()=>Fd});const Id=e=>{const r=e??(s=>s),n=new Map;return{has(s){return n.has(r(s))},get(s){return n.get(r(s))},set(s,o){n.set(r(s),o)},entries(){return n.entries()},delete(s){n.delete(s)}}};function Od(e={}){const r=e.byReference,n=e.tagName??"div";if(r&&e.key)throw new Error("byReference and key options are mutually exclusive");const s=r?void 0:e.key??fe,o=Id(s),i=e.parentEl??document.body,a=Cd(i),u=new Set;async function*c(l){for await(const f of C(l)){let d=o.get(f);d||(d=document.createElement(n),o.set(f,d),e.beforeInsert&&e.beforeInsert(d),a.append(d),e.afterInsert&&e.afterInsert(d)),u.add(d),yield{el:d,value:f}}for(const[f,d]of o.entries())u.has(d)||(e.beforeRemove&&e.beforeRemove(d),d.remove(),o.delete(f))}return c._name="dom.perValue",c}function Fd(e={}){const r=e.baseElement??document;async function*n(s){const o=C(s);for await(const i of o)for(const a of r.querySelectorAll(i))yield a}return n._name="dom.query",n}var ji={};x(ji,{average:()=>Ji,chunk:()=>Ki,debounce:()=>qi,delay:()=>Fi,drop:()=>Qi,duration:()=>Oi,filter:()=>Xi,max:()=>Bi,min:()=>Di,rank:()=>Gi,rankArray:()=>Ui,reduce:()=>Ii,sum:()=>Wi,take:()=>Ci,tally:()=>Li,transform:()=>_i});function _i(e){async function*r(n){n=C(n);for await(const s of n)yield e(s)}return r._name="transform",r}function Ci(e){async function*r(n){n=C(n);let s=0;for await(const o of n){if(++s>e)break;yield o}}return r._name="take",r}function Ii(e){async function*r(n){n=C(n);for await(const s of n)yield e(s)}return r._name="reduce",r}function Oi(e){const r=R(e,0);async function*n(s){s=C(s);const o=Oe();for await(const i of s){if(o()>r)break;yield i}}return n._name="duration",n}function Fi(e){const r=R(e.before,0),n=R(e.after,0);async function*s(o){o=C(o);for await(const i of o)r>0&&await B(r),yield i,n>0&&await B(n)}return s._name="delay",s}function qi(e){const r=R(e,0);async function*n(s){s=C(s);let o=Oe();for await(const i of s)o()<r||(yield i,o=Oe())}return n._name="debounce",n}function Li(e=!0){async function*r(n){n=C(n);const s=vd(e);for await(const o of n)yield s(o)}return r._name="tally",r}function Di(){async function*e(r){r=C(r);const n=gd();for await(const s of r){const o=n(s);o!==void 0&&(yield o)}}return e._name="min",e}function Bi(){async function*e(r){r=C(r);const n=pd();for await(const s of r){const o=n(s);o!==void 0&&(yield o)}}return e._name="max",e}function Gi(e,r={}){async function*n(s){s=C(s);const o=bd(e,r);for await(const i of s){const a=o(i);a!==void 0&&(yield a)}}return n._name="rank",n}function Ui(e,r={}){const n=r.includeType,s=r.emitEqualRanked??!1,o=r.emitRepeatHighest??!1,i=r.withinArrays??!1;async function*a(u){u=C(u);let c;for await(const l of u){let f=!1;i&&(c=void 0);for(const d of l)if(!(n&&typeof d!==n))if(c===void 0)c=d,f=!0;else{const h=e(d,c);h=="a"?(c=d,f=!0):(h==="eq"&&s||o)&&(f=!0)}f&&c&&(yield c)}}return a._name="rankArray",a}function Ji(){async function*e(r){r=C(r);const n=xd();for await(const s of r){const o=n(s);o!==void 0&&(yield o)}}return e._name="average",e}function Wi(){async function*e(r){r=C(r);const n=wd();for await(const s of r){const o=n(s);o!==void 0&&(yield o)}}return e._name="total",e}function Ki(e,r=!0){g(I(e,"aboveZero","size"));async function*n(s){s=C(s);let o=[];for await(const i of s)o.push(i),o.length>=e&&(yield o,o=[]);r&&o.length>0&&(yield o)}return n._name="chunk",n}function Xi(e){async function*r(n){n=C(n);for await(const s of n)e(s)&&(yield s)}return r._name="filter",r}function Qi(e){async function*r(n){n=C(n);for await(const s of n)e(s)||(yield s)}return r._name="drop",r}function qd(e,r=5){async function*n(){for(const s of e)await B(r),yield s}return n._name="fromArray",n._type="GenFactoryNoInput",n}function Ld(e,r){async function*n(){for(;;)yield await md(e,r)}return n._name="event",n._type="GenFactoryNoInput",n}function Hi(e){async function*r(){for(;;){const n=await e();if(typeof n>"u")break;yield n}}return r._name="fromFunction",r._type="GenFactoryNoInput",r}function Dd(e){async function*r(){for await(const n of e)yield n}return r._name="fromIterable",r._type="GenFactoryNoInput",r}function Bd(e){const r=R(e.interval,0),n=e.asClockTime??!1,s=e.loops??Number.MAX_SAFE_INTEGER;let o=0;const i=R(e.elapsed,Number.MAX_SAFE_INTEGER);async function*a(){const u=Oe();for(;o<s&&u()<i;){yield n?Date.now():u();const c=o*r-u();await B(Math.max(0,r+c)),o++}}return a._name="timestamp",a._type="GenFactoryNoInput",a}var Yi={};x(Yi,{array:()=>qd,event:()=>Ld,func:()=>Hi,iterable:()=>Dd,timestamp:()=>Bd});async function Gd(e,r){const n=typeof r=="function"?r():r;for await(const s of n)e.push(s)}async function Ud(e,r={}){const n=typeof e=="function"?e():e;return gr(n,r)}async function Jd(e,r,n){const s=typeof e=="function"?e():e;for await(const o of s)r(o);n&&n()}function Wd(e){let r;const n=typeof e=="function"?e():e;async function s(){const o=await n.next();if(!o.done)return r=o.value,r}return s}function Kd(e,r){let n=r,s=!1;const o=typeof e=="function"?e():e;function i(){return s||(s=!0,o.next().then(a=>{n=a.value,s=!1}).catch(a=>{throw s=!1,a})),n}return i}async function*Zi(e,r={}){const n=r.onSourceDone??"break",s=r.finalValue??"undefined",o=r.afterEmit??"last",i=e.map((f,d)=>({waiting:void 0,index:d,gen:C(f),done:!1,lastValue:void 0})),a=()=>!i.some(f=>!f.done),u=()=>i.some(f=>f.waiting!==void 0),c=f=>!f.some(d=>d!==void 0);let l=[];for(;;){const f=[];for(const p of i){if(p.done)continue;if(p.waiting!==void 0){f.push(p.waiting);continue}const w=Promise.resolve((async()=>{if(p.done)return p;const N=await p.gen.next();return p.waiting=void 0,N.done?(p.done=!0,s==="undefined"&&(p.lastValue=void 0)):p.lastValue=N.value,p})());p.waiting=w,f.push(w)}const d=await Promise.race(f);if("done"in d){if(d.done&&n==="break")break}else throw new Error("Missing 'done' property");const h=i.map(p=>p.lastValue);if(h.length===0)return;const y=c(h);if(y&&!u())return;if(!Kf(l,h)&&!y&&(l=h,yield h),o==="undefined")for(const p of i)p.waiting===void 0&&(p.lastValue=void 0);if(a())break}}async function*ea(e,r={}){const n=r.onSourceDone??"break",s=r.finalValue??"undefined",o=r.afterEmit??"last",i=new Map;for(const[d,h]of Object.entries(e))i.set(d,{gen:C(h),done:!1,lastValue:void 0,waiting:void 0,key:d});const a=()=>!Zt(i,d=>!d.done),u=()=>Zt(i,d=>d.waiting!==void 0),c=d=>{for(const h of Object.values(d))if(h!==void 0)return!1;return!0},l=()=>{const d={};for(const[h,y]of i)d[h]=y.lastValue;return d};let f;for(;;){const d=[];for(const w of i.values()){if(w.done)continue;if(w.waiting!==void 0){d.push(w.waiting);continue}const N=Promise.resolve((async()=>{if(w.done)return w;const $=await w.gen.next();return w.waiting=void 0,$.done?(w.done=!0,s==="undefined"&&(w.lastValue=void 0)):w.lastValue=$.value,w})());w.waiting=N,d.push(N)}const h=await Promise.race(d);if("done"in h){if(h.done&&n==="break")break}else throw new Error("Result missing 'done' property");const y=l(),p=c(y);if(p&&!u())return;if(!pn(f,y)&&!p&&(f=y,yield y),o==="undefined")for(const w of i.values())w.waiting===void 0&&(w.lastValue=void 0);if(a())break}}const co=e=>e._name??e.name;function Xd(){const e=[];let r;const n=o=>{o===void 0&&(o=r);let i=Pn(o);for(const a of e)if(i===void 0)if(Gr(a))i=a();else throw new Error(`Function '${co(a)}' requires input. Provide it to the function, or call 'input' earlier.`);else i=a(i);return i},s={rankArray:(o,i)=>(e.push(Ui(o,i)),s),rank:(o,i)=>(e.push(Gi(o,i)),s),transform:o=>(e.push(_i(o)),s),reduce:o=>(e.push(Ii(o)),s),drop:o=>(e.push(Qi(o)),s),delay:o=>(e.push(Fi(o)),s),duration:o=>(e.push(Oi(o)),s),debounce:o=>(e.push(qi(o)),s),fromFunction:o=>(e.push(Hi(o)),s),take:o=>(e.push(Ci(o)),s),chunk:(o,i=!0)=>(e.push(Ki(o,i)),s),filter:o=>(e.push(Xi(i=>o(i))),s),min:()=>(e.push(Di()),s),max:()=>(e.push(Bi()),s),average:()=>(e.push(Ji()),s),sum:()=>(e.push(Wi()),s),tally:o=>(e.push(Li(o)),s),input(o){return r=o,s},asGenerator:n,asAsync(o){let i=o??r;for(const a of e)if(i===void 0&&Gr(a))i=a();else{if(i===void 0)throw new Error(`Function '${co(a)}' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);i=a(i)}return s},asArray:async o=>{const i=n(o);return await gr(i)},firstOutput:async o=>(await n(o).next()).value,lastOutput:async o=>{const i=n(o);let a;for await(const u of i)a=u;return a}};return s}var Qd=class{#e=[];enqueue(r){this.#e.push(r)}dequeue(){return this.#e.shift()}};async function*Hd(...e){const r=e.map(u=>Pn(u)),n=new Qd;let s=0;const o=async u=>{if(u===void 0){s++;return}const c=await u.next();c.done?s++:(n.enqueue(c.value),setTimeout(()=>o(u),1))};for(const u of r)setTimeout(()=>o(u),1);const i=10;let a=1;for(;s<r.length;){const u=n.dequeue();u===void 0?a=Math.min(a+1,10):(yield u,a=1),await B(i*a)}}async function*ta(...e){let r;for(const n of e)r=typeof n=="function"?n(r??[]):C(n);if(r!==void 0)for await(const n of r)yield n}async function*Yd(e,r,n,s,o,i,a){let u;const c=arguments;for(const l of c)typeof l=="function"?u=l(u??[]):u=C(l);if(u!==void 0)for await(const l of u)yield l}function Zd(...e){return n=>ta(n,...e)}async function eh(e,r){return(await e([r]).next()).value}async function*th(e,r={}){const n=r.onSourceDone??"break",s=R(r.maximumWait,2e3),o=r.finalValue??"undefined",i=e.map(f=>({seq:0,lastValue:void 0,gen:C(f),done:!1})),a={millis:s};let u=0;const c=()=>!i.some(f=>!f.done);let l=!0;for(;l;){u++;for(const f of i){if(f.done){f.seq=u;continue}const d=await ki(f.gen,a);if(d.done){if(f.done=!0,f.seq=u,o==="undefined"&&(f.lastValue=void 0),n==="break")return}else f.lastValue=d.value,f.seq=u}if(l){const f=i.filter(d=>d.seq===u).map(d=>d.lastValue);if(f.length===0||!f.some(d=>typeof d<"u"))return;yield f}c()&&(l=!1)}}var ra={};x(ra,{Dom:()=>Ri,From:()=>Yi,Links:()=>ji,addToArray:()=>Gd,asArray:()=>Ud,asCallback:()=>Jd,asPromise:()=>Wd,asValue:()=>Kd,combineLatestToArray:()=>Zi,combineLatestToObject:()=>ea,isGenFactoryNoInput:()=>Gr,lazy:()=>Xd,mergeFlat:()=>Hd,prepare:()=>Zd,resolveToAsyncGen:()=>Pn,resolveToGen:()=>C,run:()=>Yd,runN:()=>ta,single:()=>eh,syncToArray:()=>th});const rh=(e,r)=>{let n,s=Number.MIN_SAFE_INTEGER;for(const o of e){const i=r(o);i>=s&&(s=i,n=o)}return n},nh=(e,r)=>{let n,s=Number.MAX_SAFE_INTEGER;for(const o of e){const i=r(o);i<=s&&(s=i,n=o)}return n},sh=(e,r,n)=>{const s=ud(e,r,n);return s.a.length===0&&s.b.length===0},oh=e=>{const r=R(e.delay,10);let n;const s=e.onValue;let o="stopped";const i=yr(async()=>{if(n){const d=await n.next();if(d.done)return o="stopped",!1;const h=s(d.value);return typeof h=="boolean"?(h||(o="stopped"),h):!0}else return o="stopped",!1},r),a=()=>{o!=="stopped"&&(n=void 0,i.cancel(),o="stopped")},u=()=>{o!=="paused"&&(i.cancel(),o="paused")},c=()=>{o!=="running"&&(n||l(),o="running",i.start())},l=()=>{if(e.iterator)n=e.iterator();else throw new Error("No source iterator")};return{start:c,cancel:a,restart:()=>{l(),c()},pause:u,get state(){return o}}},ih=(e,r)=>{const n=[],s=[];let o=!1;const i=l=>{n.length>0?n.shift()(...l):s.push(l)},a=()=>new Promise(l=>{if(s.length>0){const f=s.shift();l(...f)}else n.push(l)}),u=(...l)=>{i(l)};return e.addEventListener(r,u),{next:async()=>o?{done:!0,value:void 0}:{done:!1,value:await a()},return:async()=>(o=!0,e.removeEventListener(r,u),{done:!0,value:void 0}),throw:async l=>(o=!0,{done:!0,value:Promise.reject(new Error(l))})}},ah=(e,r={})=>{if(typeof e>"u")throw new Error("Param 'data' is undefined");if(Array.isArray(e))return vo(e,r);if(mr(e))return uh(e,r);throw new Error("Param 'data' is neither an array nor iterable")};function uh(e,r={}){let n=0;const s=r.nonNumbers??"ignore";let o=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,a=0;for(let u of e){if(typeof u!="number"||Number.isNaN(u)){if(s==="throw")throw new TypeError(`Data contains something not a number. Got type '${typeof u}'`);if(s==="nan"&&(u=NaN),s==="ignore")continue}n+=u,a++,o=Math.min(o,u),i=Math.max(i,u)}return{avg:n/a,total:n,max:i,min:o,count:a}}function ch(e,r={}){let n=0,s=0;const o=r.nonNumbers??"ignore";for(let i of e){if(typeof i!="number"||Number.isNaN(i)){if(o==="throw")throw new TypeError(`Data contains something not a number. Got type '${typeof i}'`);if(o==="nan"&&(i=NaN),o==="ignore")continue}s+=i,n++}return s/n}var lh={};x(lh,{Async:()=>li,Chains:()=>ra,Sync:()=>Go,asCallback:()=>jh,chunks:()=>hh,combineLatestToArray:()=>Zi,combineLatestToObject:()=>ea,computeAverage:()=>ch,concat:()=>ph,dropWhile:()=>fh,equals:()=>kh,every:()=>Ph,fill:()=>mh,filter:()=>yh,find:()=>gh,flatten:()=>bh,forEach:()=>wh,fromArray:()=>vh,fromEvent:()=>ih,fromFunction:()=>Vh,fromFunctionAwaited:()=>Rh,fromIterable:()=>Th,hasEqualValuesShallow:()=>sh,isAsyncIterable:()=>A,isIterable:()=>mr,iteratorController:()=>oh,last:()=>yt,map:()=>xh,max:()=>Jt,maxScore:()=>rh,min:()=>na,minScore:()=>nh,numbersCompute:()=>ah,reduce:()=>$h,slice:()=>Mh,some:()=>Eh,toArray:()=>zh,unique:()=>Sh,uniqueByValue:()=>Nh,until:()=>dh,zip:()=>Ah});function na(e,r=(n,s)=>n>s){return A(e)?Si(e,r):oi(e,r)}function Jt(e,r=(n,s)=>n>s){return A(e)?Mi(e,r):si(e,r)}function fh(e,r){return A(e)?hi(e,r):Xo(e,r)}function dh(e,r){if(A(e))return yi(e,r);Qo(e,r)}function hh(e,r){return A(e)?fi(e,r):Wo(e,r)}function yh(e,r){return A(e)?wi(e,r):ti(e,r)}function mh(e,r){return A(e)?gi(e,r):Zo(e,r)}function ph(...e){return A(e[0])?di(...e):Ko(...e)}function gh(e,r){return A(e)?xi(e,r):ri(e,r)}function wh(e,r,n={}){if(A(e))return bi(e,r,n);ei(e,r)}function xh(e,r){return A(e)?$i(e,r):Sn(e,r)}function vh(e,r){return r===void 0?pr(e):Nn(e,r)}function bh(e){return A(e)?vi(e):ni(e)}function Eh(e,r){return A(e)?Ai(e,r):ii(e,r)}function yt(e){return A(e)?Ei(e):Mn(e)}function $h(e,r,n){return A(e)?Ni(e,r,n):Bo(e,r,n)}function Mh(e,r=0,n=Number.POSITIVE_INFINITY){return A(e)?Pi(e,r,n):Do(e,r,n)}function Sh(e){return Array.isArray(e)?e.length===0?pr([]):A(e[0])?Br(e):Dr(e):A(e)?Br(e):Dr(e)}function*Nh(e,r=fe,n=new Set){yield*A(e)?Ti(e,r,n):Uo(e,r,n)}function zh(e,r={}){return A(e)?gr(e,r):ci(e,r)}function Ph(e,r){return A(e)?pi(e,r):Yo(e,r)}function kh(e,r,n){return A(e)&&A(r)?mi(e,r,n):Ho(e,r,n)}function Ah(...e){return e.length===0?pr([]):A(e[0])?Vi(...e):ai(...e)}function Th(e,r){return A(e)||r!==void 0?zn(e,r):ui(e)}function*Vh(e){for(;;)yield e()}async function*Rh(e){for(;;)yield await e()}function jh(e,r,n){if(A(e))return zi(e,r);Jo(e,r)}const Dt=(e,r=!1)=>n=>{const s=n.toSorted((o,i)=>$t(o[e],i[e]));return r?s.reverse():s},_h=e=>{switch(e){case"value":return Dt(1,!1);case"value-reverse":return Dt(1,!0);case"key":return Dt(0,!1);case"key-reverse":return Dt(0,!0);default:throw new Error(`Unknown sorting value '${e}'. Expecting: value, value-reverse, key or key-reverse`)}},kn=e=>typeof e!="object"||e===null?!1:"on"in e&&"onValue"in e,sa=e=>kn(e)?"last"in e&&e.last()!==void 0:!1,Ch=(e,r)=>(n,s)=>{let o=e.get(n);return o!==void 0||(o=r(n,s),e.set(n,o)),o},We=(e,r="log",n)=>s=>{s===void 0?s="(undefined)":typeof s=="object"&&(s=JSON.stringify(s));const o=n??e;switch(r){case"log":{console.log(`%c${e} ${s}`,`color: ${oa(o)}`);break}case"warn":{console.warn(e,s);break}case"error":{console.error(e,s);break}}},Ur=(e,r=!0,n)=>r?{log:We(e,"log",n),warn:We(e,"warn",n),error:We(e,"error",n)}:{log:s=>{},warn:We(e,"warn",n),error:We(e,"error",n)},An=(e,r={})=>{if(e===void 0||typeof e=="boolean"&&!e)return o=>{};const n=r.category??"",s=r.kind??void 0;return typeof e=="boolean"?o=>{const i=typeof o=="string"?{msg:o}:o,a=i.kind??s,u=i.category??n;let c=i.msg;switch(u&&(c=`[${u}] ${c}`),a){case"error":{console.error(c);break}case"warn":{console.warn(c);break}case"info":{console.info(c);break}default:console.log(c)}}:e};let Ih=0;const oa=Ch(new Map,()=>`hsl(${++Ih*137.508},50%,75%)`),Oh=(e=!0,r=500)=>{let n=0,s=0,o=performance.now();return()=>{if(n++>=r){const i=performance.now()-o;o=performance.now(),n=0,s=Math.floor(r/i*1e3),e&&console.log(`fps: ${s}`)}return s}},tr=e=>typeof e=="string"?e:e instanceof Error?e.message:e;var Fh={};x(Fh,{fpsCounter:()=>Oh,getErrorMessage:()=>tr,logColours:()=>oa,logSet:()=>Ur,logger:()=>We,resolveLogOption:()=>An});async function qh(e,...r){if(typeof e=="object")if("next"in e){const n=e[Symbol.toStringTag];if(n==="Generator"||n=="Array Iterator"){const s=e.next();return"done"in s&&"value"in s?s.value:s}else if(n==="AsyncGenerator"){const s=await e.next();return"done"in s&&"value"in s?s.value:s}else throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${n}'`)}else if(kn(e)){if(sa(e))return e.last();throw new Error("Reactive does not have last value")}else return e;else return typeof e=="function"?await e(...r):e}function ia(e,...r){if(typeof e=="object")if("next"in e){const n=e[Symbol.toStringTag];if(n==="Generator"||n=="Array Iterator"){const s=e.next();return"done"in s&&"value"in s?s.value:s}else throw n==="AsyncGenerator"?new Error("resolveSync cannot work with an async generator"):new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${n}'`)}else if(kn(e)){if(sa(e))return e.last();throw new Error("Reactive does not have last value")}else return e;else return typeof e=="function"?e(...r):e}function a0(e,r,...n){let s=!1,o=r.value;const i=r.overrideWithLast??!1;if(o===void 0)throw new Error("Param 'options.value' is undefined");try{const a=ia(e,...n);return typeof a>"u"||typeof a=="number"&&Number.isNaN(a)?o:(i&&(o=a),a)}catch(a){return s||(s=!0,console.warn("resolveWithFallbackSync swallowed an error. Additional errors not reported.",tr(a))),o}}var aa=class ua extends Array{#e;#t;constructor(r=0){super(),g(I(r,"positive","capacity")),this.#e=r,this.#t=0}add(r){const n=ua.from(this);return n[this.#t]=r,n.#e=this.#e,this.#e>0?n.#t=this.#t+1===this.#e?0:this.#t+1:n.#t=this.#t+1,n}get pointer(){return this.#t}get isFull(){return this.#e===0?!1:this.length===this.#e}};const Lh=(e,r)=>{e.debug&&console.log(`queue:${r}`)},ca=(e,r,n)=>{const s=r.length+n.length,o=e.capacity??s,i=s-o,a=e.discardPolicy??"additions";switch(a){case"additions":return r.length===0?n.slice(0,n.length-i):r.length===e.capacity?r:[...r,...n.slice(0,i-1)];case"newer":if(i>=r.length)return r.length===0?[...n.slice(0,o-1),n.at(-1)]:n.slice(Math.max(0,n.length-o),Math.min(n.length,o)+1);{const u=Math.max(1,n.length-r.length),c=n.slice(n.length-u,n.length);return[...r.slice(0,Math.min(r.length,o-1)),...c]}case"older":return[...r,...n].slice(i);default:throw new Error(`Unknown overflow policy ${a}`)}},Tn=(e,r,...n)=>{if(e===void 0)throw new Error("opts parameter undefined");const s=r.length+n.length,o=e.capacity&&s>e.capacity,i=o?ca(e,r,n):[...r,...n];if(e.capacity&&i.length!==e.capacity&&o)throw new Error(`Bug! Expected return to be at capacity. Return len: ${i.length} capacity: ${e.capacity} opts: ${JSON.stringify(e)}`);if(!e.capacity&&i.length!==s)throw new Error(`Bug! Return length not expected. Return len: ${i.length} expected: ${s} opts: ${JSON.stringify(e)}`);return i},Vn=(e,r)=>{if(r.length===0)throw new Error("Queue is empty");return r.slice(1)},rr=(e,r)=>r[0],Rn=(e,r)=>r.length===0,jn=(e,r)=>e.capacity?r.length>=e.capacity:!1;var Ee=class extends me{options;data;eq;constructor(e={},r=[]){if(super(),e===void 0)throw new Error("opts parameter undefined");this.options=e,this.data=r,this.eq=e.eq??k}clear(){const e=[...this.data];this.data=[],this.fireEvent("removed",{finalData:this.data,removed:e}),this.onClear()}onClear(){}at(e){if(e>=this.data.length)throw new Error("Index outside bounds of queue");const r=this.data.at(e);if(r===void 0)throw new Error("Index appears to be outside range of queue");return r}enqueue(...e){this.data=Tn(this.options,this.data,...e);const r=this.data.length;return this.onEnqueue(this.data,e),r}onEnqueue(e,r){this.fireEvent("enqueue",{added:r,finalData:e})}dequeue(){const e=rr(this.options,this.data);if(e!==void 0)return this.data=Vn(this.options,this.data),this.fireEvent("dequeue",{removed:e,finalData:this.data}),this.onRemoved([e],this.data),e}onRemoved(e,r){this.fireEvent("removed",{removed:e,finalData:r})}removeWhere(e){const r=this.data.length,n=this.data.filter(s=>e(s));return n.length===0?0:(this.data=this.data.filter(s=>!e(s)),this.onRemoved(n,this.data),r-this.data.length)}toArray(){return[...this.data]}get isEmpty(){return Rn(this.options,this.data)}get isFull(){return jn(this.options,this.data)}get length(){return this.data.length}get peek(){return rr(this.options,this.data)}};function la(e={},...r){return new Ee({...e},[...r])}const fa=(e,r,n)=>{const s=r.length+n.length,o=e.discardPolicy??"additions",i=e.capacity??s,a=s-i;switch(e.debug&&console.log(`Stack.push: stackLen: ${r.length} potentialLen: ${s} toRemove: ${a} policy: ${o}`),o){case"additions":return e.debug&&console.log(`Stack.push:DiscardAdditions: stackLen: ${r.length} slice: ${s-i} toAddLen: ${n.length}`),r.length===e.capacity?r:[...r,...n.slice(0,n.length-a)];case"newer":return a>=r.length?n.slice(Math.max(0,n.length-i),Math.min(n.length,i)+1):(e.debug&&console.log(` from orig: ${JSON.stringify(r.slice(0,r.length-a))}`),[...r.slice(0,r.length-a),...n.slice(0,Math.min(n.length,i-a+1))]);case"older":return[...r,...n].slice(a);default:throw new Error(`Unknown discard policy ${o}`)}},_n=(e,r,...n)=>{const s=r.length+n.length;return e.capacity&&s>e.capacity?fa(e,r,n):[...r,...n]},Cn=(e,r)=>{if(r.length===0)throw new Error("Stack is empty");return r.slice(0,-1)},nr=(e,r)=>r.at(-1),In=(e,r)=>r.length===0,On=(e,r)=>e.capacity?r.length>=e.capacity:!1;var De=class{opts;data;constructor(e={},r=[]){this.opts=e,this.data=r}push(...e){return e.length===0?this.data.length:(this.data=_n(this.opts,this.data,...e),this.data.length)}forEach(e){this.data.forEach(e)}forEachFromTop(e){[...this.data].reverse().forEach(e)}pop(){const e=nr(this.opts,this.data);return this.data=Cn(this.opts,this.data),e}get isEmpty(){return In(this.opts,this.data)}get isFull(){return On(this.opts,this.data)}get peek(){return nr(this.opts,this.data)}get length(){return this.data.length}};const Dh=(e={},...r)=>new De({...e},[...r]),Fn=(e,r,n=pn,s)=>{const o=da(e,r,n),i=Bh(e,r,n),a={valueChanged:!o,a:e,b:r,added:i.added,removed:i.removed,childChanged:!1},u={value:a,childrenStore:[],parent:s},c=i.identical.map(f=>Fn(f[0],f[1],n,u)),l=lo(a)||c.some(f=>lo(f.value));return Ma(u,c),u.toString=()=>ha(u,0),u.value.childChanged=l,ma(u),u},lo=e=>e===void 0?!1:!!(e.valueChanged||e.childChanged||e.added.length>0||e.removed.length>0),Bh=(e,r,n=pn)=>{const s=[...e.children()],o=[...r.children()],i=[],a=[];for(const c of s){let l=-1;for(const[f,d]of o.entries())if(da(c,d,n)){i.push([c,d]),l=f;break}l===-1?a.push(c):o.splice(l,1)}return{added:[...o],identical:i,removed:a}},da=(e,r,n)=>!!(e.getIdentity()===r.getIdentity()||n(e.getValue(),r.getValue())),Bt=e=>JSON.stringify(e.getValue()),ha=(e,r=0)=>{if(e===void 0)return"(undefined)";let n=Gh(e.value,r);for(const s of e.childrenStore)n+=ha(s,r+2);return n},Gh=(e,r)=>{const n=" ".repeat(r);if(e===void 0)return`${n}(undefined)`;const s=[];if(s.push(`a: ${Bt(e.a)} b: ${Bt(e.b)}`),e.valueChanged?s.push(`Value changed. Child changed: ${e.childChanged}`):s.push(`Value unchanged. Child changed: ${e.childChanged}`),e.added.length>0){s.push("Added:");for(const o of e.added)s.push(" - "+Bt(o))}if(e.removed.length>0){s.push(`Removed: ${e.removed.length}`);for(const o of e.removed)s.push(" - "+Bt(o))}return s.push(`----
`),s.map(o=>n+o).join(`
`)};var ya={};x(ya,{add:()=>Jn,addValue:()=>or,asDynamicTraversable:()=>Ye,breadthFirst:()=>Dn,children:()=>Kh,childrenLength:()=>ty,childrenValues:()=>Xh,compare:()=>Uh,computeMaxDepth:()=>Zh,createNode:()=>Nt,depthFirst:()=>Wh,findAnyChildByValue:()=>Yh,findChildByValue:()=>Hh,findParentsValue:()=>xa,followValue:()=>Sa,fromPlainObject:()=>Ea,getRoot:()=>Gn,hasAnyChild:()=>wr,hasAnyParent:()=>sr,hasChild:()=>pa,hasParent:()=>va,nodeDepth:()=>Qh,parents:()=>St,parentsValues:()=>wa,queryByValue:()=>ga,queryParentsValue:()=>Un,remove:()=>Ln,root:()=>xr,rootWrapped:()=>ey,setChildren:()=>Ma,stripParentage:()=>qn,throwTreeTest:()=>ma,toStringDeep:()=>Wn,treeTest:()=>Bn,value:()=>ry,wrap:()=>ue});const Uh=(e,r,n)=>Fn(Ye(e),Ye(r),n),qn=e=>({value:e.value,childrenStore:e.childrenStore.map(n=>qn(n))}),Ne=e=>"wraps"in e?e.wraps:e,Jh=e=>"wraps"in e?e:ue(e),ue=e=>({*children(){for(const r of e.childrenStore)yield ue(r)},getValue:()=>e.value,getIdentity:()=>e,*queryValue(r){for(const n of ga(r,Ne(e)))yield ue(n)},*queryParentsValue(r,n,s){for(const o of Un(Ne(r),n,s))yield ue(o)},*parentsValues(r){yield*wa(Ne(r))},findParentsValue(r,n,s){const o=xa(r,n,s);if(o!==void 0)return ue(o)},getParent:()=>e.parent===void 0?void 0:ue(e.parent),hasParent:r=>va(e,Ne(r)),hasAnyParent:r=>sr(e,Ne(r)),hasChild:r=>pa(Ne(r),e),hasAnyChild:r=>wr(Ne(r),e),remove:()=>{Ln(e)},addValue:r=>{const n=or(r,e);return ue(n)},add:r=>(Jn(Ne(r),e),Jh(r)),wraps:e}),Ln=e=>{const r=e.parent;r!==void 0&&(e.parent=void 0,r.childrenStore=mn(r.childrenStore,e))};function*Wh(e){if(!xr)return;const r=new De;r.push(...e.childrenStore);let n=r.pop();for(;n&&(yield n,n&&r.push(...n.childrenStore),!r.isEmpty);)n=r.pop()}function*Dn(e){if(!e)return;const r=new Ee;r.enqueue(...e.childrenStore);let n=r.dequeue();for(;n&&(yield n,n&&r.enqueue(...n.childrenStore),!r.isEmpty);)n=r.dequeue()}function Bn(e,r=[]){if(e.parent===e)return[!1,"Root has itself as parent",e];if(r.includes(e))return[!1,"Same node instance is appearing further in tree",e];if(r.push(e),Qf(e.childrenStore))return[!1,"Children list contains duplicates",e];for(const n of e.childrenStore){if(n.parent!==e)return[!1,"Member of childrenStore does not have .parent set",n];if(wr(e,n))return[!1,"Child has parent as its own child",n];const s=Bn(n,r);if(!s[0])return s}return[!0,"",e]}function ma(e){const r=Bn(e);if(!r[0])throw new Error(`${r[1]} Node: ${er(r[2].value,30)}`,{cause:r[2]})}function*Kh(e){for(const r of e.childrenStore)yield r}function*Xh(e){for(const r of e.childrenStore)typeof r.value<"u"&&(yield r.value)}function*St(e){let r=e.parent;for(;r;)yield r,r=r.parent}function Qh(e){return[...St(e)].length}const pa=(e,r)=>{for(const n of r.childrenStore)if(n===e)return!0;return!1},Hh=(e,r,n=k)=>{for(const s of r.childrenStore)if(n(e,s.value))return s};function*ga(e,r,n=k){for(const s of r.childrenStore)n(e,s.value)&&(yield s)}const wr=(e,r)=>{for(const n of Dn(r))if(n===e)return!0;return!1},Yh=(e,r,n=k)=>{for(const s of Dn(r))if(n(s.value,e))return s},Gn=e=>e.parent?Gn(e.parent):e,sr=(e,r)=>{for(const n of St(e))if(n===r)return!0;return!1};function*wa(e){for(const r of St(e))typeof r.value<"u"&&(yield r.value);return!1}function*Un(e,r,n=k){for(const s of St(e))typeof s.value<"u"&&n(s.value,r)&&(yield s);return!1}function xa(e,r,n=k){for(const s of Un(e,r,n))return s}const va=(e,r)=>e.parent===r,Zh=e=>ba(e,0),ba=(e,r=0)=>{let n=r;for(const s of e.childrenStore)n=Math.max(n,ba(s,r+1));return n},Jn=(e,r)=>{$a(e,r);const n=e.parent;r.childrenStore=[...r.childrenStore,e],e.parent=r,n&&(n.childrenStore=mn(n.childrenStore,e))},or=(e,r)=>Nt(e,r),xr=e=>Nt(e),Ea=(e,r="",n,s=[])=>{const o=Object.entries(e);n=n===void 0?xr():or({label:r,value:e},n);for(const i of o){const a=i[1];s.includes(a)||(s.push(a),typeof i[1]=="object"?Ea(a,i[0],n,s):or({label:i[0],value:a},n))}return n},ey=e=>ue(Nt(e)),Nt=(e,r)=>{const n={childrenStore:[],parent:r,value:e};return r!==void 0&&(r.childrenStore=[...r.childrenStore,n]),n},ty=e=>e.childrenStore.length,ry=e=>e.value,Ye=e=>({*children(){for(const n of e.childrenStore)yield Ye(n)},getParent(){if(e.parent!==void 0)return Ye(e.parent)},getValue(){return e.value},getIdentity(){return e}}),$a=(e,r)=>{if(r===e)throw new Error("Cannot add self as child");if(e.parent!==r){if(sr(r,e))throw new Error("Child contains parent (1)",{cause:e});if(sr(e,r))throw new Error("Parent already contains child",{cause:e});if(wr(r,e))throw new Error("Child contains parent (2)",{cause:e})}},Ma=(e,r)=>{for(const n of r)$a(n,e);e.childrenStore=[...r];for(const n of r)n.parent=e},Wn=(e,r=0)=>{const n=`${"  ".repeat(r)} + ${e.value?JSON.stringify(e.value):"-"}`;return e.childrenStore.length>0?n+`
`+e.childrenStore.map(s=>Wn(s,r+1)).join(`
`):n};function*Sa(e,r,n=1){for(const s of e.childrenStore){const o=s.value;o!==void 0&&r(o,n)&&(yield s.value,yield*Sa(s,r,n+1))}}var Na={};x(Na,{asDynamicTraversable:()=>Kn,children:()=>et,create:()=>Xn,createSimplified:()=>ay,createWrapped:()=>iy,depthFirst:()=>ka,getByPath:()=>oy,prettyPrint:()=>za,prettyPrintEntries:()=>ny,toStringDeep:()=>Pa,traceByPath:()=>Aa});function ny(e){if(e.length===0)return"(empty)";let r="";for(const[n,s]of e.entries())r+="  ".repeat(n),r+=s.name+" = "+JSON.stringify(s.leafValue)+`
`;return r}const za=(e,r=0,n={})=>{g(Qt(e,"node"));const s=n.name??"node",o=uy(e,s),i=`${"  ".repeat(r)} + name: ${o.name} value: ${JSON.stringify(o.leafValue)}`,a=[...et(e,n)];return a.length>0?i+`
`+a.map(u=>za(u.leafValue,r+1,{...n,name:u.name})).join(`
`):i},Pa=(e,r=0)=>{let n=" ".repeat(r)+` ${e.value?.name}`;if(e.value!==void 0){if("sourceValue"in e.value&&"leafValue"in e.value){let s=er(e.value.sourceValue,20);const o=er(e.value.leafValue,20);s=s===o?"":"source: "+s,n+=` = ${o} ${s}`}else"sourceValue"in e.value&&e.value.sourceValue!==void 0&&(n+=` = ${e.value.sourceValue}`);"ancestors"in e.value&&(n+=` (ancestors: ${e.value.ancestors.join(", ")})`)}n+=`
`;for(const s of e.childrenStore)n+=Pa(s,r+1);return n};function*et(e,r={}){g(Qt(e,"node"));const n=r.filter??"none",s=o=>n==="none"?[!0,ht(o)]:n==="leaves"&&ht(o)?[!0,!0]:n==="branches"&&!ht(o)?[!0,!1]:[!1,ht(o)];if(Array.isArray(e))for(const[o,i]of e.entries()){const a=s(i);a[0]&&(yield{name:o.toString(),_kind:"entry",sourceValue:i,leafValue:a[1]?i:void 0})}else if(typeof e=="object"){const o="entries"in e?e.entries():Object.entries(e);for(const[i,a]of o){const[u,c]=s(a);u&&(yield{name:i,_kind:"entry",sourceValue:a,leafValue:c?a:void 0})}}}function*ka(e,r={},n=[]){for(const s of et(e,r))yield{...s,ancestors:[...n],_kind:"entry-ancestors"},yield*ka(s.sourceValue,r,[...n,s.name])}function sy(e,r){for(const n of et(r))if(n.name===e)return n}function oy(e,r,n={}){const s=Mn(Aa(e,r,n));if(!s)throw new Error(`Could not trace path: ${e} `);return s}function*Aa(e,r,n={}){g(Qt(e,"path"),Qt(r,"node"));const s=n.separator??".",o=e.split(s),i=[];for(const a of o){const u=sy(a,r);if(!u){yield{name:a,sourceValue:void 0,leafValue:void 0,ancestors:i,_kind:"entry-ancestors"};return}r=u.sourceValue,yield{...u,ancestors:[...i],_kind:"entry-ancestors"},i.push(a)}}const Kn=(e,r={},n=[],s)=>{const o=r.name??"object",i={*children(){for(const{name:a,sourceValue:u,leafValue:c}of et(e,r))yield Kn(u,{...r,name:a},[...n,o],i)},getParent(){return s},getValue(){return{name:o,sourceValue:e,ancestors:n,_kind:"entry-static"}},getIdentity(){return e}};return i},iy=(e,r)=>ue(Xn(e,r)),Xn=(e,r={})=>{const s=r.valuesAtLeaves??!1?o=>{if(ht(o))return o}:o=>o;return Ta(e,s(e),r,[])},Ta=(e,r,n={},s)=>{const o=n.name??"object_ci",i=xr({name:o,sourceValue:r,ancestors:[...s],_kind:"entry-static"});s=[...s,o];for(const a of et(e,n)){const u=n.valuesAtLeaves?a.leafValue:a.sourceValue;Jn(Ta(a.sourceValue,u,{...n,name:a.name},s),i)}return i},ay=(e,r={})=>qn(Xn(e,r));function uy(e,r=""){return"name"in e&&"leafValue"in e&&"sourceValue"in e?{name:e.name,_kind:"entry",leafValue:e.leafValue,sourceValue:e.sourceValue}:"name"in e?{name:e.name,leafValue:e,sourceValue:e,_kind:"entry"}:{name:r,leafValue:e,sourceValue:e,_kind:"entry"}}var Va={};x(Va,{addValueByPath:()=>Ra,childrenLengthByPath:()=>ly,clearValuesByPath:()=>_a,create:()=>cy,removeByPath:()=>ja,valueByPath:()=>Ca,valuesByPath:()=>Hn});const cy=(e={})=>{let r;return{getRoot:()=>r,add:(h,y)=>{const p=Ra(h,y,r,e);r===void 0&&(r=Gn(p))},prettyPrint:()=>r===void 0?"(empty)":Wn(r),remove:h=>r===void 0?!1:ja(h,r,e),getValue:h=>{if(r!==void 0)return Ca(h,r,e)},getValues:h=>r===void 0?[]:Hn(h,r,e),hasPath:h=>r===void 0?!1:Ke(h,r,e)!==void 0,childrenLength:h=>{if(r===void 0)return 0;const y=Ke(h,r,e);return y===void 0?0:y.childrenStore.length},getNode:h=>r===void 0?void 0:Ke(h,r,e),clearValues:h=>r===void 0?!1:_a(h,r,e)}},Ra=(e,r,n,s={})=>{const o=s.separator??".",i=s.duplicates??"overwrite",a=r.split(o);let u=0;for(const c of a){const l=u===a.length-1,f=Qn(c,n);if(f===void 0)n=Nt({value:l?e:void 0,label:c},n);else if(n=f,l)switch(i){case"ignore":break;case"allow":{const d=Ia(n);n.value={values:[...d,e],label:c};break}case"overwrite":{n.value={value:e,label:c};break}}else n=f;u++}if(n===void 0)throw new Error("Could not create tree");return n},ja=(e,r,n={})=>{if(r===void 0)return!1;const s=Ke(e,r,n);return s===void 0?!1:(Ln(s),!0)},_a=(e,r,n={})=>{if(r===void 0)return!1;const s=Ke(e,r,n);return s===void 0?!1:(s.value={label:s.value?.label??"",value:void 0},!0)},ly=(e,r,n={})=>{if(r===void 0)return 0;const s=Ke(e,r,n);return s===void 0?0:s.childrenStore.length},Qn=(e,r)=>{if(r!==void 0){if(e===void 0)throw new Error("Parameter 'label' cannot be undefined");if(r.value?.label===e)return r;for(const n of r.childrenStore)if(n.value?.label===e)return n}},Ca=(e,r,n={})=>{const s=Hn(e,r,n);if(s.length!==0){if(s.length>1)throw new Error("Multiple values at path. Use getValues instead");return s[0]}},Ia=e=>e.value===void 0?[]:"values"in e.value?e.value.values:"value"in e.value?e.value.value===void 0?[]:[e.value.value]:[],Ke=(e,r,n={})=>{const s=n.separator??".",o=e.split(s);let i=r;for(const a of o)if(i=Qn(a,i),i===void 0)return;return i},Hn=(e,r,n={})=>{const s=n.separator??".",o=e.split(s);let i=r;for(const a of o)if(i=Qn(a,i),i===void 0)return[];return Ia(i)};var Oa={};x(Oa,{breadthFirst:()=>tt,childrenLength:()=>fy,couldAddChild:()=>my,depthFirst:()=>ts,find:()=>vy,findAnyChildByValue:()=>xy,findAnyParentByValue:()=>yy,findByValue:()=>by,findChildByValue:()=>La,findParentByValue:()=>es,followValue:()=>Da,hasAnyChild:()=>Jr,hasAnyChildValue:()=>py,hasAnyParent:()=>dy,hasAnyParentValue:()=>hy,hasChild:()=>Fa,hasChildValue:()=>qa,hasParent:()=>Yn,hasParentValue:()=>Zn,parents:()=>wy,siblings:()=>gy,toString:()=>Ey,toStringDeep:()=>Ba});const fy=e=>[...e.children()].length,dy=(e,r,n)=>Yn(e,r,n,Number.MAX_SAFE_INTEGER),hy=(e,r,n)=>{if(typeof e>"u")throw new TypeError("Param 'child' is undefined");return Zn(e,r,n,Number.MAX_SAFE_INTEGER)},yy=(e,r,n)=>es(e,r,n,Number.MAX_SAFE_INTEGER),Yn=(e,r,n=k,s=0)=>{if(s<0)return!1;const o=Ve(e),i=Ve(r),a=o?e.getParent():e.parent;if(typeof a>"u")return!1;if(n(a,r))return!0;const u=o?a.getIdentity():a.value,c=i?r.getIdentity():r.value;return n(u,c)?!0:Yn(a,r,n,s-1)},Zn=(e,r,n=k,s=0)=>{if(e===void 0)throw new Error("Param 'child' is undefined");if(s<0)return!1;const o="getParent"in e?e.getParent():e.parent;if(o===void 0)return!1;const i="getValue"in o?o.getValue():o.value;return n(i,r)?!0:Zn(o,r,n,s-1)},es=(e,r,n=k,s=0)=>{if(s<0)return;const o="getParent"in e?e.getParent():e.parent;if(o===void 0)return;const i="getValue"in o?o.getValue():o.value;return n(i,r)?o:es(o,r,n,s-1)},my=(e,r,n=k)=>{if(n(e,r))throw new Error("Child equals parent");if(Jr(e,r,n))throw new Error("Circular. Parent already has child");if(Jr(r,e,n))throw new Error("Prospective child has parent as child relation")},Jr=(e,r,n=k)=>Fa(e,r,n,Number.MAX_SAFE_INTEGER),py=(e,r,n=k)=>qa(e,r,n,Number.MAX_SAFE_INTEGER),Fa=(e,r,n=k,s=0)=>{if(s<0)return!1;if(n(e,r))return!0;const o="getIdentity"in e?e.getIdentity():e.value,i="getIdentity"in r?r.getIdentity():r.value;if(n(o,i))return!0;for(const a of tt(e,s)){const u="getIdentity"in a?a.getIdentity():a.value;if(n(a,r)||n(u,i))return!0}return!1},qa=(e,r,n=k,s=0)=>{if(s<0)return!1;if(n(e.getValue(),r))return!0;for(const o of tt(e,s)){const i=o.getValue();if(n(i,r))return!0}return!1};function*gy(e){const r=e.getParent();if(r!==void 0)for(const n of r.children())n!==e&&(yield n)}function*wy(e){if(Ve(e)){let r=e.getParent();for(;r!==void 0;)yield r,r=r.getParent()}else{let r=e.parent;for(;r!==void 0;)yield r,r=r.parent}}function xy(e,r,n=k){return La(e,r,n,Number.MAX_SAFE_INTEGER)}function La(e,r,n=k,s=0){if(s<0)return;const o=Ve(e);if(o){if(n(e.getValue(),r))return e}else if(n(e.value,r))return e;for(const i of tt(e,s))if(o){if(n(i.getValue(),r))return i}else if(n(i.value,r))return i}function*ts(e){if(!e)return;const r=new De;let n=e;for(;n;){const s=Ve(n)?[...n.children()]:[...n.childrenStore];if(r.push(...s),r.isEmpty)break;n=r.pop(),n&&(yield n)}}function*tt(e,r=Number.MAX_SAFE_INTEGER){if(!e)return;const s=Ve(e)?new Ee:new Ee;let o=e;for(;o;){if(r<0)return;if(o!==void 0){const i="childrenStore"in o?o.childrenStore:o.children();for(const a of i)yield a,s.enqueue(a)}o=s.dequeue(),r--}}function vy(e,r,n="breadth"){if(r(e))return e;const s=n==="breadth"?tt:ts;for(const o of s(e))if(r(o))return o}function by(e,r,n="breadth"){if(r(e.getValue()))return e;const s=n==="breadth"?tt:ts;for(const o of s(e))if(r(o.getValue()))return o}function*Da(e,r,n=1){for(const s of e.children())r(s.getValue(),n)&&(yield s.getValue(),yield*Da(s,r,n+1))}function Ba(e,r=0){if(e===void 0)return"(undefined)";if(e===null)return"(null)";const n=e.getValue();let s=typeof n;Array.isArray(n)&&(s="array");let o="  ".repeat(r)+`value: ${JSON.stringify(n)} (${s})
`;for(const i of e.children())o+=Ba(i,r+1);return o}function Ey(...e){let r="";for(const n of e){const s=n.getValue(),o=er(s),i=[...n.children()],a=n.getParent();let u=typeof s;Array.isArray(s)&&(u="array"),r+=`value: ${o} (${u}) kids: ${i.length} parented: ${a?"y":"n"}
`}return r}var Ga={};x(Ga,{FromObject:()=>Na,Mutable:()=>ya,Pathed:()=>Va,Traverse:()=>Oa,compare:()=>Fn,isTraversable:()=>Ve,isTreeNode:()=>Ua,toTraversable:()=>$y});const $y=e=>{if(Ve(e))return e;if(Ua(e))return Ye(e);if(typeof e=="object")return Kn(e);throw new Error("Parameter 'node' not convertible")},Ua=e=>!!("parent"in e&&"childrenStore"in e&&"value"in e&&Array.isArray(e.childrenStore)),Ve=e=>"children"in e&&"getParent"in e&&"getValue"in e&&"getIdentity"in e;var rs=class Wr{opts;data;constructor(r={},n=[]){this.opts=r,this.data=n}push(...r){return new Wr(this.opts,_n(this.opts,this.data,...r))}pop(){return new Wr(this.opts,Cn(this.opts,this.data))}forEach(r){this.data.forEach(r)}forEachFromTop(r){[...this.data].reverse().forEach(r)}get isEmpty(){return In(this.opts,this.data)}get isFull(){return On(this.opts,this.data)}get peek(){return nr(this.opts,this.data)}get length(){return this.data.length}};const My=(e={},...r)=>new rs({...e},[...r]);var Ja={};x(Ja,{StackImmutable:()=>rs,StackMutable:()=>De,immutable:()=>My,isEmpty:()=>In,isFull:()=>On,mutable:()=>Dh,peek:()=>nr,pop:()=>Cn,push:()=>_n,trimStack:()=>fa});const Wa=e=>new ns(e);var ns=class extends me{store=new Map;keyString;constructor(e){super(),this.keyString=e??Mt}get size(){return this.store.size}add(...e){let r=!1;for(const n of e){const s=this.has(n);this.store.set(this.keyString(n),n),super.fireEvent("add",{value:n,updated:s}),s||(r=!0)}return r}values(){return this.store.values()}clear(){this.store.clear(),super.fireEvent("clear",!0)}delete(e){const r=this.store.delete(this.keyString(e));return r&&super.fireEvent("delete",e),r}has(e){return this.store.has(this.keyString(e))}toArray(){return[...this.store.values()]}},ss=class Kr{store;keyString;constructor(r,n){this.store=n??new Map,this.keyString=r??Mt}get size(){return this.store.size}add(...r){const n=new Map(this.store);for(const s of r){const o=this.keyString(s);n.set(o,s)}return new Kr(this.keyString,n)}delete(r){const n=new Map(this.store),s=this.keyString(r);return n.delete(s)?new Kr(this.keyString,n):this}has(r){const n=this.keyString(r);return this.store.has(n)}toArray(){return[...this.store.values()]}*values(){yield*this.store.values()}};const Sy=(e=fe)=>new ss(e);var Ny=class Ka{#e;#t;children=new Map;values=[];constructor(r=1,n=0){this.#e=n,this.#t=r}sizeLocal(){return this.values.length}sizeChildren(){return[...this.children.values()].length}sizeChildrenDeep(){let r=this.sizeChildren();for(const n of this.children.values())r+=n.sizeChildrenDeep();return r}size(){let r=this.values.length;for(const n of this.children.values())r+=n.size();return r}add(r){if(typeof r!="string")throw new Error(`Param 'value' must be a string. Got: ${typeof r}`);if(r.length===0)throw new Error("Param 'value' is empty");const n=this.#n(r,!0);if(n===this){this.hasLocal(r)||this.values.push(r);return}if(!n)throw new Error(`Could not create child set for: ${r}`);n.add(r)}remove(r){if(typeof r!="string")throw new Error(`Param 'value' must be a string. Got: ${typeof r}`);if(r.length===0)throw new Error("Param 'value' is empty");const n=this.#n(r,!1);return n===void 0?!1:n===this?this.hasLocal(r)?(this.values=this.values.filter(s=>s!==r),!0):!1:n.remove(r)}debugDump(){const r=this.#r();for(const n of r)console.log(n)}#r(r=0){const n=[];n.push(`Depth: ${this.#e} Max: ${this.#t}`);for(const[s,o]of this.children.entries()){const i=o.#r(r+1);n.push(` key: ${s}`);for(const a of i)n.push(" ".repeat(r+1)+a)}n.push(`Values: (${this.values.length})`);for(const s of this.values)n.push(` ${s}`);return n.map(s=>" ".repeat(r)+s)}#n(r,n){if(r===void 0)throw new Error("Param 'value' undefined");if(this.#e===this.#t)return this;if(r.length<=this.#e)return this;const s=r[this.#e];if(s===void 0)throw new Error(`Logic error. Depth: ${this.#e} Len: ${r.length}`);let o=this.children.get(s);return o===void 0&&n&&(o=new Ka(this.#t,this.#e+1),this.children.set(s,o)),o}hasLocal(r){for(const n of this.values)if(n===r)return!0;return!1}has(r){if(typeof r!="string")return!1;const n=this.#n(r,!1);return n===void 0?!1:n===this?this.hasLocal(r):n.has(r)}},Xa={};x(Xa,{MassiveSet:()=>Ny,SetStringImmutable:()=>ss,SetStringMutable:()=>ns,immutable:()=>Sy,mutable:()=>Wa});var os=class extends Ee{constructor(e={}){e.eq===void 0&&(e={...e,eq:(r,n)=>k(r.item,n.item)}),super(e)}enqueueWithPriority(e,r){g(z(r,"positive")),super.enqueue({item:e,priority:r})}changePriority(e,r,n=!1,s){if(e===void 0)throw new Error("Item cannot be undefined");let o;for(const i of this.data)if(s){if(s(i.item,e)){o=i;break}}else if(this.eq(i,{item:e,priority:0})){o=i;break}if(o===void 0&&!n)throw new Error(`Item not found in priority queue. Item: ${JSON.stringify(e)}`);o!==void 0&&this.removeWhere(i=>o===i),this.enqueueWithPriority(e,r)}dequeueMax(){const e=yt(Jt(this.data,(r,n)=>r.priority>=n.priority));if(e!==void 0)return this.removeWhere(r=>r===e),e.item}dequeueMin(){const e=yt(Jt(this.data,(r,n)=>r.priority>=n.priority));if(e!==void 0)return this.removeWhere(r=>r.item===e),e.item}peekMax(){const e=yt(Jt(this.data,(r,n)=>r.priority>=n.priority));if(e!==void 0)return e.item}peekMin(){const e=yt(na(this.data,(r,n)=>r.priority>=n.priority));if(e!==void 0)return e.item}};function zy(e={}){return new os(e)}var is=class Xr{opts;#e;constructor(r={},n=[]){if(r===void 0)throw new Error("opts parameter undefined");this.opts=r,this.#e=n}forEach(r){for(let n=this.#e.length-1;n>=0;n--)r(this.#e[n])}forEachFromFront(r){this.#e.forEach(n=>{r(n)})}enqueue(...r){return new Xr(this.opts,Tn(this.opts,this.#e,...r))}dequeue(){return new Xr(this.opts,Vn(this.opts,this.#e))}get isEmpty(){return Rn(this.opts,this.#e)}get isFull(){return jn(this.opts,this.#e)}get length(){return this.#e.length}get peek(){return rr(this.opts,this.#e)}toArray(){return[...this.#e]}};const Py=(e={},...r)=>(e={...e},new is(e,[...r]));var Qa={};x(Qa,{PriorityMutable:()=>os,QueueImmutable:()=>is,QueueMutable:()=>Ee,debug:()=>Lh,dequeue:()=>Vn,enqueue:()=>Tn,immutable:()=>Py,isEmpty:()=>Rn,isFull:()=>jn,mutable:()=>la,peek:()=>rr,priority:()=>zy,trimQueue:()=>ca});const ky=(e={})=>new as(e);var as=class extends me{capacity;store;evictPolicy;autoDeleteElapsedMs;autoDeletePolicy;autoDeleteTimer;disposed=!1;constructor(e={}){if(super(),this.capacity=e.capacity??-1,g(I(this.capacity,"nonZero","capacity")),this.store=new Map,e.evictPolicy&&this.capacity<=0)throw new Error("evictPolicy is set, but no capacity limit is set");this.evictPolicy=e.evictPolicy??"none",this.autoDeleteElapsedMs=e.autoDeleteElapsedMs??-1,this.autoDeletePolicy=e.autoDeletePolicy??"none",this.autoDeleteElapsedMs>0&&(this.autoDeleteTimer=setInterval(()=>{this.#e()},Math.max(1e3,this.autoDeleteElapsedMs*2)))}dispose(){this.disposed||(this.disposed=!0,this.autoDeleteTimer&&(clearInterval(this.autoDeleteTimer),this.autoDeleteTimer=void 0))}get keyLength(){return this.store.size}*entries(){for(const e of this.store.entries())yield[e[0],e[1].value]}*values(){for(const e of this.store.values())yield e.value}*keys(){yield*this.store.keys()}elapsedSet(e){const r=this.store.get(e);if(!(typeof r>"u"))return Date.now()-r.lastSet}elapsedGet(e){const r=this.store.get(e);if(!(typeof r>"u"))return Date.now()-r.lastGet}has(e){return this.store.has(e)}get(e){const r=this.store.get(e);if(r)return(this.autoDeletePolicy==="either"||this.autoDeletePolicy==="get")&&this.store.set(e,{...r,lastGet:performance.now()}),r.value}delete(e){const r=this.store.get(e);if(!r)return!1;const n=this.store.delete(e);return this.fireEvent("removed",{key:e,value:r.value}),n}clear(){this.store.clear()}touch(e){const r=this.store.get(e);return r?(this.store.set(e,{...r,lastSet:Date.now(),lastGet:Date.now()}),!0):!1}findEvicteeKey(){if(this.evictPolicy==="none")return;let e="";if(this.evictPolicy==="oldestGet")e="lastGet";else if(this.evictPolicy==="oldestSet")e="lastSet";else throw new Error(`Unknown eviction policy ${this.evictPolicy}`);return xn(this.store,e)[0][0]}#e(){this.autoDeletePolicy!=="none"&&this.deleteWithElapsed(this.autoDeleteElapsedMs,this.autoDeletePolicy)}deleteWithElapsed(e,r){const n=[...this.store.entries()],s=[],o=R(e,1e3),i=performance.now();for(const a of n){const u=i-a[1].lastGet,c=i-a[1].lastSet;(r==="get"?u:r==="set"?c:Math.max(u,c))>=o&&s.push([a[0],a[1].value])}for(const a of s){this.store.delete(a[0]);const u={key:a[0],value:a[1]};this.fireEvent("expired",u),this.fireEvent("removed",u)}return s}set(e,r){const n=this.store.get(e);if(n){this.store.set(e,{...n,lastSet:performance.now()});return}if(this.keyLength===this.capacity&&this.capacity>0){const s=this.findEvicteeKey();if(!s)throw new Error(`ExpiringMap full (capacity: ${this.capacity})`);const o=this.store.get(s);if(this.store.delete(s),o){const i={key:s,value:o.value};this.fireEvent("expired",i),this.fireEvent("removed",i)}}this.store.set(e,{lastGet:0,lastSet:performance.now(),value:r}),this.fireEvent("newKey",{key:e,value:r})}};const Ay=(e,r)=>{for(const n of e.entries()){const s=n[1];for(const o of s)if(r(o,n[0]))return n}},Ty=e=>{let r=["",0];for(const n of e.keysAndCounts())n[1]>r[1]&&(r=n);return r[1]},Ha=(e,r,n=k)=>{for(const s of e.entries()){const o=s[1];for(const i of o)if(n(i,r))return s}};var Ya=class{map;groupBy;valueEq;constructor(e=Mt,r=k,n=[]){this.groupBy=e,this.valueEq=r,this.map=new Map(n)}has(e){return this.map.has(e)}hasKeyValue(e,r){const n=this.map.get(e);if(!n)return!1;for(const s of n)if(this.valueEq(s,r))return!0;return!1}debugString(){let e="";return[...this.map.keys()].every(n=>{const s=this.map.get(n);s!==void 0&&(e+=n+` (${s.length}) = ${JSON.stringify(s)}\r
`)}),e}count(e){const r=this.map.get(e);return r?r.length:0}firstKeyByValue(e,r=k){const n=Ha(this,e,r);if(n)return n[0]}*entriesFlat(){for(const e of this.map.keys())for(const r of this.map.get(e))yield[e,r]}*entries(){for(const[e,r]of this.map.entries())yield[e,[...r]]}*get(e){const r=this.map.get(e);r&&(yield*r.values())}*keys(){yield*this.map.keys()}*valuesFlat(){for(const e of this.map)yield*e[1]}*values(){for(const e of this.map)yield e[1]}*keysAndCounts(){for(const e of this.map)yield[e[0],e[1].length]}get lengthKeys(){return this.map.size}get isEmpty(){return this.map.size===0}},us=class extends Ya{addKeyedValues(e,...r){const n=this.map.get(e);n===void 0?this.map.set(e,r):this.map.set(e,[...n,...r])}setValues(e,r){this.map.set(e,r)}addValue(...e){for(const r of e){const n=this.groupBy(r);this.addKeyedValues(n,r)}}deleteKeyValue(e,r){const n=this.map.get(e);if(n===void 0)return!1;const s=n.filter(o=>!this.valueEq(o,r));return this.map.set(e,s),s.length<n.length}deleteByValue(e){let r=!1;const n=[...this.map.entries()];for(const s of n)for(const o of s[1])this.valueEq(o,e)&&(r=!0,this.deleteKeyValue(s[0],e));return r}delete(e){const r=this.map.get(e);return!r||r.length===0?!1:(this.map.delete(e),!0)}clear(){this.map.clear()}};const fo=(e=Mt,r=k)=>new us(e,r),Vy=(e,r)=>{const n=new Map(e.entries());for(const s of r){if(s[0]===void 0)throw new Error("key cannot be undefined");if(s[1]===void 0)throw new Error("value cannot be undefined");n.set(s[0],s[1])}return n},Ry=(e,r)=>{const n=new Map(e.entries());for(const s of r){if(s.key===void 0)throw new Error("key cannot be undefined");if(s.value===void 0)throw new Error("value cannot be undefined");n.set(s.key,s.value)}return n},jy=(e,r)=>e.has(r),gt=(e,...r)=>{if(e===void 0)throw new Error("map parameter is undefined");if(r===void 0)throw new Error("data parameter i.s undefined");if(r.length===0)return e;const n=r[0];return typeof n.key<"u"&&typeof n.value<"u"?Ry(e,r):Vy(e,r)},Za=(e,r,n)=>{const s=new Map(e.entries());return s.set(r,n),s},eu=(e,r)=>{const n=new Map(e.entries());return n.delete(r),n},se=e=>{if(e===void 0)return se([]);if(Array.isArray(e))return se(gt(new Map,...e));const r=e;return{add:(...n)=>{const s=gt(r,...n);return se(s)},set:(n,s)=>{const o=Za(r,n,s);return se(o)},get:n=>r.get(n),delete:n=>se(eu(r,n)),clear:()=>se(),has:n=>r.has(n),entries:()=>r.entries(),values:()=>r.values(),isEmpty:()=>r.size===0}},_y=(...e)=>{let r=gt(new Map,...e);return{add:(...n)=>{r=gt(r,...n)},delete:n=>{r=eu(r,n)},clear:()=>{r=gt(new Map)},set:(n,s)=>{r=Za(r,n,s)},get:n=>r.get(n),entries:()=>r.entries(),values:()=>r.values(),isEmpty:()=>r.size===0,has:n=>jy(r,n)}};var vr=class extends me{#e=new Map;groupBy;type;constructor(e,r={}){super(),this.type=e,this.groupBy=r.groupBy??fe}get typeName(){return this.type.name}get lengthKeys(){return this.#e.size}get lengthMax(){let e=0;for(const r of this.#e.values())e=Math.max(e,this.type.count(r));return e}debugString(){const e=[...this.#e.keys()];let r=`Keys: ${e.join(", ")}\r
`;for(const n of e){const s=this.#e.get(n);if(s===void 0)r+=` - ${n} (undefined)\r
`;else{const o=this.type.toArray(s);o!==void 0&&(r+=` - ${n} (${this.type.count(s)}) = ${JSON.stringify(o)}\r
`)}}return r}get isEmpty(){return this.#e.size===0}clear(){this.#e.clear(),super.fireEvent("clear",!0)}addKeyedValues(e,...r){const n=this.#e.get(e);n===void 0?(this.#e.set(e,this.type.addKeyedValues(void 0,r)),super.fireEvent("addedKey",{key:e}),super.fireEvent("addedValues",{values:r})):(this.#e.set(e,this.type.addKeyedValues(n,r)),super.fireEvent("addedValues",{values:r}))}set(e,r){return this.addKeyedValues(e,...r),this}addValue(...e){for(const r of e)this.addKeyedValues(this.groupBy(r),r)}hasKeyValue(e,r,n){const s=this.#e.get(e);return s===void 0?!1:this.type.has(s,r,n)}has(e){return this.#e.has(e)}deleteKeyValue(e,r){const n=this.#e.get(e);return n===void 0?!1:this.deleteKeyValueFromMap(n,e,r)}deleteKeyValueFromMap(e,r,n){const s=this.type.count(e),o=this.type.without(e,n),i=o.length;return this.#e.set(r,this.type.addKeyedValues(void 0,o)),s>i}deleteByValue(e){let r=!1;return[...this.#e.keys()].filter(n=>{const s=this.#e.get(n);if(!s)throw new Error("Bug: map could not be accessed");this.deleteKeyValueFromMap(s,n,e)&&(r=!0,this.count(n)===0&&this.delete(n))}),r}delete(e){return this.#e.get(e)===void 0?!1:(this.#e.delete(e),this.fireEvent("deleteKey",{key:e}),!0)}firstKeyByValue(e,r=k){return[...this.#e.keys()].find(o=>{const i=this.#e.get(o);if(i===void 0)throw new Error("Bug: map could not be accessed");return this.type.has(i,e,r)})}count(e){const r=this.#e.get(e);return r===void 0?0:this.type.count(r)}*get(e){const r=this.#e.get(e);r!==void 0&&(yield*this.type.iterable(r))}*valuesFor(e){const r=this.#e.get(e);r!==void 0&&(yield*this.type.iterable(r))}getSource(e){return this.#e.get(e)}*keys(){yield*this.#e.keys()}*entriesFlat(){for(const e of this.#e.entries())for(const r of this.type.iterable(e[1]))yield[e[0],r]}*valuesFlat(){for(const e of this.#e.entries())yield*this.type.iterable(e[1])}*entries(){for(const[e,r]of this.#e.entries()){const n=[...this.type.iterable(r)];yield[e,n]}}*keysAndCounts(){for(const e of this.keys())yield[e,this.count(e)]}merge(e){for(const r of e.keys()){const n=e.get(r);this.addKeyedValues(r,...n)}}get size(){return this.#e.size}get[Symbol.toStringTag](){return this.#e[Symbol.toStringTag]}};const Cy=e=>{const r=e?.hash??fe,n=(i,a)=>r(i)===r(a),s={get name(){return"set"},iterable:i=>i.values(),addKeyedValues:(i,a)=>gn(i,r,"skip",...a),count:i=>i.size,find:(i,a)=>En(i,a),filter:(i,a)=>bn(i,a),toArray:i=>Ht(i),has:(i,a)=>vn(i,a,n),without:(i,a)=>mn(Ht(i),a,n)};return new vr(s,e)},Iy=e=>{const r=k,n={get name(){return"circular"},addKeyedValues:(s,o)=>{let i=s??new aa(e.capacity);for(const a of o)i=i.add(a);return i},count:s=>s.length,find:(s,o)=>s.find(o),filter:(s,o)=>s.filter(o),toArray:s=>s,iterable:s=>s.values(),has:(s,o)=>s.find(i=>r(i,o))!==void 0,without:(s,o)=>s.filter(i=>!r(i,o))};return new vr(n,e)};var tu=class extends Map{defaultValue;constructor(e=0){super(),this.defaultValue=e}get(e){const r=super.get(e);return r===void 0?this.defaultValue:r}reset(e){return super.set(e,this.defaultValue),this.defaultValue}multiply(e,r){let s=super.get(e)??this.defaultValue;return s*=r,super.set(e,s),s}add(e,r=1){let s=super.get(e)??this.defaultValue;return s+=r,super.set(e,s),s}subtract(e,r=1){let s=super.get(e)??this.defaultValue;return s-=r,super.set(e,s),s}};const Oy=(e={})=>{const r=e.convertToString,n=typeof r>"u"?k:(a,u)=>r(a)===r(u),s=e.comparer??n,o={get name(){return"array"},addKeyedValues:(a,u)=>a===void 0?[...u]:[...a,...u],iterable:a=>a.values(),count:a=>a.length,find:(a,u)=>a.find(c=>u(c)),filter:(a,u)=>a.filter(c=>u(c)),toArray:a=>a,has:(a,u)=>a.some(c=>s(c,u)),without:(a,u)=>a.filter(c=>!s(c,u))};return new vr(o,e)};var ru=class mt extends Ya{addKeyedValues(r,...n){return this.addBatch([[r,n]])}addValue(...r){const n=r.map(s=>[this.groupBy(s),s]);return this.addBatch(n)}addBatch(r){const n=new Map([...this.map.entries()].map(s=>[s[0],[...s[1]]]));for(const[s,o]of r){const i=n.get(s);typeof i>"u"?n.set(s,o):i.push(...o)}return new mt(this.groupBy,this.valueEq,[...n.entries()])}clear(){return new mt(this.groupBy,this.valueEq)}deleteKeyValue(r,n){throw new Error("Method not implemented.")}deleteByValue(r,n){const s=[...this.map.entries()],o=n??this.valueEq,i=s.map(a=>{const u=a[0],c=a[1].filter(l=>!o(l,r));return[u,c]});return new mt(this.groupBy,this.valueEq,i)}delete(r){const n=[...this.map.entries()].filter(s=>s[0]!==r);return new mt(this.groupBy,this.valueEq,n)}};const Fy=(e=Mt,r=k)=>new ru(e,r);var nu={};x(nu,{ExpiringMap:()=>as,MapOfMutableImpl:()=>vr,MapOfSimple:()=>ru,MapOfSimpleMutable:()=>us,NumberMap:()=>tu,addObjectEntriesMutate:()=>Yt,addValue:()=>gn,addValueMutate:()=>To,addValueMutator:()=>wn,deleteByValueCompareMutate:()=>Po,expiringMap:()=>ky,filterValues:()=>bn,findBySomeKey:()=>No,findEntryByPredicate:()=>ko,findEntryByValue:()=>Ao,findValue:()=>En,firstEntry:()=>Ay,firstEntryByValue:()=>Ha,fromIterable:()=>Ro,fromObject:()=>jo,getClosestIntegerKey:()=>So,getOrGenerate:()=>$n,getOrGenerateSync:()=>qo,hasAnyValue:()=>vn,hasKeyValue:()=>zo,immutable:()=>se,lengthMax:()=>Ty,mapOfSimpleMutable:()=>fo,mapToArray:()=>Oo,mapToObjectTransform:()=>_o,mergeByKey:()=>Fo,mutable:()=>_y,ofArrayMutable:()=>Oy,ofCircularMutable:()=>Iy,ofSetMutable:()=>Cy,ofSimple:()=>Fy,ofSimpleMutable:()=>fo,some:()=>Zt,sortByValue:()=>Vo,sortByValueProperty:()=>xn,toArray:()=>Ht,toObject:()=>Io,transformMap:()=>Co,zipKeyValue:()=>hr});var cs=class{rows=[];rowLabels=[];colLabels=[];columnMaxLength=0;getColumnLabelIndex(e){for(const[r,n]of this.colLabels.entries())if(n===e)return r}getRowLabelIndex(e){for(const[r,n]of this.rowLabels.entries())if(n===e)return r}print(){console.table([...this.rowsWithLabelsObject()])}asArray(){const e=[];for(const r of this.rows)r===void 0?e.push([]):e.push([...r]);return e}get rowCount(){return this.rows.length}get columnCount(){return this.columnMaxLength}*rowsWithLabelsObject(){for(let e=0;e<this.rows.length;e++)yield this.getRowWithLabelsObject(e)}*rowsWithLabelsArray(){for(let e=0;e<this.rows.length;e++)yield this.getRowWithLabelsArray(e)}labelColumns(...e){this.colLabels=e}labelColumn(e,r){this.colLabels[e]=r}labelRows(...e){this.rowLabels=e}labelRow(e,r){this.rowLabels[e]=r}appendRow(...e){return this.columnMaxLength=Math.max(this.columnMaxLength,e.length),this.rows.push(e),e}getRowWithLabelsArray(e){const r=this.rows.at(e);if(r!==void 0)return r.map((n,s)=>[this.colLabels.at(s),n])}getRowWithLabelsObject(e){const r=this.rows.at(e);if(r===void 0)return;const n={};for(let s=0;s<this.colLabels.length;s++){const o=this.colLabels.at(s)??s.toString();n[o]=r[s]}return n}#e(e){const r=typeof e=="number"?e:this.getRowLabelIndex(e);if(r===void 0)return{success:!1,error:"row-label-notfound"};if(r<0)return{success:!1,error:"row-index-invalid"};if(r<this.rows.length)return{success:!0,value:this.rows[r]};const n=[];return this.rows[r]=n,{success:!0,value:n}}row(e){const r=this.#t(e);if(Ue(r))throw new Error(r.error);return[...r.value]}set(e,r,n){const s=this.#e(e);if(Ue(s))throw new Error(s.error);const o=s.value,i=typeof r=="number"?r:this.getColumnLabelIndex(r);if(typeof i>"u")throw new Error(`Column label '${r}' not found or is invalid`);if(i<0)throw new Error("Column index invalid (less than zero)");o[i]=n}get(e,r){const n=this.#t(e);if(Ue(n))throw new Error(n.error);const s=this.#r(n.value,r);if(Ue(s))throw new Error(s.error);return s.value.value}#t(e){let r=0;if(typeof e=="number")r=e;else if(r=this.getRowLabelIndex(e),typeof r!="number")return{error:"row-label-notfound",success:!1};return typeof r!="number"?{error:"row-invalid",success:!1}:r<0||r>=this.rows.length?{error:"row-index-out-of-range",success:!1}:{success:!0,value:this.rows[r]}}#r(e,r){const n=typeof r=="number"?r:this.getColumnLabelIndex(r);return typeof n!="number"?{success:!1,error:"col-label-notfound"}:n<0||n>=e.length?{success:!1,error:"col-index-out-of-range"}:{success:!0,value:{index:n,value:e[n]}}}setRow(e,r,n){const s=this.#e(e);if(Ue(s))throw new Error(s.error);const o=s.value,i=typeof n=="number"?n:this.columnMaxLength;for(let a=0;a<i;a++)o[a]=r;return o}},su={};x(su,{adjacentVertices:()=>fs,areAdjacent:()=>Hy,bfs:()=>Yy,clone:()=>em,connect:()=>cu,connectTo:()=>Hr,connectWithEdges:()=>lu,createVertex:()=>ou,dfs:()=>fu,disconnect:()=>uu,distance:()=>iu,distanceDefault:()=>Xy,dumpGraph:()=>By,edges:()=>au,get:()=>Ly,getCycles:()=>hu,getOrCreate:()=>Qr,getOrFail:()=>Ky,graph:()=>tm,graphFromVertices:()=>du,hasKey:()=>qy,hasNoOuts:()=>Jy,hasOnlyOuts:()=>Wy,hasOut:()=>Fe,isAcyclic:()=>rm,pathDijkstra:()=>Zy,toAdjacencyMatrix:()=>Dy,topologicalSort:()=>nm,transitiveReduction:()=>yu,updateGraphVertex:()=>br,vertexHasOut:()=>Uy,vertices:()=>ls});const ou=e=>({id:e,out:[]});function qy(e,r){return g(j(e)),e.vertices.has(r)}function Ly(e,r){return g(j(e)),g(Hf(r,"non-empty","key")),e.vertices.get(r)}function Dy(e){g(j(e));const r=[...e.vertices.values()],n=new cs;n.labelColumns(...r.map(s=>s.id)),n.labelRows(...r.map(s=>s.id));for(let s=0;s<r.length;s++){n.setRow(s,!1,r.length);const o=r[s];for(const[i,a]of r.entries())o.out.some(u=>u.id===a.id)&&n.set(s,i,!0)}return n}const By=e=>Gy(e).join(`
`),Gy=e=>{const r=[],n="vertices"in e?e.vertices.values():e;for(const s of n){const o=Qy(s);r.push(...o.map(i=>` ${i}`))}return r},iu=(e,r)=>r.weight!==void 0?r.weight:1;function*au(e){g(j(e));const r=[...e.vertices.values()];for(const n of r)for(const s of n.out)yield s}function*ls(e){g(j(e));const r=[...e.vertices.values()];for(const n of r)yield n}function j(e,r="graph"){if(e===void 0)return{success:!1,error:`Param '${r}' is undefined. Expected Graph`};if(e===null)return{success:!1,error:`Param '${r}' is null. Expected Graph`};if(typeof e=="object"){if(!("vertices"in e))return{success:!1,error:`Param '${r}.vertices' does not exist. Is it a Graph type?`}}else return{success:!1,error:`Param '${r} is type '${typeof e}'. Expected an object Graph`};return{success:!0,value:e}}function*fs(e,r){if(g(j(e)),r===void 0)return;const n=typeof r=="string"?e.vertices.get(r):r;if(n===void 0)throw new Error(`Vertex not found ${JSON.stringify(r)}`);for(const s of n.out){const o=e.vertices.get(s.id);if(o===void 0)throw new Error(`Could not find vertex: ${s.id}`);yield o}}const Uy=(e,r)=>{if(e===void 0)return!1;const n=typeof r=="string"?r:r.id;return e.out.some(s=>s.id===n)},Jy=(e,r)=>{g(j(e));const n=typeof r=="string"?e.vertices.get(r):r;return n===void 0?!1:n.out.length===0},Wy=(e,r,...n)=>{g(j(e));const s=be(e,r),o=n.map(i=>be(e,i));if(o.length!==s.out.length)return!1;for(const i of o)if(!Fe(e,s,i))return!1;return!0},Fe=(e,r,n)=>{g(j(e));const s=be(e,r),o=typeof n=="string"?n:n.id;return s.out.some(i=>i.id===o)},Qr=(e,r)=>{g(j(e));const n=e.vertices.get(r);if(n!==void 0)return{graph:e,vertex:n};const s=ou(r);return{graph:br(e,s),vertex:s}},Ky=(e,r)=>{g(j(e));const n=e.vertices.get(r);if(n===void 0)throw new Error(`Vertex '${r}' not found in graph`);return n},br=(e,r)=>(g(j(e)),{...e,vertices:e.vertices.set(r.id,r)}),Xy=(e,r)=>r.weight!==void 0?r.weight:1;function uu(e,r,n){g(j(e));const s=be(e,r),o=be(e,n);return Fe(e,s,o)?br(e,{...s,out:s.out.filter(i=>i.id!==o.id)}):e}function Hr(e,r,n,s){g(j(e));const o=Qr(e,r);e=o.graph;const i=Qr(e,n);e=i.graph;const a={id:n,weight:s};return Fe(e,o.vertex,i.vertex)||(e=br(e,{...o.vertex,out:[...o.vertex.out,a]})),{graph:e,edge:a}}function cu(e,r){if(typeof e!="object")throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${typeof e}`);if(typeof r!="object")throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${typeof r}`);return lu(e,r).graph}function lu(e,r){g(j(e));const{to:n,weight:s,from:o}=r,i=r.bidi??!1,a=Array.isArray(n)?n:[n],u=[];for(const c of a){const l=Hr(e,o,c,s);e=l.graph,u.push(l.edge)}if(!i)return{graph:e,edges:u};for(const c of a){const l=Hr(e,c,o,s);e=l.graph,u.push(l.edge)}return{graph:e,edges:u}}const Qy=e=>{const r=[e.id],n=s=>s.weight===void 0?s.id:`${s.id} (${s.weight})`;for(const s of e.out)r.push(` -> ${n(s)}`);return e.out.length===0&&(r[0]+=" (terminal)"),r};function Hy(e,r,n){if(g(j(e)),Fe(e,r,n.id)||Fe(e,n,r.id))return!0}function be(e,r){if(g(j(e)),r===void 0)throw new Error("Param 'idOrVertex' is undefined. Expected string or Vertex");const n=typeof r=="string"?e.vertices.get(r):r;if(n===void 0)throw new Error(`Id not found ${r}`);return n}function*Yy(e,r,n){g(j(e));const s=be(e,r),o=n===void 0?void 0:be(e,n),i=new Ee,a=new Set;for(i.enqueue(s);!i.isEmpty;){const u=i.dequeue();if(yield u,o!==void 0&&o===u)return;for(const c of fs(e,u))a.has(c.id)||(a.add(c.id),i.enqueue(be(e,c.id)))}}function*fu(e,r){g(j(e));const n=be(e,r),s=new De,o=new Set;for(s.push(n);!s.isEmpty;){const i=s.pop();if(i!==void 0&&!o.has(i.id)){o.add(i.id),yield i;for(const a of i.out){const u=e.vertices.get(a.id);u&&s.push(u)}}}}const Zy=(e,r)=>{g(j(e));const n=typeof r=="string"?e.vertices.get(r):r;if(n===void 0)throw new Error("source vertex not found");const s=new Map,o=new Map;s.set(n.id,0);const i=new os,a=[...e.vertices.values()];for(const c of a)c.id!==n.id&&(s.set(c.id,Number.MAX_SAFE_INTEGER),o.set(c.id,null)),i.enqueueWithPriority(c.id,Number.MAX_SAFE_INTEGER);for(;!i.isEmpty;){const c=i.dequeueMin();if(c===void 0)throw new Error("Bug. Queue unexpectedly empty");const l=e.vertices.get(c);for(const f of l.out){const d=s.get(c)+iu(e,f);d<s.get(f.id)&&(s.set(f.id,d),o.set(f.id,l),i.changePriority(f.id,d,!0))}}return{distances:s,previous:o,pathTo:c=>{const l=[];for(;c!==n.id;){const f=o.get(c);if(f==null)throw new Error(`Id not present: ${c}`);l.push({id:c,weight:s.get(c)}),c=f.id}return l}}},em=e=>(g(j(e)),{vertices:se([...e.vertices.entries()])}),tm=(...e)=>{let r={vertices:se()};for(const n of e)r=cu(r,n);return r};function rm(e){return g(j(e)),hu(e).length===0}function nm(e){g(j(e));const r=new tu(0);for(const i of au(e))r.add(i.id,1);const n=new Ee;let s=0;for(const i of ls(e))r.get(i.id)===0&&n.enqueue(i),s++;const o=[];for(;!n.isEmpty;){const i=n.dequeue();o.push(i);for(const a of i.out)r.subtract(a.id,1)===0&&n.enqueue(e.vertices.get(a.id))}if(o.length!==s)throw new Error("Graph contains cycles");return du(o)}function du(e){const r=Sn(e,s=>[s.id,s]);return{vertices:se([...r])}}function hu(e){g(j(e));let r=0;const n=new De,s=new Map,o=[];for(const a of e.vertices.values())s.set(a.id,{...a,lowlink:NaN,index:NaN,onStack:!1});const i=a=>{a.index=r,a.lowlink=r,r++,n.push(a),a.onStack=!0;for(const u of a.out){const c=s.get(u.id);Number.isNaN(c.index)?(i(c),a.lowlink=Math.min(a.lowlink,c.lowlink)):c.onStack&&(a.lowlink=Math.min(a.lowlink,c.lowlink))}if(a.lowlink===a.index){const u=[];let c;for(;a!==c;)c=n.pop(),c.onStack=!1,u.push({id:c.id,out:c.out});u.length>1&&o.push(u)}};for(const a of s.values())Number.isNaN(a.index)&&i(a);return o}function yu(e){g(j(e));for(const r of ls(e))for(const n of fs(e,r))for(const s of fu(e,n))if(n.id!==s.id&&Fe(e,r,s)){const o=uu(e,r,s);return yu(o)}return e}var mu={};x(mu,{adjacentVertices:()=>cm,connect:()=>vu,connectTo:()=>xu,connectWithEdges:()=>bu,createVertex:()=>pu,dumpGraph:()=>im,edgesForVertex:()=>lm,getConnection:()=>ds,getOrCreate:()=>Yr,graph:()=>sm,hasConnection:()=>wu,toAdjacencyMatrix:()=>om,updateGraphVertex:()=>gu});const pu=e=>({id:e}),gu=(e,r)=>({...e,vertices:e.vertices.set(r.id,r)}),Yr=(e,r)=>{const n=e.vertices.get(r);if(n!==void 0)return{graph:e,vertex:n};const s=pu(r);return{graph:gu(e,s),vertex:s}};function ir(e,r){if(r===void 0)throw new Error("Param 'idOrVertex' is undefined. Expected string or Vertex");if(e===void 0)throw new Error("Param 'graph' is undefined. Expected Graph");const n=typeof r=="string"?e.vertices.get(r):r;if(n===void 0)throw new Error(`Id not found ${r}`);return n}const wu=(e,r,n)=>ds(e,r,n)!==void 0,ds=(e,r,n)=>{if(r===void 0)throw new Error("Param 'a' is undefined. Expected string or Vertex");if(n===void 0)throw new Error("Param 'b' is undefined. Expected string or Vertex");if(e===void 0)throw new Error("Param 'graph' is undefined. Expected Graph");const s=ir(e,r),o=ir(e,n);for(const i of e.edges)if(i.a==s.id&&i.b===o.id||i.a==o.id&&i.b===s.id)return i};function xu(e,r,n,s){e=Yr(e,r).graph,e=Yr(e,n).graph;let a=ds(e,r,n);return a!==void 0?{graph:e,edge:a}:(a={a:r,b:n,weight:s},{graph:{...e,edges:[...e.edges,a]},edge:a})}function vu(e,r){return bu(e,r).graph}function bu(e,r){const{a:n,weight:s,b:o}=r,i=Array.isArray(o)?o:[o],a=[];for(const u of i){const c=xu(e,n,u,s);e=c.graph,a.push(c.edge)}return{graph:e,edges:a}}const sm=(...e)=>{let r={vertices:se(),edges:[]};for(const n of e)r=vu(r,n);return r};function om(e){const r=[...e.vertices.values()],n=new cs;n.labelColumns(...r.map(s=>s.id)),n.labelRows(...r.map(s=>s.id));for(let s=0;s<r.length;s++){n.setRow(s,!1,r.length);const o=r[s];for(const[i,a]of r.entries())wu(e,o,a)&&n.set(s,i,!0)}return n}const im=e=>am(e).join(`
`),am=e=>{const r=[];r.push(`Vertices: ${[...e.vertices.values()].map(n=>n.id).join(", ")}`),r.push("Edges:");for(const n of e.edges)r.push(um(n));return r},um=e=>{const r=e.weight?` (${e.weight})`:"";return`${e.a} <-> ${e.b}${r}`};function*cm(e,r){if(r===void 0)return;if((typeof r=="string"?e.vertices.get(r):r)===void 0)throw new Error(`Vertex not found ${JSON.stringify(r)}`);for(const s of e.edges)s.a===r?yield ir(e,s.b):s.b===r&&(yield ir(e,s.a))}function*lm(e,r){if(r===void 0)return;if((typeof r=="string"?e.vertices.get(r):r)===void 0)throw new Error(`Vertex not found ${JSON.stringify(r)}`);for(const s of e.edges)s.a===r?yield s:s.b===r&&(yield s)}var Eu={};x(Eu,{Directed:()=>su,Undirected:()=>mu});var fm={};x(fm,{CircularArray:()=>aa,ExpiringMap:()=>as,Graphs:()=>Eu,MapOfSimpleMutable:()=>us,Maps:()=>nu,QueueImmutable:()=>is,QueueMutable:()=>Ee,Queues:()=>Qa,SetStringImmutable:()=>ss,SetStringMutable:()=>ns,Sets:()=>Xa,StackImmutable:()=>rs,StackMutable:()=>De,Stacks:()=>Ja,Table:()=>cs,Trees:()=>Ga});const ar=(e,r="")=>typeof e=="object"&&"name"in e&&e.name!==void 0?e.name:r;function*hs(e,r){typeof r>"u"&&(r=ar(e));for(const[n,s]of Zr(e))yield[s,r];for(const[n,s]of Zr(e)){const o=ar(s,"?"),i=r.length>0?r+"."+o:o;yield*hs(s,i)}}function*dm(e,r){typeof r>"u"&&(r=ar(e));for(const[n,s]of Zr(e)){yield[s,r];const o=ar(s,"?"),i=r.length>0?r+"."+o:o;yield*hs(s,i)}}function hm(e){return e.seq!==void 0}function ym(e){return e.sel!==void 0}function*Zr(e){if(hm(e))yield*e.seq.entries();else if(ym(e))yield*e.sel.entries();else if(typeof e!="string")throw new TypeError("Unexpected shape of node. seq/sel missing")}const mm=async(e,r)=>{const n=typeof r=="number"?{millis:r}:r,s=n.delay??"before";(s==="before"||s==="both")&&await B(n);const o=Promise.resolve(await e());return(s==="after"||s==="both")&&await B(n),o};async function*pm(){let e,r=new Promise(o=>e=o),n=0;const s=()=>{e&&e(),r=new Promise(o=>e=o)};try{for(;;)n=globalThis.requestAnimationFrame(s),yield await r}finally{e&&e(),globalThis.cancelAnimationFrame(n)}}async function*gm(e){const r=R(e);if(typeof r>"u")throw new Error("timeout is undefined");if(r<0)throw new Error("Timeout is less than zero");if(r===0)return yield*pm();let n,s=new Promise(a=>n=a),o;const i=()=>{n&&n(),s=new Promise(a=>n=a)};try{for(;;)o=globalThis.setTimeout(i,r),yield await s}finally{n&&n(),o!==void 0&&globalThis.clearTimeout(o),o=void 0}}const Er=(e,r)=>{if(e===void 0)throw new Error("callback parameter is undefined");const n=R(r);g(I(n,"aboveZero","interval"));let s,o=0,i=0,a=0,u="idle";const c=()=>{o=0,globalThis.clearTimeout(s),u="idle"},l=async(d=r,h)=>new Promise((p,w)=>{o=performance.now();const N=R(d),$=I(N,"aboveZero","altTimeoutMs");if(Ue($)){w(ed($));return}switch(u){case"scheduled":{f();break}}u="scheduled",s=globalThis.setTimeout(async()=>{if(u!=="scheduled"){console.warn("Timeout skipping execution since state is not 'scheduled'"),c();return}const T=h??[];i++,a++,u="running",await e(performance.now()-o,...T),u="idle",c(),p()},N)}),f=()=>{u!=="idle"&&c()};return{start:l,cancel:f,get runState(){return u},get startCount(){return i},get startCountTotal(){return a}}},wm=(e,r)=>{const n=Er(e,r);return(...s)=>{n.start(void 0,s)}};var xm=class{#e;#t=0;#r=Math.floor(Math.random()*100);constructor(){this.#e=[]}isEmpty(){return this.#e.length===0}add(e,r={}){this.#t++;const n=r.once??!1,s={id:`${this.#r} - ${this.#t}`,handler:e,once:n};return this.#e.push(s),s.id}remove(e){const r=this.#e.length;return this.#e=this.#e.filter(n=>n.id!==e),this.#e.length!==r}notify(e){for(const r of this.#e)r.handler(e),r.once&&this.remove(r.id)}clear(){this.#e=[]}};const vm=(e,r)=>{g(I(e,"positive","nth"));let n=0;return s=>(n++,n===e?(n=0,r&&r(s),!0):!1)},ys=async(e,r={},n)=>{const s=[],o=r.rank??$t;let i=Array.isArray(e)?e:[e];r.shuffle&&(i=Yf(i));for(let a=0;a<i.length;a++){const u=i[a];let c;if(typeof u=="function"?c=await u(n):c=u,c!==void 0&&(s.push(c),s.sort(o)),typeof r.stop<"u"&&r.stop(c,s))break}return r.filter?s.filter(r.filter):s},bm=async(e,r={},n)=>{const s=await ys(e,r,n);if(!s||s.length===0)return;const o=r.at??-1;return s.at(o)},Em=(e,r,n={})=>{const s=n.timeoutMs??601e3,o=n.signal;let i=!1,a=!1,u;return new Promise((l,f)=>{const d=y=>{"type"in y?r.includes(y.type)?(i=!0,l(y),h()):console.warn(`eventRace: Got event '${y.type}' that is not in race list`):(console.warn("eventRace: Event data does not have expected 'type' field"),console.log(y))};for(const y of r)e.addEventListener(y,d);const h=()=>{if(!a){u!==void 0&&clearTimeout(u),u=void 0,a=!0;for(const y of r)e.removeEventListener(y,d)}};u=setTimeout(()=>{i||a||(h(),f(new Error(`eventRace: Events not fired within interval. Events: ${JSON.stringify(r)} Interval: ${s}`)))},s),o?.addEventListener("abort",()=>{i||a||(h(),f(new Error(`Abort signal received ${o.reason}`)))})})},$m=e=>{const r=Ut(),n=zu({...e,whatToCall:s=>{r(s)},fallback(){return e.default??0}});return s=>(n(s),r())};var $u=class extends me{key;resource;_lastUpdate;_pool;_state;_userExpireAfterMs;constructor(e,r){super(),this.key=e,this.resource=r,this._lastUpdate=performance.now(),this._pool=r.pool,this._userExpireAfterMs=this._pool.userExpireAfterMs,this._state="idle",this._pool.log.log(`PoolUser ctor key: ${this.key}`)}toString(){return this.isDisposed?"PoolUser. State: disposed":`PoolUser. State: ${this._state} Elapsed: ${performance.now()-this._lastUpdate} Data: ${JSON.stringify(this.resource.data)}`}keepAlive(){if(this._state==="disposed")throw new Error("PoolItem disposed");this._lastUpdate=performance.now()}_dispose(e,r){if(this._state==="disposed")return;const n=this.resource;this._state="disposed",n._release(this),this._pool.log.log(`PoolUser dispose key: ${this.key} reason: ${e}`),this.fireEvent("disposed",{data:r,reason:e}),super.clearEventListeners()}release(e){if(this.isDisposed)throw new Error("User disposed");const n=this.resource.data;this._pool.log.log(`PoolUser release key: ${this.key} reason: ${e}`),this.fireEvent("released",{data:n,reason:e}),this._dispose(`release-${e}`,n)}get data(){if(this.isDisposed)throw new Error("User disposed");return this.resource.data}get isExpired(){return this._userExpireAfterMs>0?performance.now()>this._lastUpdate+this._userExpireAfterMs:!1}get elapsed(){return performance.now()-this._lastUpdate}get isDisposed(){return this._state==="disposed"}get isValid(){return!(this.isDisposed||this.isExpired||this.resource.isDisposed)}},Mu=class{pool;#e;#t;#r;#n;#s;#o;constructor(e,r){if(this.pool=e,r===void 0)throw new Error("Parameter 'data' is undefined");if(e===void 0)throw new Error("Parameter 'pool' is undefined");this.#t=r,this.#o=0,this.#s=e.resourcesWithoutUserExpireAfterMs,this.#n=e.capacityPerResource,this.#r=[],this.#e="idle"}get data(){if(this.#e==="disposed")throw new Error("Resource disposed");return this.#t}updateData(e){if(this.#e==="disposed")throw new Error("Resource disposed");if(e===void 0)throw new Error("Parameter 'data' is undefined");this.#t=e}toString(){return`Resource (expired: ${this.isExpiredFromUsers} users: ${this.#r.length}, state: ${this.#e}) data: ${JSON.stringify(this.data)}`}_assign(e){if(this.#r.find(n=>n===e||n.key===e.key))throw new Error("User instance already assigned to resource");this.#r.push(e),this.#o=performance.now()}_release(e){this.#r=this.#r.filter(r=>r!==e),this.pool._release(e),this.#o=performance.now()}get hasUserCapacity(){return this.usersCount<this.#n}get usersCount(){return this.#r.length}get isExpiredFromUsers(){return this.#s<=0||this.#r.length>0?!1:performance.now()>this.#s+this.#o}get isDisposed(){return this.#e==="disposed"}dispose(e){if(this.#e==="disposed")return;const r=this.#t;this.#e="disposed",this.pool.log.log(`Resource disposed (${e})`);for(const n of this.#r)n._dispose(`resource-${e}`,r);this.#r=[],this.#o=performance.now(),this.pool._releaseResource(this,e),this.pool.freeResource&&this.pool.freeResource(r)}},Su=class{_resources;_users;capacity;userExpireAfterMs;resourcesWithoutUserExpireAfterMs;capacityPerResource;fullPolicy;generateResource;freeResource;log=Ur("Pool");constructor(e={}){this.capacity=e.capacity??-1,this.fullPolicy=e.fullPolicy??"error",this.capacityPerResource=e.capacityPerResource??1,this.userExpireAfterMs=e.userExpireAfterMs??-1,this.resourcesWithoutUserExpireAfterMs=e.resourcesWithoutUserExpireAfterMs??-1,this.generateResource=e.generate,this.freeResource=e.free,this._users=new Map,this._resources=[],this.log=Ur("Pool",e.debug??!1);const r=Math.max(this.userExpireAfterMs,this.resourcesWithoutUserExpireAfterMs);r>0&&setInterval(()=>{this.maintain()},r*1.1)}dumpToString(){let e=`Pool
    capacity: ${this.capacity} userExpireAfterMs: ${this.userExpireAfterMs} capacityPerResource: ${this.capacityPerResource}
    resources count: ${this._resources.length}`;const r=this._resources.map(n=>n.toString()).join(`\r
	`);e+=`\r
Resources:\r
	`+r,e+=`\r
Users: \r
`;for(const[n,s]of this._users.entries())e+=`	k: ${n} v: ${s.toString()}\r
`;return e}getUsersByLongestElapsed(){return[...this._users.values()].sort((e,r)=>{const n=e.elapsed,s=r.elapsed;return n===s?0:n<s?1:-1})}getResourcesSortedByUse(){return[...this._resources].sort((e,r)=>e.usersCount===r.usersCount?0:e.usersCount<r.usersCount?-1:1)}addResource(e){if(e===void 0)throw new Error("Cannot add undefined resource");if(e===null)throw new TypeError("Cannot add null resource");if(this.capacity>0&&this._resources.length===this.capacity)throw new Error(`Capacity limit (${this.capacity}) reached. Cannot add more.`);this.log.log(`Adding resource: ${JSON.stringify(e)}`);const r=new Mu(this,e);return this._resources.push(r),r}maintain(){let e=!1;const r=[];for(const s of this._resources)s.isDisposed?(this.log.log(`Maintain, disposed resource: ${JSON.stringify(s.data)}`),r.push(s)):s.isExpiredFromUsers&&(this.log.log(`Maintain, expired resource: ${JSON.stringify(s.data)}`),r.push(s));if(r.length>0){for(const s of r)s.dispose("diposed/expired");e=!0}const n=[];for(const[s,o]of this._users.entries())o.isValid||(this.log.log(`Maintain. Invalid user: ${o.key} (Disposed: ${o.isDisposed} Expired: ${o.isExpired} Resource disposed: ${o.resource.isDisposed})`),n.push(s),o._dispose("invalid",o.data));for(const s of n)this._users.delete(s),e=!0;e&&this.log.log(`End: resource len: ${this._resources.length} users: ${this.usersLength}`)}*resources(){const e=[...this._resources];for(const r of e)yield r}*values(){const e=[...this._resources];for(const r of e)yield r.data}release(e,r){const n=this._users.get(e);n&&n.release(r??"Pool.release")}_release(e){this._users.delete(e.key)}_releaseResource(e,r){this._resources=this._resources.filter(n=>n!==e)}hasResource(e){return this._resources.find(n=>n.data===e)!==void 0}hasUser(e){return this._users.has(e)}_assign(e,r){const n=new $u(e,r);return this._users.set(e,n),r._assign(n),n}#e(e){const r=this.getResourcesSortedByUse();if(r.length>0&&r[0].hasUserCapacity)return this._assign(e,r[0]);if(this.generateResource&&(this.capacity<0||this._resources.length<this.capacity)){this.log.log(`capacity: ${this.capacity} resources: ${this._resources.length}`);const n=this.addResource(this.generateResource());return this._assign(e,n)}}get usersLength(){return[...this._users.values()].length}useValue(e){return this.use(e).resource.data}use(e){const r=this._users.get(e);if(r)return r.keepAlive(),r;this.maintain();const n=this.#e(e);if(n)return n;if(this.fullPolicy==="error")throw new Error(`Pool is fully used (fullPolicy: ${this.fullPolicy}, capacity: ${this.capacity})`);if(this.fullPolicy==="evictOldestUser"){const s=this.getUsersByLongestElapsed();if(s.length>0){this.release(s[0].key,"evictedOldestUser");const o=this.#e(e);if(o)return o}}throw new Error(`Pool is fully used (${this.fullPolicy})`)}};const Mm=(e={})=>new Su(e);function Nu(){let e,r;return{promise:new Promise((s,o)=>{e=s,r=o}),resolve:e,reject:r}}const zu=e=>{let r=!1;const n=Er(()=>{r||(n.start(),e.whatToCall(e.fallback()))},e.interval);return e.abort&&e.abort.addEventListener("abort",s=>{r=!0,n.cancel()}),n.start(),s=>{if(r)throw new Error("AbortSignal has been fired");n.start(),e.whatToCall(s)}};async function*Sm(e,r){const n=r.signal??void 0,s=r.delayWhen??"before",o=r.count??void 0,i=r.allowUndefined??!1,a=r.delayMinimum?R(r.delayMinimum):void 0,u=r.while;let c=!1,l=R(r.delay,R(r.delayMinimum,0)),f=performance.now();const d=async()=>{const p=performance.now()-f;if(typeof a<"u"&&(l=Math.max(0,a-p)),l&&await B({millis:l,signal:n}),f=performance.now(),n?.aborted)throw new Error(`Signal aborted ${n.reason}`)};Array.isArray(e)&&(e=e.values()),r.onStart&&r.onStart();let h=!0,y=0;try{for(;!c;){y++,(s==="before"||s==="both")&&await d();const p=await qh(e);typeof p>"u"&&!i?c=!0:(yield p,(s==="after"||s==="both")&&await d(),o!==void 0&&y>=o&&(c=!0)),u&&(u(y)||(c=!0))}h=!1}finally{c=!0,r.onComplete&&r.onComplete(h)}}function*Nm(e,r){const n=r.signal??void 0,s=r.count??void 0,o=r.allowUndefined??!1;let i=!1;Array.isArray(e)&&(e=e.values()),r.onStart&&r.onStart();let a=!0,u=0;try{for(;!i;){u++;const c=ia(e);typeof c>"u"&&!o?i=!0:(yield c,s!==void 0&&u>=s&&(i=!0),n?.aborted&&(i=!0))}a=!1}finally{i=!0,r.onComplete&&r.onComplete(a)}}var zm=class extends me{timeoutMs;whenUnmatchedResponse;keyRequest;keyResponse;#e=new Map;#t;constructor(e={}){if(super(),typeof window>"u"&&(globalThis.window={setTimeout,clearTimeout}),this.timeoutMs=e.timeoutMs??1e3,this.whenUnmatchedResponse=e.whenUnmatchedResponse??"throw",this.#t=yr(()=>this.#r(),this.timeoutMs*2),e.key){if(e.keyRequest)throw new Error("Cannot set 'keyRequest' when 'key' is set ");if(e.keyResponse)throw new Error("Cannot set 'keyResponse' when 'key' is set ");this.keyRequest=e.key,this.keyResponse=e.key}else{if(!e.keyRequest||!e.keyResponse)throw new Error("Expects 'keyRequest' & 'keyResponse' fields to be set if 'key' is not set");this.keyRequest=e.keyRequest,this.keyResponse=e.keyResponse}}#r(){const e=[...this.#e.values()],r=Date.now();for(const n of e)if(n.expiresAt<=r){n.promiseReject&&n.promiseReject("Request timeout");const s=n.callback;s&&setTimeout(()=>{s(!0,"Request timeout")},1),this.fireEvent("completed",{request:n.req,response:"Request timeout",success:!1}),this.#e.delete(n.id)}return this.debugDump(),this.#e.size>0}debugDump(){const e=[...this.#e.values()],r=Date.now();for(const n of e){const s=r-n.expiresAt;console.log(`${n.id} Expires in: ${Math.floor(s/1e3).toString()}s`)}}request(e,r){if(r!==void 0){this.#s(e,r);return}return this.#n(e)}requestAndForget(e){const r=this.keyRequest(e);if(this.#e.has(r))throw new Error(`Already a request pending with id '${r}'`);const n={expiresAt:Date.now()+this.timeoutMs,id:r,req:e};this.#e.set(r,n),this.#t.start()}#n(e){const r=this.keyRequest(e);if(this.#e.has(r))throw new Error(`Already a request pending with id '${r}'`);return new Promise((s,o)=>{const i={expiresAt:Date.now()+this.timeoutMs,id:r,req:e,promiseResolve:s,promiseReject:o};this.#e.set(r,i),this.#t.start()})}#s(e,r){const n=this.keyRequest(e);if(this.#e.has(n))throw new Error(`Already a request pending with id '${n}'`);const s={expiresAt:Date.now()+this.timeoutMs,id:n,req:e,callback:r};this.#e.set(n,s),this.#t.start()}response(e,r){const n=this.keyResponse(e),s=this.#e.get(n);if(!s){if(this.whenUnmatchedResponse==="throw")throw new Error(`Unmatched response with id: '${n}'`,{cause:e});return!1}return r?s.expiresAt=Date.now()+this.timeoutMs:this.#e.delete(n),s.promiseResolve&&s.promiseResolve(e),s.callback&&s.callback(!1,e),this.fireEvent("match",{request:s.req,response:e}),r||this.fireEvent("completed",{request:s.req,response:e,success:!0}),!0}};function*Pu(e={}){const r=e.startAt??1;let n=e.limitAttempts??Number.MAX_SAFE_INTEGER;const s=e.limitValue,o=e.power??1.1;let i=r;for(g(I(n,"aboveZero","limitAttempts"),z(r,"","startAt"),z(n,"","limitAttempts"),()=>s!==void 0?z(s,"","limitValue"):void 0,z(o,"","power"));n>0;){if(s&&i>=s)return;n--,yield i,i+=Math.pow(i,o)}}const Pm=(e,r={})=>ku({async probe(){try{const s=await e();return s===void 0?{value:r.taskValueFallback,error:"Fallback",success:!1}:{value:s,success:!0}}catch(s){return{success:!1,error:s}}}},r),ku=async(e,r={})=>{const n=r.abort,s=An(r.log),o=r.predelayMs??0,i=Oe();let a=0;const u=r.startAt??1e3,c=r.limitAttempts??Number.MAX_SAFE_INTEGER,l=Pu({...r,startAt:u,limitAttempts:c});if(u<=0)throw new Error("Param 'initialValue' must be above zero");if(o>0)try{await B({millis:o,signal:n})}catch(f){return{success:!1,attempts:a,value:r.taskValueFallback,elapsed:i(),message:tr(f)}}for(const f of l){a++;const d=await e.probe(a);if(d.success)return{success:d.success,value:d.value,attempts:a,elapsed:i()};if(s({msg:`retry attempts: ${a.toString()} t: ${Mo(f)}`}),a>=c)break;try{await B({millis:f,signal:n})}catch(h){return{success:!1,attempts:a,value:r.taskValueFallback,message:tr(h),elapsed:i()}}}return{message:`Giving up after ${a.toString()} attempts.`,success:!1,attempts:a,value:r.taskValueFallback,elapsed:i()}},km=e=>{let r=!1,n=!1;return()=>(r||(r=!0,n=e()),n)};var Am=class{#e;#t;#r;signal(){this.#e&&(this.#e(),this.#e=void 0),this.#r=Promise.resolve()}flush(){this.#t&&(this.#t("Flushed"),this.#t=void 0),this.#e=void 0,this.#r=void 0}#n(){const e=new Promise((r,n)=>{this.#e=r,this.#t=n});return this.#r=e,e}async forSignal(e){let r=this.#r;if(r??=this.#n(),e){const n=this.#t;setTimeout(()=>{n&&n(`Timeout elapsed ${e.toString()}`)},e)}await r,this.#r=void 0,this.#e=void 0,this.#t=void 0}async didSignal(e){try{return await this.forSignal(e),!0}catch{return!1}}},Tm=class Au extends me{static shared=new Au;_loop;_queue;constructor(){super(),this._queue=la(),this._loop=yr(()=>this.processQueue(),100)}enqueue(r){const n=this._queue.enqueue(r);return this._loop.runState==="idle"&&(this.fireEvent("started",{}),this._loop.start()),n}dequeue(){return this._queue.dequeue()}async processQueue(){const r=this._queue.dequeue();if(r===void 0)return this.fireEvent("empty",{}),!1;try{await r()}catch(n){console.error(n)}}clear(){this._queue.length!==0&&(this._queue.clear(),this._loop.cancel(),this.fireEvent("empty",{}))}get isEmpty(){return this._queue.isEmpty}get length(){return this._queue.length}};const Vm=(e,r)=>{let n=0;return async(...s)=>{const o=performance.now()-n;if(o>=r){const i=e(o,...s);typeof i=="object"&&await i,n=performance.now()}}};function Rm(e){const r=$r(R(e,0),{timer:zt(),clampValue:!0});return()=>r.isDone}function jm(e,r={}){const n=R(e);if(!n)throw new Error("Param 'duration' not valid");const s={...r,timer:zt()};let o;return()=>(o??=$r(n,s),o.elapsed)}function _m(e,r={}){const n={...r,timer:Ru()};let s;return()=>(s??=$r(e,n),s.elapsed)}const Tu=()=>({elapsed:1,isDone:!0,reset(){},mod(e){}}),Vu=()=>({elapsed:0,isDone:!1,reset(){},mod(){}}),$r=(e,r={})=>{if(Number.isFinite(e)){if(Number.isNaN(e))return Vu()}else return Tu();const n=r.clampValue??!1,s=r.wrapValue??!1;if(n&&s)throw new Error("clampValue and wrapValue cannot both be enabled");let o=1;const i=r.timer??zt();let a=0;const u=c=>{a=c;let l=c/(e*o);return n?l=Je(l):s&&l>=1&&(l=l%1),l};return{mod(c){o=c},get isDone(){return u(a)>=1},get elapsed(){return u(i.elapsed)},reset:()=>{i.reset()}}},Cm=(e,r={})=>{const n=r.timer??zt(),s=e/1e3;let o=1;const i=()=>{const a=n.elapsed*(s*o),u=a-Math.floor(a);if(u<0)throw new Error(`Unexpected cycle fraction less than 0. Elapsed: ${a} f: ${u}`);if(u>1)throw new Error(`Unexpected cycle fraction more than 1. Elapsed: ${a} f: ${u}`);return u};return{mod:a=>{o=a},reset:()=>{n.reset()},get isDone(){return i()>=1},get elapsed(){return i()}}},zt=()=>{let e=performance.now();return{reset:()=>{e=performance.now()},get elapsed(){return performance.now()-e}}},Ru=()=>{let e=0;return{reset:()=>{e=0},get peek(){return e},get elapsed(){return++e}}},Im=(e,r)=>{if(typeof e!="function")throw new Error(`Param 'fn' should be a function. Got: ${typeof e}`);let n=1;return{get elapsed(){return r.elapsed},get isDone(){return r.isDone},get runState(){return r.isDone?"idle":"scheduled"},get startCount(){return n},get startCountTotal(){return n},compute:()=>{const s=r.elapsed;return e(s)},reset:()=>{r.reset(),n++}}},Om=(e,r,n="slow")=>{let s=0,o,i=R(r,1e3);return()=>new Promise(async(a,u)=>{const c=performance.now()-s;if(o===void 0||c>i)try{s=performance.now(),o=await e(c),i=R(r,1e3)}catch(l){n==="fast"?(o=void 0,s=0):n==="backoff"&&(i=Math.floor(i*1.2)),u(l);return}a(o)})};var ju=class{#e;#t;#r=!1;constructor(){const{promise:e,resolve:r}=Nu();this.#e=e,this.#t=r}get(){return this.#e}add(e){if(this.#r)throw new Error("QueueSingleUse has already been used");this.#r=!0,this.#t(e)}get isUsed(){return this.#r}};const Fm=()=>new ju,qm=(e,r,n)=>{let s,o=!1;const i=a=>{s!==void 0&&(window.clearTimeout(s),s=void 0),a?r(a):o=!0,n!==void 0&&n(o)};return s=globalThis.setTimeout(()=>{s=void 0;try{r(`Timeout after ${e}ms`)}finally{n!==void 0&&n(o)}},e),i},en=e=>Object.freeze({value:e.value,visited:[...e.visited],machine:e.machine}),Mr=(e,r)=>{const[n,s]=_u(e);if(!n)throw new Error(s);const o=r??Object.keys(n.states)[0];if(typeof n.states[o]>"u")throw new TypeError(`Initial state ('${o}') not found`);const i=Lm(n.states);if(i===void 0)throw new Error("Could not normalise transitions");return Object.freeze({value:o,visited:[],machine:Object.freeze(Object.fromEntries(i))})},tn=e=>Mr(e.machine),_u=e=>typeof e>"u"?[void 0,"Parameter undefined"]:e===null?[void 0,"Parameter null"]:"states"in e?[e,""]:typeof e=="object"?[{states:e},""]:[void 0,`Unexpected type: ${typeof e}. Expected object`],rn=e=>wt(e).length===0,ms=e=>{Iu(e);const r=e.machine[e.value];return r.length===1&&r[0].state===null?[]:r},wt=e=>ms(e).map(n=>n.state),Cu=e=>{const r=n=>{if(n===null)return{state:null};if(typeof n=="string")return{state:n};if(typeof n=="object"&&"state"in n){const s=n.state;if(typeof s!="string")throw new TypeError(`Target 'state' field is not a string. Got: ${typeof s}`);return"preconditions"in n?{state:s,preconditions:n.preconditions}:{state:s}}else throw new Error(`Unexpected type: ${typeof n}. Expected string or object with 'state' field.`)};if(Array.isArray(e)){let n=!1;const s=e.map(o=>{const i=r(o);if(!i)throw new Error("Invalid target");return n=n||i.state===null,i});if(n&&s.length>1)throw new Error("Cannot have null as an possible state");return s}else{const n=r(e);return n?[n]:void 0}},Lm=e=>{const r=new Map;for(const[n,s]of Object.entries(e)){if(typeof n>"u")throw new TypeError("Top-level undefined state");if(typeof s>"u")throw new TypeError(`Undefined target state for ${n}`);if(r.has(n))throw new Error(`State defined twice: ${n}`);if(n.includes(" "))throw new Error("State names cannot contain spaces");r.set(n,[])}for(const[n,s]of Object.entries(e)){const o=Cu(s);if(o===void 0)throw new Error("Could not normalise target");if(o!==null){const i=new Set;for(const a of o){if(i.has(a.state))throw new Error(`Target state '${a.state}' already exists for '${n}'`);if(i.add(a.state),a.state!==null&&!r.has(a.state))throw new Error(`Target state '${a.state}' is not defined as a top-level state. Defined under: '${n}'`)}r.set(n,o)}}return r},Iu=e=>{if(typeof e>"u")throw new TypeError("Param 'state' is undefined");if(typeof e.value!="string")throw new TypeError("Existing state is not a string")},xt=(e,r)=>(Iu(e),Sr(e,r),Object.freeze({value:r,machine:e.machine,visited:Xf([e.visited,[e.value]])})),Ou=e=>{const r=ms(e).at(0);if(!r||r.state===null)throw new Error(`Not possible to move to a next state from '${e.value}`);return xt(e,r.state)},Fu=(e,r)=>{try{return Sr(e,r),!0}catch{return!1}},Sr=(e,r)=>{if(r===null)throw new Error("Cannot transition to null state");if(typeof r>"u")throw new Error("Cannot transition to undefined state");if(typeof r!="string")throw new TypeError(`Parameter 'toState' should be a string. Got: ${typeof r}`);const n=wt(e);if(n.length===0)throw new Error("Machine is in terminal state");if(!n.includes(r))throw new Error(`Target state '${r}' not available at current state '${e.value}'. Possible states: ${n.join(", ")}`)},Dm=(...e)=>{const r={};if(!Array.isArray(e))throw new Error("Expected array of strings");if(e.length<=2)throw new Error("Expects at least two states");for(let n=0;n<e.length;n++){const s=e[n];if(typeof s!="string")throw new TypeError(`Expected array of strings. Got type '${typeof s}' at index ${n.toString()}`);r[s]=n===e.length-1?null:e[n+1]}return r},Bm=(...e)=>{const r={};if(!Array.isArray(e))throw new Error("Expected array of strings");if(e.length<2)throw new Error("Expects at least two states");for(const[n,s]of e.entries()){if(typeof s!="string")throw new TypeError(`Expected array of strings. Got type '${typeof s}' at index ${n.toString()}`);r[s]=[]}for(let n=0;n<e.length;n++){const s=r[e[n]];n===e.length-1?e.length>1?s.push(e[n-1]):r[e[n]]=null:(s.push(e[n+1]),n>0&&s.push(e[n-1]))}return r};async function Gm(e,r){const n=Array.isArray(r)?{handlers:r}:r,s=An(n.debug,{category:"StateMachineDriver"}),o=new Map;for(const c of n.handlers){const l=Array.isArray(c.if)?c.if:[c.if];for(const f of l){if(typeof f!="string")throw new TypeError(`Expected single or array of strings for the 'if' field. Got: '${typeof f}'.`);if(o.has(f))throw new Error(`Multiple handlers defined for state '${f}'. There should be at most one.`);o.set(f,c)}}const i={rank:(c,l)=>$t(c.score??0,l.score??0),shuffle:n.shuffleHandlers??!1};let a=Mr(e);for(const[c]of o)if(typeof a.machine[c]>"u"&&c!=="__fallback")throw new Error(`StateMachineDriver handler references a state ('${c}') which is not defined on the machine. Therefore this handler will never run.'`);return{reset:()=>{a=tn(a)},getValue:()=>a.value,run:async()=>{s(`Run. State: ${a.value}`);const c=a.value;let l=o.get(c);if(l===void 0&&(s(`  No handler for state '${c}', trying __fallback`),l=o.get("__fallback")),l===void 0){s("  No __fallback handler");return}const f=l.resultChoice==="first"?{...i,stop:y=>y?"reset"in y||"next"in y&&y.next!==void 0:!1}:i,d=await ys(l.then,f,a);s(`  In state '${a.value}' results: ${d.length}. Choice: ${l.resultChoice}`);let h;switch(l.resultChoice??"highest"){case"highest":{h=d.at(-1);break}case"first":{h=d[0];break}case"lowest":{h=d.at(0);break}case"random":{h=Zf(d);break}default:throw new Error(`Unknown 'resultChoice' option: ${l.resultChoice}. Expected highest, first, lowest or random`)}return s(`  Chosen result: ${JSON.stringify(h)}`),h?.reset?a=tn(a):h&&h.next&&(typeof h.next=="boolean"?a=Ou(a):(s(JSON.stringify(d)),a=xt(a,h.next))),a},to:c=>(a=xt(a,c),a)}}var Um=class extends me{#e;#t;#r;#n=!1;#s=!1;#o=yd();constructor(e,r={}){super(),this.#r=r.debug??!1,this.#e=Mr(e,r.initial),this.#t=en(this.#e)}#i(e){this.#s!==e&&(this.#s=e,e?(this.#n=!0,setTimeout(()=>{this.#n&&(this.#n=!1,this.fireEvent("stop",{state:this.#e.value}))},2)):this.#n=!1)}get statesPossible(){return wt(this.#e)}get statesDefined(){return Object.keys(this.#e.machine)}next(){const e=wt(this.#e);return e.length===0?null:(this.state=e[0],e[0])}get isDone(){return rn(this.#e)}reset(){this.#i(!1),this.#e=en(this.#t),this.#o=Oe()}validateTransition(e){Sr(this.#e,e)}isValid(e){return Fu(this.#e,e)}set state(e){const r=this.#e.value;e!==this.#e.value&&(this.#e=xt(this.#e,e),this.#r&&console.log(`StateMachine: ${r} -> ${e}`),this.#o=Oe(),setTimeout(()=>{this.fireEvent("change",{newState:e,priorState:r})},1),rn(this.#e)&&this.#i(!0))}get state(){return this.#e.value}get changedAt(){return this.#o()}get elapsed(){return this.#o()}},qu={};x(qu,{StateMachineWithEvents:()=>Um,cloneState:()=>en,driver:()=>Gm,fromList:()=>Dm,fromListBidirectional:()=>Bm,init:()=>Mr,isDone:()=>rn,isValidTransition:()=>Fu,next:()=>Ou,normaliseTargets:()=>Cu,possible:()=>wt,possibleTargets:()=>ms,reset:()=>tn,to:()=>xt,validateMachine:()=>_u,validateTransition:()=>Sr});var Jm={};x(Jm,{DispatchList:()=>xm,Pool:()=>Su,PoolUser:()=>$u,RequestResponseMatch:()=>zm,Resource:()=>Mu,StateMachine:()=>qu,SyncWait:()=>Am,TaskQueueMutable:()=>Tm,WaitForValue:()=>ju,backoffGenerator:()=>Pu,continuously:()=>yr,create:()=>Mm,debounce:()=>wm,delay:()=>mm,delayLoop:()=>gm,elapsedMillisecondsAbsolute:()=>zt,elapsedTicksAbsolute:()=>Ru,eventRace:()=>Em,everyNth:()=>vm,frequencyTimer:()=>Cm,hasElapsed:()=>Rm,iterateBreadth:()=>hs,iterateDepth:()=>dm,movingAverageTimed:()=>$m,ofTotal:()=>jm,ofTotalTicks:()=>_m,promiseWithResolvers:()=>Nu,rateMinimum:()=>zu,relative:()=>$r,repeat:()=>Sm,repeatSync:()=>Nm,retryFunction:()=>Pm,retryTask:()=>ku,run:()=>ys,runOnce:()=>km,runSingle:()=>bm,singleItem:()=>Fm,sleep:()=>B,throttle:()=>Vm,timeout:()=>Er,timerAlwaysDone:()=>Tu,timerNeverDone:()=>Vu,timerWithFunction:()=>Im,updateOutdated:()=>Om,waitFor:()=>qm});const Lu=(e,r=Math.random)=>{const n=[];let s=0;for(let o=0;o<e.length;o++)s+=e[o],n[o]=s;if(s!==1)throw new Error(`Weightings should add up to 1. Got: ${s}`);return()=>{const o=r();for(let i=0;i<n.length;i++)if(o<=n[i])return i;throw new Error("Bug: weightedIndex could not select index")}},Du=(e,r=Math.random)=>Math.floor(r()*e.length);function Wm(e,r={}){if(typeof e>"u")throw new Error("Param 'array' is undefined");if(!Array.isArray(e))throw new Error("Param 'array' is not an array");const n=r.mutate??!1,s=r.source??Math.random;if(e.length===0)return n?void 0:{value:void 0,remainder:[]};const o=Du(e,s);if(n){const i=e[o];return e.splice(o,1),i}else{const i=[...e];return i.splice(o,1),{value:e[o],remainder:i}}}const Bu=(e,r=Math.random)=>(g(td(e,"array")),e[Math.floor(r()*e.length)]),Km=(e,r,n=Math.random)=>{if(e.length!==r.length)throw new Error("Lengths of 'array' and 'weightings' should be the same.");const s=Lu(r,n);return()=>{const o=s();return e[o]}},nn=(e,r=Math.random)=>{const n=[...e];for(let s=n.length-1;s>0;s--){const o=Math.floor(r()*(s+1));[n[s],n[o]]=[n[o],n[s]]}return n},Xm=(e,r,n,s)=>{const o=s??Math.random,i=u=>typeof u=="function"?u():u,a=i(e);return g(z(a,"percentage","p")),o()<=a?i(n):i(r)},Gu=e=>{const r=ps(e);return()=>r()*2-1},Qm=e=>Gu(e)(),ps=(e=1)=>{const r=typeof e=="number"?{max:e}:e;let n=r.max??1,s=r.min??0;const o=r.source??Math.random;if(g(z(s,"","min"),z(n,"","max")),!r.min&&n<0&&(s=n,n=0),s>n)throw new Error(`Min is greater than max. Min: ${s.toString()} max: ${n.toString()}`);return()=>o()*(n-s)+s},Hm=(e=1)=>ps(e)(),sn=(e=Math.random)=>{let r=0;for(;r===0;)r=e();return r},Ym=(e=1)=>Uu(e)(),Uu=(e=1)=>{const s=()=>{const o=sn(),i=sn();let a=Math.sqrt(-2*Math.log(o))*Math.cos(2*Math.PI*i);return a=a/10+.5,a>1||a<0?a=s():(a=Math.pow(a,e),a*=1,a+=0),a};return s},Zm=(e={})=>{const r=e.source??Math.random,n=Math.trunc(r()*46656),s=Math.trunc(r()*46656),o=`000${n.toString(36)}`.slice(-3),i=`000${s.toString(36)}`.slice(-3);return o+i};function*ep(e,r=0){if(g(I(e,"","amount"),I(r,"","offset")),e===0)return;let n=0;do yield e<0?-n+r:n+r;while(n++<Math.abs(e)-1)}const gs=e=>{if(typeof e>"u")throw new TypeError("maxOrOptions is undefined");const r=typeof e=="number"?{max:e}:e;let n=Math.floor(r.max??100),s=Math.floor(r.min??0);!r.min&&n<0&&(n=1,s=r.max??0);const o=r.source??Math.random;if(s>n)throw new Error(`Min value is greater than max (min: ${s.toString()} max: ${n.toString()})`);if(g(z(s,"","min"),z(n,"","max")),n===s)throw new Error(`Max and min values cannot be the same (${n.toString()})`);const i=Math.abs(n-s);return()=>Math.floor(o()*i)+s},Ju=e=>gs(e)();function*tp(e){const r=typeof e=="number"?{max:e}:e,n=r.min??0,s=r.max??100,o=r.source??Math.random,i=r.loop??!1;if(g(I(n,"","min"),I(s,"","max")),n>s)throw new Error(`Min value is greater than max. Min: ${n.toString()} Max: ${s.toString()}`);const a=[...ep(s-n,n)];let u=nn(a),c=0;for(;;){if(c===u.length)if(i)u=nn(a,o);else return;yield u[c++]}}function rp(e){e||(e=Math.random()*4294967295);let r=new Array(624);r[0]=e>>>0;const n=1812433253;for(let u=1;u<624;u++){const c=r[u-1]^r[u-1]>>>30;r[u]=((n&4294901760)*c>>>0)+((n&65535)*c>>>0)+u>>>0}let s=624;const o=()=>{let u;if(s>=624){for(let c=0;c<227;c++)u=(r[c]&2147483648|r[c+1]&2147483647)>>>0,r[c]=(r[c+397]^u>>>1^(u&1?2567483615:0))>>>0;for(let c=227;c<623;c++)u=(r[c]&2147483648|r[c+1]&2147483647)>>>0,r[c]=(r[c-227]^u>>>1^(u&1?2567483615:0))>>>0;u=(r[623]&2147483648|r[0]&2147483647)>>>0,r[623]=(r[396]^u>>>1^(u&1?2567483615:0))>>>0,s=0}return u=r[s++],u=(u^u>>>11)>>>0,u=(u^u<<7&2636928640)>>>0,u=(u^u<<15&4022730752)>>>0,u=(u^u>>>18)>>>0,u};return{integer:(u,c=0)=>{if(u<1)throw new Error("Upper bound must be greater than or equal to 1");if(u>4294967296)throw new Error("Upper bound must not be greater than 4294967296");if(u===1)return 0;let l=u-c;const f=Math.ceil(Math.log2(l)),d=(1<<f)-1;for(;;){const h=o()&d;if(h<l)return c+h}},float:()=>o()/4294967296}}const np=(e=5)=>{const r=typeof e=="number"?{length:e}:e,n=r.source??Math.random,s=r.length??5;let o="";for(;o.length<s;)o+=n().toString(36).slice(2);return o.substring(0,s)},Wu=e=>{const r=typeof e=="number"?{max:e}:e,n=(r.min??0)*60*1e3,s=(r.max??5)*60*1e3;return gs({...r,max:s,min:n})},sp=e=>Wu(e)(),Ku=e=>{const r=typeof e=="number"?{max:e}:e,n=(r.min??0)*1e3,s=(r.max??5)*1e3;return()=>Ju({...r,max:s,min:n})},op=e=>Ku(e)();function ip(e,r=0,n=1){return e<r?r:e>n?n:e}const Xu=e=>{const r=e.source??Math.random;if(typeof e.easingFunction>"u")throw new Error("Param 'easingFunction' is undefined");const n=e.max??1,s=e.min??0;if(n===s)throw new Error("Param 'max' is the same as  'min'");if(n<s)throw new Error("Param 'max' should be greater than  'min'");return()=>{const i=ip(e.easingFunction(r()));return Math.floor(i*(n-s))+s}},ap=e=>Xu(e)(),up=e=>Qu(e)(),Qu=e=>{const r=e.source??Math.random;if(typeof e.easing<"u")throw new Error("Param 'easingName' unavailable. Use @ixfx/modulation.weighted instead.");if(typeof e.easingFunction>"u")throw new Error("Param 'easingFunction' is undefined");return()=>e.easingFunction(r())};var cp={};x(cp,{bipolar:()=>Qm,bipolarSource:()=>Gu,calculateNonZero:()=>sn,chance:()=>Xm,float:()=>Hm,floatSource:()=>ps,gaussian:()=>Ym,gaussianSource:()=>Uu,integer:()=>Ju,integerSource:()=>gs,integerUniqueGen:()=>tp,mersenneTwister:()=>rp,minutesMs:()=>sp,minutesMsSource:()=>Wu,randomElement:()=>Bu,randomElementWeightedSource:()=>Km,randomIndex:()=>Du,randomPluck:()=>Wm,secondsMs:()=>op,secondsMsSource:()=>Ku,shortGuid:()=>Zm,shuffle:()=>nn,string:()=>np,weighted:()=>up,weightedIndex:()=>Lu,weightedInteger:()=>ap,weightedIntegerSource:()=>Xu,weightedSource:()=>Qu});function lp(e,r,n){return s=>{const o=e(s);o.changed?r(s,o.changes,o.total):typeof n<"u"&&n(s,o.identicalRun,o.total)}}function fp(e={}){const r=e.nanHandling??"error",n=e.includeFirstValueInCount??!1;let s=e.initial,o=0,i=0,a=0;return u=>{if(typeof u!="number")throw new TypeError(`Parameter should be number. Got type: ${typeof u}`);if(Number.isNaN(u))switch(r){case"error":throw new Error("Parameter is NaN");case"skip":return{changed:!1,changes:o,total:i,identicalRun:a}}i++;let c=s===u;if(Number.isNaN(s)&&Number.isNaN(u)&&(c=!0),c)a++;else return a=0,(s!==void 0||n)&&o++,s=u,{changed:!0,changes:o,total:i,identicalRun:a};return{changed:!1,changes:o,total:i,identicalRun:a}}}function dp(e={}){const r=e.includeFirstValueInCount??!1;let n=e.initial,s=0,o=0,i=0;return a=>{if(typeof a!="boolean")throw new TypeError(`Parameter should be boolean. Got type: ${typeof a}`);return o++,n!==a?(i=0,(n!==void 0||r)&&s++,n=a,{changed:!0,changes:s,total:o,identicalRun:i}):(i++,{changed:!1,changes:s,total:o,identicalRun:i})}}var Hu=class extends me{#e;#t;constructor(e){super(),this.#e=new Map,typeof e>"u"&&(e=r=>{if(r===void 0)throw new Error("Cannot create key for undefined");return typeof r=="string"?r:JSON.stringify(r)}),this.#t=e}clear(){this.#e.clear(),this.fireEvent("change",{context:this})}keys(){return this.#e.keys()}values(){return this.#e.values()}toArray(){return[...this.#e.entries()]}debugString(){let e="";for(const[r,n]of this.#e.entries())e+=`${r}: ${n.toString()}, `;return e.endsWith(", ")?e.slice(0,Math.max(0,e.length-2)):e}frequencyOf(e){if(typeof e=="string")return this.#e.get(e);const r=this.#t(e);return this.#e.get(r)}relativeFrequencyOf(e){let r;if(typeof e=="string")r=this.#e.get(e);else{const s=this.#t(e);r=this.#e.get(s)}if(r===void 0)return;const n=this.computeValues();return r/n.total}entries(){return[...this.#e.entries()]}computeValues(){const e=[...this.values()];return vo(e)}entriesSorted(e="value"){return _h(e)(this.entries())}add(...e){if(typeof e>"u")throw new Error("Param 'values' undefined");const r=e.map(n=>this.#t(n));for(const n of r){const s=this.#e.get(n)??0;this.#e.set(n,s+1)}this.fireEvent("change",{context:this})}};const hp=e=>new Hu(e);var ws=class{seenCount;storeIntermediate;resetAfterSamples;sampleLimit;id;debug;constructor(e={}){this.id=e.id??"tracker",this.debug=e.debug??!1,this.sampleLimit=e.sampleLimit??-1,this.resetAfterSamples=e.resetAfterSamples??-1,this.storeIntermediate=e.storeIntermediate??(this.sampleLimit>-1||this.resetAfterSamples>-1),this.seenCount=0,this.debug&&console.log(`TrackerBase: sampleLimit: ${this.sampleLimit} resetAfter: ${this.resetAfterSamples} store: ${this.storeIntermediate}`)}reset(){this.seenCount=0,this.onReset()}seen(...e){this.resetAfterSamples>0&&this.seenCount>this.resetAfterSamples?this.reset():this.sampleLimit>0&&this.seenCount>this.sampleLimit*2&&(this.seenCount=this.trimStore(this.sampleLimit),this.onTrimmed("resize")),this.seenCount+=e.length;const r=this.filterData(e);return this.computeResults(r)}},Yu=class extends ws{values;timestamps;constructor(e){super(e),this.values=[],this.timestamps=[]}trimStore(e){return e>=this.values.length?this.values.length:(this.values=this.values.slice(-e),this.timestamps=this.timestamps.slice(-e),this.values.length)}onTrimmed(e){}get last(){return this.values.at(-1)}get initial(){return this.values.at(0)}get size(){return this.values.length}get elapsed(){if(this.values.length<0)throw new Error("No values seen yet");return Date.now()-this.timestamps[0]}onReset(){this.values=[],this.timestamps=[]}filterData(e){const n={value:e.at(-1),at:performance.now()},s=e.map(o=>({at:performance.now(),value:o}));if(this.storeIntermediate)this.values.push(...e),this.timestamps.push(...s.map(o=>o.at));else switch(this.values.length){case 0:{this.values.push(n.value),this.timestamps.push(n.at);break}case 2:{this.values[1]=n.value,this.timestamps[1]=n.at;break}case 1:{this.values.push(n.value),this.timestamps.push(n.at);break}}return s}},xs=class extends Yu{total=0;min=Number.MAX_SAFE_INTEGER;max=Number.MIN_SAFE_INTEGER;get avg(){return this.total/this.seenCount}difference(){if(this.last!==void 0&&this.initial!==void 0)return this.last-this.initial}relativeDifference(){if(this.last!==void 0&&this.initial!==void 0)return this.last/this.initial}onReset(){this.min=Number.MAX_SAFE_INTEGER,this.max=Number.MIN_SAFE_INTEGER,this.total=0,super.onReset()}onTrimmed(e){this.min=bo(this.values),this.max=rd(this.values),this.total=nd(this.values)}computeResults(e){if(e.some(s=>Number.isNaN(s)))throw new Error("Cannot add NaN");const r=e.map(s=>s.value);return this.total=r.reduce((s,o)=>s+o,this.total),this.min=Math.min(...r,this.min),this.max=Math.max(...r,this.max),{max:this.max,min:this.min,total:this.total,avg:this.avg}}getMinMaxAvg(){return{min:this.min,max:this.max,avg:this.avg}}};const yp=(e={})=>new xs(e);var Zu=class extends xs{lastMark=0;mark(){this.lastMark>0&&this.seen(performance.now()-this.lastMark),this.lastMark=performance.now()}};const mp=e=>new Zu(e);var ec=class{#e=[];#t;#r;#n;#s;constructor(e={}){this.#r=e.resetAfterSamples??Number.MAX_SAFE_INTEGER,this.#n=e.sampleLimit??Number.MAX_SAFE_INTEGER,e.timeoutInterval&&(this.#s=Er(()=>{this.reset()},e.timeoutInterval)),this.#t=performance.now()}mark(){this.#e.length>=this.#r?this.reset():this.#e.length>=this.#n&&(this.#e=this.#e.slice(1),this.#t=this.#e[0]),this.#e.push(performance.now()),this.#s&&this.#s.start()}computeIntervals(){let e=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,n=0,s=0,o=0;for(const a of this.#e){if(s>0){const u=a-o;e=Math.min(u,e),r=Math.max(u,r),n+=u}o=a,s++}const i=n/s;return{min:e,max:r,avg:i}}get elapsed(){return performance.now()-this.#t}reset(){this.#e=[],this.#t=performance.now()}get perSecond(){return this.#e.length/(this.elapsed/1e3)}get perMinute(){return this.#e.length/(this.elapsed/1e3/60)}};const pp=(e={})=>new ec(e);var tc=class extends ws{values;constructor(e={}){super(e),this.values=[]}onTrimmed(e){}trimStore(e){return e>=this.values.length?this.values.length:(this.values=this.values.slice(-e),this.values.length)}onReset(){this.values=[]}filterData(e){const r=e.map(s=>"at"in s?s:{...s,at:Date.now()}),n=r.at(-1);if(this.storeIntermediate)this.values.push(...r);else switch(this.values.length){case 0:{this.values.push(n);break}case 1:{this.values.push(n);break}case 2:{this.values[1]=n;break}}return r}get last(){return this.values.length===1?this.values[0]:this.values.at(-1)}get initial(){return this.values.at(0)}get size(){return this.values.length}get elapsed(){return Date.now()-this.values[0].at}},rc=class{store;gog;constructor(e){this.store=new Map,this.gog=$n(this.store,e)}get size(){return this.store.size}has(e){return this.store.has(e)}async seen(e,...r){return(await this.getTrackedValue(e,...r)).seen(...r)}async getTrackedValue(e,...r){if(e===null)throw new Error("id parameter cannot be null");if(e===void 0)throw new Error("id parameter cannot be undefined");return await this.gog(e,r[0])}delete(e){this.store.delete(e)}reset(){this.store=new Map}*ids(){yield*this.store.keys()}*tracked(){yield*this.store.values()}*trackedByAge(){const e=[...this.store.values()];e.sort((r,n)=>{const s=r.elapsed,o=n.elapsed;return s===o?0:s>o?-1:1});for(const r of e)yield r}*valuesByAge(){for(const e of this.trackedByAge())yield e.last}*last(){for(const e of this.store.values())yield e.last}*initialValues(){for(const e of this.store.values())yield e.initial}get(e){return this.store.get(e)}},gp={};x(gp,{FrequencyTracker:()=>Hu,IntervalTracker:()=>Zu,NumberTracker:()=>xs,ObjectTracker:()=>tc,PrimitiveTracker:()=>Yu,RateTracker:()=>ec,TrackedValueMap:()=>rc,TrackerBase:()=>ws,frequency:()=>hp,handleChangeResult:()=>lp,interval:()=>mp,number:()=>yp,rate:()=>pp,trackBooleanChange:()=>dp,trackNumberChange:()=>fp});const{abs:at,cos:ge,sin:Ge,acos:wp,atan2:ut,sqrt:ze,pow:Z}=Math;function ct(e){return e<0?-Z(-e,1/3):Z(e,1/3)}const nc=Math.PI,Gt=2*nc,Pe=nc/2,xp=1e-6,Or=Number.MAX_SAFE_INTEGER||9007199254740991,Fr=Number.MIN_SAFE_INTEGER||-9007199254740991,vp={x:0,y:0,z:0},m={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(e,r){const n=r(e);let s=n.x*n.x+n.y*n.y;return typeof n.z<"u"&&(s+=n.z*n.z),ze(s)},compute:function(e,r,n){if(e===0)return r[0].t=0,r[0];const s=r.length-1;if(e===1)return r[s].t=1,r[s];const o=1-e;let i=r;if(s===0)return r[0].t=e,r[0];if(s===1){const u={x:o*i[0].x+e*i[1].x,y:o*i[0].y+e*i[1].y,t:e};return n&&(u.z=o*i[0].z+e*i[1].z),u}if(s<4){let u=o*o,c=e*e,l,f,d,h=0;s===2?(i=[i[0],i[1],i[2],vp],l=u,f=o*e*2,d=c):s===3&&(l=u*o,f=u*e*3,d=o*c*3,h=e*c);const y={x:l*i[0].x+f*i[1].x+d*i[2].x+h*i[3].x,y:l*i[0].y+f*i[1].y+d*i[2].y+h*i[3].y,t:e};return n&&(y.z=l*i[0].z+f*i[1].z+d*i[2].z+h*i[3].z),y}const a=JSON.parse(JSON.stringify(r));for(;a.length>1;){for(let u=0;u<a.length-1;u++)a[u]={x:a[u].x+(a[u+1].x-a[u].x)*e,y:a[u].y+(a[u+1].y-a[u].y)*e},typeof a[u].z<"u"&&(a[u].z=a[u].z+(a[u+1].z-a[u].z)*e);a.splice(a.length-1,1)}return a[0].t=e,a[0]},computeWithRatios:function(e,r,n,s){const o=1-e,i=n,a=r;let u=i[0],c=i[1],l=i[2],f=i[3],d;if(u*=o,c*=e,a.length===2)return d=u+c,{x:(u*a[0].x+c*a[1].x)/d,y:(u*a[0].y+c*a[1].y)/d,z:s?(u*a[0].z+c*a[1].z)/d:!1,t:e};if(u*=o,c*=2*o,l*=e*e,a.length===3)return d=u+c+l,{x:(u*a[0].x+c*a[1].x+l*a[2].x)/d,y:(u*a[0].y+c*a[1].y+l*a[2].y)/d,z:s?(u*a[0].z+c*a[1].z+l*a[2].z)/d:!1,t:e};if(u*=o,c*=1.5*o,l*=3*o,f*=e*e*e,a.length===4)return d=u+c+l+f,{x:(u*a[0].x+c*a[1].x+l*a[2].x+f*a[3].x)/d,y:(u*a[0].y+c*a[1].y+l*a[2].y+f*a[3].y)/d,z:s?(u*a[0].z+c*a[1].z+l*a[2].z+f*a[3].z)/d:!1,t:e}},derive:function(e,r){const n=[];for(let s=e,o=s.length,i=o-1;o>1;o--,i--){const a=[];for(let u=0,c;u<i;u++)c={x:i*(s[u+1].x-s[u].x),y:i*(s[u+1].y-s[u].y)},r&&(c.z=i*(s[u+1].z-s[u].z)),a.push(c);n.push(a),s=a}return n},between:function(e,r,n){return r<=e&&e<=n||m.approximately(e,r)||m.approximately(e,n)},approximately:function(e,r,n){return at(e-r)<=(n||xp)},length:function(e){const n=m.Tvalues.length;let s=0;for(let o=0,i;o<n;o++)i=.5*m.Tvalues[o]+.5,s+=m.Cvalues[o]*m.arcfn(i,e);return .5*s},map:function(e,r,n,s,o){const i=n-r,a=o-s,u=e-r,c=u/i;return s+a*c},lerp:function(e,r,n){const s={x:r.x+e*(n.x-r.x),y:r.y+e*(n.y-r.y)};return r.z!==void 0&&n.z!==void 0&&(s.z=r.z+e*(n.z-r.z)),s},pointToString:function(e){let r=e.x+"/"+e.y;return typeof e.z<"u"&&(r+="/"+e.z),r},pointsToString:function(e){return"["+e.map(m.pointToString).join(", ")+"]"},copy:function(e){return JSON.parse(JSON.stringify(e))},angle:function(e,r,n){const s=r.x-e.x,o=r.y-e.y,i=n.x-e.x,a=n.y-e.y,u=s*a-o*i,c=s*i+o*a;return ut(u,c)},round:function(e,r){const n=""+e,s=n.indexOf(".");return parseFloat(n.substring(0,s+1+r))},dist:function(e,r){const n=e.x-r.x,s=e.y-r.y;return ze(n*n+s*s)},closest:function(e,r){let n=Z(2,63),s,o;return e.forEach(function(i,a){o=m.dist(r,i),o<n&&(n=o,s=a)}),{mdist:n,mpos:s}},abcratio:function(e,r){if(r!==2&&r!==3)return!1;if(typeof e>"u")e=.5;else if(e===0||e===1)return e;const n=Z(e,r)+Z(1-e,r),s=n-1;return at(s/n)},projectionratio:function(e,r){if(r!==2&&r!==3)return!1;if(typeof e>"u")e=.5;else if(e===0||e===1)return e;const n=Z(1-e,r),s=Z(e,r)+n;return n/s},lli8:function(e,r,n,s,o,i,a,u){const c=(e*s-r*n)*(o-a)-(e-n)*(o*u-i*a),l=(e*s-r*n)*(i-u)-(r-s)*(o*u-i*a),f=(e-n)*(i-u)-(r-s)*(o-a);return f==0?!1:{x:c/f,y:l/f}},lli4:function(e,r,n,s){const o=e.x,i=e.y,a=r.x,u=r.y,c=n.x,l=n.y,f=s.x,d=s.y;return m.lli8(o,i,a,u,c,l,f,d)},lli:function(e,r){return m.lli4(e,e.c,r,r.c)},makeline:function(e,r){return new vt(e.x,e.y,(e.x+r.x)/2,(e.y+r.y)/2,r.x,r.y)},findbbox:function(e){let r=Or,n=Or,s=Fr,o=Fr;return e.forEach(function(i){const a=i.bbox();r>a.x.min&&(r=a.x.min),n>a.y.min&&(n=a.y.min),s<a.x.max&&(s=a.x.max),o<a.y.max&&(o=a.y.max)}),{x:{min:r,mid:(r+s)/2,max:s,size:s-r},y:{min:n,mid:(n+o)/2,max:o,size:o-n}}},shapeintersections:function(e,r,n,s,o){if(!m.bboxoverlap(r,s))return[];const i=[],a=[e.startcap,e.forward,e.back,e.endcap],u=[n.startcap,n.forward,n.back,n.endcap];return a.forEach(function(c){c.virtual||u.forEach(function(l){if(l.virtual)return;const f=c.intersects(l,o);f.length>0&&(f.c1=c,f.c2=l,f.s1=e,f.s2=n,i.push(f))})}),i},makeshape:function(e,r,n){const s=r.points.length,o=e.points.length,i=m.makeline(r.points[s-1],e.points[0]),a=m.makeline(e.points[o-1],r.points[0]),u={startcap:i,forward:e,back:r,endcap:a,bbox:m.findbbox([i,e,r,a])};return u.intersections=function(c){return m.shapeintersections(u,u.bbox,c,c.bbox,n)},u},getminmax:function(e,r,n){if(!n)return{min:0,max:0};let s=Or,o=Fr,i,a;n.indexOf(0)===-1&&(n=[0].concat(n)),n.indexOf(1)===-1&&n.push(1);for(let u=0,c=n.length;u<c;u++)i=n[u],a=e.get(i),a[r]<s&&(s=a[r]),a[r]>o&&(o=a[r]);return{min:s,mid:(s+o)/2,max:o,size:o-s}},align:function(e,r){const n=r.p1.x,s=r.p1.y,o=-ut(r.p2.y-s,r.p2.x-n),i=function(a){return{x:(a.x-n)*ge(o)-(a.y-s)*Ge(o),y:(a.x-n)*Ge(o)+(a.y-s)*ge(o)}};return e.map(i)},roots:function(e,r){r=r||{p1:{x:0,y:0},p2:{x:1,y:0}};const n=e.length-1,s=m.align(e,r),o=function(M){return 0<=M&&M<=1};if(n===2){const M=s[0].y,P=s[1].y,U=s[2].y,L=M-2*P+U;if(L!==0){const ae=-ze(P*P-M*U),Y=-M+P,Se=-(ae+Y)/L,Ie=-(-ae+Y)/L;return[Se,Ie].filter(o)}else if(P!==U&&L===0)return[(2*P-U)/(2*P-2*U)].filter(o);return[]}const i=s[0].y,a=s[1].y,u=s[2].y,c=s[3].y;let l=-i+3*a-3*u+c,f=3*i-6*a+3*u,d=-3*i+3*a,h=i;if(m.approximately(l,0)){if(m.approximately(f,0))return m.approximately(d,0)?[]:[-h/d].filter(o);const M=ze(d*d-4*f*h),P=2*f;return[(M-d)/P,(-d-M)/P].filter(o)}f/=l,d/=l,h/=l;const y=(3*d-f*f)/3,p=y/3,w=(2*f*f*f-9*f*d+27*h)/27,N=w/2,$=N*N+p*p*p;let T,O,K,v,_;if($<0){const M=-y/3,P=M*M*M,U=ze(P),L=-w/(2*U),ae=L<-1?-1:L>1?1:L,Y=wp(ae),Se=ct(U),Ie=2*Se;return K=Ie*ge(Y/3)-f/3,v=Ie*ge((Y+Gt)/3)-f/3,_=Ie*ge((Y+2*Gt)/3)-f/3,[K,v,_].filter(o)}else{if($===0)return T=N<0?ct(-N):-ct(N),K=2*T-f/3,v=-T-f/3,[K,v].filter(o);{const M=ze($);return T=ct(-N+M),O=ct(N+M),[T-O-f/3].filter(o)}}},droots:function(e){if(e.length===3){const r=e[0],n=e[1],s=e[2],o=r-2*n+s;if(o!==0){const i=-ze(n*n-r*s),a=-r+n,u=-(i+a)/o,c=-(-i+a)/o;return[u,c]}else if(n!==s&&o===0)return[(2*n-s)/(2*(n-s))];return[]}if(e.length===2){const r=e[0],n=e[1];return r!==n?[r/(r-n)]:[]}return[]},curvature:function(e,r,n,s,o){let i,a,u,c,l=0,f=0;const d=m.compute(e,r),h=m.compute(e,n),y=d.x*d.x+d.y*d.y;if(s?(i=ze(Z(d.y*h.z-h.y*d.z,2)+Z(d.z*h.x-h.z*d.x,2)+Z(d.x*h.y-h.x*d.y,2)),a=Z(y+d.z*d.z,3/2)):(i=d.x*h.y-d.y*h.x,a=Z(y,3/2)),i===0||a===0)return{k:0,r:0};if(l=i/a,f=a/i,!o){const p=m.curvature(e-.001,r,n,s,!0).k,w=m.curvature(e+.001,r,n,s,!0).k;c=(w-l+(l-p))/2,u=(at(w-l)+at(l-p))/2}return{k:l,r:f,dk:c,adk:u}},inflections:function(e){if(e.length<4)return[];const r=m.align(e,{p1:e[0],p2:e.slice(-1)[0]}),n=r[2].x*r[1].y,s=r[3].x*r[1].y,o=r[1].x*r[2].y,i=r[3].x*r[2].y,a=18*(-3*n+2*s+3*o-i),u=18*(3*n-s-3*o),c=18*(o-n);if(m.approximately(a,0)){if(!m.approximately(u,0)){let h=-c/u;if(0<=h&&h<=1)return[h]}return[]}const l=2*a;if(m.approximately(l,0))return[];const f=u*u-4*a*c;if(f<0)return[];const d=Math.sqrt(f);return[(d-u)/l,-(u+d)/l].filter(function(h){return 0<=h&&h<=1})},bboxoverlap:function(e,r){const n=["x","y"],s=n.length;for(let o=0,i,a,u,c;o<s;o++)if(i=n[o],a=e[i].mid,u=r[i].mid,c=(e[i].size+r[i].size)/2,at(a-u)>=c)return!1;return!0},expandbox:function(e,r){r.x.min<e.x.min&&(e.x.min=r.x.min),r.y.min<e.y.min&&(e.y.min=r.y.min),r.z&&r.z.min<e.z.min&&(e.z.min=r.z.min),r.x.max>e.x.max&&(e.x.max=r.x.max),r.y.max>e.y.max&&(e.y.max=r.y.max),r.z&&r.z.max>e.z.max&&(e.z.max=r.z.max),e.x.mid=(e.x.min+e.x.max)/2,e.y.mid=(e.y.min+e.y.max)/2,e.z&&(e.z.mid=(e.z.min+e.z.max)/2),e.x.size=e.x.max-e.x.min,e.y.size=e.y.max-e.y.min,e.z&&(e.z.size=e.z.max-e.z.min)},pairiteration:function(e,r,n){const s=e.bbox(),o=r.bbox(),i=1e5,a=n||.5;if(s.x.size+s.y.size<a&&o.x.size+o.y.size<a)return[(i*(e._t1+e._t2)/2|0)/i+"/"+(i*(r._t1+r._t2)/2|0)/i];let u=e.split(.5),c=r.split(.5),l=[{left:u.left,right:c.left},{left:u.left,right:c.right},{left:u.right,right:c.right},{left:u.right,right:c.left}];l=l.filter(function(d){return m.bboxoverlap(d.left.bbox(),d.right.bbox())});let f=[];return l.length===0||(l.forEach(function(d){f=f.concat(m.pairiteration(d.left,d.right,a))}),f=f.filter(function(d,h){return f.indexOf(d)===h})),f},getccenter:function(e,r,n){const s=r.x-e.x,o=r.y-e.y,i=n.x-r.x,a=n.y-r.y,u=s*ge(Pe)-o*Ge(Pe),c=s*Ge(Pe)+o*ge(Pe),l=i*ge(Pe)-a*Ge(Pe),f=i*Ge(Pe)+a*ge(Pe),d=(e.x+r.x)/2,h=(e.y+r.y)/2,y=(r.x+n.x)/2,p=(r.y+n.y)/2,w=d+u,N=h+c,$=y+l,T=p+f,O=m.lli8(d,h,w,N,y,p,$,T),K=m.dist(O,e);let v=ut(e.y-O.y,e.x-O.x),_=ut(r.y-O.y,r.x-O.x),M=ut(n.y-O.y,n.x-O.x),P;return v<M?((v>_||_>M)&&(v+=Gt),v>M&&(P=M,M=v,v=P)):M<_&&_<v?(P=M,M=v,v=P):M+=Gt,O.s=v,O.e=M,O.r=K,O},numberSort:function(e,r){return e-r}};var qr=class sc{constructor(r){this.curves=[],this._3d=!1,r&&(this.curves=r,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map(function(r){return m.pointsToString(r.points)}).join(", ")+"]"}addCurve(r){this.curves.push(r),this._3d=this._3d||r._3d}length(){return this.curves.map(function(r){return r.length()}).reduce(function(r,n){return r+n})}curve(r){return this.curves[r]}bbox(){const r=this.curves;for(var n=r[0].bbox(),s=1;s<r.length;s++)m.expandbox(n,r[s].bbox());return n}offset(r){const n=[];return this.curves.forEach(function(s){n.push(...s.offset(r))}),new sc(n)}};const{abs:lt,min:ho,max:yo,cos:bp,sin:Ep,acos:$p,sqrt:ft}=Math,Mp=Math.PI;var vt=class F{constructor(r){let n=r&&r.forEach?r:Array.from(arguments).slice(),s=!1;if(typeof n[0]=="object"){s=n.length;const y=[];n.forEach(function(p){["x","y","z"].forEach(function(w){typeof p[w]<"u"&&y.push(p[w])})}),n=y}let o=!1;const i=n.length;if(s){if(s>4){if(arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");o=!0}}else if(i!==6&&i!==8&&i!==9&&i!==12&&arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");const a=this._3d=!o&&(i===9||i===12)||r&&r[0]&&typeof r[0].z<"u",u=this.points=[];for(let y=0,p=a?3:2;y<i;y+=p){var c={x:n[y],y:n[y+1]};a&&(c.z=n[y+2]),u.push(c)}const l=this.order=u.length-1,f=this.dims=["x","y"];a&&f.push("z"),this.dimlen=f.length;const d=m.align(u,{p1:u[0],p2:u[l]}),h=m.dist(u[0],u[l]);this._linear=d.reduce((y,p)=>y+lt(p.y),0)<h/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(r,n,s,o){if(typeof o>"u"&&(o=.5),o===0)return new F(n,n,s);if(o===1)return new F(r,n,n);const i=F.getABC(2,r,n,s,o);return new F(r,i.A,s)}static cubicFromPoints(r,n,s,o,i){typeof o>"u"&&(o=.5);const a=F.getABC(3,r,n,s,o);typeof i>"u"&&(i=m.dist(n,a.C));const u=i*(1-o)/o,c=m.dist(r,s),l=(s.x-r.x)/c,f=(s.y-r.y)/c,d=i*l,h=i*f,y=u*l,p=u*f,w={x:n.x-d,y:n.y-h},N={x:n.x+y,y:n.y+p},$=a.A,T={x:$.x+(w.x-$.x)/(1-o),y:$.y+(w.y-$.y)/(1-o)},O={x:$.x+(N.x-$.x)/o,y:$.y+(N.y-$.y)/o},K={x:r.x+(T.x-r.x)/o,y:r.y+(T.y-r.y)/o},v={x:s.x+(O.x-s.x)/(1-o),y:s.y+(O.y-s.y)/(1-o)};return new F(r,K,v,s)}static getUtils(){return m}getUtils(){return F.getUtils()}static get PolyBezier(){return qr}valueOf(){return this.toString()}toString(){return m.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const r=this.points,n=r[0].x,s=r[0].y,o=["M",n,s,this.order===2?"Q":"C"];for(let i=1,a=r.length;i<a;i++)o.push(r[i].x),o.push(r[i].y);return o.join(" ")}setRatios(r){if(r.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=r,this._lut=[]}verify(){const r=this.coordDigest();r!==this._print&&(this._print=r,this.update())}coordDigest(){return this.points.map(function(r,n){return""+n+r.x+r.y+(r.z?r.z:0)}).join("")}update(){this._lut=[],this.dpoints=m.derive(this.points,this._3d),this.computedirection()}computedirection(){const r=this.points,n=m.angle(r[0],r[this.order],r[1]);this.clockwise=n>0}length(){return m.length(this.derivative.bind(this))}static getABC(r=2,n,s,o,i=.5){const a=m.projectionratio(i,r),u=1-a,c={x:a*n.x+u*o.x,y:a*n.y+u*o.y},l=m.abcratio(i,r);return{A:{x:s.x+(s.x-c.x)/l,y:s.y+(s.y-c.y)/l},B:s,C:c,S:n,E:o}}getABC(r,n){n=n||this.get(r);let s=this.points[0],o=this.points[this.order];return F.getABC(this.order,s,n,o,r)}getLUT(r){if(this.verify(),r=r||100,this._lut.length===r+1)return this._lut;this._lut=[],r++,this._lut=[];for(let n=0,s,o;n<r;n++)o=n/(r-1),s=this.compute(o),s.t=o,this._lut.push(s);return this._lut}on(r,n){n=n||5;const s=this.getLUT(),o=[];for(let i=0,a,u=0;i<s.length;i++)a=s[i],m.dist(a,r)<n&&(o.push(a),u+=i/s.length);return o.length?t/=o.length:!1}project(r){const n=this.getLUT(),s=n.length-1,o=m.closest(n,r),i=o.mpos,a=(i-1)/s,u=(i+1)/s,c=.1/s;let l=o.mdist,f=a,d=f,h;l+=1;for(let y;f<u+c;f+=c)h=this.compute(f),y=m.dist(r,h),y<l&&(l=y,d=f);return d=d<0?0:d>1?1:d,h=this.compute(d),h.t=d,h.d=l,h}get(r){return this.compute(r)}point(r){return this.points[r]}compute(r){return this.ratios?m.computeWithRatios(r,this.points,this.ratios,this._3d):m.compute(r,this.points,this._3d,this.ratios)}raise(){const r=this.points,n=[r[0]],s=r.length;for(let o=1,i,a;o<s;o++)i=r[o],a=r[o-1],n[o]={x:(s-o)/s*i.x+o/s*a.x,y:(s-o)/s*i.y+o/s*a.y};return n[s]=r[s-1],new F(n)}derivative(r){return m.compute(r,this.dpoints[0],this._3d)}dderivative(r){return m.compute(r,this.dpoints[1],this._3d)}align(){let r=this.points;return new F(m.align(r,{p1:r[0],p2:r[r.length-1]}))}curvature(r){return m.curvature(r,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return m.inflections(this.points)}normal(r){return this._3d?this.__normal3(r):this.__normal2(r)}__normal2(r){const n=this.derivative(r),s=ft(n.x*n.x+n.y*n.y);return{t:r,x:-n.y/s,y:n.x/s}}__normal3(r){const n=this.derivative(r),s=this.derivative(r+.01),o=ft(n.x*n.x+n.y*n.y+n.z*n.z),i=ft(s.x*s.x+s.y*s.y+s.z*s.z);n.x/=o,n.y/=o,n.z/=o,s.x/=i,s.y/=i,s.z/=i;const a={x:s.y*n.z-s.z*n.y,y:s.z*n.x-s.x*n.z,z:s.x*n.y-s.y*n.x},u=ft(a.x*a.x+a.y*a.y+a.z*a.z);a.x/=u,a.y/=u,a.z/=u;const c=[a.x*a.x,a.x*a.y-a.z,a.x*a.z+a.y,a.x*a.y+a.z,a.y*a.y,a.y*a.z-a.x,a.x*a.z-a.y,a.y*a.z+a.x,a.z*a.z];return{t:r,x:c[0]*n.x+c[1]*n.y+c[2]*n.z,y:c[3]*n.x+c[4]*n.y+c[5]*n.z,z:c[6]*n.x+c[7]*n.y+c[8]*n.z}}hull(r){let n=this.points,s=[],o=[],i=0;for(o[i++]=n[0],o[i++]=n[1],o[i++]=n[2],this.order===3&&(o[i++]=n[3]);n.length>1;){s=[];for(let a=0,u,c=n.length-1;a<c;a++)u=m.lerp(r,n[a],n[a+1]),o[i++]=u,s.push(u);n=s}return o}split(r,n){if(r===0&&n)return this.split(n).left;if(n===1)return this.split(r).right;const s=this.hull(r),o={left:this.order===2?new F([s[0],s[3],s[5]]):new F([s[0],s[4],s[7],s[9]]),right:this.order===2?new F([s[5],s[4],s[2]]):new F([s[9],s[8],s[6],s[3]]),span:s};return o.left._t1=m.map(0,0,1,this._t1,this._t2),o.left._t2=m.map(r,0,1,this._t1,this._t2),o.right._t1=m.map(r,0,1,this._t1,this._t2),o.right._t2=m.map(1,0,1,this._t1,this._t2),n?(n=m.map(n,r,1,0,1),o.right.split(n).left):o}extrema(){const r={};let n=[];return this.dims.forEach((function(s){let o=function(a){return a[s]},i=this.dpoints[0].map(o);r[s]=m.droots(i),this.order===3&&(i=this.dpoints[1].map(o),r[s]=r[s].concat(m.droots(i))),r[s]=r[s].filter(function(a){return a>=0&&a<=1}),n=n.concat(r[s].sort(m.numberSort))}).bind(this)),r.values=n.sort(m.numberSort).filter(function(s,o){return n.indexOf(s)===o}),r}bbox(){const r=this.extrema(),n={};return this.dims.forEach((function(s){n[s]=m.getminmax(this,s,r[s])}).bind(this)),n}overlaps(r){const n=this.bbox(),s=r.bbox();return m.bboxoverlap(n,s)}offset(r,n){if(typeof n<"u"){const s=this.get(r),o=this.normal(r),i={c:s,n:o,x:s.x+o.x*n,y:s.y+o.y*n};return this._3d&&(i.z=s.z+o.z*n),i}if(this._linear){const s=this.normal(0),o=this.points.map(function(i){const a={x:i.x+r*s.x,y:i.y+r*s.y};return i.z&&s.z&&(a.z=i.z+r*s.z),a});return[new F(o)]}return this.reduce().map(function(s){return s._linear?s.offset(r)[0]:s.scale(r)})}simple(){if(this.order===3){const o=m.angle(this.points[0],this.points[3],this.points[1]),i=m.angle(this.points[0],this.points[3],this.points[2]);if(o>0&&i<0||o<0&&i>0)return!1}const r=this.normal(0),n=this.normal(1);let s=r.x*n.x+r.y*n.y;return this._3d&&(s+=r.z*n.z),lt($p(s))<Mp/3}reduce(){let r,n=0,s=0,o=.01,i,a=[],u=[],c=this.extrema().values;for(c.indexOf(0)===-1&&(c=[0].concat(c)),c.indexOf(1)===-1&&c.push(1),n=c[0],r=1;r<c.length;r++)s=c[r],i=this.split(n,s),i._t1=n,i._t2=s,a.push(i),n=s;return a.forEach(function(l){for(n=0,s=0;s<=1;)for(s=n+o;s<=1+o;s+=o)if(i=l.split(n,s),!i.simple()){if(s-=o,lt(n-s)<o)return[];i=l.split(n,s),i._t1=m.map(n,0,1,l._t1,l._t2),i._t2=m.map(s,0,1,l._t1,l._t2),u.push(i),n=s;break}n<1&&(i=l.split(n,1),i._t1=m.map(n,0,1,l._t1,l._t2),i._t2=l._t2,u.push(i))}),u}translate(r,n,s){s=typeof s=="number"?s:n;const o=this.order;let i=this.points.map((a,u)=>(1-u/o)*n+u/o*s);return new F(this.points.map((a,u)=>({x:a.x+r.x*i[u],y:a.y+r.y*i[u]})))}scale(r){const n=this.order;let s=!1;if(typeof r=="function"&&(s=r),s&&n===2)return this.raise().scale(s);const o=this.clockwise,i=this.points;if(this._linear)return this.translate(this.normal(0),s?s(0):r,s?s(1):r);const a=s?s(0):r,u=s?s(1):r,c=[this.offset(0,10),this.offset(1,10)],l=[],f=m.lli4(c[0],c[0].c,c[1],c[1].c);if(!f)throw new Error("cannot scale this curve. Try reducing it first.");return[0,1].forEach(function(d){const h=l[d*n]=m.copy(i[d*n]);h.x+=(d?u:a)*c[d].n.x,h.y+=(d?u:a)*c[d].n.y}),s?([0,1].forEach(function(d){if(!(n===2&&d)){var h=i[d+1],y={x:h.x-f.x,y:h.y-f.y},p=s?s((d+1)/n):r;s&&!o&&(p=-p);var w=ft(y.x*y.x+y.y*y.y);y.x/=w,y.y/=w,l[d+1]={x:h.x+p*y.x,y:h.y+p*y.y}}}),new F(l)):([0,1].forEach(d=>{if(n===2&&d)return;const h=l[d*n],y=this.derivative(d),p={x:h.x+y.x,y:h.y+y.y};l[d+1]=m.lli4(h,p,f,i[d+1])}),new F(l))}outline(r,n,s,o){if(n=n===void 0?r:n,this._linear){const v=this.normal(0),_=this.points[0],M=this.points[this.points.length-1];let P,U,L;s===void 0&&(s=r,o=n),P={x:_.x+v.x*r,y:_.y+v.y*r},L={x:M.x+v.x*s,y:M.y+v.y*s},U={x:(P.x+L.x)/2,y:(P.y+L.y)/2};const ae=[P,U,L];P={x:_.x-v.x*n,y:_.y-v.y*n},L={x:M.x-v.x*o,y:M.y-v.y*o},U={x:(P.x+L.x)/2,y:(P.y+L.y)/2};const Y=[L,U,P],Se=m.makeline(Y[2],ae[0]),Ie=m.makeline(ae[2],Y[0]),Wf=[Se,new F(ae),Ie,new F(Y)];return new qr(Wf)}const i=this.reduce(),a=i.length,u=[];let c=[],l,f=0,d=this.length();const h=typeof s<"u"&&typeof o<"u";function y(v,_,M,P,U){return function(L){const ae=P/M,Y=(P+U)/M,Se=_-v;return m.map(L,0,1,v+ae*Se,v+Y*Se)}}i.forEach(function(v){const _=v.length();h?(u.push(v.scale(y(r,s,d,f,_))),c.push(v.scale(y(-n,-o,d,f,_)))):(u.push(v.scale(r)),c.push(v.scale(-n))),f+=_}),c=c.map(function(v){return l=v.points,l[3]?v.points=[l[3],l[2],l[1],l[0]]:v.points=[l[2],l[1],l[0]],v}).reverse();const p=u[0].points[0],w=u[a-1].points[u[a-1].points.length-1],N=c[a-1].points[c[a-1].points.length-1],$=c[0].points[0],T=m.makeline(N,p),O=m.makeline(w,$),K=[T].concat(u).concat([O]).concat(c);return new qr(K)}outlineshapes(r,n,s){n=n||r;const o=this.outline(r,n).curves,i=[];for(let a=1,u=o.length;a<u/2;a++){const c=m.makeshape(o[a],o[u-a],s);c.startcap.virtual=a>1,c.endcap.virtual=a<u/2-1,i.push(c)}return i}intersects(r,n){return r?r.p1&&r.p2?this.lineIntersects(r):(r instanceof F&&(r=r.reduce()),this.curveintersects(this.reduce(),r,n)):this.selfintersects(n)}lineIntersects(r){const n=ho(r.p1.x,r.p2.x),s=ho(r.p1.y,r.p2.y),o=yo(r.p1.x,r.p2.x),i=yo(r.p1.y,r.p2.y);return m.roots(this.points,r).filter(a=>{var u=this.get(a);return m.between(u.x,n,o)&&m.between(u.y,s,i)})}selfintersects(r){const n=this.reduce(),s=n.length-2,o=[];for(let i=0,a,u,c;i<s;i++)u=n.slice(i,i+1),c=n.slice(i+2),a=this.curveintersects(u,c,r),o.push(...a);return o}curveintersects(r,n,s){const o=[];r.forEach(function(a){n.forEach(function(u){a.overlaps(u)&&o.push({left:a,right:u})})});let i=[];return o.forEach(function(a){const u=m.pairiteration(a.left,a.right,s);u.length>0&&(i=i.concat(u))}),i}arcs(r){return r=r||.5,this._iterate(r,[])}_error(r,n,s,o){const i=(o-s)/4,a=this.get(s+i),u=this.get(o-i),c=m.dist(r,n),l=m.dist(r,a),f=m.dist(r,u);return lt(l-c)+lt(f-c)}_iterate(r,n){let s=0,o=1,i;do{i=0,o=1;let a=this.get(s),u,c,l,f,d=!1,h=!1,y,p=o,w=1;do if(h=d,f=l,p=(s+o)/2,u=this.get(p),c=this.get(o),l=m.getccenter(a,u,c),l.interval={start:s,end:o},d=this._error(l,a,s,o)<=r,y=h&&!d,y||(w=o),d){if(o>=1){if(l.interval.end=w=1,f=l,o>1){let $={x:l.x+l.r*bp(l.e),y:l.y+l.r*Ep(l.e)};l.e+=m.angle({x:l.x,y:l.y},$,this.get(1))}break}o=o+(o-s)/2}else o=p;while(!y&&i++<100);if(i>=100)break;f=f||l,n.push(f),s=w}while(o<1);return n}};const Sp=e=>S(e)&&e.z!==null?!1:e.x===null&&e.y===null,Np=e=>S(e)&&!Number.isNaN(e.z)?!1:Number.isNaN(e.x)||Number.isNaN(e.y);function oc(e,r="Point",n=""){if(e===void 0)return X(`'${r}' is undefined. Expected {x,y} got ${JSON.stringify(e)}`,n);if(e===null)return X(`'${r}' is null. Expected {x,y} got ${JSON.stringify(e)}`,n);if(typeof e!="object")return X(`'${r}' is type '${typeof e}'. Expected object.`,n);if(e.x===void 0)return X(`'${r}.x' is undefined. Expected {x,y} got ${JSON.stringify(e)}`,n);if(e.y===void 0)return X(`'${r}.y' is undefined. Expected {x,y} got ${JSON.stringify(e)}`,n);if(typeof e.x!="number")return X(`'${r}.x' must be a number. Got ${typeof e.x}`,n);if(typeof e.y!="number")return X(`'${r}.y' must be a number. Got ${typeof e.y}`,n);if(e.z!==void 0){if(typeof e.z!="number")return X(`${r}.z must be a number. Got: ${typeof e.z}`,n);if(Number.isNaN(e.z))return X(`'${r}.z' is NaN. Got: ${JSON.stringify(e)}`,n)}return e.x===null?X(`'${r}.x' is null`,n):e.y===null?X(`'${r}.y' is null`,n):Number.isNaN(e.x)?X(`'${r}.x' is NaN`,n):Number.isNaN(e.y)?X(`'${r}.y' is NaN`,n):{success:!0,value:e}}function b(e,r="Point",n){g(oc(e,r,n))}const ic=(e,r="pt")=>(b(e,r),g(z(e.x,"nonZero",`${r}.x`),z(e.y,"nonZero",`${r}.y`),()=>{if(typeof e.z<"u")return z(e.z,"nonZero",`${r}.z`)}),!0);function E(e){return!(e===void 0||e===null||e.x===void 0||e.y===void 0)}const S=e=>!(e===void 0||e===null||e.x===void 0||e.y===void 0||e.z===void 0),Xe=e=>S(e)&&e.z!==0?!1:e.x===0&&e.y===0,Qe=e=>S(e)&&!Number.isNaN(e.z)?!1:Number.isNaN(e.x)&&Number.isNaN(e.y),qe=(e,r="Dimension")=>{if(e===void 0)throw new Error(`${r} is undefined`);if(Number.isNaN(e))throw new Error(`${r} is NaN`);if(e<0)throw new Error(`${r} cannot be negative`)},pe=(e,r="rect")=>{if(e===void 0)throw new Error("{$name} undefined");D(e)&&b(e,r),qe(e.width,r+".width"),qe(e.height,r+".height")},vs=(e,r)=>{if(pe(e),D(e)&&r===void 0)return e;if(r===void 0)throw new Error("Unpositioned rect needs origin parameter");return Object.freeze({...e,...r})},bs=(e,r="rect")=>{if(!D(e))throw new Error(`Expected ${r} to have x,y`);pe(e,r)},zp=e=>e.width===0&&e.height===0,Pp=e=>Number.isNaN(e.width)&&Number.isNaN(e.height),D=e=>e.x!==void 0&&e.y!==void 0,ee=e=>!(e===void 0||e.width===void 0||e.height===void 0),de=e=>ee(e)&&D(e),kp=e=>(pe(e),e.height*e.width);function Ap(e,r,n){let s=typeof r=="number"?r:r.width,o=typeof r=="number"?n:r.height;if(s===void 0)throw new Error("Param 'width' undefined");if(o===void 0)throw new Error("Param 'height' undefined");if(s=e(s,"width"),o=e(o,"height"),typeof r=="object")if(D(r)){const i=e(r.x,"x"),a=e(r.y,"y");return{...r,width:s,height:o,x:i,y:a}}else return{...r,width:s,height:o};return{width:s,height:o}}function Pt(e,r,n,s){if(pe(r,"a"),ee(n))return de(r)?Object.freeze({...r,x:e(r.x,n.width),y:e(r.y,n.height),width:e(r.width,n.width),height:e(r.height,n.height)}):Object.freeze({...r,width:e(r.width,n.width),height:e(r.height,n.height)});if(typeof n!="number")throw new TypeError(`Expected second parameter of type Rect or number. Got ${JSON.stringify(n)}`);if(typeof s!="number")throw new Error(`Expected third param as height. Got ${JSON.stringify(s)}`);return de(r)?Object.freeze({...r,x:e(r.x,n),y:e(r.y,s),width:e(r.width,n),height:e(r.height,s)}):Object.freeze({...r,width:e(r.width,n),height:e(r.height,s)})}function Es(e,r,n){return D(r)?Object.freeze({...r,x:e(r.x,n),y:e(r.y,n),width:e(r.width,n),height:e(r.height,n)}):Object.freeze({...r,width:e(r.width,n),height:e(r.height,n)})}function $s(e,r,n){return Object.freeze({...r,width:e(r.width,n),height:e(r.height,n)})}const Tp=(e,r)=>{const{x:n,y:s,width:o,height:i}=e;switch(r){case"nw":return Object.freeze({x:n,y:s});case"n":return Object.freeze({x:n+o/2,y:s});case"ne":return Object.freeze({x:n+o,y:s});case"sw":return Object.freeze({x:n,y:s+i});case"s":return Object.freeze({x:n+o/2,y:s+i});case"se":return Object.freeze({x:n+o,y:s+i});case"w":return Object.freeze({x:n,y:s+i/2});case"e":return Object.freeze({x:n+o,y:s+i/2});case"center":return Object.freeze({x:n+o/2,y:s+i/2});default:throw new Error(`Unknown direction: ${r}`)}},Nr=(e,r)=>(pe(e),r===void 0&&E(e)?r=e:r===void 0&&(r={x:0,y:0}),vs(e,r),Object.freeze({x:r.x+e.width/2,y:r.y+e.height/2})),Vp=e=>{const r=Nr(e),n=e.width/2,s=e.height/2;return{relativeToAbsolute:a=>({...a,x:a.x*n+r.x,y:a.y*s+r.y}),absoluteToRelative:a=>({...a,x:(a.x-e.x)/n-1,y:(a.y-e.y)/s-1})}},ac=Object.freeze({x:NaN,y:NaN}),Rp=Object.freeze({x:NaN,y:NaN,z:NaN}),He=(e,r)=>{const n=vs(e,r);return[{x:n.x,y:n.y},{x:n.x+n.width,y:n.y},{x:n.x+n.width,y:n.y+n.height},{x:n.x,y:n.y+n.height}]},kt=(e,r="circle")=>{if(q(e)&&b(e,"circle"),Number.isNaN(e.radius))throw new Error(`${r}.radius is NaN`);if(e.radius<=0)throw new Error(`${r}.radius must be greater than zero`)},ur=(e,r="circle")=>{if(!q(e))throw new Error("Expected a positioned circle with x,y");kt(e,r)},jp=e=>!!(Number.isNaN(e.radius)||q(e)&&(Number.isNaN(e.x)||Number.isNaN(e.y))),uc=e=>e.x!==void 0&&e.y!==void 0,rt=e=>e.radius!==void 0,q=e=>rt(e)&&uc(e),cc=(e,r)=>e.radius!==r.radius?!1:q(e)&&q(r)?!(e.x!==r.x||e.y!==r.y||e.z!==r.z):(!q(e)&&!q(r),!1);function At(e,r,n,s,o,i){if(S(e)&&S(r))return[e,r];if(E(e)&&E(r))return[e,r];if(S(e)){const c={x:r,y:n,z:s};if(!S(c))throw new Error("Expected x, y & z parameters");return[e,c]}if(E(e)){const c={x:r,y:n};if(!E(c))throw new Error("Expected x & y parameters");return[e,c]}if(typeof o<"u"&&typeof s<"u"){const c={x:e,y:r,z:n},l={x:s,y:o,z:i};if(!S(c))throw new Error("Expected x,y,z for first point");if(!S(l))throw new Error("Expected x,y,z for second point");return[c,l]}const a={x:e,y:r},u={x:n,y:s};if(!E(a))throw new Error("Expected x,y for first point");if(!E(u))throw new Error("Expected x,y for second point");return[a,u]}function oe(e,r,n){if(e===void 0)return{x:0,y:0};if(Array.isArray(e)){if(e.length===0)return Object.freeze({x:0,y:0});if(e.length===1)return Object.freeze({x:e[0],y:0});if(e.length===2)return Object.freeze({x:e[0],y:e[1]});if(e.length===3)return Object.freeze({x:e[0],y:e[1],z:e[2]});throw new Error(`Expected array to be 1-3 elements in length. Got ${e.length}.`)}if(E(e))return e;if(typeof e!="number"||typeof r!="number")throw new TypeError(`Expected point or x,y as parameters. Got: a: ${JSON.stringify(e)} b: ${JSON.stringify(r)}`);return Object.freeze(typeof n=="number"?{x:e,y:r,z:n}:{x:e,y:r})}function Re(e,r,n,s,o,i){const[a,u]=At(e,r,n,s,o,i);b(a,"a"),b(u,"b");const c={x:a.x+u.x,y:a.y+u.y};return(S(a)||S(u))&&(c.z=(a.z??0)+(u.z??0)),Object.freeze(c)}function Q(e,r,n,s,o,i){const[a,u]=At(e,r,n,s,o,i);b(a,"a"),b(u,"b");const c={x:a.x-u.x,y:a.y-u.y};return(S(a)||S(u))&&(c.z=(a.z??0)-(u.z??0)),Object.freeze(c)}const _p=(e,r)=>{const n={x:r.b.x-r.a.x,y:r.b.y-r.a.y},s={x:r.a.x-e.x,y:r.a.y-e.y},o=(n.x*s.x+n.y*s.y)*-2,i=2*(n.x*n.x+n.y*n.y),a=Math.sqrt(o*o-2*i*(s.x*s.x+s.y*s.y-e.radius*e.radius));if(Number.isNaN(a))return[];const u=(o-a)/i,c=(o+a)/i,l=[];return u<=1&&u>=0&&l.push({x:r.a.x+n.x*u,y:r.a.y+n.y*u}),c<=1&&c>=0&&l.push({x:r.a.x+n.x*c,y:r.a.y+n.y*c}),l},lc=(e,r)=>{const n=Q(r,e),s=Math.hypot(n.y,n.x);if(s>e.radius+r.radius)return[];if(s<Math.abs(e.radius-r.radius))return[];if(cc(e,r))return[];const o=(e.radius*e.radius-r.radius*r.radius+s*s)/(2*s),i={x:e.x+n.x*o/s,y:e.y+n.y*o/s},a=Math.sqrt(e.radius*e.radius-o*o),u={x:-n.y*(a/s),y:n.x*(a/s)};return[Re(i,u),Q(i,u)]},fc=(e,r)=>{const n=e.x-Math.max(r.x,Math.min(e.x,r.x+r.width)),s=e.y-Math.max(r.y,Math.min(e.y,r.y+r.height));return n*n+s*s<e.radius*e.radius},mo=(e,r)=>lc(e,r).length===2;function Tt(e,r,n){pe(e,"rect");let s=0,o=0;if(typeof r=="number"){if(n===void 0)throw new Error("x and y coordinate needed");s=r,o=n}else s=r.x,o=r.y;if(D(e)){if(s-e.x>e.width||s<e.x||o-e.y>e.height||o<e.y)return!1}else if(s>e.width||s<0||o>e.height||o<0)return!1;return!0}const dc=(e,r)=>{if(!de(e))throw new Error("a parameter should be RectPositioned");if(q(r))return fc(r,e);if(E(r))return Tt(e,r);throw new Error(`Unknown shape for b: ${JSON.stringify(r)}`)};function V(e,r,n,s){const o=oe(r,n,s);return b(o,"b"),b(e,"a"),S(o)&&S(e)?Math.hypot(o.x-e.x,o.y-e.y,o.z-e.z):Math.hypot(o.x-e.x,o.y-e.y)}const Ms=(e,r)=>{if(bs(e,"rect"),b(r,"pt"),Tt(e,r))return 0;const n=Math.max(e.x-r.x,0,r.x-e.x+e.width),s=Math.max(e.y-r.y,0,r.y-e.y+e.height);return Math.hypot(n,s)},Cp=(e,r)=>V(Nr(e),r),Ss=(e,r)=>e/r;function Ip(e,r,n){return Pt(Ss,e,r,n)}function Op(e,r){return Es(Ss,e,r)}function Fp(e,r){return $s(Ss,e,r)}const Vt=(e,r)=>(b(e,"a"),b(r,"b"),e=Object.freeze({...e}),r=Object.freeze({...r}),Object.freeze({a:e,b:r})),Rt=(...e)=>{const r=[];let n=e[0];for(let s=1;s<e.length;s++)r.push(Vt(n,e[s])),n=e[s];return r},hc=(e,r)=>{const n=He(e,r);return Rt(...n,n[0])},qp=(e,r)=>{switch(pe(e),r){case"top":return E(e)?e.x:0;case"bottom":return E(e)?e.x:0;case"left":return E(e)?e.y:0;case"right":return E(e)?e.x+e.width:e.width}},Lp=(e,r)=>{switch(pe(e),r){case"top":return E(e)?e.y:0;case"bottom":return E(e)?e.y+e.height:e.height;case"left":return E(e)?e.y:0;case"right":return E(e)?e.y:0}},Dp=Object.freeze({width:0,height:0}),Bp=Object.freeze({x:0,y:0,width:0,height:0}),Gp=(e,...r)=>{const n=r.map(f=>f.x),s=r.map(f=>f.y);let o=Math.min(...n,e.x),i=Math.min(...s,e.y),a=Math.max(...n,e.x+e.width),u=Math.max(...s,e.y+e.height),c=Math.max(e.width,a-o),l=Math.max(e.height,u-i);return Object.freeze({...e,x:o,y:i,width:c,height:l})},yc=(e,r,n)=>{b(e,"origin"),qe(r,"width"),qe(n,"height");const s=r/2,o=n/2;return{x:e.x-s,y:e.y-o,width:r,height:n}},Up=e=>({width:e.clientWidth,height:e.clientHeight});function Jp(e,r,n,s){if(n===void 0||s===void 0){if(typeof e!="number")throw new Error("width is not an number");if(typeof r!="number")throw new TypeError("height is not an number");return Object.freeze({width:e,height:r})}if(typeof e!="number")throw new Error("x is not an number");if(typeof r!="number")throw new Error("y is not an number");if(typeof n!="number")throw new Error("width is not an number");if(typeof s!="number")throw new Error("height is not an number");return Object.freeze({x:e,y:r,width:n,height:s})}const Ae=(e,r,n)=>(qe(r,"width"),qe(n,"height"),b(e,"origin"),{x:e.x,y:e.y,width:r,height:n});function Wp(e,r,n,s){if(typeof e=="number")if(typeof r=="number"){if(typeof n=="number"&&typeof s=="number")return{x:e,y:r,width:n,height:s};if(ee(n))return{x:e,y:r,width:n.width,height:n.height};throw new TypeError("If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect")}else throw new TypeError("If parameter 'a' is a number, expect following parameters to be: y,w,h");else{if(de(e))return e;if(ee(e)){if(typeof r=="number"&&typeof n=="number")return{width:e.width,height:e.height,x:r,y:n};if(E(r))return{width:e.width,height:e.height,x:r.x,y:r.y};throw new TypeError("If param 'a' is a Rect, expects following parameters to be x,y")}else if(E(e)){if(typeof r=="number"&&typeof n=="number")return{x:e.x,y:e.y,width:r,height:n};if(ee(r))return{x:e.x,y:e.y,width:r.width,height:r.height};throw new TypeError("If parameter 'a' is a Point, expect following params to be: Rect or width,height")}}throw new TypeError("Expect a first parameter to be x,RectPositioned,Rect or Point")}const ce=(...e)=>{if(e===void 0)throw new Error("parameter 'p' is undefined");if(e.length<2)return!0;for(let r=1;r<e.length;r++)if(e[r].x!==e[0].x||e[r].y!==e[0].y)return!1;return!0},Kp=(e,r)=>{if(e===void 0)throw new Error("a undefined");if(r===void 0)throw new Error("b undefined");return e.width===r.width&&e.height===r.height},Xp=(e,r)=>D(e)&&D(r)?ce(e,r)?e.width===r.width&&e.height===r.height:!1:!D(e)&&!D(r)?e.width===r.width&&e.height===r.height:!1,Me=e=>!(e===void 0||e.a===void 0||e.b===void 0||!E(e.a)||!E(e.b)),mc=e=>Array.isArray(e)?!e.some(n=>!Me(n)):!1,jt=(e,r="line")=>{if(e===void 0)throw new Error(`${r} undefined`);if(e.a===void 0)throw new Error(`${r}.a undefined. Expected {a:Point, b:Point}. Got: ${JSON.stringify(e)}`);if(e.b===void 0)throw new Error(`${r}.b undefined. Expected {a:Point, b:Point} Got: ${JSON.stringify(e)}`)},zr=(e,r)=>{let n;if(Me(e))r=e.b,n=e.a;else if(n=e,r===void 0)throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${JSON.stringify(n)} b: ${JSON.stringify(r)}`);return b(n,"a"),b(n,"b"),[n,r]};function G(e,r){if(mc(e))return e.reduce((u,c)=>G(c)+u,0);if(e===void 0)throw new TypeError("Parameter 'aOrLine' is undefined");const[n,s]=zr(e,r),o=s.x-n.x,i=s.y-n.y;if(n.z!==void 0&&s.z!==void 0){const a=s.z-n.z;return Math.hypot(o,i,a)}else return Math.hypot(o,i)}const Qp=e=>(bs(e,"rect"),hc(e).map(r=>G(r))),pc=(e,r,n,s)=>{if(e.y>n.y)throw new Error("topLeft.y greater than bottomRight.y");if(e.y>s.y)throw new Error("topLeft.y greater than bottomLeft.y");const o=r.x-e.x,i=n.x-s.x,a=Math.abs(s.y-e.y),u=Math.abs(n.y-r.y);return{x:Math.min(e.x,s.x),y:Math.min(r.y,e.y),width:Math.max(o,i),height:Math.max(a,u)}},Ns=(e,r)=>e*r;function Hp(e,r,n){return Pt(Ns,e,r,n)}function Yp(e,r){return Es(Ns,e,r)}function Zp(e,r){return $s(Ns,e,r)}const eg=(e,r)=>{let{x:n,y:s}=r;return n<e.x?n=e.x:n>e.x+e.width&&(n=e.x+e.width),s<e.y?s=e.y:s>e.y+e.height&&(s=e.y+e.height),Object.freeze({...r,x:n,y:s})},gc=Object.freeze({width:NaN,height:NaN}),tg=Object.freeze({x:NaN,y:NaN,width:NaN,height:NaN}),rg=e=>(pe(e),e.height+e.height+e.width+e.width),ng=e=>{const r=Math.max(e.width,e.height);return n=>{if(typeof n=="number")return n/r;if(S(n))return Object.freeze({...n,x:n.x/r,y:n.y/r,z:n.x/r});if(E(n))return Object.freeze({...n,x:n.x/r,y:n.y/r});throw new Error("Param 'value' is neither number nor Point")}},sg=e=>(e??=Math.random,Object.freeze({x:e(),y:e(),width:e(),height:e()})),wc=(e,r={})=>{const n=r.randomSource??Math.random,s=r.margin??{x:0,y:0},o=n()*(e.width-s.x-s.x),i=n()*(e.height-s.y-s.y),a={x:o+s.x,y:i+s.y};return D(e)?Re(a,e):Object.freeze(a)},og=(e,r)=>e-r;function ig(e,r,n){return Pt(og,e,r,n)}function ag(e,r,n){const s=typeof r=="number"?r:r.width,o=typeof r=="number"?n:r.height;if(o===void 0)throw new Error("Expected height as third parameter");return{...e,width:e.width-s,height:e.height-o}}function ug(e,r){let n=0,s=0;D(e)&&(n=e.x,s=e.y);let o=0,i=0;return D(r)&&(o=r.x,i=r.y),Object.freeze({...e,x:n-o,y:s-i,width:e.width-r.width,height:e.height-r.height})}const cg=(e,r)=>e+r;function lg(e,r,n){return Pt(cg,e,r,n)}function fg(e,r){let n=0,s=0;D(e)&&(n=e.x,s=e.y);let o=0,i=0;return D(r)&&(o=r.x,i=r.y),Object.freeze({...e,x:n+o,y:s+i,width:e.width+r.width,height:e.height+r.height})}function dg(e){if(D(e))return[e.x,e.y,e.width,e.height];if(ee(e))return[e.width,e.height];throw new Error(`Param 'rect' is not a rectangle. Got: ${JSON.stringify(e)}`)}var xc={};x(xc,{Empty:()=>Dp,EmptyPositioned:()=>Bp,Placeholder:()=>gc,PlaceholderPositioned:()=>tg,applyDim:()=>$s,applyFields:()=>Ap,applyMerge:()=>Pt,applyScalar:()=>Es,area:()=>kp,cardinal:()=>Tp,center:()=>Nr,centerOrigin:()=>Vp,corners:()=>He,distanceFromCenter:()=>Cp,distanceFromExterior:()=>Ms,divide:()=>Ip,divideDim:()=>Fp,divideScalar:()=>Op,dividerByLargestDimension:()=>ng,edges:()=>hc,encompass:()=>Gp,fromCenter:()=>yc,fromElement:()=>Up,fromNumbers:()=>Jp,fromTopLeft:()=>Ae,getEdgeX:()=>qp,getEdgeY:()=>Lp,getRectPositioned:()=>vs,getRectPositionedParameter:()=>Wp,guard:()=>pe,guardDim:()=>qe,guardPositioned:()=>bs,intersectsPoint:()=>Tt,isEmpty:()=>zp,isEqual:()=>Xp,isEqualSize:()=>Kp,isIntersecting:()=>dc,isPlaceholder:()=>Pp,isPositioned:()=>D,isRect:()=>ee,isRectPositioned:()=>de,lengths:()=>Qp,maxFromCorners:()=>pc,multiply:()=>Hp,multiplyDim:()=>Zp,multiplyScalar:()=>Yp,nearestInternal:()=>eg,perimeter:()=>rg,random:()=>sg,randomPoint:()=>wc,subtract:()=>ig,subtractOffset:()=>ug,subtractSize:()=>ag,sum:()=>lg,sumOffset:()=>fg,toArray:()=>dg});function hg(e){if(S(e))return Object.freeze({...e,x:Math.abs(e.x),y:Math.abs(e.y),z:Math.abs(e.z)});if(E(e))return Object.freeze({...e,x:Math.abs(e.x),y:Math.abs(e.y)});throw new TypeError("Param 'pt' is not a point")}const W=Math.PI*2,Te=(e,r,n)=>(b(e,"a"),r===void 0?Math.atan2(e.y,e.x):(b(r,"b"),n===void 0?Math.atan2(r.y-e.y,r.x-e.x):(b(n,"c"),Math.atan2(r.y-e.y,r.x-e.x)-Math.atan2(n.y-e.y,n.x-e.x)))),yg=(e,r,n)=>{const s=Te(e,r,n);return s<0?s+W:s};function mg(e,r){return b(e,"pt"),S(e)?Object.freeze({...e,x:r(e.x,"x"),y:r(e.y,"y"),z:r(e.z,"z")}):Object.freeze({...e,x:r(e.x,"x"),y:r(e.y,"y")})}function pg(e,r={}){let n,s,o;switch(e){case"moving-average-light":{const i=r.scaling??3;n=Ut(i),s=Ut(i),o=Ut(i);break}default:throw new Error(`Unknown averaging kind '${e}'. Expected: 'moving-average-light'`)}return i=>{const a=n(i.x),u=s(i.y);if(S(i)){const c=o(i.z);return Object.freeze({x:a,y:u,z:c})}else return Object.freeze({x:a,y:u})}}function xe(e,...r){if(r.length===0)throw new Error("No points provided");let n=r[0];for(const s of r)S(n)&&S(s),n=e(n,s);return n}const _t=(...e)=>{const r=xe((l,f)=>l.x<f.x?l:f,...e),n=xe((l,f)=>l.x>f.x?l:f,...e),s=xe((l,f)=>l.y<f.y?l:f,...e),o=xe((l,f)=>l.y>f.y?l:f,...e),i={x:r.x,y:s.y},a={x:n.x,y:s.y},u={x:n.x,y:o.y},c={x:r.x,y:o.y};return pc(i,a,u,c)},gg=(...e)=>{const r=_t(...e),n=xe((o,i)=>o.z<i.z?o:i,...e),s=xe((o,i)=>o.z>i.z?o:i,...e);return{...r,z:n.z,depth:s.z-n.z}},vc=(...e)=>{if(!Array.isArray(e))throw new Error("Expected list of points");const r=e.reduce((n,s)=>{if(s===void 0)return n;if(Array.isArray(s))throw new TypeError("'points' list contains an array. Did you mean: centroid(...myPoints)?");if(!E(s))throw new Error(`'points' contains something which is not a point: ${JSON.stringify(s)}`);return{x:n.x+s.x,y:n.y+s.y}},{x:0,y:0});return Object.freeze({x:r.x/e.length,y:r.y/e.length})};function wg(e,r=0,n=1){return S(e)?Object.freeze({x:Je(e.x,r,n),y:Je(e.y,r,n),z:Je(e.z,r,n)}):Object.freeze({x:Je(e.x,r,n),y:Je(e.y,r,n)})}const xg=(e,r)=>e.x<r.x&&e.y<r.y?-2:e.x>r.x&&e.y>r.y?2:e.x<r.x||e.y<r.y?-1:e.x>r.x||e.y>r.y?1:e.x===r.x&&e.x===r.y?0:NaN,bc=(e,r)=>e.x===r.x?0:e.x<r.x?-1:1,vg=(e,r)=>e.y===r.y?0:e.y<r.y?-1:1,bg=(e,r)=>e.z===r.z?0:e.z<r.z?-1:1,Eg=(...e)=>{const r=[...e].sort(bc);if(r.length===1)return r;const n=i=>{const a=[];for(const u of i){for(;a.length>=2;){const c=a.at(-1),l=a.at(-2);if((c.x-l.x)*(u.y-l.y)>=(c.y-l.y)*(u.x-l.x))a.pop();else break}a.push(u)}return a.pop(),a},s=n(r),o=n(r.reverse());return s.length===1&&o.length===1&&ce(o[0],s[0])?s:[...s,...o]},zs=(e,r)=>(ur(e,"a"),q(r)&&ur(r,"b"),V(e,r)),Ps=(e,r)=>{if(ur(e,"a"),q(r))return Math.max(0,zs(e,r)-e.radius-r.radius);if(E(r)){const n=V(e,r);return n<e.radius?0:n}else throw new Error("Second parameter invalid type")},$g=(e,r)=>{if(de(r))return Ms(r,e);if(q(r))return Ps(r,e);if(E(r))return V(e,r);throw new Error("Unknown shape")},Mg=(e,r)=>{if(de(r))return Ms(r,e);if(q(r))return Ps(r,e);if(E(r))return V(e,r);throw new Error("Unknown shape")};function cr(e,r,n,s,o,i){const[a,u]=At(e,r,n,s,o,i);if(b(a,"a"),b(u,"b"),u.x===0)throw new TypeError("Cannot divide by zero (b.x is 0)");if(u.y===0)throw new TypeError("Cannot divide by zero (b.y is 0)");const c={x:a.x/u.x,y:a.y/u.y};if(S(a)||S(u)){if(u.z===0)throw new TypeError("Cannot divide by zero (b.z is 0)");c.z=(a.z??0)/(u.z??0)}return Object.freeze(c)}function Sg(e,r,n){const s=oe(e,r,n);return ic(s,"divisor"),(o,i,a)=>{const u=oe(o,i,a);return typeof u.z>"u"?Object.freeze({x:u.x/s.x,y:u.y/s.y}):Object.freeze({x:u.x/s.x,y:u.y/s.y,z:u.z/(s.z??1)})}}const Ec=e=>[e.x,e.y],$c=(...e)=>{const r=e.map(n=>Ec(n));return id(r)},je={x:0,y:0},Ng={x:1,y:1},zg={x:0,y:0,z:0},Pg={x:1,y:1,z:1};function kg(e,r,n){if(Array.isArray(e)){if(e.length===3)return Object.freeze({x:e[0],y:e[1],z:e[2]});if(e.length===2)return Object.freeze({x:e[0],y:e[1]});throw new Error(`Expected array of length two or three, got ${e.length}`)}else{if(e===void 0)throw new Error("Requires an array of [x,y] or x,y parameters at least");if(Number.isNaN(e))throw new Error("x is NaN");if(r===void 0)throw new Error("Param 'y' is missing");if(Number.isNaN(r))throw new Error("y is NaN");return Object.freeze(n===void 0?{x:e,y:r}:{x:e,y:r,z:n})}}const Ag=e=>{if(typeof e!="string")throw new TypeError(`Param 'str' ought to be a string. Got: ${typeof e}`);const r=e.indexOf(","),n=Number.parseFloat(e.substring(0,r)),s=e.indexOf(",",r+1);if(s>0){const o=Number.parseFloat(e.substring(r+1,s-r+2)),i=Number.parseFloat(e.substring(s+1));return{x:n,y:o,z:i}}else{const o=Number.parseFloat(e.substring(r+1));return{x:n,y:o}}},ks=(...e)=>{const r=[];if(Array.isArray(e[0]))for(const n of e){if(n.length%2!==0)throw new Error("coords array should be even-numbered");r.push(Object.freeze({x:n[0],y:n[1]}))}else{if(e.length%2!==0)throw new Error("Expected even number of elements: [x,y,x,y...]");for(let n=0;n<e.length;n+=2)r.push(Object.freeze({x:e[n],y:e[n+1]}))}return r};function Mc(e){return jt(e,"line"),{a:e.b,b:e.a}}function he(e,r,n,s){typeof n=="boolean"&&(s=n,n=void 0),s?g(z(e,"","amount")):g(ad(e,"amount"));const[o,i]=zr(r,n),a=G(o,i),u=a*(1-e);if(a===0&&u===0)return Object.freeze({...i});const c=i.x-u*(i.x-o.x)/a,l=i.y-u*(i.y-o.y)/a;return Object.freeze({...i,x:c,y:l})}function Tg(e,r,n=!0){n||(e=Mc(e));const s=e.b.x-e.a.x,o=e.b.y-e.a.y,i=Math.atan2(o,s),a=r*Math.cos(i),u=r*Math.sin(i);return{x:a+e.a.x,y:u+e.a.y}}const Vg=(e,r,n,s=!1)=>he(e,r,n,s),Rg=(e,r="both")=>{switch(r){case"both":return S(e)?Object.freeze({...e,x:e.x*-1,y:e.y*-1,z:e.z*-1}):Object.freeze({...e,x:e.x*-1,y:e.y*-1});case"x":return Object.freeze({...e,x:e.x*-1});case"y":return Object.freeze({...e,y:e.y*-1});case"z":if(S(e))return Object.freeze({...e,z:e.z*-1});throw new Error("pt parameter is missing z");default:throw new Error("Unknown what parameter. Expecting 'both', 'x' or 'y'")}};function bt(e,r,n,s,o,i){const[a,u]=At(e,r,n,s,o,i);b(a,"a"),b(u,"b");const c={x:a.x*u.x,y:a.y*u.y};return(S(a)||S(u))&&(c.z=(a.z??0)*(u.z??0)),Object.freeze(c)}const Sc=(e,r)=>S(e)?Object.freeze({...e,x:e.x*r,y:e.y*r,z:e.z*r}):Object.freeze({...e,x:e.x*r,y:e.y*r}),Nc=(e,r=1,n=0)=>{const s=V(e);let o=1;return s>r?o=r/s:s<n&&(o=n/s),o===1?e:bt(e,o,o)},jg=(...e)=>xe((r,n)=>r.x<=n.x?r:n,...e),_g=(...e)=>xe((r,n)=>r.x>=n.x?r:n,...e),Cg=(e,r)=>{if(E(e)&&(r=e.y,e=e.x),r===void 0)throw new Error("Expected y");return Math.hypot(e,r)},zc=(e,r)=>{const n=oe(e,r),s=Cg(n);return s===0?je:Object.freeze({...n,x:n.x/s,y:n.y/s})};function on(e,r,n,s){if(E(e)){if(typeof r=="number"&&n!==void 0)g(z(r,"positive","width"),z(n,"positive","height"));else{if(!ee(r))throw new Error("Expected second parameter to be a rect");n=r.height,r=r.width}return Object.freeze({x:e.x/r,y:e.y/n})}else{if(g(z(e,"positive","x")),typeof r!="number")throw new TypeError("Expecting second parameter to be a number (width)");if(typeof n!="number")throw new TypeError("Expecting third parameter to be a number (height)");if(g(z(r,"positive","y")),g(z(n,"positive","width")),s===void 0)throw new Error("Expected height parameter");return g(z(s,"positive","height")),Object.freeze({x:e/n,y:r/s})}}const Ig=(e,...r)=>Pc(...r)(e),Pc=(...e)=>r=>e.reduce((n,s)=>s(n),r),As=e=>!(e.distance===void 0||e.angleRadian===void 0),H=(e,r="Point")=>{if(e===void 0)throw new Error(`'${r}' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(e===null)throw new Error(`'${r}' is null. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(e.angleRadian===void 0)throw new Error(`'${r}.angleRadian' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(e.distance===void 0)throw new Error(`'${r}.distance' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(typeof e.angleRadian!="number")throw new TypeError(`'${r}.angleRadian' must be a number. Got ${e.angleRadian}`);if(typeof e.distance!="number")throw new TypeError(`'${r}.distance' must be a number. Got ${e.distance}`);if(e.angleRadian===null)throw new Error(`'${r}.angleRadian' is null`);if(e.distance===null)throw new Error(`'${r}.distance' is null`);if(Number.isNaN(e.angleRadian))throw new TypeError(`'${r}.angleRadian' is NaN`);if(Number.isNaN(e.distance))throw new Error(`'${r}.distance' is NaN`)};function te(e){return Array.isArray(e)?e.map(r=>r*(Math.PI/180)):e*(Math.PI/180)}function kc(e){return(e+Math.PI)%(2*Math.PI)}function Ac(e){return e*1.111111}function Tc(e,r=!0){return r?e*.9%360:e*.9}function Wt(e){return e*63.6619772368}function an(e){return e*.0157079633}function nt(e){return Array.isArray(e)?e.map(r=>r*180/Math.PI):e*180/Math.PI}const Og=e=>Math.atan2(e.x,e.y),Pr=(e,r,n=!0)=>{if(n){let s=e+r;return s>=W&&(s=s%W),s}else{const s=e-r;return s<0?W+s:s}},Fg=(e,r,n=!0)=>nt(Pr(te(e),te(r),n)),Ts=(e,r,n=!0)=>{let s=e;r<s&&(s=0,r=W-e+r);let o=r-s;return n&&(o=W-o),o>=W?o%W:o},qg=(e,r,n=!0)=>nt(Ts(te(e),te(r),n)),Vc=e=>{if(Lg(e))return e;if(typeof e=="number")return{value:e,unit:"deg"};e=e.toLowerCase();let r="deg",n=NaN;if(e.endsWith("grad")?(n=Number.parseFloat(e.substring(0,e.length-4)),r="grad"):e.endsWith("rad")?(n=Number.parseFloat(e.substring(0,e.length-3)),r="rad"):e.endsWith("turn")?(n=Number.parseFloat(e.substring(0,e.length-4)),r="turn"):e.endsWith("deg")?(n=Number.parseFloat(e.substring(0,e.length-3)),r="deg"):n=Number.parseFloat(e),Number.isNaN(n))throw new Error("Invalid angle (bad value?)");if(r.length===0)throw new Error("Invalid angle (no unit)");return{value:n,unit:r}},Lg=e=>typeof e!="object"?!1:"unit"in e&&"value"in e?!(typeof e.unit!="string"||typeof e.value!="number"):!1,Dg=(e,r)=>{const n=typeof e=="object"?e:Vc(e);switch(r){case"deg":if(n.unit==="deg")return n;if(n.unit==="rad")return{value:nt(n.value),unit:"deg"};if(n.unit==="grad")return{value:Tc(n.value),unit:"deg"};if(n.unit==="turn")return{value:Rc(n.value),unit:"deg"};throw new Error(`Unknown unit: ${n.unit}`);case"grad":if(n.unit==="deg")return{value:Ac(n.value),unit:"grad"};if(n.unit==="rad")return{value:Wt(n.value),unit:"grad"};if(n.unit==="grad")return n;if(n.unit==="turn")return{value:Wt(un(n.value)),unit:"grad"};throw new Error(`Unknown unit: ${n.unit}`);case"rad":if(n.unit==="deg")return{value:te(n.value),unit:"rad"};if(n.unit==="rad")return n;if(n.unit==="grad")return{value:an(n.value),unit:"rad"};if(n.unit==="turn")return{value:Wt(un(n.value)),unit:"grad"};throw new Error(`Unknown unit: ${n.unit}`);case"turn":if(n.unit==="deg")return{value:jc(n.value),unit:"turn"};if(n.unit==="rad")return{value:cn(n.value),unit:"turn"};if(n.unit==="grad")return{value:cn(an(n.value)),unit:"turn"};if(n.unit==="turn")return n;throw new Error(`Unknown unit: ${n.unit}`);default:throw new Error(`Destination unit unknown ('${r}). Expects: deg, grad, rad or turn`)}},Rc=(e,r=!0)=>r?e*360%360:e*360,un=e=>e*W,jc=e=>e/360,cn=e=>e/W,_c=(e,r)=>Object.freeze({...e,angleRadian:e.angleRadian+r}),Bg=e=>(H(e,"c"),Object.freeze({...e,angleRadian:e.angleRadian-Math.PI})),Gg=(e,r)=>(H(e,"a"),H(r,"b"),e.distance!==r.distance?!1:e.angleRadian===-r.angleRadian),Ug=(e,r)=>(H(e,"a"),H(r,"b"),e.angleRadian===r.angleRadian),Jg=(e,r)=>(H(e,"a"),H(r,"b"),e.angleRadian===-r.angleRadian),Wg=(e,r)=>Object.freeze({...e,angleRadian:e.angleRadian+te(r)}),Kg=(e,r)=>{const n=J(e,r);return{a:r,b:n}},J=(e,r,n)=>{if(As(e)){if(typeof r>"u"&&(r=je),E(r))return po(e.distance,e.angleRadian,r);throw new Error("Expecting (Coord, Point). Second parameter is not a point")}else{if(typeof e=="object")throw new TypeError(`First param is an object, but not a Coord: ${JSON.stringify(e)}`);if(typeof e=="number"&&typeof r=="number"){if(typeof n>"u"&&(n=je),!E(n))throw new Error("Expecting (number, number, Point). Point param wrong type");return po(e,r,n)}else throw new TypeError(`Expecting parameters of (number, number). Got: (${typeof e}, ${typeof r}, ${typeof n}). a: ${JSON.stringify(e)}`)}},Vs=(e,r)=>{if(typeof e>"u")throw new Error("Param 'point' missing. Expecting a Point");if(typeof r>"u")throw new Error("Param 'origin' missing. Expecting a Point");e=Q(e,r);const n=Math.atan2(e.y,e.x),s=Math.hypot(e.x,e.y),o={...e,angleRadian:n,distance:s};return delete o.x,delete o.y,Object.freeze(o)},po=(e,r,n=je)=>(b(n),Object.freeze({x:n.x+e*Math.cos(r),y:n.y+e*Math.sin(r)})),Cc=(e,r)=>{if(e===void 0)return"(undefined)";if(e===null)return"(null)";const n=nt(e.angleRadian),s=r?e.distance.toFixed(r):e.distance,o=r?n.toFixed(r):n;return`(${s},${o})`},Ic=(e,r=je)=>(H(e,"v"),Object.freeze({x:r.x+e.distance*Math.cos(e.angleRadian),y:r.y+e.distance*Math.sin(e.angleRadian)})),Oc=e=>{if(e.distance===0)throw new Error("Cannot normalise vector of length 0");return Object.freeze({...e,distance:1})},Fc=(e,r=1,n=0)=>{let s=e.distance;return s>r&&(s=r),s<n&&(s=n),Object.freeze({...e,distance:s})},qc=(e,r)=>(H(e,"a"),H(r,"b"),e.distance*r.distance*Math.cos(r.angleRadian-e.angleRadian)),Xg=(e,r)=>(H(e),g(z(r,"","amt")),Object.freeze({...e,distance:e.distance*r})),Qg=(e,r)=>(H(e),g(z(r,"","amt")),Object.freeze({...e,distance:e.distance/r})),Hg=(e,r=Math.round)=>(b(e,"pt"),Object.freeze({x:r(e.x),y:r(e.y)})),Yg=e=>{b(e,"pt");let r={...e};return delete r.z,Object.freeze(r)},Zg=(e,r=0)=>(b(e,"pt"),Object.freeze({...e,z:r}));function Et(e,r){if(e===void 0)return"(undefined)";if(e===null)return"(null)";b(e,"pt");const n=r?e.x.toFixed(r):e.x,s=r?e.y.toFixed(r):e.y;if(e.z===void 0)return`(${n},${s})`;{const o=r?e.z.toFixed(r):e.z;return`(${n},${s},${o})`}}var Lc={};x(Lc,{fromLine:()=>nw,toCartesian:()=>ew,toString:()=>rw});const ew=(e,r)=>{const n=tw(e,r),s=J(e.offset,e.angleRadian,n),o=J(e.offset+e.length,e.angleRadian,n);return{a:s,b:o}},tw=(e,r)=>r!==void 0?r:e.origin!==void 0?e.origin:{x:0,y:0},rw=e=>{let r=`PolarRay(angle: ${e.angleRadian} offset: ${e.offset} len: ${e.length}`;return e.origin&&(r+=` origin: ${Et(e.origin)}`),r+=")",r},nw=(e,r)=>{const n=r??e.a;return{angleRadian:Te(e.b,n),offset:V(e.a,n),length:V(e.b,e.a),origin:n}};function*sw(e,r){let n=0;for(;;){const s=e*n++;yield{distance:r*s,angleRadian:s,step:n}}}const ow=(e,r,n)=>{const s=r*e;return Object.freeze({distance:n*s,angleRadian:s})};var Dc={};x(Dc,{Ray:()=>Lc,clampMagnitude:()=>Fc,divide:()=>Qg,dotProduct:()=>qc,fromCartesian:()=>Vs,guard:()=>H,invert:()=>Bg,isAntiParallel:()=>Jg,isOpposite:()=>Gg,isParallel:()=>Ug,isPolarCoord:()=>As,multiply:()=>Xg,normalise:()=>Oc,rotate:()=>_c,rotateDegrees:()=>Wg,spiral:()=>sw,spiralRaw:()=>ow,toCartesian:()=>J,toLine:()=>Kg,toPoint:()=>Ic,toString:()=>Cc});var Bc={};x(Bc,{clampMagnitude:()=>hw,divide:()=>gw,dotProduct:()=>dw,fromLineCartesian:()=>Uc,fromLinePolar:()=>Jc,fromPointPolar:()=>Gc,fromRadians:()=>aw,multiply:()=>pw,normalise:()=>cw,quadrantOffsetAngle:()=>lw,subtract:()=>mw,sum:()=>yw,toCartesian:()=>$e,toPolar:()=>Ct,toRadians:()=>uw,toString:()=>fw});const iw=Object.freeze({x:0,y:0}),Kt=Math.PI*2,lr=Math.PI,aw=e=>Object.freeze({x:Math.cos(e),y:Math.sin(e)}),uw=e=>Math.atan2(e.y,e.x),Gc=(e,r="",n=iw)=>{e=Q(e,n);let s=Math.atan2(e.y,e.x);return r==="unipolar"&&s<0?s+=Kt:r==="bipolar"&&(s>lr?s-=Kt:s<=-lr&&(s+=Kt)),Object.freeze({distance:V(e),angleRadian:s})},Uc=e=>Q(e.b,e.a),Jc=e=>{jt(e,"line");const r=Q(e.b,e.a);return Gc(r)},ie=e=>!!As(e),Le=e=>!!E(e),cw=e=>{if(ie(e))return Oc(e);if(Le(e))return zc(e);throw new Error(`Expected polar/cartesian vector. Got: ${e}`)},lw=e=>e.x>=0&&e.y>=0?0:e.x<0&&e.y>=0||e.x<0&&e.y<0?lr:Kt,Ct=(e,r=je)=>{if(ie(e))return e;if(Le(e))return Vs(e,r);throw new Error(`Expected polar/cartesian vector. Got: ${e}`)},$e=e=>{if(ie(e))return Ic(e);if(Le(e))return e;throw new Error(`Expected polar/cartesian vector. Got: ${e}`)},fw=(e,r)=>{if(ie(e))return Cc(e,r);if(Le(e))return Et(e,r);throw new Error(`Expected polar/cartesian vector. Got: ${e}`)},dw=(e,r)=>{if(ie(e)&&ie(r))return qc(e,r);if(Le(e)&&Le(r))return $c(e,r);throw new Error("Expected two polar/Cartesian vectors.")},hw=(e,r=1,n=0)=>{if(ie(e))return Fc(e,r,n);if(Le(e))return Nc(e,r,n);throw new Error("Expected either polar or Cartesian vector")},yw=(e,r)=>{const n=ie(e);e=$e(e),r=$e(r);const s=Re(e,r);return n?Ct(s):s},mw=(e,r)=>{const n=ie(e);e=$e(e),r=$e(r);const s=Q(e,r);return n?Ct(s):s},pw=(e,r)=>{const n=ie(e);e=$e(e),r=$e(r);const s=bt(e,r);return n?Ct(s):s},gw=(e,r)=>{const n=ie(e);e=$e(e),r=$e(r);const s=cr(e,r);return n?Ct(s):s},Rs=(e,r)=>{const n=s=>{const{a:o,b:i}=s,a={x:i.x-o.x,y:i.y-o.y},u={x:r.x-o.x,y:r.y-o.y},c=a.x*a.x+a.y*a.y;let l=u.x*a.x+u.y*a.y;const f=Math.min(1,Math.max(0,l/c));return l=(i.x-o.x)*(r.y-o.y)-(i.y-o.y)*(r.x-o.x),{x:o.x+a.x*f,y:o.y+a.y*f}};if(Array.isArray(e)){const s=e.map(i=>n(i)),o=s.map(i=>V(i,r));return Object.freeze(s[Eo(...o)])}else return Object.freeze(n(e))},fr=(e,r)=>{if(jt(e,"line"),b(r,"point"),G(e)===0)return G(e.a,r);const n=Rs(e,r);return G(n,r)},Wc=e=>({x:e.b.x-e.a.x,y:e.b.y-e.a.y}),Kc=e=>{const r=G(e),n=Wc(e);return{x:n.x/r,y:n.y/r}},Xc=(e,r)=>{const n=Wc(e),s=Kc(e),o={x:e.a.x-s.y*r,y:e.a.y+s.x*r};return{a:o,b:{x:o.x+n.x,y:o.y+n.y}}},Qc=(e,r,n=0)=>{const s=he(n,e),o=Kc(e);return{x:s.x-o.y*r,y:s.y+o.x*r}},Hc=e=>_t(e.a,e.b),Yc=(e,r)=>Object.freeze({...e,a:cr(e.a,r),b:cr(e.b,r)}),Zc=(e,r,n,s)=>{if(Number.isNaN(e))throw new Error("x1 is NaN");if(Number.isNaN(n))throw new Error("x2 is NaN");if(Number.isNaN(r))throw new Error("y1 is NaN");if(Number.isNaN(s))throw new Error("y2 is NaN");return Vt({x:e,y:r},{x:n,y:s})},ww=e=>{if(!Array.isArray(e))throw new Error("arr parameter is not an array");if(e.length!==4)throw new Error("array is expected to have length four");return Zc(e[0],e[1],e[2],e[3])},xw=(e={x:.5,y:.5},r=1,n=0,s=.5)=>{const o=r*s,i=r*(1-s),a=J(o,kc(n),e),u=J(i,n,e);return Object.freeze({a,b:u})},el=(e,r)=>{const[n,s]=zr(e,r);return he(.5,n,s)},tl=(e,r)=>{const n=V(e.a,r),s=G(e);return n/s},rl=(e,r)=>Object.freeze({...e,a:Re(e.a,r),b:Re(e.b,r)}),nl=(e,r,n)=>typeof r>"u"||r===0?e:(typeof n>"u"&&(n=.5),typeof n=="number"&&(n=he(n,e.a,e.b)),Object.freeze({...e,a:le(e.a,r,n),b:le(e.b,r,n)})),sl=(e,r)=>ce(e.a,r.a)&&ce(e.b,r.b),ol=(e,r)=>Object.freeze({...e,a:bt(e.a,r),b:bt(e.b,r)}),il=(e,r)=>Object.freeze({...e,a:Q(e.a,r),b:Q(e.b,r)});function al(e,r){if(Me(e))jt(e,"a"),r=e.b,e=e.a;else if(r===void 0)throw new Error("Expect second point if first is a point");return Et(e)+"-"+Et(r)}const we=e=>{const{a:r,b:n}=e;return Object.freeze({...e,length:()=>G(r,n),interpolate:s=>he(s,r,n),relativePosition:s=>tl(e,s),bbox:()=>Hc(e),toString:()=>al(r,n),toFlatArray:()=>hl(r,n),toSvgString:()=>yl(r,n),toPoints:()=>[r,n],rotate:(s,o)=>we(nl(e,s,o)),nearest:s=>Rs(e,s),sum:s=>we(rl(e,s)),divide:s=>we(Yc(e,s)),multiply:s=>we(ol(e,s)),subtract:s=>we(il(e,s)),midpoint:()=>el(r,n),distanceToPoint:s=>fr(e,s),parallel:s=>Xc(e,s),perpendicularPoint:(s,o)=>Qc(e,s,o),slope:()=>js(e),withinRange:(s,o)=>fl(e,s,o),isEqual:s=>sl(e,s),apply:s=>we(ll(e,s)),kind:"line"})},vw=(e,r)=>we(Vt(e,r));var ul={};x(ul,{Empty:()=>cl,Placeholder:()=>bw,angleRadian:()=>Mw,apply:()=>ll,asPoints:()=>Aw,bbox:()=>Hc,distance:()=>dl,distanceSingleLine:()=>fr,divide:()=>Yc,extendFromA:()=>Pw,fromFlatArray:()=>ww,fromNumbers:()=>Zc,fromPivot:()=>xw,fromPoints:()=>Vt,fromPointsToPath:()=>vw,getPointParameter:()=>zr,guard:()=>jt,interpolate:()=>he,isEmpty:()=>Ew,isEqual:()=>sl,isLine:()=>Me,isPlaceholder:()=>$w,isPolyLine:()=>mc,joinPointsToLines:()=>Rt,length:()=>G,midpoint:()=>el,multiply:()=>ol,nearest:()=>Rs,normaliseByRect:()=>Sw,parallel:()=>Xc,perpendicularPoint:()=>Qc,pointAtDistance:()=>Tg,pointAtX:()=>zw,pointsOf:()=>kw,relativePosition:()=>tl,reverse:()=>Mc,rotate:()=>nl,scaleFromMidpoint:()=>Nw,slope:()=>js,subtract:()=>il,sum:()=>rl,toFlatArray:()=>hl,toPath:()=>we,toString:()=>al,toSvgString:()=>yl,withinRange:()=>fl});const cl=Object.freeze({a:Object.freeze({x:0,y:0}),b:Object.freeze({x:0,y:0})}),bw=Object.freeze({a:Object.freeze({x:NaN,y:NaN}),b:Object.freeze({x:NaN,y:NaN})}),Ew=e=>Xe(e.a)&&Xe(e.b),$w=e=>Qe(e.a)&&Qe(e.b),ll=(e,r)=>Object.freeze({...e,a:r(e.a),b:r(e.b)}),Mw=(e,r)=>{let n;if(Me(e))n=e.a,r=e.b;else if(n=e,r===void 0)throw new Error("b point must be provided");return Math.atan2(r.y-n.y,r.x-n.x)},Sw=(e,r,n)=>Object.freeze({...e,a:on(e.a,r,n),b:on(e.b,r,n)}),fl=(e,r,n)=>dl(e,r)<=n,js=(e,r)=>{let n;if(Me(e))n=e.a,r=e.b;else if(n=e,r===void 0)throw new Error("b parameter required");if(r===void 0)throw new TypeError("Second point missing");return(r.y-n.y)/(r.x-n.x)},Nw=(e,r)=>{const n=he(r/2,e),s=he(.5+r/2,e);return{a:n,b:s}},zw=(e,r)=>{const n=e.a.y+(r-e.a.x)*js(e);return Object.freeze({x:r,y:n})},Pw=(e,r)=>{const n=G(e);return Object.freeze({...e,a:e.a,b:Object.freeze({x:e.b.x+(e.b.x-e.a.x)/n*r,y:e.b.y+(e.b.y-e.a.y)/n*r})})};function*kw(e){const{a:r,b:n}=e;let s=Math.floor(r.x),o=Math.floor(r.y);const i=Math.floor(n.x),a=Math.floor(n.y),u=Math.abs(i-s),c=-Math.abs(a-o),l=s<i?1:-1,f=o<a?1:-1;let d=u+c;for(;yield{x:s,y:o},!(s===i&&o===a);){const h=2*d;h>=c&&(d+=c,s+=l),h<=u&&(d+=u,o+=f)}}const dl=(e,r)=>{if(Array.isArray(e)){const n=e.map(s=>fr(s,r));return bo(n)}else return fr(e,r)},hl=(e,r)=>{if(Me(e))return[e.a.x,e.a.y,e.b.x,e.b.y];if(E(e)&&E(r))return[e.x,e.y,r.x,r.y];throw new Error("Expected single line parameter, or a and b points")};function*Aw(e){for(const r of e)yield r.a,yield r.b}const yl=(e,r)=>[`M${e.x} ${e.y} L ${r.x} ${r.y}`],pt=(e,r)=>{const n=oe(e,r);let s=0,o=0,i=0,a=performance.now(),u=n;return(l,f)=>{const d=oe(l,f);s+=d.x,o+=d.y,i++;const h=V(d,n),y=V(d,u),p=performance.now(),w=y/(p-a);return a=p,u=d,Object.freeze({angle:Te(d,n),distanceFromStart:h,distanceFromLast:y,speed:w,centroid:vc(d,n),average:{x:s/i,y:o/i}})}};var _s=class extends tc{initialRelation;markRelation;lastResult;constructor(e={}){super(e)}onTrimmed(e){this.initialRelation=void 0}onReset(){super.onReset(),this.lastResult=void 0,this.initialRelation=void 0,this.markRelation=void 0}seenEvent(e){if("getCoalescedEvents"in e){const n=e.getCoalescedEvents().map(s=>({x:s.clientX,y:s.clientY}));return this.seen(...n)}else return this.seen({x:e.clientX,y:e.clientY})}mark(){this.markRelation=pt(this.last)}computeResults(e){const r=this.last,n=this.values.at(-2);if(this.initialRelation===void 0&&this.initial)this.initialRelation=pt(this.initial);else if(this.initialRelation===void 0)throw new Error("Bug: No initialRelation, and this.inital is undefined?");const s=pt(n===void 0?r:n),o=this.initialRelation(r),i=this.markRelation!==void 0?this.markRelation(r):void 0,a=n===void 0?0:G(n,r)/(r.at-n.at),u={...s(r),speed:a},c={fromInitial:o,fromLast:u,fromMark:i,values:[...this.values]};return this.lastResult=c,c}get line(){return this.values.length===1?[]:Rt(...this.values)}get vectorPolar(){return Jc(this.lineStartEnd)}get vectorCartesian(){return Uc(this.lineStartEnd)}get lineStartEnd(){const e=this.initial;return this.values.length<2||!e?cl:{a:e,b:this.last}}distanceFromStart(){const e=this.initial;return this.values.length>=2&&e!==void 0?V(e,this.last):0}difference(){const e=this.initial;return this.values.length>=2&&e!==void 0?Q(this.last,e):ac}angleFromStart(){const e=this.initial;if(e!==void 0&&this.values.length>2)return Te(e,this.last)}get length(){if(this.values.length===1)return 0;const e=this.line;return G(e)}get x(){return this.last.x}get y(){return this.last.y}get z(){return this.last.z}},ml=class extends rc{constructor(e={}){super((r,n)=>{if(n===void 0)throw new Error("Requires start point");const s=new _s({...e,id:r});return s.seen(n),s})}seenEvent(e){if("getCoalescedEvents"in e){const n=e.getCoalescedEvents().map(s=>super.seen(s.pointerId.toString(),s));return Promise.all(n)}else return Promise.all([super.seen(e.pointerId.toString(),e)])}};const Tw=(e,r,n)=>{const s=Q(e,r),o=Q(n,r);return S(s)&&S(o)?(s.x*o.x+s.y*o.y+s.z*o.z)/(o.x*o.x+o.y*o.y+o.z*o.z):(s.x*o.x+s.y*o.y)/(o.x*o.x+o.y*o.y)},ln=(e,r,n)=>{const s=Math.cos(n)*r+e.x,o=Math.sin(n)*r+e.y;return{x:s,y:o}};function Vw(e,r,n=!0){if(b(e,"pt"),b(r,"snap"),S(e)){if(!S(r))throw new TypeError("Param 'snap' is missing 'z' field");return Object.freeze({x:it(e.x,r.x,n),y:it(e.y,r.y,n),z:it(e.z,r.z,n)})}return Object.freeze({x:it(e.x,r.x,n),y:it(e.y,r.y,n)})}const Rw=e=>(typeof e>"u"&&(e=Math.random),Object.freeze({x:e(),y:e()})),jw=e=>(typeof e>"u"&&(e=Math.random),Object.freeze({x:e(),y:e(),z:e()})),pl=(e,r,n)=>{n===void 0&&(n={x:0,y:0});let s=n;for(const o of e)s=r(o,s);return s};function le(e,r,n){typeof n>"u"&&(n={x:0,y:0}),b(n,"origin"),g(z(r,"","amountRadian"));const s=Array.isArray(e);if(r===0)return e;s||(e=[e]);const o=e;for(const[c,l]of o.entries())b(l,`pt[${c}]`);const u=o.map(c=>Vs(c,n)).map(c=>_c(c,r)).map(c=>J(c,n));return s?u:u[0]}const _w=(e,r)=>{const n=[[Math.cos(r),-Math.sin(r)],[Math.sin(r),Math.cos(r)]],s=[];for(const[o,i]of e.entries())s[o]=[n[0][0]*i[0]+n[0][1]*i[1],n[1][0]*i[0]+n[1][1]*i[1]];return s},Cw=(e,r,n)=>{const s=oe(e,r);return n=n??r,n=n??2,Object.freeze({...s,x:io(n,s.x),y:io(n,s.y)})},Iw=(e,r,n)=>{b(e,"a"),b(r,"b"),typeof n=="number"?(g(z(n,"positive","maxRange")),n={x:n,y:n}):b(n,"maxRange");const s=Math.abs(r.x-e.x),o=Math.abs(r.y-e.y);return s<=n.x&&o<=n.y},Ow=(e,r,n)=>(r===void 0&&(r={x:1,y:1}),n===void 0&&(n={x:0,y:0}),b(e,"pt"),b(r,"ptMax"),b(n,"ptMin"),Object.freeze({x:oo(e.x,n.x,r.x),y:oo(e.y,n.y,r.y)}));var gl={};x(gl,{Empty:()=>je,Empty3d:()=>zg,Placeholder:()=>ac,Placeholder3d:()=>Rp,PointTracker:()=>_s,PointsTracker:()=>ml,Unit:()=>Ng,Unit3d:()=>Pg,abs:()=>hg,angleRadian:()=>Te,angleRadianCircle:()=>yg,apply:()=>mg,averager:()=>pg,bbox:()=>_t,bbox3d:()=>gg,centroid:()=>vc,clamp:()=>wg,clampMagnitude:()=>Nc,compare:()=>xg,compareByX:()=>bc,compareByY:()=>vg,compareByZ:()=>bg,convexHull:()=>Eg,distance:()=>V,distanceToCenter:()=>$g,distanceToExterior:()=>Mg,divide:()=>cr,divider:()=>Sg,dotProduct:()=>$c,findMinimum:()=>xe,from:()=>kg,fromNumbers:()=>ks,fromString:()=>Ag,getPointParameter:()=>oe,getTwoPointParameters:()=>At,guard:()=>b,guardNonZeroPoint:()=>ic,interpolate:()=>Vg,invert:()=>Rg,isEmpty:()=>Xe,isEqual:()=>ce,isNaN:()=>Np,isNull:()=>Sp,isPlaceholder:()=>Qe,isPoint:()=>E,isPoint3d:()=>S,leftmost:()=>jg,multiply:()=>bt,multiplyScalar:()=>Sc,normalise:()=>zc,normaliseByRect:()=>on,pipeline:()=>Pc,pipelineApply:()=>Ig,progressBetween:()=>Tw,project:()=>ln,quantiseEvery:()=>Vw,random:()=>Rw,random3d:()=>jw,reduce:()=>pl,relation:()=>pt,rightmost:()=>_g,rotate:()=>le,rotatePointArray:()=>_w,round:()=>Cw,subtract:()=>Q,sum:()=>Re,test:()=>oc,to2d:()=>Yg,to3d:()=>Zg,toArray:()=>Ec,toIntegerValues:()=>Hg,toString:()=>Et,withinRange:()=>Iw,wrap:()=>Ow});var wl={};x(wl,{angularSize:()=>bl,bbox:()=>Ml,distanceCenter:()=>Bw,fromCircle:()=>El,fromCircleAmount:()=>Dw,fromDegrees:()=>Fw,getStartEnd:()=>qw,guard:()=>kr,interpolate:()=>Cs,isArc:()=>xl,isEqual:()=>Gw,isPositioned:()=>ve,length:()=>$l,point:()=>Ze,toLine:()=>vl,toPath:()=>Lw,toSvg:()=>Sl});const xl=e=>typeof e.startRadian<"u"&&typeof e.endRadian<"u"&&typeof e.clockwise<"u",ve=e=>typeof e.x<"u"&&typeof e.y<"u";function Fw(e,r,n,s,o){const i={radius:e,startRadian:te(r),endRadian:te(n),clockwise:s};if(E(o)){b(o);const a={...i,x:o.x,y:o.y};return Object.freeze(a)}else return Object.freeze(i)}const vl=e=>Vt(Ze(e,e.startRadian),Ze(e,e.endRadian)),qw=(e,r)=>{kr(e);const n=Ze(e,e.startRadian,r),s=Ze(e,e.endRadian,r);return[n,s]},Ze=(e,r,n)=>(typeof n>"u"&&(n=ve(e)?e:{x:0,y:0}),{x:Math.cos(r)*e.radius+n.x,y:Math.sin(r)*e.radius+n.y}),kr=e=>{if(typeof e>"u")throw new TypeError("Arc is undefined");if(ve(e)&&b(e,"arc"),typeof e.radius>"u")throw new TypeError(`Arc radius is undefined (${JSON.stringify(e)})`);if(typeof e.radius!="number")throw new TypeError("Radius must be a number");if(Number.isNaN(e.radius))throw new TypeError("Radius is NaN");if(e.radius<=0)throw new TypeError("Radius must be greater than zero");if(typeof e.startRadian>"u")throw new TypeError("Arc is missing 'startRadian' field");if(typeof e.endRadian>"u")throw new TypeError("Arc is missing 'startRadian' field");if(Number.isNaN(e.endRadian))throw new TypeError("Arc endRadian is NaN");if(Number.isNaN(e.startRadian))throw new TypeError("Arc endRadian is NaN");if(typeof e.clockwise>"u")throw new TypeError("Arc is missing 'clockwise field");if(e.startRadian>=e.endRadian)throw new TypeError("startRadian is expected to be les than endRadian")},Cs=(e,r,n,s)=>{if(kr(r),!(n??!1)){if(e<0)throw new Error("Param 'amount' is under zero, and overflow is not allowed");if(e>1)throw new Error("Param 'amount' is above 1 and overflow is not allowed")}const a=bl(r)*e,u=Pr(r.startRadian,a,r.clockwise);return Ze(r,u,s)},bl=e=>Ts(e.startRadian,e.endRadian,e.clockwise),Lw=e=>(kr(e),Object.freeze({...e,nearest:r=>{throw new Error("not implemented")},interpolate:r=>Cs(r,e),bbox:()=>Ml(e),length:()=>$l(e),toSvgString:()=>Sl(e),relativePosition:(r,n)=>{throw new Error("Not implemented")},distanceToPoint:r=>{throw new Error("Not implemented")},kind:"arc"})),El=(e,r,n,s=!0)=>Object.freeze({...e,endRadian:n,startRadian:r,clockwise:s}),Dw=(e,r,n,s=!0)=>{const o=Pr(r,n,s);return El(e,r,o)},$l=e=>W*e.radius*((e.startRadian-e.endRadian)/W),Ml=e=>{if(ve(e)){const r=Cs(.5,e),n=vl(e);return _t(r,n.a,n.b)}else return{width:e.radius*2,height:e.radius*2}},Sl=(e,r,n,s,o)=>{if(xl(e))return ve(e)?E(r)?dt(r,e.radius,e.startRadian,e.endRadian,n):dt(e,e.radius,e.startRadian,e.endRadian,r):E(r)?dt(r,e.radius,e.startRadian,e.endRadian,n):dt({x:0,y:0},e.radius,e.startRadian,e.endRadian);if(n===void 0)throw new Error("startAngle undefined");if(s===void 0)throw new Error("endAngle undefined");if(E(e)){if(typeof r=="number"&&typeof n=="number"&&typeof s=="number")return dt(e,r,n,s,o);throw new TypeError("Expected (point, number, number, number). Missing a number param.")}else throw new Error("Expected (point, number, number, number). Missing first point.")},dt=(e,r,n,s,o)=>{(o===void 0||typeof o!="object")&&(o={});const i=s-n===360,a=J(r,s-.01,e),u=J(r,n,e),{largeArc:c=!1,sweep:l=!1}=o,f=[`
    M ${a.x} ${a.y}
    A ${r} ${r} 0 ${c?"1":"0"} ${l?"1":"0"} ${u.x} ${u.y},
  `];return i&&f.push("z"),f},Bw=(e,r)=>V(e,r),Gw=(e,r)=>{if(e.radius!==r.radius||e.endRadian!==r.endRadian||e.startRadian!==r.startRadian||e.clockwise!==r.clockwise)return!1;if(ve(e)&&ve(r)){if(e.x!==r.x||e.y!==r.y||e.z!==r.z)return!1}else if(!(!ve(e)&&!ve(r)))return!1;return!0},Ar=e=>e.quadratic!==void 0,Is=e=>e.cubic1!==void 0&&e.cubic2!==void 0;var Nl={};x(Nl,{cubic:()=>Kw,interpolator:()=>Jw,isCubicBezier:()=>Is,isQuadraticBezier:()=>Ar,quadratic:()=>Pl,quadraticSimple:()=>Uw,quadraticToSvgString:()=>zl,toPath:()=>Ww});const Uw=(e,r,n=0)=>{if(Number.isNaN(n))throw new Error("bend is NaN");if(n<-1||n>1)throw new Error("Expects bend range of -1 to 1");const s=he(.5,e,r);let o=s;r.y<e.y?o=n>0?{x:Math.min(e.x,r.x),y:Math.min(e.y,r.y)}:{x:Math.max(e.x,r.x),y:Math.max(e.y,r.y)}:o=n>0?{x:Math.max(e.x,r.x),y:Math.min(e.y,r.y)}:{x:Math.min(e.x,r.x),y:Math.max(e.y,r.y)};const i=he(Math.abs(n),s,o);return Pl(e,r,i)},Jw=e=>{const r=Is(e)?new vt(e.a.x,e.a.y,e.cubic1.x,e.cubic1.y,e.cubic2.x,e.cubic2.y,e.b.x,e.b.y):new vt(e.a,e.quadratic,e.b);return n=>r.compute(n)},zl=(e,r,n)=>[`M ${e.x} ${e.y} Q ${n.x} ${n.y} ${r.x} ${r.y}`],Ww=e=>{if(Is(e))return Xw(e);if(Ar(e))return Qw(e);throw new Error("Unknown bezier type")},Kw=(e,r,n,s)=>({a:Object.freeze(e),b:Object.freeze(r),cubic1:Object.freeze(n),cubic2:Object.freeze(s)}),Xw=e=>{const{a:r,cubic1:n,cubic2:s,b:o}=e,i=new vt(r,n,s,o);return Object.freeze({...e,length:()=>i.length(),interpolate:a=>i.compute(a),nearest:a=>{throw new Error("not implemented")},bbox:()=>{const{x:a,y:u}=i.bbox(),c=a.size,l=u.size;if(c===void 0)throw new Error("x.size not present on calculated bbox");if(l===void 0)throw new Error("x.size not present on calculated bbox");return Ae({x:a.min,y:u.min},c,l)},relativePosition:(a,u)=>{throw new Error("Not implemented")},distanceToPoint:a=>{throw new Error("Not implemented")},toSvgString:()=>["brrup"],kind:"bezier/cubic"})},Pl=(e,r,n)=>({a:Object.freeze(e),b:Object.freeze(r),quadratic:Object.freeze(n)}),Qw=e=>{const{a:r,b:n,quadratic:s}=e,o=new vt(r,s,n);return Object.freeze({...e,length:()=>o.length(),interpolate:i=>o.compute(i),nearest:i=>{throw new Error("not implemented")},bbox:()=>{const{x:i,y:a}=o.bbox(),u=i.size,c=a.size;if(u===void 0)throw new Error("x.size not present on calculated bbox");if(c===void 0)throw new Error("x.size not present on calculated bbox");return Ae({x:i.min,y:a.min},u,c)},distanceToPoint:i=>{throw new Error("Not implemented")},relativePosition:(i,a)=>{throw new Error("Not implemented")},toString:()=>o.toString(),toSvgString:()=>zl(r,n,s),kind:"bezier/quadratic"})},Hw=e=>(kt(e),Math.PI*e.radius*e.radius),kl=e=>q(e)?yc(e,e.radius*2,e.radius*2):{width:e.radius*2,height:e.radius*2,x:0,y:0},Al=e=>q(e)?Object.freeze({x:e.x,y:e.y}):Object.freeze({x:e.radius,y:e.radius});function*Yw(e){const{x:r,y:n,radius:s}=e;let o=s,i=0,a=1-r;for(;o>=i;)yield{x:o+r,y:i+n},yield{x:i+r,y:o+n},yield{x:-o+r,y:i+n},yield{x:-i+r,y:o+n},yield{x:-o+r,y:-i+n},yield{x:-i+r,y:-o+n},yield{x:o+r,y:-i+n},yield{x:i+r,y:-o+n},i++,a<0?a+=2*i+1:(o--,a+=2*(i-o+1))}function*Zw(e){const r=e.x-e.radius,n=e.x+e.radius,s=e.y-e.radius,o=e.y+e.radius;for(let i=r;i<n;i++)for(let a=s;a<o;a++)Math.abs(V(e,i,a))<=e.radius&&(yield{x:i,y:a})}const ex=Math.PI*2,Tl=(e,r)=>{const n=s=>{const o=Math.sqrt(Math.pow(r.x-s.x,2)+Math.pow(r.y-s.y,2)),i=s.x+s.radius*((r.x-s.x)/o),a=s.y+s.radius*((r.y-s.y)/o);return{x:i,y:a}};if(Array.isArray(e)){const s=e.map(i=>n(i)),o=s.map(i=>V(i,r));return Object.freeze(s[Eo(...o)])}else return Object.freeze(n(e))},Vl=(e,r,n)=>(n===void 0&&(n=q(e)?e:{x:0,y:0}),{x:Math.cos(-r)*e.radius+n.x,y:Math.sin(-r)*e.radius+n.y}),Os=e=>(kt(e),ex*e.radius),tx=e=>Os(e),rx=Math.PI*2,Rl=(e,r)=>Vl(e,r*rx),jl=(e,r,n)=>{const s=zs(e,r);if(rt(r))return s<Math.abs(e.radius-r.radius);if(E(r))return n===void 0?s<=e.radius:s<Math.abs(e.radius-n);throw new Error("b parameter is expected to be CirclePositioned or Point")},Fs=(e,r,n)=>ce(e,r)||jl(e,r,n)?!0:rt(r)?mo(e,r):de(r)?fc(e,r):E(r)&&n!==void 0?mo(e,{...r,radius:n}):!1;function nx(e,r){if(q(e)){const n=Sc(e,r);return Object.freeze({...e,...n,radius:e.radius*r})}else return Object.freeze({...e,radius:e.radius*r})}const go=Math.PI*2,_l=(e,r={})=>{const n=q(e)?e:{x:0,y:0},s=r.strategy??"uniform",o=r.margin??0,i=e.radius-o,a=r.randomSource??Math.random;switch(s){case"naive":return Re(n,J(a()*i,a()*go));case"uniform":return Re(n,J(Math.sqrt(a())*i,a()*go));default:throw new Error(`Unknown strategy '${s}'. Expects 'uniform' or 'naive'`)}},Cl=(e,r,n)=>{if(rt(e)){if(n!==void 0)return Lr(e.radius,n,r);if(q(e))return Lr(e.radius,e,r);throw new Error("origin parameter needed for non-positioned circle")}else{if(n===void 0)throw new Error("origin parameter needed");return Lr(e,n,r)}},Lr=(e,r,n)=>{const{x:s,y:o}=r,i=n?"1":"0";return`
    M ${s}, ${o}
    m -${e}, 0
    a ${e},${e} 0 1,${i} ${e*2},0
    a ${e},${e} 0 1,${i} -${e*2},0
  `.split(`
`)},sx=e=>(kt(e),{...e,nearest:r=>Tl(e,r),interpolate:r=>Rl(e,r),bbox:()=>kl(e),length:()=>Os(e),toSvgString:(r=!0)=>Cl(e,r),relativePosition:(r,n)=>{throw new Error("Not implemented")},distanceToPoint:r=>{throw new Error("Not implemented")},kind:"circular"}),qs=(e,r,n)=>{if(q(e))return e;const s=oe(r,n);return Object.freeze({...e,...s})};var Il={};x(Il,{area:()=>Hw,bbox:()=>kl,center:()=>Al,circumference:()=>Os,distanceCenter:()=>zs,distanceFromExterior:()=>Ps,exteriorIntegerPoints:()=>Yw,guard:()=>kt,guardPositioned:()=>ur,interiorIntegerPoints:()=>Zw,interpolate:()=>Rl,intersectionLine:()=>_p,intersections:()=>lc,isCircle:()=>rt,isCirclePositioned:()=>q,isContainedBy:()=>jl,isEqual:()=>cc,isIntersecting:()=>Fs,isNaN:()=>jp,isPositioned:()=>uc,length:()=>tx,multiplyScalar:()=>nx,nearest:()=>Tl,pointOnPerimeter:()=>Vl,randomPoint:()=>_l,toPath:()=>sx,toPositioned:()=>qs,toSvg:()=>Cl});const Ol=(e,r)=>!(r.x<0||r.y<0||r.x>=e.cols||r.y>=e.rows),ox=e=>e===void 0?!1:"x"in e&&"y"in e,ye=(e,r="Param",n)=>{if(e===void 0)throw new Error(r+" is undefined. Expecting {x,y}");if(e.x===void 0)throw new Error(r+".x is undefined");if(e.y===void 0)throw new Error(r+".y is undefined");if(Number.isNaN(e.x))throw new Error(r+".x is NaN");if(Number.isNaN(e.y))throw new Error(r+".y is NaN");if(!Number.isInteger(e.x))throw new TypeError(r+".x is non-integer");if(!Number.isInteger(e.y))throw new TypeError(r+".y is non-integer");if(n!==void 0&&!Ol(n,e))throw new Error(`${r} is outside of grid. Cell: ${e.x},${e.y} Grid: ${n.cols}, ${n.rows}`)},Be=(e,r="Param")=>{if(e===void 0)throw new Error(`${r} is undefined. Expecting grid.`);if(!("rows"in e))throw new Error(`${r}.rows is undefined`);if(!("cols"in e))throw new Error(`${r}.cols is undefined`);if(!Number.isInteger(e.rows))throw new TypeError(`${r}.rows is not an integer`);if(!Number.isInteger(e.cols))throw new TypeError(`${r}.cols is not an integer`)},It=function(e,r,n="undefined"){Be(e,"grid"),ye(r,"cell");let s=r.x,o=r.y;switch(n){case"wrap":{s=s%e.cols,o=o%e.rows,s<0?s=e.cols+s:s>=e.cols&&(s-=e.cols),o<0?o=e.rows+o:o>=e.rows&&(o-=e.rows),s=Math.abs(s),o=Math.abs(o);break}case"stop":{s=so(s,e.cols),o=so(o,e.rows);break}case"undefined":{if(s<0||o<0||s>=e.cols||o>=e.rows)return;break}case"unbounded":break;default:throw new Error(`Unknown BoundsLogic '${n}'. Expected: wrap, stop, undefined or unbounded`)}return Object.freeze({x:s,y:o})};var Fl={};x(Fl,{access:()=>ql,createArray:()=>Jl,createMutable:()=>ux,set:()=>ax,setMutate:()=>Dl,wrap:()=>Ul,wrapMutable:()=>Gl});const ql=(e,r)=>{const n=Ot(e,r);return(o,i="undefined")=>Ll(n,e,o,i)},Ll=(e,r,n,s)=>{const o=Rr(e,n,s);if(o!==void 0)return r[o]},Dl=(e,r)=>{const n=Ot(e,r);return(s,o,i="undefined")=>ix(n,e,s,o,i)},ix=(e,r,n,s,o)=>{const i=Rr(e,s,o);if(i===void 0)throw new RangeError(`Cell (${s.x},${s.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);return r[i]=n,r},ax=(e,r)=>{const n=Ot(e,r);return(s,o,i)=>Bl(n,e,s,o,i)},Bl=(e,r,n,s,o)=>{const i=Rr(e,s,o);if(i===void 0)throw new RangeError(`Cell (${s.x},${s.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);const a=[...r];return a[i]=n,r=a,a},Ot=(e,r)=>({cols:r,rows:Math.ceil(e.length/r)}),Gl=(e,r)=>({...Ot(e,r),get:ql(e,r),set:Dl(e,r),get array(){return e}}),Ul=(e,r)=>{const n=Ot(e,r);return{...n,get:(s,o="undefined")=>Ll(n,e,s,o),set:(s,o,i="undefined")=>(e=Bl(n,e,s,o,i),Ul(e,r)),get array(){return e}}},Jl=(e,r,n)=>{const s=typeof r=="number"?r:r.rows,o=typeof r=="object"?r.cols:n;if(!o)throw new Error("Parameter 'columns' missing");g(I(s,"aboveZero","rows"),I(o,"aboveZero","cols"));const i=[],a=s*o;for(let u=0;u<a;u++)i[u]=e;return i},ux=(e,r,n)=>{const s=typeof r=="number"?r:r.rows,o=typeof r=="object"?r.cols:n;if(!o)throw new Error("Parameter 'columns' missing");const i=Jl(e,s,o);return Gl(i,o)};var Wl={};x(Wl,{access:()=>Xl,create:()=>st,set:()=>fx,setMutate:()=>Kl,wrap:()=>Yl,wrapMutable:()=>lx});const st=e=>{let r=NaN;for(const n of e)if(Number.isNaN(r))r=n.length;else if(r!==n.length)throw new Error("Array does not have uniform column length");return{rows:e.length,cols:r}},Kl=e=>{const r=st(e);return(n,s,o="undefined")=>cx(r,e,n,s,o)},cx=(e,r,n,s,o)=>{let i=It(e,s,o);if(i===void 0)throw new RangeError(`Cell (${s.x},${s.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);return r[i.y][i.x]=n,r},Xl=e=>{const r=st(e);return(s,o="undefined")=>Ql(r,e,s,o)},Ql=(e,r,n,s)=>{let o=It(e,n,s);if(o!==void 0)return r[o.y][o.x]},lx=e=>({...st(e),get:Xl(e),set:Kl(e),get array(){return e}}),fx=e=>{const r=st(e);return(n,s,o)=>Hl(r,e,n,s,o)},Hl=(e,r,n,s,o)=>{let i=It(e,s,o);if(i===void 0)throw new RangeError(`Cell (${s.x},${s.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);let a=[...r],u=[...a[i.y]];return u[i.x]=n,a[i.y]=u,r=a,a},Yl=e=>{const r=st(e);return{...r,get:(n,s="undefined")=>Ql(r,e,n,s),set:(n,s,o="undefined")=>(e=Hl(r,e,n,s,o),Yl(e)),get array(){return e}}};function*Zl(e,r){for(const n of r)Array.isArray(n)?yield n.map(s=>e.get(s,"undefined")):yield e.get(n,"undefined")}function*ot(e,r,n=!0){r||(r={x:0,y:0}),Be(e,"grid"),ye(r,"start",e);let{x:s,y:o}=r,i=!0;do yield{x:s,y:o},s++,s===e.cols&&(o++,s=0),o===e.rows&&(n?(o=0,s=0):i=!1),s===r.x&&o===r.y&&(i=!1);while(i)}function*dx(e,r,n=!0){yield*Zl(e,ot(e,r,n))}function*hx(e,r,n=!0){for(const s of ot(e,r,n))yield{cell:s,value:e.get(s)}}var ef={};x(ef,{columns:()=>mx,rows:()=>yx});const yx=function*(e,r){r||(r={x:0,y:0});let n=r.y,s=[];for(const o of ot(e,r))o.y===n?s.push(o):(yield s,s=[o],n=o.y);s.length>0&&(yield s)};function*mx(e,r){r||(r={x:0,y:0});for(let n=r.x;n<e.cols;n++){let s=[];for(let o=r.y;o<e.rows;o++)s.push({x:n,y:o});yield s}}const Tr=function(e,r,n,s="undefined"){return It(e,{x:r.x+n.x,y:r.y+n.y},s)},Vr=Object.freeze(["n","ne","nw","e","s","se","sw","w"]),tf=Object.freeze(["n","e","s","w"]),px=(e,r,n,s="stop")=>{Be(e,"grid"),ye(r,"start"),g(I(n,"aboveZero","steps"));const o=Vr,i=o.map(u=>Ls(u,n)),a=o.map((u,c)=>Tr(e,r,i[c],s));return hr(o,a)},Ls=(e,r=1)=>{let n;switch(e){case"n":{n={x:0,y:-1*r};break}case"ne":{n={x:1*r,y:-1*r};break}case"e":{n={x:1*r,y:0};break}case"se":{n={x:1*r,y:1*r};break}case"s":{n={x:0,y:1*r};break}case"sw":{n={x:-1*r,y:1*r};break}case"w":{n={x:-1*r,y:0};break}case"nw":{n={x:-1*r,y:-1*r};break}default:n={x:0,y:0}}return Object.freeze(n)};var rf={};x(rf,{cellValues:()=>dx,cells:()=>ot,cellsAndValues:()=>hx});const gx=(e,r)=>{ye(e),ye(r);let n=e.x,s=e.y;const o=Math.abs(r.x-n),i=Math.abs(r.y-s),a=n<r.x?1:-1,u=s<r.y?1:-1;let c=o-i;const l=[];for(;l.push(Object.freeze({x:n,y:s})),!(n===r.x&&s===r.y);){const f=2*c;f>-i&&(c-=i,n+=a),f<o&&(c+=o,s+=u)}return l},wx=function(e,r,n=!1){const s=[];if(e.x===r.x){const o=n?r.y+1:r.y;for(let i=e.y;i<o;i++)s.push({x:e.x,y:i})}else if(e.y===r.y){const o=n?r.x+1:r.x;for(let i=e.x;i<o;i++)s.push({x:i,y:e.y})}else throw new Error(`Only does vertical and horizontal: ${e.x},${e.y} - ${r.x},${r.y}`);return s},Rr=(e,r,n)=>{if(Be(e,"grid"),r.x<0)switch(n){case"stop":{r={...r,x:0};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{r=Tr(e,{x:0,y:r.y},{x:r.x,y:0},"wrap");break}}if(r.y<0)switch(n){case"stop":{r={...r,y:0};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{r={...r,y:e.rows+r.y};break}}if(r.x>=e.cols)switch(n){case"stop":{r={...r,x:e.cols-1};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{r={...r,x:r.x%e.cols};break}}if(r.y>=e.rows)switch(n){case"stop":{r={...r,y:e.rows-1};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{r={...r,y:r.y%e.rows};break}}return r.y*e.cols+r.x},xx=(e,r)=>{let n=0;return n=typeof e=="number"?e:e.cols,g(I(n,"aboveZero","colsOrGrid")),{x:r%n,y:Math.floor(r/n)}},vx=(e,r)=>{if(r===void 0||e===void 0)return!1;if("rows"in e&&"cols"in e)if("rows"in r&&"cols"in r){if(e.rows!==r.rows||e.cols!==r.cols)return!1}else return!1;if("size"in e)if("size"in r){if(e.size!==r.size)return!1}else return!1;return!0},nf=(e,r)=>r===void 0||e===void 0?!1:e.x===r.x&&e.y===r.y,Ds=e=>Bu(e),bx=e=>!(e===void 0||e[1]===void 0),Bs=(e,r,n,s)=>{const o=sf(e,r,s,n);return Object.entries(o).filter(a=>bx(a))},sf=(e,r,n="undefined",s)=>{const o=s??Vr,i=o.map(a=>Tr(e,r,Ls(a),n));return hr(o,i)},Ex=(e,r)=>{const n=[];for(let s=0;s<e.rows;s++)if(n[s]=Array.from({length:e.cols}),r)for(let o=0;o<e.cols;o++)n[s][o]=r;return n},of=e=>`Cell{${e.x},${e.y}}`;function*$x(e){for(const r of ot(e))yield af(e,r)}const Mx=(e,r)=>{const n=e.size;if(g(z(n,"positive","grid.size")),r.x<0||r.y<0)return;const s=Math.floor(r.x/n),o=Math.floor(r.y/n);if(!(s>=e.cols)&&!(o>=e.rows))return{x:s,y:o}},af=(e,r)=>{ye(r);const n=e.size,s=r.x*n,o=r.y*n;return Ae({x:s,y:o},n,n)},Sx=(e,r)=>{ye(r);const n=e.size,s=r.x*n,o=r.y*n;return Object.freeze({x:s+n/2,y:o+n/2})},uf=()=>({select:e=>e[0]}),cf=()=>({select:e=>e.at(0),getNeighbours:(e,r)=>Bs(e,r,Vr,"undefined")}),lf=(e={})=>{const r=e.reversed??!1;return{select:n=>n.find(s=>s[0]===(r?"n":"s")),getNeighbours:(n,s)=>(r?s.y>0?s={x:s.x,y:s.y-1}:s.x===0?s={x:n.cols-1,y:n.rows-1}:s={x:s.x-1,y:n.rows-1}:s.y<n.rows-1?s={x:s.x,y:s.y+1}:s.x<n.cols-1?s={x:s.x+1,y:0}:s={x:0,y:0},[[r?"n":"s",s]])}},ff=()=>({select:e=>e.at(-1)}),df=()=>({getNeighbours:(e,r)=>{const n=[];for(const s of ot(e,r))n.push(["n",s]);return n},select:Ds}),hf=()=>({select:Ds}),yf=(e={})=>{const r=e.reversed??!1;return{select:n=>n.find(s=>s[0]===(r?"w":"e")),getNeighbours:(n,s)=>(r?s.x>0?s={x:s.x-1,y:s.y}:s.y>0?s={x:n.cols-1,y:s.y-1}:s={x:n.cols-1,y:n.rows-1}:s.x<n.rows-1?s={x:s.x+1,y:s.y}:s.y<n.rows-1?s={x:0,y:s.y+1}:s={x:0,y:0},[[r?"w":"e",s]])}};function*mf(e,r,n={}){Be(r,"grid");const s=n.start??{x:0,y:0};ye(s,"opts.start",r);const o=n.visited??Wa(of),i=e.getNeighbours??((l,f)=>Bs(l,f,tf,"undefined"));let a=[s],u=[],c;for(;a.length>0;){if(c===void 0){const l=a.pop();if(l===void 0)break;c=l}if(!o.has(c)){o.add(c),yield c;const l=i(r,c).filter(f=>f[1]===void 0?!1:!o.has(f[1]));if(l.length===0)c!==void 0&&(a=a.filter(f=>nf(f,c)));else for(const f of l)f!==void 0&&f[1]!==void 0&&u.push(f)}if(u=u.filter(l=>!o.has(l[1])),u.length===0)c=void 0;else{const l=e.select(u);l!==void 0&&(a.push(l[1]),c=l[1])}}}const Nx=(e,r,n={x:0,y:0},s=1)=>{Be(e,"grid"),ye(n,"start"),g(I(s,"","resolution"));const o=[];let i=0,a=0;for(const u of r(e,{start:n,boundsWrap:"undefined"}))i++,i%s===0&&o.push(u);return(u,c=!1)=>(g(I(u,"","step")),c?a=u:a+=u,o.at(a%o.length))};var pf={};x(pf,{breadthLogic:()=>uf,columnLogic:()=>lf,create:()=>zx,depthLogic:()=>ff,neighboursLogic:()=>cf,randomContiguousLogic:()=>hf,randomLogic:()=>df,rowLogic:()=>yf,stepper:()=>Nx,visitByNeighbours:()=>mf,withLogic:()=>ke});const zx=(e,r={})=>{switch(e){case"random-contiguous":return ke(hf(),r);case"random":return ke(df(),r);case"depth":return ke(ff(),r);case"breadth":return ke(uf(),r);case"neighbours":return ke(cf(),r);case"row":return ke(yf(r),r);case"column":return ke(lf(r),r);default:throw new TypeError(`Param 'type' unknown. Value: ${e}`)}},ke=(e,r={})=>(n,s={})=>mf(e,n,{...r,...s});var gf={};x(gf,{Array1d:()=>Fl,Array2d:()=>Wl,As:()=>ef,By:()=>rf,Visit:()=>pf,allDirections:()=>Vr,applyBounds:()=>It,asRectangles:()=>$x,cellAtPoint:()=>Mx,cellEquals:()=>nf,cellFromIndex:()=>xx,cellKeyString:()=>of,cellMiddle:()=>Sx,crossDirections:()=>tf,getLine:()=>gx,getVectorFromCardinal:()=>Ls,guardCell:()=>ye,guardGrid:()=>Be,indexFromCell:()=>Rr,inside:()=>Ol,isCell:()=>ox,isEqual:()=>vx,neighbourList:()=>Bs,neighbours:()=>sf,offset:()=>Tr,offsetCardinals:()=>px,randomNeighbour:()=>Ds,rectangleForCell:()=>af,simpleLine:()=>wx,toArray2d:()=>Ex,values:()=>Zl});const wf=function(e){if(Ar(e))return e.a;if(Me(e))return e.a;throw new Error(`Unknown path type ${JSON.stringify(e)}`)},fn=function(e){if(Ar(e))return e.b;if(Me(e))return e.b;throw new Error(`Unknown path type ${JSON.stringify(e)}`)};var xf={};x(xf,{bbox:()=>Ws,computeDimensions:()=>Ft,distanceToPoint:()=>Us,fromPaths:()=>Hs,guardContinuous:()=>Xs,interpolate:()=>Gs,relativePosition:()=>Js,setSegment:()=>vf,toString:()=>Ks,toSvgString:()=>Qs});const vf=(e,r,n)=>{const s=[...e.segments];return s[r]=n,Hs(...s)},Gs=(e,r,n,s)=>{s===void 0&&(s=Ft(e));const o=r*(n?s.totalWidth:s.totalLength);let i=0;const a=n?s.widths:s.lengths;for(const[u,c]of a.entries())if(i+c>=o){let f=(o-i)/c;return f>1&&(f=1),e[u].interpolate(f)}else i+=c;return{x:0,y:0}},Us=(e,r)=>{if(e.length===0)return 0;let n=e.map((s,o)=>({path:s,index:o,distance:s.distanceToPoint(r)}));if(n=dr(n,"distance"),n.length===0)throw new Error("Could not look up distances");return n[0].distance},Js=(e,r,n,s)=>{s===void 0&&(s=Ft(e));let o=e.map((l,f)=>({path:l,index:f,distance:l.distanceToPoint(r)}));if(o=dr(o,"distance"),o.length<0)throw new Error("Point does not intersect with path");const i=o[0];if(i.distance>n)throw new Error(`Point does not intersect with path. Minimum distance: ${i.distance}, threshold: ${n}`);const a=i.path.relativePosition(r,n);let u=0;for(let l=0;l<i.index;l++)u+=s.lengths[l];u+=s.lengths[i.index]*a;const c=u/s.totalLength;return console.log(`acc: ${u} rel: ${c} on path: ${a} path: ${i.index}`),c},Ft=e=>{const r=e.map(i=>i.bbox().width),n=e.map(i=>i.length());let s=0,o=0;for(const i of n)s+=i;for(const i of r)o+=i;return{totalLength:s,totalWidth:o,widths:r,lengths:n}},Ws=e=>{const n=e.map(s=>s.bbox()).flatMap(s=>He(s));return _t(...n)},Ks=e=>e.map(r=>r.toString()).join(", "),Xs=e=>{let r=fn(e[0]);for(let n=1;n<e.length;n++){const s=wf(e[n]);if(!ce(s,r))throw new Error(`Path index ${n} does not start at prior path end. Start: ${s.x},${s.y} expected: ${r.x},${r.y}`);r=fn(e[n])}},Qs=e=>e.flatMap(r=>r.toSvgString()),Hs=(...e)=>{Xs(e);const r=Ft(e);return Object.freeze({segments:e,length:()=>r.totalLength,nearest:n=>{throw new Error("not implemented")},interpolate:(n,s=!1)=>Gs(e,n,s,r),relativePosition:(n,s)=>Js(e,n,s,r),distanceToPoint:n=>Us(e,n),bbox:()=>Ws(e),toString:()=>Ks(e),toSvgString:()=>Qs(e),kind:"compound"})};var bf={};x(bf,{bbox:()=>Ws,computeDimensions:()=>Ft,distanceToPoint:()=>Us,fromPaths:()=>Hs,getEnd:()=>fn,getStart:()=>wf,guardContinuous:()=>Xs,interpolate:()=>Gs,relativePosition:()=>Js,setSegment:()=>vf,toString:()=>Ks,toSvgString:()=>Qs});const Px=Object.freeze({a:{x:0,y:0},b:{x:0,y:0},c:{x:0,y:0}}),kx=Object.freeze({a:{x:NaN,y:NaN},b:{x:NaN,y:NaN},c:{x:NaN,y:NaN}}),Xt=(e,r=10,n=Math.PI/2)=>{e||(e=Object.freeze({x:0,y:0}));const s=ln(e,r,Math.PI- -n/2),o=ln(e,r,Math.PI-n/2);return{a:s,b:e,c:o}},Ax=(e,r,n={})=>{const s=n.tailLength??10,o=n.tailThickness??Math.max(s/5,5),i=n.angleRadian??0,a=n.arrowSize??Math.max(s/5,15),u=Math.PI/2;let c,l;if(r==="tip")c=Xt(e,a,u),l=He(Ae({x:c.a.x-s,y:e.y-o/2},s,o));else if(r==="middle"){const d=s+a/2,h=o/2;c=Xt({x:e.x+a*1.2,y:e.y},a,u),l=He(Ae({x:e.x-d,y:e.y-h},s+a,o))}else l=He(Ae({x:e.x,y:e.y-o/2},s,o)),c=Xt({x:e.x+s+a*.7,y:e.y},a,u);return le([l[0],l[1],c.a,c.b,c.c,l[2],l[3]],i,e)},re=(e,r="t")=>{if(e===void 0)throw new Error("{$name} undefined");b(e.a,r+".a"),b(e.b,r+".b"),b(e.c,r+".c")},Ef=e=>{if(e===void 0)return!1;const r=e;return!(!E(r.a)||!E(r.b)||!E(r.c))},Tx=e=>Xe(e.a)&&Xe(e.b)&&Xe(e.c),Vx=e=>Qe(e.a)&&Qe(e.b)&&Qe(e.c),Rx=(e,r)=>ce(e.a,r.a)&&ce(e.b,r.b)&&ce(e.c,r.c),qt=e=>{re(e);const r=pl([e.a,e.b,e.c],(s,o)=>({x:s.x+o.x,y:s.y+o.y}));return{x:r.x/3,y:r.y/3}},$f=(e,r={})=>{if(q(e))return _l(e,r);if(de(e))return wc(e,r);throw new Error("Unknown shape. Only CirclePositioned and RectPositioned are supported.")},jx=e=>{if(e===void 0)return Object.freeze({x:.5,y:.5});if(ee(e))return Nr(e);if(Ef(e))return qt(e);if(rt(e))return Al(e);throw new Error(`Unknown shape: ${JSON.stringify(e)}`)},Mf=(e,r)=>{if(q(e))return Fs(e,r);if(de(e))return dc(e,r);throw new Error(`a or b are unknown shapes. a: ${JSON.stringify(e)} b: ${JSON.stringify(r)}`)},_x=(e,r=5,n,s=je,o)=>{g(I(r,"positive","points"));const i=Math.PI*2/r,a=i/2,u=o?.initialAngleRadian??-Math.PI/2;n===void 0&&(n=e/2);let c=u;const l=[];for(let f=0;f<r;f++){const d=J(e,c,s),h=J(n,c-a,s),y=J(n,c+a,s);l.push(h,d),f+1<r&&l.push(y),c+=i}return l};var Sf={};x(Sf,{arrow:()=>Ax,center:()=>jx,isIntersecting:()=>Mf,randomPoint:()=>$f,starburst:()=>_x});var Nf={};x(Nf,{fromPoints:()=>Cx,init:()=>zf});const Cx=(e,r={})=>{const n=Rt(...e);return zf(n.map(s=>we(s)),r)},zf=(e,r={})=>{const n=r.maxDistanceFromLine??.1;return o=>{const a=e.map((c,l)=>{const f=c.nearest(o),d=V(o,f);return{positionRelative:c.relativePosition(f,n),path:c,index:l,nearest:f,distance:d,rank:Number.MAX_SAFE_INTEGER}}).filter(c=>c.distance<=n),u=dr(a,"distance");for(let c=0;c<u.length;c++)u[c].rank=c;return u}};var Pf={};x(Pf,{random:()=>Ix});const Ix=(e,r,n={})=>{if(!Array.isArray(e))throw new Error("Parameter 'circles' is not an array");const s=n.attempts??2e3,o=dr(e,"radius"),i=[],a=(u,c)=>i.some(l=>Fs(l,u,c));for(;o.length>0;){const u=o.pop();if(!u)break;const c={...n,margin:{x:u.radius,y:u.radius}};for(let l=0;l<s;l++){const f=$f(r,c);if(!a(f,u.radius)){i.push(Object.freeze({...u,...f}));break}}}return i};var kf={};x(kf,{CirclePacking:()=>Pf});var Af={};x(Af,{fromDegrees:()=>Ox});const Ox=(e,r,n=0,s=0,o=360)=>({radiusX:e,radiusY:r,rotation:te(n),startAngle:te(s),endAngle:te(o)});var Tf={};x(Tf,{rdpPerpendicularDistance:()=>hn,rdpShortestDistance:()=>dn});const dn=(e,r=.1)=>{const n=e[0],s=e.at(-1);if(e.length<3)return e;let o=-1,i=0;for(let a=1;a<e.length-1;a++){const u=qx(e[a],n,s);u>i&&(i=u,o=a)}if(i>r){const a=e.slice(0,o+1),u=e.slice(o),c=dn(a,r),l=dn(u,r);return[...c.slice(0,-1),...l]}else return[n,s]},hn=(e,r=.1)=>{const n=e[0],s=e.at(-1);if(e.length<3)return e;let o=-1,i=0;for(let a=1;a<e.length-1;a++){const u=Fx(e[a],n,s);u>i&&(i=u,o=a)}if(i>r){const a=e.slice(0,o+1),u=e.slice(o),c=hn(a,r),l=hn(u,r);return[...c.slice(0,-1),...l]}else return[n,s]};function Fx(e,r,n){let s,o,i;return r.x==n.x?s=Math.abs(e.x-r.x):(o=(n.y-r.y)/(n.x-r.x),i=r.y-o*r.x,s=Math.abs(o*e.x-e.y+i)/Math.sqrt(Math.pow(o,2)+1)),s}const qx=(e,r,n)=>{const s=V(r,n);if(s==0)return V(e,r);const o=((e.x-r.x)*(n.x-r.x)+(e.y-r.y)*(n.y-r.y))/s;return o<0?V(e,r):o>1?V(e,n):V(e,{x:r.x+o*(n.x-r.x),y:r.y+o*(n.y-r.y)})};var Vf={};x(Vf,{Direction:()=>yn,QuadTreeNode:()=>Rf,quadTree:()=>Lx});var yn;(function(e){e[e.Nw=0]="Nw",e[e.Ne=1]="Ne",e[e.Sw=2]="Sw",e[e.Se=3]="Se"})(yn||(yn={}));const Lx=(e,r=[],n={})=>{const s={maxItems:n.maxItems??4,maxLevels:n.maxLevels??4},o=new Rf(void 0,e,0,s);for(const i of r)o.add(i);return o};var Rf=class jf{boundary;level;opts;#e=[];#t=[];#r;constructor(r,n,s,o){this.boundary=n,this.level=s,this.opts=o,this.#r=r}getLengthChildren(){return this.#t.length}*parents(){let r=this;for(;r.#r!==void 0;)yield r.#r,r=r.#r}getParent(){return this.#r}*children(){for(const r of this.#t)yield r}getValue(){return this.#e}getIdentity(){return this}direction(r){return this.#t[r]}add(r){if(!Mf(this.boundary,r))return!1;if(this.#t.length>0){for(const n of this.#t)n.add(r);return!0}if(this.#e.push(r),this.#e.length>this.opts.maxItems&&this.level<this.opts.maxLevels){this.#t.length===0&&this.#n();for(const n of this.#e)for(const s of this.#t)s.add(n);this.#e=[]}return!0}couldHold(r){return Tt(this.boundary,r)}#n(){const r=this.boundary.width/2,n=this.boundary.height/2,s=this.boundary.x,o=this.boundary.y,a=ks(s+r,o,s,o,s,o+n,s+r,o+n).map(u=>Ae(u,r,n));this.#t=a.map(u=>new jf(this,u,this.level+1,this.opts))}};const Dx=(e="both",r)=>{const n=r??gc;let s=1,o=1,i={x:1,y:1};const a=()=>{switch(e){case"height":return{x:o,y:o};case"width":return{x:s,y:s};case"min":return{x:Math.min(s,o),y:Math.min(s,o)};case"max":return{x:Math.max(s,o),y:Math.max(s,o)};default:return{x:s,y:o}}},u=(d,h,y,p)=>{let w=NaN,N=NaN,$=n.width,T=n.height;if(typeof d=="number")if(w=d,typeof h=="number"){if(N=h,y===void 0)return[w,N,$,T];if(ee(y))$=y.width,T=y.height;else if(typeof y=="number")if($=y,typeof p=="number")T=p;else throw new TypeError("Missing final height value");else throw new Error("Missing valid output range")}else if(ee(h))$=h.width,T=h.height;else throw new Error("Expected input y or output Rect to follow first number parameter");else if(E(d)){if(w=d.x,N=d.y,h===void 0)return[w,N,$,T];if(ee(h))$=h.width,T=h.height;else if(typeof h=="number")if($=h,typeof y=="number")T=y;else throw new TypeError("Expected height as third parameter after Point and output width");else throw new TypeError("Expected Rect or width as second parameter when first parameter is a Point")}else throw new Error("Expected input Point or x value as first parameter");return[w,N,$,T]},c=(d,h,y,p)=>{const w=u(d,h,y,p);return f(!0,...w)},l=(d,h,y,p)=>{const w=u(d,h,y,p);return f(!1,...w)},f=(d,h,y,p,w)=>{if(Number.isNaN(p))throw new Error("Output width range missing");if(Number.isNaN(w))throw new Error("Output height range missing");return(p!==s||w!==o)&&(s=p,o=w,i=a()),d?{x:h*i.x,y:y*i.y}:{x:h/i.x,y:y/i.y}};return{computeScale:a,rel:l,abs:c,width:n.width,height:n.height}};var _f={};x(_f,{circleRings:()=>Xx,circleVogelSpiral:()=>Kx,sphereFibonacci:()=>Qx});const Ys=Math.cos,Zs=Math.sin,Bx=Math.asin,eo=Math.sqrt,Gx=Math.pow,to=Math.PI,Ux=Math.PI*2,Jx=to*(3-eo(5)),Wx=(1+eo(5))/2;function*Kx(e,r={}){const n=r.maxPoints??5e3,s=r.density??.95,o=r.rotation??0,i=qs(e??{radius:1,x:0,y:0}),a=i.radius;let u=i.radius*sd(s,0,1,.3,.01);r.spacing&&(u=r.spacing);let c=0,l=0,f=0;for(;l<n&&c<a;)c=u*l**.5,f=o+l*2*to/Wx,yield Object.freeze({x:i.x+c*Ys(f),y:i.y+c*Zs(f)}),l++}function*Xx(e,r={}){const n=r.rings??5,s=qs(e??{radius:1,x:0,y:0}),o=1/n,i=r.rotation??0;let a=1;yield Object.freeze({x:s.x,y:s.y});for(let u=o;u<=1;u+=o){const c=Math.round(to/Bx(1/(2*a)));for(const l of od(0,Ux,c+1))yield Object.freeze({x:s.x+u*Ys(l+i)*s.radius,y:s.y+u*Zs(l+i)*s.radius});a++}}function*Qx(e=100,r=0,n){const s=2/e,o=n??{x:0,y:0,z:0,radius:1};for(let i=0;i<e;i++){const a=i*s-1+s/2,u=eo(1-Gx(a,2)),c=(i+1)%e*Jx+r,l=Ys(c)*u,f=Zs(c)*u;yield Object.freeze({x:o.x+l*o.radius,y:o.y+a*o.radius,z:o.z+f*o.radius})}}const Lt=e=>(re(e),[Te(e.a,e.b),Te(e.b,e.c),Te(e.c,e.a)]),Hx=e=>(re(e),nt(Lt(e))),jr=e=>(re(e),Rt(e.a,e.b,e.c,e.a)),Cf=e=>{re(e,"t");const r=jr(e).map(s=>G(s)),n=(r[0]+r[1]+r[2])/2;return Math.sqrt(n*(n-r[0])*(n-r[1])*(n-r[2]))},If=(e,r,n)=>{const s=oe(r,n),o=(c,l,f,d)=>(f.y-d.y)*c+(d.x-f.x)*l+f.x*d.y-d.x*f.y,i=o(s.x,s.y,e.b,e.c)/o(e.a.x,e.a.y,e.b,e.c),a=o(s.x,s.y,e.c,e.a)/o(e.b.x,e.b.y,e.c,e.a),u=o(s.x,s.y,e.a,e.b)/o(e.c.x,e.c.y,e.a,e.b);return{a:i,b:a,c:u}},Yx=(e,r)=>{re(e);const{a:n,b:s,c:o}=e,i=n.x*r.a+s.x*r.b+o.x*r.c,a=n.y*r.a+s.y*r.b+o.y*r.c;if(n.z&&s.z&&o.z){const u=n.z*r.a+s.z*r.b+o.z*r.c;return Object.freeze({x:i,y:a,z:u})}else return Object.freeze({x:i,y:a})},Of=(e,r=0)=>{const{a:n,b:s,c:o}=e,i=Math.min(n.x,s.x,o.x)-r,a=Math.max(n.x,s.x,o.x)+r,u=Math.min(n.y,s.y,o.y)-r,c=Math.max(n.y,s.y,o.y)+r;return{x:i,y:u,width:a-i,height:c-u}},Zx=e=>(re(e),[e.a,e.b,e.c]),ev=(e,r,n={})=>{g(z(r,"positive","radius")),b(e,"origin");const s=n.initialAngleRadian??0,i=[s,s+W*1/3,s+W*2/3].map(a=>J(r,a,e));return ro(i)},tv=e=>{if(!Array.isArray(e))throw new Error("coords expected as array");if(e.length!==6)throw new Error(`coords array expected with 6 elements. Got ${e.length}`);return ro(ks(...e))},ro=e=>{if(!Array.isArray(e))throw new Error("points expected as array");if(e.length!==3)throw new Error(`points array expected with 3 elements. Got ${e.length}`);return{a:e[0],b:e[1],c:e[2]}},Ff=e=>(re(e),jr(e).reduce((r,n)=>r+G(n),0)),rv=e=>{const r=qt(e),n=Ff(e)/2;return{radius:Cf(e)/n,...r}},nv=(e,r,n)=>{const s=Of(e),o=oe(r,n);if(!Tt(s,o))return!1;const i=If(e,o);return 0<=i.a&&i.a<=1&&0<=i.b&&i.b<=1&&0<=i.c&&i.c<=1},no=e=>(re(e),[V(e.a,e.b),V(e.b,e.c),V(e.c,e.a)]),sv=e=>{re(e);const[r,n,s]=no(e);return r===n&&n===s},ov=e=>{const[r,n,s]=no(e);return r===n||n===s||s===r},qf=e=>Lt(e).includes(Math.PI/2),iv=e=>!qf(e),av=e=>!Lt(e).some(r=>r>=Math.PI/2),uv=e=>Lt(e).some(r=>r>Math.PI/2),cv=(e,r)=>Object.freeze({...e,a:r(e.a,"a"),b:r(e.b,"b"),c:r(e.c,"c")}),lv=e=>{const[r,n,s]=jr(e).map(a=>G(a)),o=qt(e);return{radius:r*n*s/Math.sqrt((r+n+s)*(-r+n+s)*(r-n+s)*(r+n-s)),...o}},fv=(e,r,n)=>r===void 0||r===0?e:(n===void 0&&(n=qt(e)),Object.freeze({...e,a:le(e.a,r,n),b:le(e.b,r,n),c:le(e.c,r,n)})),dv=(e,r,n="b")=>{const s=n==="a"?e.a:n==="b"?e.b:e.c;return Object.freeze({a:le(e.a,r,s),b:le(e.b,r,s),c:le(e.c,r,s)})},hv=e=>(re(e),[e.a.x,e.a.y,e.b.x,e.b.y,e.c.x,e.c.y]);var Lf={};x(Lf,{area:()=>vv,centerFromA:()=>mv,centerFromB:()=>pv,centerFromC:()=>gv,circumcircle:()=>bv,fromCenter:()=>yv,height:()=>wv,incircle:()=>_r,perimeter:()=>xv});const wo=Math.PI*4/3,xo=Math.PI*2/3,_e=e=>typeof e=="number"?e:e.length,yv=(e,r,n)=>{r||(r=Object.freeze({x:0,y:0}));const s=_e(e)/Math.sqrt(3),o=n??Math.PI*1.5,i={x:s*Math.cos(o)+r.x,y:s*Math.sin(o)+r.y},a={x:s*Math.cos(o+wo)+r.x,y:s*Math.sin(o+wo)+r.y},u={x:s*Math.cos(o+xo)+r.x,y:s*Math.sin(o+xo)+r.y};return Object.freeze({a,b:i,c:u})},mv=(e,r)=>{r||(r=Object.freeze({x:0,y:0}));const n=_e(e),{radius:s}=_r(e);return{x:r.x+n/2,y:r.y-s}},pv=(e,r)=>{r||(r=Object.freeze({x:0,y:0}));const{radius:n}=_r(e);return{x:r.x,y:r.y+n*2}},gv=(e,r)=>{r||(r=Object.freeze({x:0,y:0}));const n=_e(e),{radius:s}=_r(e);return{x:r.x-n/2,y:r.y-s}},wv=e=>Math.sqrt(3)/2*_e(e),xv=e=>_e(e)*3,vv=e=>Math.pow(_e(e),2)*Math.sqrt(3)/4,bv=e=>({radius:Math.sqrt(3)/3*_e(e)}),_r=e=>({radius:Math.sqrt(3)/6*_e(e)});var Df={};x(Df,{adjacentFromHypotenuse:()=>jv,adjacentFromOpposite:()=>_v,angleAtPointA:()=>zv,angleAtPointB:()=>Pv,area:()=>Nv,circumcircle:()=>Av,fromA:()=>Ev,fromB:()=>$v,fromC:()=>Mv,height:()=>Cr,hypotenuseFromAdjacent:()=>Iv,hypotenuseFromOpposite:()=>Cv,hypotenuseSegments:()=>Ir,incircle:()=>Tv,medians:()=>kv,oppositeFromAdjacent:()=>Vv,oppositeFromHypotenuse:()=>Rv,perimeter:()=>Sv,resolveLengths:()=>ne});const Ev=(e,r)=>{r||(r=Object.freeze({x:0,y:0}));const n=ne(e),s=Ir(e),o=Cr(e),i={x:r.x,y:r.y},a={x:r.x+n.hypotenuse,y:r.y},u={x:r.x+s[1],y:r.y-o};return{a:i,b:a,c:u}},$v=(e,r)=>{r||(r=Object.freeze({x:0,y:0}));const n=ne(e),s=Ir(e),o=Cr(e),i={x:r.x,y:r.y},a={x:r.x-n.hypotenuse,y:r.y},u={x:r.x-s[0],y:r.y-o};return{a,b:i,c:u}},Mv=(e,r)=>{r||(r=Object.freeze({x:0,y:0}));const n=Ir(e),s=Cr(e),o={x:r.x,y:r.y},i={x:r.x-n[1],y:r.y+s},a={x:r.x+n[0],y:r.y+s};return{a:i,b:a,c:o}},ne=e=>{const r=e.adjacent,n=e.opposite,s=e.hypotenuse;if(r!==void 0&&n!==void 0)return{...e,adjacent:r,opposite:n,hypotenuse:Math.hypot(r,n)};if(r&&s)return{...e,adjacent:r,hypotenuse:s,opposite:s*s-r*r};if(n&&s)return{...e,hypotenuse:s,opposite:n,adjacent:s*s-n*n};if(e.opposite&&e.hypotenuse&&e.adjacent)return e;throw new Error("Missing at least two edges")},Cr=e=>{const r=ne(e),n=r.opposite*r.opposite/r.hypotenuse,s=r.adjacent*r.adjacent/r.hypotenuse;return Math.sqrt(n*s)},Ir=e=>{const r=ne(e),n=r.opposite*r.opposite/r.hypotenuse,s=r.adjacent*r.adjacent/r.hypotenuse;return[n,s]},Sv=e=>{const r=ne(e);return r.adjacent+r.hypotenuse+r.opposite},Nv=e=>{const r=ne(e);return r.opposite*r.adjacent/2},zv=e=>{const r=ne(e);return Math.acos((r.adjacent*r.adjacent+r.hypotenuse*r.hypotenuse-r.opposite*r.opposite)/(2*r.adjacent*r.hypotenuse))},Pv=e=>{const r=ne(e);return Math.acos((r.opposite*r.opposite+r.hypotenuse*r.hypotenuse-r.adjacent*r.adjacent)/(2*r.opposite*r.hypotenuse))},kv=e=>{const r=ne(e),n=r.adjacent*r.adjacent,s=r.hypotenuse*r.hypotenuse,o=r.opposite*r.opposite;return[Math.sqrt(2*(n+s)-o)/2,Math.sqrt(2*(s+o)-n)/2,Math.sqrt(2*(o+n)-s)/2]},Av=e=>({radius:ne(e).hypotenuse/2}),Tv=e=>{const r=ne(e);return{radius:(r.adjacent+r.opposite-r.hypotenuse)/2}},Vv=(e,r)=>Math.tan(e)*r,Rv=(e,r)=>Math.sin(e)*r,jv=(e,r)=>Math.cos(e)*r,_v=(e,r)=>r/Math.tan(e),Cv=(e,r)=>r/Math.sin(e),Iv=(e,r)=>r/Math.cos(e);var Bf={};x(Bf,{apexAngle:()=>Ov,area:()=>Lv,baseAngle:()=>Gf,circumcircle:()=>Dv,fromA:()=>Uv,fromB:()=>Jv,fromC:()=>Wv,fromCenter:()=>Gv,height:()=>Ce,incircle:()=>Uf,legHeights:()=>Fv,medians:()=>Bv,perimeter:()=>qv});const Gf=e=>Math.acos(e.base/(2*e.legs)),Ov=e=>{const r=e.legs*e.legs,n=e.base*e.base;return Math.acos((2*r-n)/(2*r))},Ce=e=>{const r=e.legs*e.legs,n=e.base*e.base;return Math.sqrt((4*r-n)/4)},Fv=e=>{const r=Gf(e);return e.base*Math.sin(r)},qv=e=>2*e.legs+e.base,Lv=e=>Ce(e)*e.base/2,Dv=e=>{const r=Ce(e),n=r*r,s=e.base*e.base;return{radius:(4*n+s)/(8*r)}},Uf=e=>{const r=Ce(e);return{radius:e.base*r/(2*e.legs+e.base)}},Bv=e=>{const r=e.legs*e.legs,n=e.base*e.base,s=Math.sqrt(r+2*n)/2,o=Math.sqrt(4*r-n)/2;return[s,s,o]},Gv=(e,r)=>{r||(r=Object.freeze({x:0,y:0}));const n=Ce(e),s=Uf(e).radius,o=n-s,i={x:r.x-e.base/2,y:r.y+s},a={x:r.x+e.base/2,y:r.y+s},u={x:r.x,y:r.y-o};return{a:i,b:a,c:u}},Uv=(e,r)=>{r||(r=Object.freeze({x:0,y:0}));const n=Ce(e),s={x:r.x,y:r.y},o={x:r.x+e.base,y:r.y},i={x:r.x+e.base/2,y:r.y-n};return{a:s,b:o,c:i}},Jv=(e,r)=>{r||(r=Object.freeze({x:0,y:0}));const n=Ce(e),s={x:r.x,y:r.y},o={x:r.x-e.base,y:r.y},i={x:r.x-e.base/2,y:r.y-n};return{a:o,b:s,c:i}},Wv=(e,r)=>{r||(r=Object.freeze({x:0,y:0}));const n=Ce(e),s={x:r.x,y:r.y},o={x:r.x-e.base/2,y:r.y+n},i={x:r.x+e.base/2,y:r.y+n};return{a:o,b:i,c:s}};var Jf={};x(Jf,{Empty:()=>Px,Equilateral:()=>Lf,Isosceles:()=>Bf,Placeholder:()=>kx,Right:()=>Df,angles:()=>Lt,anglesDegrees:()=>Hx,apply:()=>cv,area:()=>Cf,barycentricCoord:()=>If,barycentricToCartestian:()=>Yx,bbox:()=>Of,centroid:()=>qt,corners:()=>Zx,edges:()=>jr,equilateralFromVertex:()=>Xt,fromFlatArray:()=>tv,fromPoints:()=>ro,fromRadius:()=>ev,guard:()=>re,innerCircle:()=>rv,intersectsPoint:()=>nv,isAcute:()=>av,isEmpty:()=>Tx,isEqual:()=>Rx,isEquilateral:()=>sv,isIsosceles:()=>ov,isOblique:()=>iv,isObtuse:()=>uv,isPlaceholder:()=>Vx,isRightAngle:()=>qf,isTriangle:()=>Ef,lengths:()=>no,outerCircle:()=>lv,perimeter:()=>Ff,rotate:()=>fv,rotateByVertex:()=>dv,toFlatArray:()=>hv});var Kv={};x(Kv,{Arcs:()=>wl,Beziers:()=>Nl,Circles:()=>Il,Compound:()=>xf,CurveSimplification:()=>Tf,Ellipses:()=>Af,Grids:()=>gf,Layouts:()=>kf,Lines:()=>ul,Paths:()=>bf,PointTracker:()=>_s,Points:()=>gl,PointsTracker:()=>ml,Polar:()=>Dc,QuadTree:()=>Vf,Rects:()=>xc,Shapes:()=>Sf,SurfacePoints:()=>_f,Triangles:()=>Jf,Vectors:()=>Bc,Waypoints:()=>Nf,angleConvert:()=>Dg,angleParse:()=>Vc,degreeArc:()=>qg,degreeToGradian:()=>Ac,degreeToRadian:()=>te,degreeToTurn:()=>jc,degreesSum:()=>Fg,gradianToDegree:()=>Tc,gradianToRadian:()=>an,radianArc:()=>Ts,radianInvert:()=>kc,radianToDegree:()=>nt,radianToGradian:()=>Wt,radianToTurn:()=>cn,radiansFromAxisX:()=>Og,radiansSum:()=>Pr,scaler:()=>Dx,turnToDegree:()=>Rc,turnToRadian:()=>un});export{je as $,xd as A,pn as B,md as C,xm as D,np as E,qm as F,Um as G,Pm as H,t0 as I,r0 as J,Zm as K,yp as L,wm as M,n0 as N,ku as O,Em as P,Ee as Q,Jm as R,me as S,ht as T,Cm as U,a0 as V,Sm as W,Re as X,J as Y,qp as Z,Lp as _,mr as a,Dp as a$,Rg as a0,Sc as a1,zc as a2,Q as a3,V as a4,Pc as a5,Te as a6,Ig as a7,bt as a8,Nc as a9,xn as aA,Vo as aB,Mt as aC,Fo as aD,_o as aE,Oo as aF,zo as aG,vn as aH,qo as aI,$n as aJ,So as aK,jo as aL,Ro as aM,En as aN,Ao as aO,ko as aP,bn as aQ,Po as aR,wn as aS,To as aT,gn as aU,Yt as aV,Sn as aW,yt as aX,Jt as aY,na as aZ,ud as a_,xg as aa,hg as ab,Vg as ac,Kw as ad,Ng as ae,Jw as af,zt as ag,$r as ah,Im as ai,jm as aj,_m as ak,Ru as al,Ww as am,Uw as an,cr as ao,ps as ap,Hm as aq,Er as ar,hr as as,tm as at,k as au,er as av,Mn as aw,Co as ax,Io as ay,Ht as az,A as b,Bp as b0,pe as b1,ac as b2,Qe as b3,Pp as b4,tg as b5,ia as b6,la as b7,An as b8,yd as b9,Zx as bA,nw as bB,us as bC,de as bD,ag as bE,Nr as bF,ml as bG,oe as bH,Tp as bI,$t as ba,tc as bb,rc as bc,vt as bd,Bu as be,Wa as bf,Dx as bg,Ap as bh,Yp as bi,Xp as bj,b as bk,Ar as bl,Is as bm,He as bn,Rr as bo,Me as bp,rs as bq,Vc as br,Dg as bs,yx as bt,ew as bu,Zc as bv,Tr as bw,ot as bx,gm as by,is as bz,R as c,Mr as d,yr as e,B as f,tr as g,Yv as h,Hv as i,Qv as j,$d as k,Md as l,No as m,ki as n,Zv as o,e0 as p,fe as q,vd as r,Zt as s,xt as t,wd as u,bd as v,s0 as w,gd as x,pd as y,Oe as z};
