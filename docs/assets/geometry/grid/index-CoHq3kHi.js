import"../../modulepreload-polyfill-B5Qt9EMX.js";import{c as I}from"../../state-machine-ROMMoZIR.js";import{i as W}from"../../interval-type-CIaujdcR.js";import{a as O,g as E}from"../../dom-source-CE_2PbT_.js";import{z as L}from"../../maps-CLnHBw0l.js";import{i as N,g as T,a as v,o as P,b as q}from"../../indexing-Xa_Aovu7.js";import{r as w}from"../../result-aflA1LW7.js";import{i as k,n as D}from"../../numbers-SvRH5ijj.js";import{a as U}from"../../arrays-Dsf3vC8Q.js";import{S as X}from"../../simple-event-emitter-BaCTAiR9.js";import{i as K,c as C,d as Y}from"../../guard-RzpFIjKH.js";import{f as Z}from"../../from-top-left-CR5-Vjbi.js";import{r as G}from"../../resolve-el-BUhvOf7L.js";import{E as Q}from"../../element-sizing-Bsx-rrC3.js";import"../../sleep-DwDBk_RX.js";import"../../error-message-BtgnhF27.js";import"../../async-Dr__bS9h.js";import"../../conversion-CGf7QoDW.js";import"../../clamp-ClLuI7HB.js";import"../../guard-BPeP3-pA.js";const J=(s,e=Math.random)=>(w(U(s,"array")),s[Math.floor(e()*s.length)]),ee=(s={})=>{const e=s.source??Math.random,n=Math.trunc(e()*46656),t=Math.trunc(e()*46656),i=`000${n.toString(36)}`.slice(-3),o=`000${t.toString(36)}`.slice(-3);return i+o},$=s=>{if(typeof s!="string")throw new TypeError(`Param 'str' ought to be a string. Got: ${typeof s}`);const e=s.indexOf(","),n=Number.parseFloat(s.substring(0,e)),t=s.indexOf(",",e+1);if(t>0){const i=Number.parseFloat(s.substring(e+1,t-e+2)),o=Number.parseFloat(s.substring(t+1));return{x:n,y:i,z:o}}else{const i=Number.parseFloat(s.substring(e+1));return{x:n,y:i}}},te=(s,e)=>K(s)?Object.freeze({...s,x:s.x*e,y:s.y*e,z:s.z*e}):Object.freeze({...s,x:s.x*e,y:s.y*e}),se=s=>new ne(s);class ne extends X{store=new Map;keyString;constructor(e){super(),this.keyString=e??O}get size(){return this.store.size}add(...e){let n=!1;for(const t of e){const i=this.has(t);this.store.set(this.keyString(t),t),super.fireEvent("add",{value:t,updated:i}),i||(n=!0)}return n}values(){return this.store.values()}clear(){this.store.clear(),super.fireEvent("clear",!0)}delete(e){const n=this.store.delete(this.keyString(e));return n&&super.fireEvent("delete",e),n}has(e){return this.store.has(this.keyString(e))}toArray(){return[...this.store.values()]}}const ie=s=>{const e=W(s.delay,10);let n;const t=s.onValue;let i="stopped";const o=I(async()=>{if(n){const h=await n.next();if(h.done)return i="stopped",!1;const d=t(h.value);return typeof d=="boolean"?(d||(i="stopped"),d):!0}else return i="stopped",!1},e),u=()=>{i!=="stopped"&&(n=void 0,o.cancel(),i="stopped")},l=()=>{i!=="paused"&&(o.cancel(),i="paused")},a=()=>{i!=="running"&&(n||c(),i="running",o.start())},c=()=>{if(s.iterator)n=s.iterator();else throw new Error("No source iterator")};return{start:a,cancel:u,restart:()=>{c(),a()},pause:l,get state(){return i}}};function oe(s,e){const n=getComputedStyle(document.body),i=Object.entries(s).map(o=>[o[0],re(n,o[0],o[1])]);return Object.fromEntries(i)}function re(s,e,n){e.startsWith("--")||(e="--"+e),e=e.replaceAll("_","-");const t=s.getPropertyValue(e);if(t.length===0)return n;if(typeof n=="number")return parseFloat(t);if(typeof n=="boolean"){if(t==="true")return!0;if(t==="false")return!1}return t}const ce=(s,e)=>{const n=z(s,e);return(i,o="undefined")=>ae(n,s,i,o)},ae=(s,e,n,t)=>{const i=N(s,n,t);if(i!==void 0)return e[i]},le=(s,e)=>{const n=z(s,e);return(t,i,o="undefined")=>de(n,s,t,i,o)},de=(s,e,n,t,i)=>{const o=N(s,t,i);if(o===void 0)throw new RangeError(`Cell (${t.x},${t.y}) is out of range of grid cols: ${s.cols} rows: ${s.rows}`);return e[o]=n,e},z=(s,e)=>({cols:e,rows:Math.ceil(s.length/e)}),ue=(s,e)=>({...z(s,e),get:ce(s,e),set:le(s,e),get array(){return s}}),fe=(s,e,n)=>{const t=typeof e=="number"?e:e.rows,i=typeof e=="object"?e.cols:n;if(!i)throw new Error("Parameter 'columns' missing");w(k(t,"aboveZero","rows"),k(i,"aboveZero","cols"));const o=[],u=t*i;for(let l=0;l<u;l++)o[l]=s;return o},he=(s,e,n)=>{const t=typeof e=="number"?e:e.rows,i=typeof e=="object"?e.cols:n;if(!i)throw new Error("Parameter 'columns' missing");const o=fe(s,t,i);return ue(o,i)};function*M(s,e,n=!0){e||(e={x:0,y:0}),T(s,"grid"),v(e,"start",s);let{x:t,y:i}=e,o=!0;do yield{x:t,y:i},t++,t===s.cols&&(i++,t=0),i===s.rows&&(n?(i=0,t=0):o=!1),t===e.x&&i===e.y&&(o=!1);while(o)}function*ye(s,e,n=!0){for(const t of M(s,e,n))yield{cell:t,value:s.get(t)}}const V=Object.freeze(["n","ne","nw","e","s","se","sw","w"]),ge=Object.freeze(["n","e","s","w"]),xe=(s,e,n,t="stop")=>{T(s,"grid"),v(e,"start"),w(k(n,"aboveZero","steps"));const i=V,o=i.map(l=>_(l,n)),u=i.map((l,a)=>P(s,e,o[a],t));return L(i,u)},_=(s,e=1)=>{let n;switch(s){case"n":{n={x:0,y:-1*e};break}case"ne":{n={x:1*e,y:-1*e};break}case"e":{n={x:1*e,y:0};break}case"se":{n={x:1*e,y:1*e};break}case"s":{n={x:0,y:1*e};break}case"sw":{n={x:-1*e,y:1*e};break}case"w":{n={x:-1*e,y:0};break}case"nw":{n={x:-1*e,y:-1*e};break}default:n={x:0,y:0}}return Object.freeze(n)},me=(s,e)=>{v(s),v(e);let n=s.x,t=s.y;const i=Math.abs(e.x-n),o=Math.abs(e.y-t),u=n<e.x?1:-1,l=t<e.y?1:-1;let a=i-o;const c=[];for(;c.push(Object.freeze({x:n,y:t})),!(n===e.x&&t===e.y);){const r=2*a;r>-o&&(a-=o,n+=u),r<i&&(a+=i,t+=l)}return c},pe=(s,e)=>e===void 0||s===void 0?!1:s.x===e.x&&s.y===e.y,A=s=>J(s),be=s=>!(s===void 0||s[1]===void 0),B=(s,e,n,t)=>{const i=ve(s,e,t,n);return Object.entries(i).filter(u=>be(u))},ve=(s,e,n="undefined",t)=>{const i=t??V,o=i.map(u=>P(s,e,_(u),n));return L(i,o)},we=s=>`Cell{${s.x},${s.y}}`;function*Se(s){for(const e of M(s))yield b(s,e)}const R=(s,e)=>{const n=s.size;if(w(D(n,"positive","grid.size")),e.x<0||e.y<0)return;const t=Math.floor(e.x/n),i=Math.floor(e.y/n);if(!(t>=s.cols)&&!(i>=s.rows))return{x:t,y:i}},b=(s,e)=>{v(e);const n=s.size,t=e.x*n,i=e.y*n;return Z({x:t,y:i},n,n)},ke=()=>({select:s=>s[0]}),Ce=()=>({select:s=>s.at(0),getNeighbours:(s,e)=>B(s,e,V,"undefined")}),$e=(s={})=>{const e=s.reversed??!1;return{select:n=>n.find(t=>t[0]===(e?"n":"s")),getNeighbours:(n,t)=>(e?t.y>0?t={x:t.x,y:t.y-1}:t.x===0?t={x:n.cols-1,y:n.rows-1}:t={x:t.x-1,y:n.rows-1}:t.y<n.rows-1?t={x:t.x,y:t.y+1}:t.x<n.cols-1?t={x:t.x+1,y:0}:t={x:0,y:0},[[e?"n":"s",t]])}},Ee=()=>({select:s=>s.at(-1)}),Te=()=>({getNeighbours:(s,e)=>{const n=[];for(const t of M(s,e))n.push(["n",t]);return n},select:A}),Pe=()=>({select:A}),ze=(s={})=>{const e=s.reversed??!1;return{select:n=>n.find(t=>t[0]===(e?"w":"e")),getNeighbours:(n,t)=>(e?t.x>0?t={x:t.x-1,y:t.y}:t.y>0?t={x:n.cols-1,y:t.y-1}:t={x:n.cols-1,y:n.rows-1}:t.x<n.rows-1?t={x:t.x+1,y:t.y}:t.y<n.rows-1?t={x:0,y:t.y+1}:t={x:0,y:0},[[e?"w":"e",t]])}};function*Me(s,e,n={}){T(e,"grid");const t=n.start??{x:0,y:0};v(t,"opts.start",e);const i=n.visited??se(we),o=s.getNeighbours??((c,r)=>B(c,r,ge,"undefined"));let u=[t],l=[],a;for(;u.length>0;){if(a===void 0){const c=u.pop();if(c===void 0)break;a=c}if(!i.has(a)){i.add(a),yield a;const c=o(e,a).filter(r=>r[1]===void 0?!1:!i.has(r[1]));if(c.length===0)a!==void 0&&(u=u.filter(r=>pe(r,a)));else for(const r of c)r!==void 0&&r[1]!==void 0&&l.push(r)}if(l=l.filter(c=>!i.has(c[1])),l.length===0)a=void 0;else{const c=s.select(l);c!==void 0&&(u.push(c[1]),a=c[1])}}}const Ve=(s,e={})=>{switch(s){case"random-contiguous":return p(Pe(),e);case"random":return p(Te(),e);case"depth":return p(Ee(),e);case"breadth":return p(ke(),e);case"neighbours":return p(Ce(),e);case"row":return p(ze(e),e);case"column":return p($e(e),e);default:throw new TypeError(`Param 'type' unknown. Value: ${s}`)}},p=(s,e={})=>(n,t={})=>Me(s,n,{...e,...t}),Fe=s=>{const e=s.panels,n=s.preselectId??e[0].id,t=`tabset-${ee()}`,i=G(s.parent),o=`
  <div class="ixfx-tabset" id="${t}">
    <fieldset class="ixfx-tabset-controls">
    ${e.map(d=>{const f=`${t}-${d.id}-select`;return`<input type="radio" name="${t}-tabs" id="${f}" data-tabset="${d.id}"><label for="${f}">${d.label}</label>`}).join("")}
    </fieldset>
    <div class="ixfx-tabset-host" id="${t}-host"></div>
  </div>
  `;i.innerHTML=o;const u=document.getElementById(`${t}-host`),l=document.getElementById(t);l.querySelector("fieldset")?.addEventListener("change",d=>{const f=d.target;c(f.getAttribute("data-tabset"))});let a;const c=d=>{const f=e.find(m=>m.id===d),g=a;if(s.onPanelChanging){const m=s.onPanelChanging(g,f);if(typeof m=="boolean"&&!m)return}if(g&&g.dismount(),a=f,f){f.mount(u);const m=`#${t}-${d}-select`,F=l.querySelector(m);F?F.checked=!0:console.warn(`Could not find INPUT element for panel id: ${d} (${m})`)}s.onPanelChange&&s.onPanelChange(g,f)};c(n);let r=!1;return{select:c,panels:e,hostEl:u,tabSetEl:l,notify:(d,f)=>{a&&(a.notify?a.notify(d,f):r||(r=!0,console.warn(`TabbedPanel.notify dropping notification '${d}'. Panel implementation is missing 'notify' function`)))}}},Le=(s,e)=>{let n={x:0,y:0},t,i=()=>{};const o=async()=>{e&&e.clearVisited(),l&&l.restart()},u=()=>{const r=t.last(),h=r["visit-type"],d=r.reverse;return Ve(h,{start:n,boundsWrap:"undefined",reversed:d})(s)};let l=ie({delay:50,iterator:()=>u(),onValue:r=>(e&&e.addVisited(r),!0)});return{id:"visit",label:"Visit",dismount:()=>{l.cancel(),i()},mount:r=>{r.innerHTML=`
      <form>
        <label for="visit-type">Logic</label>
        <select name="visit-type" id="visit-type">
          <option>row</option>
          <option>random</option>
          <option>random-contiguous</option>
          <option>neighbours</option>
          <option>column</option>
          <option>breadth</option>
          <option>depth</option>
        </select>
        
        <label for="reverse">Reverse</label>
        <input name="reverse" type="checkbox" value="true" id="reverse">
      </form>
      `,t=E("form"),i=t.onValue(h=>{o()})},notify:(r,h)=>{switch(r){case"click":{h||(h={x:0,y:0}),n=h,o();break}default:console.warn(`visitPanel.notify: ${r}`)}}}},Ne=(s,e)=>{let n={x:0,y:0},t,i=()=>{};const o=c=>{c===void 0&&t&&(c=t.last());const r=$(c.xy??"0,0");if(!C(r))if(e&&(e.clearVisited(),e.clearCellText()),c.cardinals){if(Y(r))return;const h=xe(s,n,Math.max(r.x,r.y),c["wrap-type"]);for(const[d,f]of Object.entries(h))e&&f&&(e.addVisited(f),e.appendCellText(d+" ",f))}else{const h=P(s,n,r,c["wrap-type"]);e&&h&&e.addVisited(h)}};return{id:"offset",label:"Offset",dismount:()=>{i()},mount:c=>{c.innerHTML=`
      <form>
        <label for="xy">x,y</label>
        <input id="xy" type="text" name="xy" value="2,2">
        
        <label for="wrap-type">Wrapping</label>
        <select id="wrap-type" name="wrap-type">
          <option>undefined</option>
          <option>stop</option>
          <option>unbounded</option>
          <option>wrap</option>
        </select>
        
        <label for="cardinals">Cardinals</label>
        <div>
          <input name="cardinals" type="checkbox" value="true" id="cardinals" checked>
          <p>When enabled, the larger of x or y option above is used to calculate an offset on all directions.</p>
        </div>
      <form>
      `,t=E("form"),i=t.onValue(r=>{o(r)})},notify:(c,r)=>{switch(c){case"click":{r||(r={x:0,y:0}),n=r,e&&(e.activated=[r]),o();break}default:console.warn(`visitPanel.notify: ${c}`)}}}},_e=(s,e)=>{let n,t={x:0,y:0},i={x:0,y:0},o=!1,u=()=>{};const l=d=>{const f=$(d["a-xy"]??"0,0"),g=$(d["b-xy"]??"0,0");C(f)||C(g)||(t=f,i=g)},a=()=>{e&&e.clearVisited();const d=me(t,i);for(const f of d)e.addVisited(f)};return{id:"line",label:"Line",dismount:()=>{u()},mount:d=>{d.innerHTML=`
      <form>
        <label for="a-xy">A (x,y)</label>
        <input id="a-xy" type="text" name="a-xy" value="2,6">
        
        <label for="b-xy">B (x,y)</label>
        <input id="a-xy" type="text" name="b-xy" value="7,2">
        
      <form>
      `,n=E("form"),u=n.onValue(f=>{l(f),a()}),l(n.last()),a()},notify:(d,f)=>{switch(d){case"click":{f||(f={x:0,y:0}),o?(i=f,n.setNamedValue("b-xy",`${i.x},${i.y}`)):(t=f,n.setNamedValue("a-xy",`${t.x},${t.y}`)),o=!o,a();break}default:console.warn(`visitPanel.notify: ${d}`)}}}};class Ae{highlighted=[];visited=[];activated=[];cellText;grid;gridlineStrokeStyle="red";textFillStyle="white";activatedFillStyle="gray";highlightedStrokeStyle="orangered";visitedFillStyle="indigo";ctx;canvasEl;constructor(e){this.grid=e,this.cellText=this.clearCellText(),this.canvasEl=document.querySelector("#grid"),this.ctx=this.canvasEl.getContext("2d");const n=oe({chrome_1:"white",chrome_2:"silver",chrome_5:"black",chrome_active_1:"red",chrome_active_2:"red",chrome_active_3:"red",chrome_active_4:"red",chrome_active_5:"red"});this.gridlineStrokeStyle=n.chrome_2,this.activatedFillStyle=n.chrome_active_3,this.textFillStyle=n.chrome_active_5,this.highlightedStrokeStyle=n.chrome_active_3,this.visitedFillStyle=n.chrome_active_1}clearCellText(){return this.cellText=he("",this.grid),this.cellText}reset(){this.clearCellText(),this.clearVisited(),this.activated=[],this.setHighlighted(void 0)}appendCellText(e,n){if(!q(this.cellText,n))return;let t=this.cellText.get(n);t||(t=""),t+=e,this.cellText.set(t,n)}setHighlighted(e){e===void 0?this.highlighted=[]:Array.isArray(e)?this.highlighted=[...this.highlighted,...e]:this.highlighted=[e],this.draw()}addVisited(e){this.visited.push(e),this.draw()}clearVisited(){this.visited=[],this.draw()}fillCell(e,n="yellow"){const{ctx:t}=this,i=b(this.grid,e);t.fillStyle=n,t.fillRect(i.x,i.y,i.width,i.height),t.strokeStyle=this.gridlineStrokeStyle,t.strokeRect(i.x,i.y,i.width,i.height)}draw(){this.ctx.font="12pt system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif",this.drawBg(),this.drawGrid(),this.drawVisited(),this.drawActivated(),this.drawHighlighted(),this.drawText()}drawText(){const{ctx:e}=this;for(const{cell:n,value:t}of ye(this.cellText)){const i=b(this.grid,n);let{x:o,y:u}=i,l=t??"";if(l.length===0)continue;const a=e.measureText(l);o+=i.width/2-a.width/2,u+=i.height/2-(a.actualBoundingBoxAscent+a.actualBoundingBoxDescent)/2,e.textBaseline="middle",e.fillStyle=this.textFillStyle,e.fillText(l,o,u)}}drawVisited(){const{ctx:e}=this;for(const n of this.visited){const t=b(this.grid,n);e.fillStyle=this.visitedFillStyle,e.fillRect(t.x,t.y,t.width,t.height),e.strokeStyle=this.gridlineStrokeStyle,e.strokeRect(t.x,t.y,t.width,t.height)}}drawHighlighted(){const{ctx:e}=this;for(const n of this.highlighted){const t=b(this.grid,n);e.strokeStyle=this.highlightedStrokeStyle,e.strokeRect(t.x,t.y,t.width,t.height)}}drawActivated(){const{ctx:e}=this;for(const n of this.activated){const t=b(this.grid,n);e.fillStyle=this.activatedFillStyle,e.fillRect(t.x,t.y,t.width,t.height)}}drawGrid(){const{ctx:e}=this;e.strokeStyle=this.gridlineStrokeStyle,e.lineWidth=1;for(const n of Se(this.grid))e.strokeRect(n.x,n.y,n.width,n.height)}drawBg(){const{ctx:e}=this;e.clearRect(0,0,e.canvas.width,e.canvas.height)}}const S=document.querySelector("#grid"),Be=document.querySelector("#coords");let j=!1,y={rows:10,cols:10,size:50};Q.canvasParent("#grid",{naturalSize:{height:200,width:200},stretch:"min",onSizeChanging(s,e){je()}});const x=new Ae(y),Re=Fe({panels:[Le(y,x),Ne(y,x),_e(y,x)],parent:"#tools",onPanelChanging:(s,e)=>{x.reset()},preselectId:"visit"});S.addEventListener("pointermove",s=>{let e={x:s.offsetX,y:s.offsetY};e=H(e);const n=R(y,e);x.setHighlighted(n),Be.innerHTML=n?`Cell: ${n.x},${n.y}`:""});const H=s=>{const n=S.getBoundingClientRect().width/10,t=y.size/n;return te(s,t)};S.addEventListener("pointerup",s=>{let e={x:s.offsetX,y:s.offsetY};e=H(e),Re.notify("click",R(y,e))});function je(){const s=S.getBoundingClientRect();let e=Math.min(s.width,s.height),n=10,t=Math.floor(e/n);t<15&&(n=5,t=Math.floor(e/n)),y={rows:n,cols:n,size:t},j&&(x.grid=y,x.draw())}x.draw();j=!0;
