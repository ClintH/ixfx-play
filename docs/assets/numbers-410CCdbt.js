import{c as N,n as u,D as y,d as S,_ as h,p as _,s as P,E}from"./src-2eX6lIN8-VI_Nykma.js";const A=r=>r.filter(e=>typeof e=="number"&&!Number.isNaN(e)),M=r=>{if(r===void 0)throw new Error("data parameter is undefined");const e=A(r);return e.reduce((n,a)=>n+a,0)/e.length},g=(r,e)=>{const t=y(r,e),[n,a]=t.reduce((o,s)=>[o[0]+s[0]*s[1],o[1]+s[1]],[0,0]);return n/a},x=(r,e=0,t=1)=>{if(Number.isNaN(r))throw new Error("Param 'value' is NaN");if(Number.isNaN(e))throw new Error("Param 'min' is NaN");if(Number.isNaN(t))throw new Error("Param 'max' is NaN");return r<e?e:r>t?t:r},G=(r=0,e=1)=>{if(Number.isNaN(r))throw new Error("Param 'min' is NaN");if(Number.isNaN(e))throw new Error("Param 'max' is NaN");return t=>t>e?e:t<r?r:t};function D(r,e,t){N(S(r,"positive","decimalPlaces"));let n;{const a=Math.pow(10,r);n=o=>Math.floor(o*a)/a}return n}var I={};h(I,{clamp:()=>f,fromScalar:()=>T,immutable:()=>c,scale:()=>F,scaleUnclamped:()=>q,toScalar:()=>d,towardZero:()=>b});const c=(r=0)=>{if(typeof r>"u")throw new Error("Start value is undefined");const e=typeof r=="number"?r:r.value;if(e>1)throw new Error("Start value cannot be larger than 1");if(e<-1)throw new Error("Start value cannot be smaller than -1");if(Number.isNaN(e))throw new Error("Start value is NaN");const t=e;return{[Symbol.toPrimitive](n){return n==="number"?t:n==="string"?t.toString():!0},value:t,towardZero:n=>c(b(t,n)),add:n=>c(f(t+n)),multiply:n=>c(f(t*n)),inverse:()=>c(-t),interpolate:(n,a)=>c(f(_(n,t,a))),asScalar:(n=1,a=0)=>d(t,n,a)}},d=(r,e=1,t=0)=>{if(typeof r!="number")throw new Error(`Expected v to be a number. Got: ${typeof r}`);if(Number.isNaN(r))throw new Error("Parameter is NaN");return P(r,-1,1,t,e)},T=r=>(N(u(r,"percentage","v")),r*2-1),F=(r,e,t)=>f(E(e,t,-1,1)(r)),q=(r,e,t)=>E(e,t,-1,1)(r),f=r=>{if(typeof r!="number")throw new Error(`Param 'bipolarValue' must be a number. Got: ${typeof r}`);if(Number.isNaN(r))throw new Error("Param 'bipolarValue' is NaN");return r>1?1:r<-1?-1:r},b=(r,e)=>{if(typeof r!="number")throw new Error(`Parameter 'v' must be a number. Got: ${typeof r}`);if(typeof e!="number")throw new Error(`Parameter 'amt' must be a number. Got: ${typeof e}`);if(e<0)throw new Error("Parameter 'amt' must be positive");return r<0?(r+=e,r>0&&(r=0)):r>0&&(r-=e,r<0&&(r=0)),r},Q=(r,e=0,t=1)=>{if(N(u(r,"","min"),u(e,"","min"),u(t,"","max")),r===e||r===t)return e;for(;(r<=e||r>=t)&&!(r===t||r===e);)r>t?r=e+(r-t):r<e&&(r=t-(e-r));return r};var v=class{#r=[];enqueue(r){this.#r.push(r)}dequeue(){return this.#r.shift()}get data(){return this.#r}get size(){return this.#r.length}};const j=(r=100,e)=>{const t=new v;return n=>{if(u(n).success&&n!==void 0)for(t.enqueue(n);t.size>r;)t.dequeue();return e===void 0?M(t.data):g(t.data,e)}},l=(r,e,t,n,a,o)=>z(e,t,n,a)(r),z=(r,e,t,n,a,o)=>{N(u(r,"finite","inMin"),u(e,"finite","inMax"));const s=n??1,m=t??0,i=o?G(t,n):void 0;return p=>{if(r===e)return s;const w=(p-r)/(e-r)*(s-m)+m;return i?i(w):w}},U=(r,e={})=>{if(r.length===0)return{total:NaN,min:NaN,max:NaN,avg:NaN,count:NaN};const t=e.nonNumbers??"throw";let n=0,a=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,s=0;for(let m=0;m<r.length;m++){let i=r[m];if(typeof i!="number"){if(t==="ignore")continue;if(t==="throw")throw new Error(`Param 'data' contains a non-number at index: ${m.toString()}`);t==="nan"&&(i=NaN)}Number.isNaN(i)||i!==void 0&&(a=Math.min(a,i),o=Math.max(o,i),n+=i,s++)}return{total:n,max:o,min:a,count:s,avg:n/s}};var X={};h(X,{array:()=>k,stream:()=>Z});const Z=(r,e)=>{let t=r??Number.MAX_SAFE_INTEGER,n=e??Number.MIN_SAFE_INTEGER;return N(u(t),u(n)),a=>(N(u(a)),t=Math.min(t,a),n=Math.max(n,a),l(a,t,n))},k=(r,e,t)=>{if(!Array.isArray(r))throw new TypeError(`Param 'values' should be an array. Got: ${typeof r}`);const n=U(r),a=e??n.min,o=t??n.max;return r.map(s=>x(l(s,a,o)))};function H(r,e){return r.max<=e.max&&r.min>=e.min?e:{min:Math.min(r.min,e.min),max:Math.max(r.max,e.max)}}const J=()=>({min:Number.MAX_SAFE_INTEGER,max:Number.MIN_SAFE_INTEGER});export{H as a,z as b,x as c,D as d,j as m,J as r,l as s,Q as w};
