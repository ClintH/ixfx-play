import{c as b,G as v,_ as h,g as Q,z as xo,H as Le,h as wo,I as mo,n as p,J as bo,K as Yt,L as It,M as go,w as _t,C as Bt,N as ue,d as fe,O as Xe}from"./src-BeVDUOoq-B6OoJ3p3.js";import{b8 as po,b9 as zo,ba as Ae,bb as Eo,bc as vo,a6 as Ht}from"./src-C7XtfIer-DYL4nwfS.js";const N=Math.PI*2;function te(e){return Array.isArray(e)?e.map(t=>t*(Math.PI/180)):e*(Math.PI/180)}function $o(e){return(e+Math.PI)%(2*Math.PI)}function Xt(e){return Array.isArray(e)?e.map(t=>t*180/Math.PI):e*180/Math.PI}const Zt=(e,t,r=!0)=>{if(r){let n=e+t;return n>=N&&(n=n%N),n}else{const n=e-t;return n<0?N+n:n}},Po=(e,t,r=!0)=>{let n=e;t<n&&(n=0,t=N-e+t);let o=t-n;return r&&(o=N-o),o>=N?o%N:o},No=e=>l(e)&&e.z!==null?!1:e.x===null&&e.y===null,Mo=e=>l(e)&&!Number.isNaN(e.z)?!1:Number.isNaN(e.x)||Number.isNaN(e.y);function Qt(e,t="Point",r=""){if(e===void 0)return v(`'${t}' is undefined. Expected {x,y} got ${JSON.stringify(e)}`,r);if(e===null)return v(`'${t}' is null. Expected {x,y} got ${JSON.stringify(e)}`,r);if(typeof e!="object")return v(`'${t}' is type '${typeof e}'. Expected object.`,r);if(e.x===void 0)return v(`'${t}.x' is undefined. Expected {x,y} got ${JSON.stringify(e)}`,r);if(e.y===void 0)return v(`'${t}.y' is undefined. Expected {x,y} got ${JSON.stringify(e)}`,r);if(typeof e.x!="number")return v(`'${t}.x' must be a number. Got ${typeof e.x}`,r);if(typeof e.y!="number")return v(`'${t}.y' must be a number. Got ${typeof e.y}`,r);if(e.z!==void 0){if(typeof e.z!="number")return v(`${t}.z must be a number. Got: ${typeof e.z}`,r);if(Number.isNaN(e.z))return v(`'${t}.z' is NaN. Got: ${JSON.stringify(e)}`,r)}return e.x===null?v(`'${t}.x' is null`,r):e.y===null?v(`'${t}.y' is null`,r):Number.isNaN(e.x)?v(`'${t}.x' is NaN`,r):Number.isNaN(e.y)?v(`'${t}.y' is NaN`,r):{success:!0,value:e}}function d(e,t="Point",r){b(Qt(e,t,r))}const Kt=(e,t="pt")=>(d(e,t),b(p(e.x,"nonZero",`${t}.x`),p(e.y,"nonZero",`${t}.y`),()=>{if(typeof e.z<"u")return p(e.z,"nonZero",`${t}.z`)}),!0);function y(e){return!(e===void 0||e===null||e.x===void 0||e.y===void 0)}const l=e=>!(e===void 0||e===null||e.x===void 0||e.y===void 0||e.z===void 0),re=e=>l(e)&&e.z!==0?!1:e.x===0&&e.y===0,ne=e=>l(e)&&!Number.isNaN(e.z)?!1:Number.isNaN(e.x)&&Number.isNaN(e.y);function xe(e,t,r,n,o,s){if(l(e)&&l(t))return[e,t];if(y(e)&&y(t))return[e,t];if(l(e)){const c={x:t,y:r,z:n};if(!l(c))throw new Error("Expected x, y & z parameters");return[e,c]}if(y(e)){const c={x:t,y:r};if(!y(c))throw new Error("Expected x & y parameters");return[e,c]}if(typeof o<"u"&&typeof n<"u"){const c={x:e,y:t,z:r},u={x:n,y:o,z:s};if(!l(c))throw new Error("Expected x,y,z for first point");if(!l(u))throw new Error("Expected x,y,z for second point");return[c,u]}const i={x:e,y:t},a={x:r,y:n};if(!y(i))throw new Error("Expected x,y for first point");if(!y(a))throw new Error("Expected x,y for second point");return[i,a]}function O(e,t,r){if(e===void 0)return{x:0,y:0};if(Array.isArray(e)){if(e.length===0)return Object.freeze({x:0,y:0});if(e.length===1)return Object.freeze({x:e[0],y:0});if(e.length===2)return Object.freeze({x:e[0],y:e[1]});if(e.length===3)return Object.freeze({x:e[0],y:e[1],z:e[2]});throw new Error(`Expected array to be 1-3 elements in length. Got ${e.length}.`)}if(y(e))return e;if(typeof e!="number"||typeof t!="number")throw new TypeError(`Expected point or x,y as parameters. Got: a: ${JSON.stringify(e)} b: ${JSON.stringify(t)}`);return Object.freeze(typeof r=="number"?{x:e,y:t,z:r}:{x:e,y:t})}function x(e,t,r,n){const o=O(t,r,n);return d(o,"b"),d(e,"a"),l(o)&&l(e)?Math.hypot(o.x-e.x,o.y-e.y,o.z-e.z):Math.hypot(o.x-e.x,o.y-e.y)}function I(e,...t){if(t.length===0)throw new Error("No points provided");let r=t[0];for(const n of t)l(r)&&l(n),r=e(r,n);return r}const Wt=(e,t,r,n)=>{if(e.y>r.y)throw new Error("topLeft.y greater than bottomRight.y");if(e.y>n.y)throw new Error("topLeft.y greater than bottomLeft.y");const o=t.x-e.x,s=r.x-n.x,i=Math.abs(n.y-e.y),a=Math.abs(r.y-t.y);return{x:Math.min(e.x,n.x),y:Math.min(t.y,e.y),width:Math.max(o,s),height:Math.max(i,a)}},we=(...e)=>{const t=I((u,f)=>u.x<f.x?u:f,...e),r=I((u,f)=>u.x>f.x?u:f,...e),n=I((u,f)=>u.y<f.y?u:f,...e),o=I((u,f)=>u.y>f.y?u:f,...e),s={x:t.x,y:n.y},i={x:r.x,y:n.y},a={x:r.x,y:o.y},c={x:t.x,y:o.y};return Wt(s,i,a,c)},jo=(...e)=>{const t=we(...e),r=I((o,s)=>o.z<s.z?o:s,...e),n=I((o,s)=>o.z>s.z?o:s,...e);return{...t,z:r.z,depth:n.z-r.z}},rt=e=>!(e.distance===void 0||e.angleRadian===void 0),$=(e,t="Point")=>{if(e===void 0)throw new Error(`'${t}' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(e===null)throw new Error(`'${t}' is null. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(e.angleRadian===void 0)throw new Error(`'${t}.angleRadian' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(e.distance===void 0)throw new Error(`'${t}.distance' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(typeof e.angleRadian!="number")throw new TypeError(`'${t}.angleRadian' must be a number. Got ${e.angleRadian}`);if(typeof e.distance!="number")throw new TypeError(`'${t}.distance' must be a number. Got ${e.distance}`);if(e.angleRadian===null)throw new Error(`'${t}.angleRadian' is null`);if(e.distance===null)throw new Error(`'${t}.distance' is null`);if(Number.isNaN(e.angleRadian))throw new TypeError(`'${t}.angleRadian' is NaN`);if(Number.isNaN(e.distance))throw new Error(`'${t}.distance' is NaN`)},er=(e,t)=>Object.freeze({...e,angleRadian:e.angleRadian+t}),Oo=e=>($(e,"c"),Object.freeze({...e,angleRadian:e.angleRadian-Math.PI})),So=(e,t)=>($(e,"a"),$(t,"b"),e.distance!==t.distance?!1:e.angleRadian===-t.angleRadian),Ro=(e,t)=>($(e,"a"),$(t,"b"),e.angleRadian===t.angleRadian),Ao=(e,t)=>($(e,"a"),$(t,"b"),e.angleRadian===-t.angleRadian),Co=(e,t)=>Object.freeze({...e,angleRadian:e.angleRadian+te(t)});function P(e,t,r,n,o,s){const[i,a]=xe(e,t,r,n,o,s);d(i,"a"),d(a,"b");const c={x:i.x-a.x,y:i.y-a.y};return(l(i)||l(a))&&(c.z=(i.z??0)-(a.z??0)),Object.freeze(c)}const Y={x:0,y:0},To={x:1,y:1},ko={x:0,y:0,z:0},Fo={x:1,y:1,z:1},Lo=(e,t)=>{const r=E(e,t);return{a:t,b:r}},E=(e,t,r)=>{if(rt(e)){if(typeof t>"u"&&(t=Y),y(t))return Dt(e.distance,e.angleRadian,t);throw new Error("Expecting (Coord, Point). Second parameter is not a point")}else{if(typeof e=="object")throw new TypeError(`First param is an object, but not a Coord: ${JSON.stringify(e)}`);if(typeof e=="number"&&typeof t=="number"){if(typeof r>"u"&&(r=Y),!y(r))throw new Error("Expecting (number, number, Point). Point param wrong type");return Dt(e,t,r)}else throw new TypeError(`Expecting parameters of (number, number). Got: (${typeof e}, ${typeof t}, ${typeof r}). a: ${JSON.stringify(e)}`)}},nt=(e,t)=>{if(typeof e>"u")throw new Error("Param 'point' missing. Expecting a Point");if(typeof t>"u")throw new Error("Param 'origin' missing. Expecting a Point");e=P(e,t);const r=Math.atan2(e.y,e.x),n=Math.hypot(e.x,e.y),o={...e,angleRadian:r,distance:n};return delete o.x,delete o.y,Object.freeze(o)},Dt=(e,t,r=Y)=>(d(r),Object.freeze({x:r.x+e*Math.cos(t),y:r.y+e*Math.sin(t)})),tr=(e,t)=>{if(e===void 0)return"(undefined)";if(e===null)return"(null)";const r=Xt(e.angleRadian),n=t?e.distance.toFixed(t):e.distance,o=t?r.toFixed(t):r;return`(${n},${o})`},rr=(e,t=Y)=>($(e,"v"),Object.freeze({x:t.x+e.distance*Math.cos(e.angleRadian),y:t.y+e.distance*Math.sin(e.angleRadian)})),nr=e=>{if(e.distance===0)throw new Error("Cannot normalise vector of length 0");return Object.freeze({...e,distance:1})},or=(e,t=1,r=0)=>{let n=e.distance;return n>t&&(n=t),n<r&&(n=r),Object.freeze({...e,distance:n})},sr=(e,t)=>($(e,"a"),$(t,"b"),e.distance*t.distance*Math.cos(t.angleRadian-e.angleRadian)),qo=(e,t)=>($(e),b(p(t,"","amt")),Object.freeze({...e,distance:e.distance*t})),Io=(e,t)=>($(e),b(p(t,"","amt")),Object.freeze({...e,distance:e.distance/t})),ir=Object.freeze({x:NaN,y:NaN}),_o=Object.freeze({x:NaN,y:NaN,z:NaN}),V=(e,t,r)=>(d(e,"a"),t===void 0?Math.atan2(e.y,e.x):(d(t,"b"),r===void 0?Math.atan2(t.y-e.y,t.x-e.x):(d(r,"c"),Math.atan2(t.y-e.y,t.x-e.x)-Math.atan2(r.y-e.y,r.x-e.x)))),Bo=(e,t,r)=>{const n=V(e,t,r);return n<0?n+N:n},Do=(e,t=Math.round)=>(d(e,"pt"),Object.freeze({x:t(e.x),y:t(e.y)})),Jo=e=>{d(e,"pt");let t={...e};return delete t.z,Object.freeze(t)},Go=(e,t=0)=>(d(e,"pt"),Object.freeze({...e,z:t}));function le(e,t){if(e===void 0)return"(undefined)";if(e===null)return"(null)";d(e,"pt");const r=t?e.x.toFixed(t):e.x,n=t?e.y.toFixed(t):e.y;if(e.z===void 0)return`(${r},${n})`;{const o=t?e.z.toFixed(t):e.z;return`(${r},${n},${o})`}}var ar={};h(ar,{fromLine:()=>Ho,toCartesian:()=>Vo,toString:()=>Yo});const Vo=(e,t)=>{const r=Uo(e,t),n=E(e.offset,e.angleRadian,r),o=E(e.offset+e.length,e.angleRadian,r);return{a:n,b:o}},Uo=(e,t)=>t!==void 0?t:e.origin!==void 0?e.origin:{x:0,y:0},Yo=e=>{let t=`PolarRay(angle: ${e.angleRadian} offset: ${e.offset} len: ${e.length}`;return e.origin&&(t+=` origin: ${le(e.origin)}`),t+=")",t},Ho=(e,t)=>{const r=t??e.a;return{angleRadian:V(e.b,r),offset:x(e.a,r),length:x(e.b,e.a),origin:r}};function*Xo(e,t){let r=0;for(;;){const n=e*r++;yield{distance:t*n,angleRadian:n,step:r}}}const Zo=(e,t,r)=>{const n=t*e;return Object.freeze({distance:r*n,angleRadian:n})};var Qo={};h(Qo,{Ray:()=>ar,clampMagnitude:()=>or,divide:()=>Io,dotProduct:()=>sr,fromCartesian:()=>nt,guard:()=>$,invert:()=>Oo,isAntiParallel:()=>Ao,isOpposite:()=>So,isParallel:()=>Ro,isPolarCoord:()=>rt,multiply:()=>qo,normalise:()=>nr,rotate:()=>er,rotateDegrees:()=>Co,spiral:()=>Xo,spiralRaw:()=>Zo,toCartesian:()=>E,toLine:()=>Lo,toPoint:()=>rr,toString:()=>tr});const me=(e,t)=>(d(e,"a"),d(t,"b"),e=Object.freeze({...e}),t=Object.freeze({...t}),Object.freeze({a:e,b:t}));var Ko={};h(Ko,{angularSize:()=>fr,bbox:()=>lr,distanceCenter:()=>ns,fromCircle:()=>dr,fromCircleAmount:()=>rs,fromDegrees:()=>Wo,getStartEnd:()=>es,guard:()=>qe,interpolate:()=>ot,isArc:()=>cr,isEqual:()=>os,isPositioned:()=>_,length:()=>yr,point:()=>se,toLine:()=>ur,toPath:()=>ts,toSvg:()=>hr});const cr=e=>typeof e.startRadian<"u"&&typeof e.endRadian<"u"&&typeof e.clockwise<"u",_=e=>typeof e.x<"u"&&typeof e.y<"u";function Wo(e,t,r,n,o){const s={radius:e,startRadian:te(t),endRadian:te(r),clockwise:n};if(y(o)){d(o);const i={...s,x:o.x,y:o.y};return Object.freeze(i)}else return Object.freeze(s)}const ur=e=>me(se(e,e.startRadian),se(e,e.endRadian)),es=(e,t)=>{qe(e);const r=se(e,e.startRadian,t),n=se(e,e.endRadian,t);return[r,n]},se=(e,t,r)=>(typeof r>"u"&&(r=_(e)?e:{x:0,y:0}),{x:Math.cos(t)*e.radius+r.x,y:Math.sin(t)*e.radius+r.y}),qe=e=>{if(typeof e>"u")throw new TypeError("Arc is undefined");if(_(e)&&d(e,"arc"),typeof e.radius>"u")throw new TypeError(`Arc radius is undefined (${JSON.stringify(e)})`);if(typeof e.radius!="number")throw new TypeError("Radius must be a number");if(Number.isNaN(e.radius))throw new TypeError("Radius is NaN");if(e.radius<=0)throw new TypeError("Radius must be greater than zero");if(typeof e.startRadian>"u")throw new TypeError("Arc is missing 'startRadian' field");if(typeof e.endRadian>"u")throw new TypeError("Arc is missing 'startRadian' field");if(Number.isNaN(e.endRadian))throw new TypeError("Arc endRadian is NaN");if(Number.isNaN(e.startRadian))throw new TypeError("Arc endRadian is NaN");if(typeof e.clockwise>"u")throw new TypeError("Arc is missing 'clockwise field");if(e.startRadian>=e.endRadian)throw new TypeError("startRadian is expected to be les than endRadian")},ot=(e,t,r,n)=>{if(qe(t),!(r??!1)){if(e<0)throw new Error("Param 'amount' is under zero, and overflow is not allowed");if(e>1)throw new Error("Param 'amount' is above 1 and overflow is not allowed")}const i=fr(t)*e,a=Zt(t.startRadian,i,t.clockwise);return se(t,a,n)},fr=e=>Po(e.startRadian,e.endRadian,e.clockwise),ts=e=>(qe(e),Object.freeze({...e,nearest:t=>{throw new Error("not implemented")},interpolate:t=>ot(t,e),bbox:()=>lr(e),length:()=>yr(e),toSvgString:()=>hr(e),relativePosition:(t,r)=>{throw new Error("Not implemented")},distanceToPoint:t=>{throw new Error("Not implemented")},kind:"arc"})),dr=(e,t,r,n=!0)=>Object.freeze({...e,endRadian:r,startRadian:t,clockwise:n}),rs=(e,t,r,n=!0)=>{const o=Zt(t,r,n);return dr(e,t,o)},yr=e=>N*e.radius*((e.startRadian-e.endRadian)/N),lr=e=>{if(_(e)){const t=ot(.5,e),r=ur(e);return we(t,r.a,r.b)}else return{width:e.radius*2,height:e.radius*2}},hr=(e,t,r,n,o)=>{if(cr(e))return _(e)?y(t)?de(t,e.radius,e.startRadian,e.endRadian,r):de(e,e.radius,e.startRadian,e.endRadian,t):y(t)?de(t,e.radius,e.startRadian,e.endRadian,r):de({x:0,y:0},e.radius,e.startRadian,e.endRadian);if(r===void 0)throw new Error("startAngle undefined");if(n===void 0)throw new Error("endAngle undefined");if(y(e)){if(typeof t=="number"&&typeof r=="number"&&typeof n=="number")return de(e,t,r,n,o);throw new TypeError("Expected (point, number, number, number). Missing a number param.")}else throw new Error("Expected (point, number, number, number). Missing first point.")},de=(e,t,r,n,o)=>{(o===void 0||typeof o!="object")&&(o={});const s=n-r===360,i=E(t,n-.01,e),a=E(t,r,e),{largeArc:c=!1,sweep:u=!1}=o,f=[`
    M ${i.x} ${i.y}
    A ${t} ${t} 0 ${c?"1":"0"} ${u?"1":"0"} ${a.x} ${a.y},
  `];return s&&f.push("z"),f},ns=(e,t)=>x(e,t),os=(e,t)=>{if(e.radius!==t.radius||e.endRadian!==t.endRadian||e.startRadian!==t.startRadian||e.clockwise!==t.clockwise)return!1;if(_(e)&&_(t)){if(e.x!==t.x||e.y!==t.y||e.z!==t.z)return!1}else if(!(!_(e)&&!_(t)))return!1;return!0},J=e=>!(e===void 0||e.a===void 0||e.b===void 0||!y(e.a)||!y(e.b)),xr=e=>Array.isArray(e)?!e.some(r=>!J(r)):!1,be=(e,t="line")=>{if(e===void 0)throw new Error(`${t} undefined`);if(e.a===void 0)throw new Error(`${t}.a undefined. Expected {a:Point, b:Point}. Got: ${JSON.stringify(e)}`);if(e.b===void 0)throw new Error(`${t}.b undefined. Expected {a:Point, b:Point} Got: ${JSON.stringify(e)}`)},Ie=(e,t)=>{let r;if(J(e))t=e.b,r=e.a;else if(r=e,t===void 0)throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${JSON.stringify(r)} b: ${JSON.stringify(t)}`);return d(r,"a"),d(r,"b"),[r,t]};function z(e,t){if(xr(e))return e.reduce((a,c)=>z(c)+a,0);if(e===void 0)throw new TypeError("Parameter 'aOrLine' is undefined");const[r,n]=Ie(e,t),o=n.x-r.x,s=n.y-r.y;if(r.z!==void 0&&n.z!==void 0){const i=n.z-r.z;return Math.hypot(o,s,i)}else return Math.hypot(o,s)}function wr(e){return be(e,"line"),{a:e.b,b:e.a}}function C(e,t,r,n){typeof r=="boolean"&&(n=r,r=void 0),n?b(p(e,"","amount")):b(bo(e,"amount"));const[o,s]=Ie(t,r),i=z(o,s),a=i*(1-e);if(i===0&&a===0)return Object.freeze({...s});const c=s.x-a*(s.x-o.x)/i,u=s.y-a*(s.y-o.y)/i;return Object.freeze({...s,x:c,y:u})}function ss(e,t,r=!0){r||(e=wr(e));const n=e.b.x-e.a.x,o=e.b.y-e.a.y,s=Math.atan2(o,n),i=t*Math.cos(s),a=t*Math.sin(s);return{x:i+e.a.x,y:a+e.a.y}}const K=(e,t="Dimension")=>{if(e===void 0)throw new Error(`${t} is undefined`);if(Number.isNaN(e))throw new Error(`${t} is NaN`);if(e<0)throw new Error(`${t} cannot be negative`)},F=(e,t="rect")=>{if(e===void 0)throw new Error("{$name} undefined");g(e)&&d(e,t),K(e.width,t+".width"),K(e.height,t+".height")},st=(e,t)=>{if(F(e),g(e)&&t===void 0)return e;if(t===void 0)throw new Error("Unpositioned rect needs origin parameter");return Object.freeze({...e,...t})},it=(e,t="rect")=>{if(!g(e))throw new Error(`Expected ${t} to have x,y`);F(e,t)},is=e=>e.width===0&&e.height===0,as=e=>Number.isNaN(e.width)&&Number.isNaN(e.height),g=e=>e.x!==void 0&&e.y!==void 0,B=e=>!(e===void 0||e.width===void 0||e.height===void 0),T=e=>B(e)&&g(e),U=(e,t,r)=>(K(t,"width"),K(r,"height"),d(e,"origin"),{x:e.x,y:e.y,width:t,height:r}),_e=e=>e.quadratic!==void 0,at=e=>e.cubic1!==void 0&&e.cubic2!==void 0;var cs={};h(cs,{cubic:()=>ys,interpolator:()=>fs,isCubicBezier:()=>at,isQuadraticBezier:()=>_e,quadratic:()=>br,quadraticSimple:()=>us,quadraticToSvgString:()=>mr,toPath:()=>ds});const us=(e,t,r=0)=>{if(Number.isNaN(r))throw new Error("bend is NaN");if(r<-1||r>1)throw new Error("Expects bend range of -1 to 1");const n=C(.5,e,t);let o=n;t.y<e.y?o=r>0?{x:Math.min(e.x,t.x),y:Math.min(e.y,t.y)}:{x:Math.max(e.x,t.x),y:Math.max(e.y,t.y)}:o=r>0?{x:Math.max(e.x,t.x),y:Math.min(e.y,t.y)}:{x:Math.min(e.x,t.x),y:Math.max(e.y,t.y)};const s=C(Math.abs(r),n,o);return br(e,t,s)},fs=e=>{const t=at(e)?new Ae(e.a.x,e.a.y,e.cubic1.x,e.cubic1.y,e.cubic2.x,e.cubic2.y,e.b.x,e.b.y):new Ae(e.a,e.quadratic,e.b);return r=>t.compute(r)},mr=(e,t,r)=>[`M ${e.x} ${e.y} Q ${r.x} ${r.y} ${t.x} ${t.y}`],ds=e=>{if(at(e))return ls(e);if(_e(e))return hs(e);throw new Error("Unknown bezier type")},ys=(e,t,r,n)=>({a:Object.freeze(e),b:Object.freeze(t),cubic1:Object.freeze(r),cubic2:Object.freeze(n)}),ls=e=>{const{a:t,cubic1:r,cubic2:n,b:o}=e,s=new Ae(t,r,n,o);return Object.freeze({...e,length:()=>s.length(),interpolate:i=>s.compute(i),nearest:i=>{throw new Error("not implemented")},bbox:()=>{const{x:i,y:a}=s.bbox(),c=i.size,u=a.size;if(c===void 0)throw new Error("x.size not present on calculated bbox");if(u===void 0)throw new Error("x.size not present on calculated bbox");return U({x:i.min,y:a.min},c,u)},relativePosition:(i,a)=>{throw new Error("Not implemented")},distanceToPoint:i=>{throw new Error("Not implemented")},toSvgString:()=>["brrup"],kind:"bezier/cubic"})},br=(e,t,r)=>({a:Object.freeze(e),b:Object.freeze(t),quadratic:Object.freeze(r)}),hs=e=>{const{a:t,b:r,quadratic:n}=e,o=new Ae(t,n,r);return Object.freeze({...e,length:()=>o.length(),interpolate:s=>o.compute(s),nearest:s=>{throw new Error("not implemented")},bbox:()=>{const{x:s,y:i}=o.bbox(),a=s.size,c=i.size;if(a===void 0)throw new Error("x.size not present on calculated bbox");if(c===void 0)throw new Error("x.size not present on calculated bbox");return U({x:s.min,y:i.min},a,c)},distanceToPoint:s=>{throw new Error("Not implemented")},relativePosition:(s,i)=>{throw new Error("Not implemented")},toString:()=>o.toString(),toSvgString:()=>mr(t,r,n),kind:"bezier/quadratic"})},ge=(e,t="circle")=>{if(m(e)&&d(e,"circle"),Number.isNaN(e.radius))throw new Error(`${t}.radius is NaN`);if(e.radius<=0)throw new Error(`${t}.radius must be greater than zero`)},Ce=(e,t="circle")=>{if(!m(e))throw new Error("Expected a positioned circle with x,y");ge(e,t)},xs=e=>!!(Number.isNaN(e.radius)||m(e)&&(Number.isNaN(e.x)||Number.isNaN(e.y))),gr=e=>e.x!==void 0&&e.y!==void 0,ie=e=>e.radius!==void 0,m=e=>ie(e)&&gr(e),ws=e=>(ge(e),Math.PI*e.radius*e.radius),pr=(e,t,r)=>{d(e,"origin"),K(t,"width"),K(r,"height");const n=t/2,o=r/2;return{x:e.x-n,y:e.y-o,width:t,height:r}},zr=e=>m(e)?pr(e,e.radius*2,e.radius*2):{width:e.radius*2,height:e.radius*2,x:0,y:0},Er=e=>m(e)?Object.freeze({x:e.x,y:e.y}):Object.freeze({x:e.radius,y:e.radius}),ct=(e,t)=>(Ce(e,"a"),m(t)&&Ce(t,"b"),x(e,t)),ut=(e,t)=>{if(Ce(e,"a"),m(t))return Math.max(0,ct(e,t)-e.radius-t.radius);if(y(t)){const r=x(e,t);return r<e.radius?0:r}else throw new Error("Second parameter invalid type")};function*ms(e){const{x:t,y:r,radius:n}=e;let o=n,s=0,i=1-t;for(;o>=s;)yield{x:o+t,y:s+r},yield{x:s+t,y:o+r},yield{x:-o+t,y:s+r},yield{x:-s+t,y:o+r},yield{x:-o+t,y:-s+r},yield{x:-s+t,y:-o+r},yield{x:o+t,y:-s+r},yield{x:s+t,y:-o+r},s++,i<0?i+=2*s+1:(o--,i+=2*(s-o+1))}function*bs(e){const t=e.x-e.radius,r=e.x+e.radius,n=e.y-e.radius,o=e.y+e.radius;for(let s=t;s<r;s++)for(let i=n;i<o;i++)Math.abs(x(e,s,i))<=e.radius&&(yield{x:s,y:i})}const gs=Math.PI*2,vr=(e,t)=>{const r=n=>{const o=Math.sqrt(Math.pow(t.x-n.x,2)+Math.pow(t.y-n.y,2)),s=n.x+n.radius*((t.x-n.x)/o),i=n.y+n.radius*((t.y-n.y)/o);return{x:s,y:i}};if(Array.isArray(e)){const n=e.map(s=>r(s)),o=n.map(s=>x(s,t));return Object.freeze(n[Yt(...o)])}else return Object.freeze(r(e))},$r=(e,t,r)=>(r===void 0&&(r=m(e)?e:{x:0,y:0}),{x:Math.cos(-t)*e.radius+r.x,y:Math.sin(-t)*e.radius+r.y}),ft=e=>(ge(e),gs*e.radius),ps=e=>ft(e),zs=Math.PI*2,Pr=(e,t)=>$r(e,t*zs),Nr=(e,t)=>e.radius!==t.radius?!1:m(e)&&m(t)?!(e.x!==t.x||e.y!==t.y||e.z!==t.z):(!m(e)&&!m(t),!1);function H(e,t,r,n,o,s){const[i,a]=xe(e,t,r,n,o,s);d(i,"a"),d(a,"b");const c={x:i.x+a.x,y:i.y+a.y};return(l(i)||l(a))&&(c.z=(i.z??0)+(a.z??0)),Object.freeze(c)}const Es=(e,t)=>{const r={x:t.b.x-t.a.x,y:t.b.y-t.a.y},n={x:t.a.x-e.x,y:t.a.y-e.y},o=(r.x*n.x+r.y*n.y)*-2,s=2*(r.x*r.x+r.y*r.y),i=Math.sqrt(o*o-2*s*(n.x*n.x+n.y*n.y-e.radius*e.radius));if(Number.isNaN(i))return[];const a=(o-i)/s,c=(o+i)/s,u=[];return a<=1&&a>=0&&u.push({x:t.a.x+r.x*a,y:t.a.y+r.y*a}),c<=1&&c>=0&&u.push({x:t.a.x+r.x*c,y:t.a.y+r.y*c}),u},Mr=(e,t)=>{const r=P(t,e),n=Math.hypot(r.y,r.x);if(n>e.radius+t.radius)return[];if(n<Math.abs(e.radius-t.radius))return[];if(Nr(e,t))return[];const o=(e.radius*e.radius-t.radius*t.radius+n*n)/(2*n),s={x:e.x+r.x*o/n,y:e.y+r.y*o/n},i=Math.sqrt(e.radius*e.radius-o*o),a={x:-r.y*(i/n),y:r.x*(i/n)};return[H(s,a),P(s,a)]},jr=(e,t)=>{const r=e.x-Math.max(t.x,Math.min(e.x,t.x+t.width)),n=e.y-Math.max(t.y,Math.min(e.y,t.y+t.height));return r*r+n*n<e.radius*e.radius},Jt=(e,t)=>Mr(e,t).length===2,Or=(e,t,r)=>{const n=ct(e,t);if(ie(t))return n<Math.abs(e.radius-t.radius);if(y(t))return r===void 0?n<=e.radius:n<Math.abs(e.radius-r);throw new Error("b parameter is expected to be CirclePositioned or Point")},R=(...e)=>{if(e===void 0)throw new Error("parameter 'p' is undefined");if(e.length<2)return!0;for(let t=1;t<e.length;t++)if(e[t].x!==e[0].x||e[t].y!==e[0].y)return!1;return!0},dt=(e,t,r)=>R(e,t)||Or(e,t,r)?!0:ie(t)?Jt(e,t):T(t)?jr(e,t):y(t)&&r!==void 0?Jt(e,{...t,radius:r}):!1;function he(e,t,r,n,o,s){const[i,a]=xe(e,t,r,n,o,s);d(i,"a"),d(a,"b");const c={x:i.x*a.x,y:i.y*a.y};return(l(i)||l(a))&&(c.z=(i.z??0)*(a.z??0)),Object.freeze(c)}const Sr=(e,t)=>l(e)?Object.freeze({...e,x:e.x*t,y:e.y*t,z:e.z*t}):Object.freeze({...e,x:e.x*t,y:e.y*t});function vs(e,t){if(m(e)){const r=Sr(e,t);return Object.freeze({...e,...r,radius:e.radius*t})}else return Object.freeze({...e,radius:e.radius*t})}const Gt=Math.PI*2,Rr=(e,t={})=>{const r=m(e)?e:{x:0,y:0},n=t.strategy??"uniform",o=t.margin??0,s=e.radius-o,i=t.randomSource??Math.random;switch(n){case"naive":return H(r,E(i()*s,i()*Gt));case"uniform":return H(r,E(Math.sqrt(i())*s,i()*Gt));default:throw new Error(`Unknown strategy '${n}'. Expects 'uniform' or 'naive'`)}},Ar=(e,t,r)=>{if(ie(e)){if(r!==void 0)return Ze(e.radius,r,t);if(m(e))return Ze(e.radius,e,t);throw new Error("origin parameter needed for non-positioned circle")}else{if(r===void 0)throw new Error("origin parameter needed");return Ze(e,r,t)}},Ze=(e,t,r)=>{const{x:n,y:o}=t,s=r?"1":"0";return`
    M ${n}, ${o}
    m -${e}, 0
    a ${e},${e} 0 1,${s} ${e*2},0
    a ${e},${e} 0 1,${s} -${e*2},0
  `.split(`
`)},$s=e=>(ge(e),{...e,nearest:t=>vr(e,t),interpolate:t=>Pr(e,t),bbox:()=>zr(e),length:()=>ft(e),toSvgString:(t=!0)=>Ar(e,t),relativePosition:(t,r)=>{throw new Error("Not implemented")},distanceToPoint:t=>{throw new Error("Not implemented")},kind:"circular"}),yt=(e,t,r)=>{if(m(e))return e;const n=O(t,r);return Object.freeze({...e,...n})};var Ps={};h(Ps,{area:()=>ws,bbox:()=>zr,center:()=>Er,circumference:()=>ft,distanceCenter:()=>ct,distanceFromExterior:()=>ut,exteriorIntegerPoints:()=>ms,guard:()=>ge,guardPositioned:()=>Ce,interiorIntegerPoints:()=>bs,interpolate:()=>Pr,intersectionLine:()=>Es,intersections:()=>Mr,isCircle:()=>ie,isCirclePositioned:()=>m,isContainedBy:()=>Or,isEqual:()=>Nr,isIntersecting:()=>dt,isNaN:()=>xs,isPositioned:()=>gr,length:()=>ps,multiplyScalar:()=>vs,nearest:()=>vr,pointOnPerimeter:()=>$r,randomPoint:()=>Rr,toPath:()=>$s,toPositioned:()=>yt,toSvg:()=>Ar});const Cr=(e,t)=>!(t.x<0||t.y<0||t.x>=e.cols||t.y>=e.rows),Ns=e=>e===void 0?!1:"x"in e&&"y"in e,k=(e,t="Param",r)=>{if(e===void 0)throw new Error(t+" is undefined. Expecting {x,y}");if(e.x===void 0)throw new Error(t+".x is undefined");if(e.y===void 0)throw new Error(t+".y is undefined");if(Number.isNaN(e.x))throw new Error(t+".x is NaN");if(Number.isNaN(e.y))throw new Error(t+".y is NaN");if(!Number.isInteger(e.x))throw new TypeError(t+".x is non-integer");if(!Number.isInteger(e.y))throw new TypeError(t+".y is non-integer");if(r!==void 0&&!Cr(r,e))throw new Error(`${t} is outside of grid. Cell: ${e.x},${e.y} Grid: ${r.cols}, ${r.rows}`)},ee=(e,t="Param")=>{if(e===void 0)throw new Error(`${t} is undefined. Expecting grid.`);if(!("rows"in e))throw new Error(`${t}.rows is undefined`);if(!("cols"in e))throw new Error(`${t}.cols is undefined`);if(!Number.isInteger(e.rows))throw new TypeError(`${t}.rows is not an integer`);if(!Number.isInteger(e.cols))throw new TypeError(`${t}.cols is not an integer`)},pe=function(e,t,r="undefined"){ee(e,"grid"),k(t,"cell");let n=t.x,o=t.y;switch(r){case"wrap":{n=n%e.cols,o=o%e.rows,n<0?n=e.cols+n:n>=e.cols&&(n-=e.cols),o<0?o=e.rows+o:o>=e.rows&&(o-=e.rows),n=Math.abs(n),o=Math.abs(o);break}case"stop":{n=It(n,e.cols),o=It(o,e.rows);break}case"undefined":{if(n<0||o<0||n>=e.cols||o>=e.rows)return;break}case"unbounded":break;default:throw new Error(`Unknown BoundsLogic '${r}'. Expected: wrap, stop, undefined or unbounded`)}return Object.freeze({x:n,y:o})};var Tr={};h(Tr,{access:()=>kr,createArray:()=>Br,createMutable:()=>Os,set:()=>js,setMutate:()=>Lr,wrap:()=>_r,wrapMutable:()=>Ir});const kr=(e,t)=>{const r=ze(e,t);return(o,s="undefined")=>Fr(r,e,o,s)},Fr=(e,t,r,n)=>{const o=Je(e,r,n);if(o!==void 0)return t[o]},Lr=(e,t)=>{const r=ze(e,t);return(n,o,s="undefined")=>Ms(r,e,n,o,s)},Ms=(e,t,r,n,o)=>{const s=Je(e,n,o);if(s===void 0)throw new RangeError(`Cell (${n.x},${n.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);return t[s]=r,t},js=(e,t)=>{const r=ze(e,t);return(n,o,s)=>qr(r,e,n,o,s)},qr=(e,t,r,n,o)=>{const s=Je(e,n,o);if(s===void 0)throw new RangeError(`Cell (${n.x},${n.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);const i=[...t];return i[s]=r,t=i,i},ze=(e,t)=>({cols:t,rows:Math.ceil(e.length/t)}),Ir=(e,t)=>({...ze(e,t),get:kr(e,t),set:Lr(e,t),get array(){return e}}),_r=(e,t)=>{const r=ze(e,t);return{...r,get:(n,o="undefined")=>Fr(r,e,n,o),set:(n,o,s="undefined")=>(e=qr(r,e,n,o,s),_r(e,t)),get array(){return e}}},Br=(e,t,r)=>{const n=typeof t=="number"?t:t.rows,o=typeof t=="object"?t.cols:r;if(!o)throw new Error("Parameter 'columns' missing");b(Q(n,"aboveZero","rows"),Q(o,"aboveZero","cols"));const s=[],i=n*o;for(let a=0;a<i;a++)s[a]=e;return s},Os=(e,t,r)=>{const n=typeof t=="number"?t:t.rows,o=typeof t=="object"?t.cols:r;if(!o)throw new Error("Parameter 'columns' missing");const s=Br(e,n,o);return Ir(s,o)};var Dr={};h(Dr,{access:()=>Gr,create:()=>ae,set:()=>As,setMutate:()=>Jr,wrap:()=>Yr,wrapMutable:()=>Rs});const ae=e=>{let t=NaN;for(const r of e)if(Number.isNaN(t))t=r.length;else if(t!==r.length)throw new Error("Array does not have uniform column length");return{rows:e.length,cols:t}},Jr=e=>{const t=ae(e);return(r,n,o="undefined")=>Ss(t,e,r,n,o)},Ss=(e,t,r,n,o)=>{let s=pe(e,n,o);if(s===void 0)throw new RangeError(`Cell (${n.x},${n.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);return t[s.y][s.x]=r,t},Gr=e=>{const t=ae(e);return(n,o="undefined")=>Vr(t,e,n,o)},Vr=(e,t,r,n)=>{let o=pe(e,r,n);if(o!==void 0)return t[o.y][o.x]},Rs=e=>({...ae(e),get:Gr(e),set:Jr(e),get array(){return e}}),As=e=>{const t=ae(e);return(r,n,o)=>Ur(t,e,r,n,o)},Ur=(e,t,r,n,o)=>{let s=pe(e,n,o);if(s===void 0)throw new RangeError(`Cell (${n.x},${n.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);let i=[...t],a=[...i[s.y]];return a[s.x]=r,i[s.y]=a,t=i,i},Yr=e=>{const t=ae(e);return{...t,get:(r,n="undefined")=>Vr(t,e,r,n),set:(r,n,o="undefined")=>(e=Ur(t,e,r,n,o),Yr(e)),get array(){return e}}};function*Hr(e,t){for(const r of t)Array.isArray(r)?yield r.map(n=>e.get(n,"undefined")):yield e.get(r,"undefined")}function*ce(e,t,r=!0){t||(t={x:0,y:0}),ee(e,"grid"),k(t,"start",e);let{x:n,y:o}=t,s=!0;do yield{x:n,y:o},n++,n===e.cols&&(o++,n=0),o===e.rows&&(r?(o=0,n=0):s=!1),n===t.x&&o===t.y&&(s=!1);while(s)}function*Cs(e,t,r=!0){yield*Hr(e,ce(e,t,r))}function*Ts(e,t,r=!0){for(const n of ce(e,t,r))yield{cell:n,value:e.get(n)}}var Xr={};h(Xr,{columns:()=>Fs,rows:()=>ks});const ks=function*(e,t){t||(t={x:0,y:0});let r=t.y,n=[];for(const o of ce(e,t))o.y===r?n.push(o):(yield n,n=[o],r=o.y);n.length>0&&(yield n)};function*Fs(e,t){t||(t={x:0,y:0});for(let r=t.x;r<e.cols;r++){let n=[];for(let o=t.y;o<e.rows;o++)n.push({x:r,y:o});yield n}}const Be=function(e,t,r,n="undefined"){return pe(e,{x:t.x+r.x,y:t.y+r.y},n)},De=Object.freeze(["n","ne","nw","e","s","se","sw","w"]),Zr=Object.freeze(["n","e","s","w"]),Ls=(e,t,r,n="stop")=>{ee(e,"grid"),k(t,"start"),b(Q(r,"aboveZero","steps"));const o=De,s=o.map(a=>lt(a,r)),i=o.map((a,c)=>Be(e,t,s[c],n));return Ht(o,i)},lt=(e,t=1)=>{let r;switch(e){case"n":{r={x:0,y:-1*t};break}case"ne":{r={x:1*t,y:-1*t};break}case"e":{r={x:1*t,y:0};break}case"se":{r={x:1*t,y:1*t};break}case"s":{r={x:0,y:1*t};break}case"sw":{r={x:-1*t,y:1*t};break}case"w":{r={x:-1*t,y:0};break}case"nw":{r={x:-1*t,y:-1*t};break}default:r={x:0,y:0}}return Object.freeze(r)};var Qr={};h(Qr,{cellValues:()=>Cs,cells:()=>ce,cellsAndValues:()=>Ts});const qs=(e,t)=>{k(e),k(t);let r=e.x,n=e.y;const o=Math.abs(t.x-r),s=Math.abs(t.y-n),i=r<t.x?1:-1,a=n<t.y?1:-1;let c=o-s;const u=[];for(;u.push(Object.freeze({x:r,y:n})),!(r===t.x&&n===t.y);){const f=2*c;f>-s&&(c-=s,r+=i),f<o&&(c+=o,n+=a)}return u},Is=function(e,t,r=!1){const n=[];if(e.x===t.x){const o=r?t.y+1:t.y;for(let s=e.y;s<o;s++)n.push({x:e.x,y:s})}else if(e.y===t.y){const o=r?t.x+1:t.x;for(let s=e.x;s<o;s++)n.push({x:s,y:e.y})}else throw new Error(`Only does vertical and horizontal: ${e.x},${e.y} - ${t.x},${t.y}`);return n},Je=(e,t,r)=>{if(ee(e,"grid"),t.x<0)switch(r){case"stop":{t={...t,x:0};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{t=Be(e,{x:0,y:t.y},{x:t.x,y:0},"wrap");break}}if(t.y<0)switch(r){case"stop":{t={...t,y:0};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{t={...t,y:e.rows+t.y};break}}if(t.x>=e.cols)switch(r){case"stop":{t={...t,x:e.cols-1};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{t={...t,x:t.x%e.cols};break}}if(t.y>=e.rows)switch(r){case"stop":{t={...t,y:e.rows-1};break}case"unbounded":throw new Error("unbounded not supported");case"undefined":return;case"wrap":{t={...t,y:t.y%e.rows};break}}return t.y*e.cols+t.x},_s=(e,t)=>{let r=0;return r=typeof e=="number"?e:e.cols,b(Q(r,"aboveZero","colsOrGrid")),{x:t%r,y:Math.floor(t/r)}},Bs=(e,t)=>{if(t===void 0||e===void 0)return!1;if("rows"in e&&"cols"in e)if("rows"in t&&"cols"in t){if(e.rows!==t.rows||e.cols!==t.cols)return!1}else return!1;if("size"in e)if("size"in t){if(e.size!==t.size)return!1}else return!1;return!0},Kr=(e,t)=>t===void 0||e===void 0?!1:e.x===t.x&&e.y===t.y,ht=e=>Eo(e),Ds=e=>!(e===void 0||e[1]===void 0),xt=(e,t,r,n)=>{const o=Wr(e,t,n,r);return Object.entries(o).filter(i=>Ds(i))},Wr=(e,t,r="undefined",n)=>{const o=n??De,s=o.map(i=>Be(e,t,lt(i),r));return Ht(o,s)},Js=(e,t)=>{const r=[];for(let n=0;n<e.rows;n++)if(r[n]=Array.from({length:e.cols}),t)for(let o=0;o<e.cols;o++)r[n][o]=t;return r},en=e=>`Cell{${e.x},${e.y}}`;function*Gs(e){for(const t of ce(e))yield tn(e,t)}const Vs=(e,t)=>{const r=e.size;if(b(p(r,"positive","grid.size")),t.x<0||t.y<0)return;const n=Math.floor(t.x/r),o=Math.floor(t.y/r);if(!(n>=e.cols)&&!(o>=e.rows))return{x:n,y:o}},tn=(e,t)=>{k(t);const r=e.size,n=t.x*r,o=t.y*r;return U({x:n,y:o},r,r)},Us=(e,t)=>{k(t);const r=e.size,n=t.x*r,o=t.y*r;return Object.freeze({x:n+r/2,y:o+r/2})},rn=()=>({select:e=>e[0]}),nn=()=>({select:e=>e.at(0),getNeighbours:(e,t)=>xt(e,t,De,"undefined")}),on=(e={})=>{const t=e.reversed??!1;return{select:r=>r.find(n=>n[0]===(t?"n":"s")),getNeighbours:(r,n)=>(t?n.y>0?n={x:n.x,y:n.y-1}:n.x===0?n={x:r.cols-1,y:r.rows-1}:n={x:n.x-1,y:r.rows-1}:n.y<r.rows-1?n={x:n.x,y:n.y+1}:n.x<r.cols-1?n={x:n.x+1,y:0}:n={x:0,y:0},[[t?"n":"s",n]])}},sn=()=>({select:e=>e.at(-1)}),an=()=>({getNeighbours:(e,t)=>{const r=[];for(const n of ce(e,t))r.push(["n",n]);return r},select:ht}),cn=()=>({select:ht}),un=(e={})=>{const t=e.reversed??!1;return{select:r=>r.find(n=>n[0]===(t?"w":"e")),getNeighbours:(r,n)=>(t?n.x>0?n={x:n.x-1,y:n.y}:n.y>0?n={x:r.cols-1,y:n.y-1}:n={x:r.cols-1,y:r.rows-1}:n.x<r.rows-1?n={x:n.x+1,y:n.y}:n.y<r.rows-1?n={x:0,y:n.y+1}:n={x:0,y:0},[[t?"w":"e",n]])}};function*fn(e,t,r={}){ee(t,"grid");const n=r.start??{x:0,y:0};k(n,"opts.start",t);const o=r.visited??vo(en),s=e.getNeighbours??((u,f)=>xt(u,f,Zr,"undefined"));let i=[n],a=[],c;for(;i.length>0;){if(c===void 0){const u=i.pop();if(u===void 0)break;c=u}if(!o.has(c)){o.add(c),yield c;const u=s(t,c).filter(f=>f[1]===void 0?!1:!o.has(f[1]));if(u.length===0)c!==void 0&&(i=i.filter(f=>Kr(f,c)));else for(const f of u)f!==void 0&&f[1]!==void 0&&a.push(f)}if(a=a.filter(u=>!o.has(u[1])),a.length===0)c=void 0;else{const u=e.select(a);u!==void 0&&(i.push(u[1]),c=u[1])}}}const Ys=(e,t,r={x:0,y:0},n=1)=>{ee(e,"grid"),k(r,"start"),b(Q(n,"","resolution"));const o=[];let s=0,i=0;for(const a of t(e,{start:r,boundsWrap:"undefined"}))s++,s%n===0&&o.push(a);return(a,c=!1)=>(b(Q(a,"","step")),c?i=a:i+=a,o.at(i%o.length))};var dn={};h(dn,{breadthLogic:()=>rn,columnLogic:()=>on,create:()=>Hs,depthLogic:()=>sn,neighboursLogic:()=>nn,randomContiguousLogic:()=>cn,randomLogic:()=>an,rowLogic:()=>un,stepper:()=>Ys,visitByNeighbours:()=>fn,withLogic:()=>G});const Hs=(e,t={})=>{switch(e){case"random-contiguous":return G(cn(),t);case"random":return G(an(),t);case"depth":return G(sn(),t);case"breadth":return G(rn(),t);case"neighbours":return G(nn(),t);case"row":return G(un(t),t);case"column":return G(on(t),t);default:throw new TypeError(`Param 'type' unknown. Value: ${e}`)}},G=(e,t={})=>(r,n={})=>fn(e,r,{...t,...n});var Xs={};h(Xs,{Array1d:()=>Tr,Array2d:()=>Dr,As:()=>Xr,By:()=>Qr,Visit:()=>dn,allDirections:()=>De,applyBounds:()=>pe,asRectangles:()=>Gs,cellAtPoint:()=>Vs,cellEquals:()=>Kr,cellFromIndex:()=>_s,cellKeyString:()=>en,cellMiddle:()=>Us,crossDirections:()=>Zr,getLine:()=>qs,getVectorFromCardinal:()=>lt,guardCell:()=>k,guardGrid:()=>ee,indexFromCell:()=>Je,inside:()=>Cr,isCell:()=>Ns,isEqual:()=>Bs,neighbourList:()=>xt,neighbours:()=>Wr,offset:()=>Be,offsetCardinals:()=>Ls,randomNeighbour:()=>ht,rectangleForCell:()=>tn,simpleLine:()=>Is,toArray2d:()=>Js,values:()=>Hr});function Qe(e,t,r,n){if(y(e)){if(typeof t=="number"&&r!==void 0)b(p(t,"positive","width"),p(r,"positive","height"));else{if(!B(t))throw new Error("Expected second parameter to be a rect");r=t.height,t=t.width}return Object.freeze({x:e.x/t,y:e.y/r})}else{if(b(p(e,"positive","x")),typeof t!="number")throw new TypeError("Expecting second parameter to be a number (width)");if(typeof r!="number")throw new TypeError("Expecting third parameter to be a number (height)");if(b(p(t,"positive","y")),b(p(r,"positive","width")),n===void 0)throw new Error("Expected height parameter");return b(p(n,"positive","height")),Object.freeze({x:e/r,y:t/n})}}const wt=(e,t)=>{const r=n=>{const{a:o,b:s}=n,i={x:s.x-o.x,y:s.y-o.y},a={x:t.x-o.x,y:t.y-o.y},c=i.x*i.x+i.y*i.y;let u=a.x*i.x+a.y*i.y;const f=Math.min(1,Math.max(0,u/c));return u=(s.x-o.x)*(t.y-o.y)-(s.y-o.y)*(t.x-o.x),{x:o.x+i.x*f,y:o.y+i.y*f}};if(Array.isArray(e)){const n=e.map(s=>r(s)),o=n.map(s=>x(s,t));return Object.freeze(n[Yt(...o)])}else return Object.freeze(r(e))},Te=(e,t)=>{if(be(e,"line"),d(t,"point"),z(e)===0)return z(e.a,t);const r=wt(e,t);return z(r,t)},yn=e=>({x:e.b.x-e.a.x,y:e.b.y-e.a.y}),ln=e=>{const t=z(e),r=yn(e);return{x:r.x/t,y:r.y/t}},hn=(e,t)=>{const r=yn(e),n=ln(e),o={x:e.a.x-n.y*t,y:e.a.y+n.x*t};return{a:o,b:{x:o.x+r.x,y:o.y+r.y}}},xn=(e,t,r=0)=>{const n=C(r,e),o=ln(e);return{x:n.x-o.y*t,y:n.y+o.x*t}},wn=e=>we(e.a,e.b);function ke(e,t,r,n,o,s){const[i,a]=xe(e,t,r,n,o,s);if(d(i,"a"),d(a,"b"),a.x===0)throw new TypeError("Cannot divide by zero (b.x is 0)");if(a.y===0)throw new TypeError("Cannot divide by zero (b.y is 0)");const c={x:i.x/a.x,y:i.y/a.y};if(l(i)||l(a)){if(a.z===0)throw new TypeError("Cannot divide by zero (b.z is 0)");c.z=(i.z??0)/(a.z??0)}return Object.freeze(c)}function Zs(e,t,r){const n=O(e,t,r);return Kt(n,"divisor"),(o,s,i)=>{const a=O(o,s,i);return typeof a.z>"u"?Object.freeze({x:a.x/n.x,y:a.y/n.y}):Object.freeze({x:a.x/n.x,y:a.y/n.y,z:a.z/(n.z??1)})}}const mn=(e,t)=>Object.freeze({...e,a:ke(e.a,t),b:ke(e.b,t)}),bn=(e,t,r,n)=>{if(Number.isNaN(e))throw new Error("x1 is NaN");if(Number.isNaN(r))throw new Error("x2 is NaN");if(Number.isNaN(t))throw new Error("y1 is NaN");if(Number.isNaN(n))throw new Error("y2 is NaN");return me({x:e,y:t},{x:r,y:n})},Qs=e=>{if(!Array.isArray(e))throw new Error("arr parameter is not an array");if(e.length!==4)throw new Error("array is expected to have length four");return bn(e[0],e[1],e[2],e[3])},Ks=(e={x:.5,y:.5},t=1,r=0,n=.5)=>{const o=t*n,s=t*(1-n),i=E(o,$o(r),e),a=E(s,r,e);return Object.freeze({a:i,b:a})},gn=(e,t)=>{const[r,n]=Ie(e,t);return C(.5,r,n)},pn=(e,t)=>{const r=x(e.a,t),n=z(e);return r/n},zn=(e,t)=>Object.freeze({...e,a:H(e.a,t),b:H(e.b,t)});function Ws(e){if(l(e))return Object.freeze({...e,x:Math.abs(e.x),y:Math.abs(e.y),z:Math.abs(e.z)});if(y(e))return Object.freeze({...e,x:Math.abs(e.x),y:Math.abs(e.y)});throw new TypeError("Param 'pt' is not a point")}function ei(e,t){return d(e,"pt"),l(e)?Object.freeze({...e,x:t(e.x,"x"),y:t(e.y,"y"),z:t(e.z,"z")}):Object.freeze({...e,x:t(e.x,"x"),y:t(e.y,"y")})}function ti(e,t={}){let r,n,o;switch(e){case"moving-average-light":{const s=t.scaling??3;r=Xe(s),n=Xe(s),o=Xe(s);break}default:throw new Error(`Unknown averaging kind '${e}'. Expected: 'moving-average-light'`)}return s=>{const i=r(s.x),a=n(s.y);if(l(s)){const c=o(s.z);return Object.freeze({x:i,y:a,z:c})}else return Object.freeze({x:i,y:a})}}const En=(...e)=>{if(!Array.isArray(e))throw new Error("Expected list of points");const t=e.reduce((r,n)=>{if(n===void 0)return r;if(Array.isArray(n))throw new TypeError("'points' list contains an array. Did you mean: centroid(...myPoints)?");if(!y(n))throw new Error(`'points' contains something which is not a point: ${JSON.stringify(n)}`);return{x:r.x+n.x,y:r.y+n.y}},{x:0,y:0});return Object.freeze({x:t.x/e.length,y:t.y/e.length})};function ri(e,t=0,r=1){return l(e)?Object.freeze({x:fe(e.x,t,r),y:fe(e.y,t,r),z:fe(e.z,t,r)}):Object.freeze({x:fe(e.x,t,r),y:fe(e.y,t,r)})}const ni=(e,t)=>e.x<t.x&&e.y<t.y?-2:e.x>t.x&&e.y>t.y?2:e.x<t.x||e.y<t.y?-1:e.x>t.x||e.y>t.y?1:e.x===t.x&&e.x===t.y?0:NaN,vn=(e,t)=>e.x===t.x?0:e.x<t.x?-1:1,oi=(e,t)=>e.y===t.y?0:e.y<t.y?-1:1,si=(e,t)=>e.z===t.z?0:e.z<t.z?-1:1,ii=(...e)=>{const t=[...e].sort(vn);if(t.length===1)return t;const r=s=>{const i=[];for(const a of s){for(;i.length>=2;){const c=i.at(-1),u=i.at(-2);if((c.x-u.x)*(a.y-u.y)>=(c.y-u.y)*(a.x-u.x))i.pop();else break}i.push(a)}return i.pop(),i},n=r(t),o=r(t.reverse());return n.length===1&&o.length===1&&R(o[0],n[0])?n:[...n,...o]};function Ee(e,t,r){F(e,"rect");let n=0,o=0;if(typeof t=="number"){if(r===void 0)throw new Error("x and y coordinate needed");n=t,o=r}else n=t.x,o=t.y;if(g(e)){if(n-e.x>e.width||n<e.x||o-e.y>e.height||o<e.y)return!1}else if(n>e.width||n<0||o>e.height||o<0)return!1;return!0}const $n=(e,t)=>{if(!T(e))throw new Error("a parameter should be RectPositioned");if(m(t))return jr(t,e);if(y(t))return Ee(e,t);throw new Error(`Unknown shape for b: ${JSON.stringify(t)}`)},Ge=(e,t)=>(F(e),t===void 0&&y(e)?t=e:t===void 0&&(t={x:0,y:0}),st(e,t),Object.freeze({x:t.x+e.width/2,y:t.y+e.height/2})),mt=(e,t)=>{if(it(e,"rect"),d(t,"pt"),Ee(e,t))return 0;const r=Math.max(e.x-t.x,0,t.x-e.x+e.width),n=Math.max(e.y-t.y,0,t.y-e.y+e.height);return Math.hypot(r,n)},ai=(e,t)=>x(Ge(e),t),ci=(e,t)=>{if(T(t))return mt(t,e);if(m(t))return ut(t,e);if(y(t))return x(e,t);throw new Error("Unknown shape")},ui=(e,t)=>{if(T(t))return mt(t,e);if(m(t))return ut(t,e);if(y(t))return x(e,t);throw new Error("Unknown shape")},Pn=e=>[e.x,e.y],Nn=(...e)=>{const t=e.map(r=>Pn(r));return go(t)};function fi(e,t,r){if(Array.isArray(e)){if(e.length===3)return Object.freeze({x:e[0],y:e[1],z:e[2]});if(e.length===2)return Object.freeze({x:e[0],y:e[1]});throw new Error(`Expected array of length two or three, got ${e.length}`)}else{if(e===void 0)throw new Error("Requires an array of [x,y] or x,y parameters at least");if(Number.isNaN(e))throw new Error("x is NaN");if(t===void 0)throw new Error("Param 'y' is missing");if(Number.isNaN(t))throw new Error("y is NaN");return Object.freeze(r===void 0?{x:e,y:t}:{x:e,y:t,z:r})}}const di=e=>{if(typeof e!="string")throw new TypeError(`Param 'str' ought to be a string. Got: ${typeof e}`);const t=e.indexOf(","),r=Number.parseFloat(e.substring(0,t)),n=e.indexOf(",",t+1);if(n>0){const o=Number.parseFloat(e.substring(t+1,n-t+2)),s=Number.parseFloat(e.substring(n+1));return{x:r,y:o,z:s}}else{const o=Number.parseFloat(e.substring(t+1));return{x:r,y:o}}},bt=(...e)=>{const t=[];if(Array.isArray(e[0]))for(const r of e){if(r.length%2!==0)throw new Error("coords array should be even-numbered");t.push(Object.freeze({x:r[0],y:r[1]}))}else{if(e.length%2!==0)throw new Error("Expected even number of elements: [x,y,x,y...]");for(let r=0;r<e.length;r+=2)t.push(Object.freeze({x:e[r],y:e[r+1]}))}return t},yi=(e,t,r,n=!1)=>C(e,t,r,n),li=(e,t="both")=>{switch(t){case"both":return l(e)?Object.freeze({...e,x:e.x*-1,y:e.y*-1,z:e.z*-1}):Object.freeze({...e,x:e.x*-1,y:e.y*-1});case"x":return Object.freeze({...e,x:e.x*-1});case"y":return Object.freeze({...e,y:e.y*-1});case"z":if(l(e))return Object.freeze({...e,z:e.z*-1});throw new Error("pt parameter is missing z");default:throw new Error("Unknown what parameter. Expecting 'both', 'x' or 'y'")}},Mn=(e,t=1,r=0)=>{const n=x(e);let o=1;return n>t?o=t/n:n<r&&(o=r/n),o===1?e:he(e,o,o)},hi=(...e)=>I((t,r)=>t.x<=r.x?t:r,...e),xi=(...e)=>I((t,r)=>t.x>=r.x?t:r,...e),wi=(e,t)=>{if(y(e)&&(t=e.y,e=e.x),t===void 0)throw new Error("Expected y");return Math.hypot(e,t)},jn=(e,t)=>{const r=O(e,t),n=wi(r);return n===0?Y:Object.freeze({...r,x:r.x/n,y:r.y/n})},mi=(e,...t)=>On(...t)(e),On=(...e)=>t=>e.reduce((r,n)=>n(r),t);var bi={};h(bi,{clampMagnitude:()=>Ni,divide:()=>Si,dotProduct:()=>Pi,fromLineCartesian:()=>Rn,fromLinePolar:()=>An,fromPointPolar:()=>Sn,fromRadians:()=>pi,multiply:()=>Oi,normalise:()=>Ei,quadrantOffsetAngle:()=>vi,subtract:()=>ji,sum:()=>Mi,toCartesian:()=>D,toPolar:()=>ve,toRadians:()=>zi,toString:()=>$i});const gi=Object.freeze({x:0,y:0}),Se=Math.PI*2,Fe=Math.PI,pi=e=>Object.freeze({x:Math.cos(e),y:Math.sin(e)}),zi=e=>Math.atan2(e.y,e.x),Sn=(e,t="",r=gi)=>{e=P(e,r);let n=Math.atan2(e.y,e.x);return t==="unipolar"&&n<0?n+=Se:t==="bipolar"&&(n>Fe?n-=Se:n<=-Fe&&(n+=Se)),Object.freeze({distance:x(e),angleRadian:n})},Rn=e=>P(e.b,e.a),An=e=>{be(e,"line");const t=P(e.b,e.a);return Sn(t)},S=e=>!!rt(e),W=e=>!!y(e),Ei=e=>{if(S(e))return nr(e);if(W(e))return jn(e);throw new Error(`Expected polar/cartesian vector. Got: ${e}`)},vi=e=>e.x>=0&&e.y>=0?0:e.x<0&&e.y>=0||e.x<0&&e.y<0?Fe:Se,ve=(e,t=Y)=>{if(S(e))return e;if(W(e))return nt(e,t);throw new Error(`Expected polar/cartesian vector. Got: ${e}`)},D=e=>{if(S(e))return rr(e);if(W(e))return e;throw new Error(`Expected polar/cartesian vector. Got: ${e}`)},$i=(e,t)=>{if(S(e))return tr(e,t);if(W(e))return le(e,t);throw new Error(`Expected polar/cartesian vector. Got: ${e}`)},Pi=(e,t)=>{if(S(e)&&S(t))return sr(e,t);if(W(e)&&W(t))return Nn(e,t);throw new Error("Expected two polar/Cartesian vectors.")},Ni=(e,t=1,r=0)=>{if(S(e))return or(e,t,r);if(W(e))return Mn(e,t,r);throw new Error("Expected either polar or Cartesian vector")},Mi=(e,t)=>{const r=S(e);e=D(e),t=D(t);const n=H(e,t);return r?ve(n):n},ji=(e,t)=>{const r=S(e);e=D(e),t=D(t);const n=P(e,t);return r?ve(n):n},Oi=(e,t)=>{const r=S(e);e=D(e),t=D(t);const n=he(e,t);return r?ve(n):n},Si=(e,t)=>{const r=S(e);e=D(e),t=D(t);const n=ke(e,t);return r?ve(n):n},$e=(...e)=>{const t=[];let r=e[0];for(let n=1;n<e.length;n++)t.push(me(r,e[n])),r=e[n];return t},ye=(e,t)=>{const r=O(e,t);let n=0,o=0,s=0,i=performance.now(),a=r;return(u,f)=>{const w=O(u,f);n+=w.x,o+=w.y,s++;const L=x(w,r),Oe=x(w,a),qt=performance.now(),ho=Oe/(qt-i);return i=qt,a=w,Object.freeze({angle:V(w,r),distanceFromStart:L,distanceFromLast:Oe,speed:ho,centroid:En(w,r),average:{x:n/s,y:o/s}})}};var Cn=class extends po{initialRelation;markRelation;lastResult;constructor(e={}){super(e)}onTrimmed(e){this.initialRelation=void 0}onReset(){super.onReset(),this.lastResult=void 0,this.initialRelation=void 0,this.markRelation=void 0}seenEvent(e){if("getCoalescedEvents"in e){const r=e.getCoalescedEvents().map(n=>({x:n.clientX,y:n.clientY}));return this.seen(...r)}else return this.seen({x:e.clientX,y:e.clientY})}mark(){this.markRelation=ye(this.last)}computeResults(e){const t=this.last,r=this.values.at(-2);if(this.initialRelation===void 0&&this.initial)this.initialRelation=ye(this.initial);else if(this.initialRelation===void 0)throw new Error("Bug: No initialRelation, and this.inital is undefined?");const n=ye(r===void 0?t:r),o=this.initialRelation(t),s=this.markRelation!==void 0?this.markRelation(t):void 0,i=r===void 0?0:z(r,t)/(t.at-r.at),a={...n(t),speed:i},c={fromInitial:o,fromLast:a,fromMark:s,values:[...this.values]};return this.lastResult=c,c}get line(){return this.values.length===1?[]:$e(...this.values)}get vectorPolar(){return An(this.lineStartEnd)}get vectorCartesian(){return Rn(this.lineStartEnd)}get lineStartEnd(){const e=this.initial;return this.values.length<2||!e?_n:{a:e,b:this.last}}distanceFromStart(){const e=this.initial;return this.values.length>=2&&e!==void 0?x(e,this.last):0}difference(){const e=this.initial;return this.values.length>=2&&e!==void 0?P(this.last,e):ir}angleFromStart(){const e=this.initial;if(e!==void 0&&this.values.length>2)return V(e,this.last)}get length(){if(this.values.length===1)return 0;const e=this.line;return z(e)}get x(){return this.last.x}get y(){return this.last.y}get z(){return this.last.z}},Ri=class extends zo{constructor(e={}){super((t,r)=>{if(r===void 0)throw new Error("Requires start point");const n=new Cn({...e,id:t});return n.seen(r),n})}seenEvent(e){if("getCoalescedEvents"in e){const r=e.getCoalescedEvents().map(n=>super.seen(n.pointerId.toString(),n));return Promise.all(r)}else return Promise.all([super.seen(e.pointerId.toString(),e)])}};const Ai=(e,t,r)=>{const n=P(e,t),o=P(r,t);return l(n)&&l(o)?(n.x*o.x+n.y*o.y+n.z*o.z)/(o.x*o.x+o.y*o.y+o.z*o.z):(n.x*o.x+n.y*o.y)/(o.x*o.x+o.y*o.y)},Ke=(e,t,r)=>{const n=Math.cos(r)*t+e.x,o=Math.sin(r)*t+e.y;return{x:n,y:o}};function Ci(e,t,r=!0){if(d(e,"pt"),d(t,"snap"),l(e)){if(!l(t))throw new TypeError("Param 'snap' is missing 'z' field");return Object.freeze({x:ue(e.x,t.x,r),y:ue(e.y,t.y,r),z:ue(e.z,t.z,r)})}return Object.freeze({x:ue(e.x,t.x,r),y:ue(e.y,t.y,r)})}const Ti=e=>(typeof e>"u"&&(e=Math.random),Object.freeze({x:e(),y:e()})),ki=e=>(typeof e>"u"&&(e=Math.random),Object.freeze({x:e(),y:e(),z:e()})),Tn=(e,t,r)=>{r===void 0&&(r={x:0,y:0});let n=r;for(const o of e)n=t(o,n);return n};function A(e,t,r){typeof r>"u"&&(r={x:0,y:0}),d(r,"origin"),b(p(t,"","amountRadian"));const n=Array.isArray(e);if(t===0)return e;n||(e=[e]);const o=e;for(const[c,u]of o.entries())d(u,`pt[${c}]`);const a=o.map(c=>nt(c,r)).map(c=>er(c,t)).map(c=>E(c,r));return n?a:a[0]}const Fi=(e,t)=>{const r=[[Math.cos(t),-Math.sin(t)],[Math.sin(t),Math.cos(t)]],n=[];for(const[o,s]of e.entries())n[o]=[r[0][0]*s[0]+r[0][1]*s[1],r[1][0]*s[0]+r[1][1]*s[1]];return n},Li=(e,t,r)=>{const n=O(e,t);return r=r??t,r=r??2,Object.freeze({...n,x:Bt(r,n.x),y:Bt(r,n.y)})},qi=(e,t,r)=>{d(e,"a"),d(t,"b"),typeof r=="number"?(b(p(r,"positive","maxRange")),r={x:r,y:r}):d(r,"maxRange");const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);return n<=r.x&&o<=r.y},Ii=(e,t,r)=>(t===void 0&&(t={x:1,y:1}),r===void 0&&(r={x:0,y:0}),d(e,"pt"),d(t,"ptMax"),d(r,"ptMin"),Object.freeze({x:_t(e.x,r.x,t.x),y:_t(e.y,r.y,t.y)}));var _i={};h(_i,{Empty:()=>Y,Empty3d:()=>ko,Placeholder:()=>ir,Placeholder3d:()=>_o,PointTracker:()=>Cn,PointsTracker:()=>Ri,Unit:()=>To,Unit3d:()=>Fo,abs:()=>Ws,angleRadian:()=>V,angleRadianCircle:()=>Bo,apply:()=>ei,averager:()=>ti,bbox:()=>we,bbox3d:()=>jo,centroid:()=>En,clamp:()=>ri,clampMagnitude:()=>Mn,compare:()=>ni,compareByX:()=>vn,compareByY:()=>oi,compareByZ:()=>si,convexHull:()=>ii,distance:()=>x,distanceToCenter:()=>ci,distanceToExterior:()=>ui,divide:()=>ke,divider:()=>Zs,dotProduct:()=>Nn,findMinimum:()=>I,from:()=>fi,fromNumbers:()=>bt,fromString:()=>di,getPointParameter:()=>O,getTwoPointParameters:()=>xe,guard:()=>d,guardNonZeroPoint:()=>Kt,interpolate:()=>yi,invert:()=>li,isEmpty:()=>re,isEqual:()=>R,isNaN:()=>Mo,isNull:()=>No,isPlaceholder:()=>ne,isPoint:()=>y,isPoint3d:()=>l,leftmost:()=>hi,multiply:()=>he,multiplyScalar:()=>Sr,normalise:()=>jn,normaliseByRect:()=>Qe,pipeline:()=>On,pipelineApply:()=>mi,progressBetween:()=>Ai,project:()=>Ke,quantiseEvery:()=>Ci,random:()=>Ti,random3d:()=>ki,reduce:()=>Tn,relation:()=>ye,rightmost:()=>xi,rotate:()=>A,rotatePointArray:()=>Fi,round:()=>Li,subtract:()=>P,sum:()=>H,test:()=>Qt,to2d:()=>Jo,to3d:()=>Go,toArray:()=>Pn,toIntegerValues:()=>Do,toString:()=>le,withinRange:()=>qi,wrap:()=>Ii});const kn=(e,t,r)=>typeof t>"u"||t===0?e:(typeof r>"u"&&(r=.5),typeof r=="number"&&(r=C(r,e.a,e.b)),Object.freeze({...e,a:A(e.a,t,r),b:A(e.b,t,r)})),Fn=(e,t)=>R(e.a,t.a)&&R(e.b,t.b),Ln=(e,t)=>Object.freeze({...e,a:he(e.a,t),b:he(e.b,t)}),qn=(e,t)=>Object.freeze({...e,a:P(e.a,t),b:P(e.b,t)});function In(e,t){if(J(e))be(e,"a"),t=e.b,e=e.a;else if(t===void 0)throw new Error("Expect second point if first is a point");return le(e)+"-"+le(t)}const q=e=>{const{a:t,b:r}=e;return Object.freeze({...e,length:()=>z(t,r),interpolate:n=>C(n,t,r),relativePosition:n=>pn(e,n),bbox:()=>wn(e),toString:()=>In(t,r),toFlatArray:()=>Gn(t,r),toSvgString:()=>Vn(t,r),toPoints:()=>[t,r],rotate:(n,o)=>q(kn(e,n,o)),nearest:n=>wt(e,n),sum:n=>q(zn(e,n)),divide:n=>q(mn(e,n)),multiply:n=>q(Ln(e,n)),subtract:n=>q(qn(e,n)),midpoint:()=>gn(t,r),distanceToPoint:n=>Te(e,n),parallel:n=>hn(e,n),perpendicularPoint:(n,o)=>xn(e,n,o),slope:()=>gt(e),withinRange:(n,o)=>Dn(e,n,o),isEqual:n=>Fn(e,n),apply:n=>q(Bn(e,n)),kind:"line"})},Bi=(e,t)=>q(me(e,t));var Di={};h(Di,{Empty:()=>_n,Placeholder:()=>Ji,angleRadian:()=>Ui,apply:()=>Bn,asPoints:()=>Ki,bbox:()=>wn,distance:()=>Jn,distanceSingleLine:()=>Te,divide:()=>mn,extendFromA:()=>Zi,fromFlatArray:()=>Qs,fromNumbers:()=>bn,fromPivot:()=>Ks,fromPoints:()=>me,fromPointsToPath:()=>Bi,getPointParameter:()=>Ie,guard:()=>be,interpolate:()=>C,isEmpty:()=>Gi,isEqual:()=>Fn,isLine:()=>J,isPlaceholder:()=>Vi,isPolyLine:()=>xr,joinPointsToLines:()=>$e,length:()=>z,midpoint:()=>gn,multiply:()=>Ln,nearest:()=>wt,normaliseByRect:()=>Yi,parallel:()=>hn,perpendicularPoint:()=>xn,pointAtDistance:()=>ss,pointAtX:()=>Xi,pointsOf:()=>Qi,relativePosition:()=>pn,reverse:()=>wr,rotate:()=>kn,scaleFromMidpoint:()=>Hi,slope:()=>gt,subtract:()=>qn,sum:()=>zn,toFlatArray:()=>Gn,toPath:()=>q,toString:()=>In,toSvgString:()=>Vn,withinRange:()=>Dn});const _n=Object.freeze({a:Object.freeze({x:0,y:0}),b:Object.freeze({x:0,y:0})}),Ji=Object.freeze({a:Object.freeze({x:NaN,y:NaN}),b:Object.freeze({x:NaN,y:NaN})}),Gi=e=>re(e.a)&&re(e.b),Vi=e=>ne(e.a)&&ne(e.b),Bn=(e,t)=>Object.freeze({...e,a:t(e.a),b:t(e.b)}),Ui=(e,t)=>{let r;if(J(e))r=e.a,t=e.b;else if(r=e,t===void 0)throw new Error("b point must be provided");return Math.atan2(t.y-r.y,t.x-r.x)},Yi=(e,t,r)=>Object.freeze({...e,a:Qe(e.a,t,r),b:Qe(e.b,t,r)}),Dn=(e,t,r)=>Jn(e,t)<=r,gt=(e,t)=>{let r;if(J(e))r=e.a,t=e.b;else if(r=e,t===void 0)throw new Error("b parameter required");if(t===void 0)throw new TypeError("Second point missing");return(t.y-r.y)/(t.x-r.x)},Hi=(e,t)=>{const r=C(t/2,e),n=C(.5+t/2,e);return{a:r,b:n}},Xi=(e,t)=>{const r=e.a.y+(t-e.a.x)*gt(e);return Object.freeze({x:t,y:r})},Zi=(e,t)=>{const r=z(e);return Object.freeze({...e,a:e.a,b:Object.freeze({x:e.b.x+(e.b.x-e.a.x)/r*t,y:e.b.y+(e.b.y-e.a.y)/r*t})})};function*Qi(e){const{a:t,b:r}=e;let n=Math.floor(t.x),o=Math.floor(t.y);const s=Math.floor(r.x),i=Math.floor(r.y),a=Math.abs(s-n),c=-Math.abs(i-o),u=n<s?1:-1,f=o<i?1:-1;let w=a+c;for(;yield{x:n,y:o},!(n===s&&o===i);){const L=2*w;L>=c&&(w+=c,n+=u),L<=a&&(w+=a,o+=f)}}const Jn=(e,t)=>{if(Array.isArray(e)){const r=e.map(n=>Te(n,t));return xo(r)}else return Te(e,t)},Gn=(e,t)=>{if(J(e))return[e.a.x,e.a.y,e.b.x,e.b.y];if(y(e)&&y(t))return[e.x,e.y,t.x,t.y];throw new Error("Expected single line parameter, or a and b points")};function*Ki(e){for(const t of e)yield t.a,yield t.b}const Vn=(e,t)=>[`M${e.x} ${e.y} L ${t.x} ${t.y}`],oe=(e,t)=>{const r=st(e,t);return[{x:r.x,y:r.y},{x:r.x+r.width,y:r.y},{x:r.x+r.width,y:r.y+r.height},{x:r.x,y:r.y+r.height}]},Un=function(e){if(_e(e))return e.a;if(J(e))return e.a;throw new Error(`Unknown path type ${JSON.stringify(e)}`)},We=function(e){if(_e(e))return e.b;if(J(e))return e.b;throw new Error(`Unknown path type ${JSON.stringify(e)}`)};var Wi={};h(Wi,{bbox:()=>vt,computeDimensions:()=>Pe,distanceToPoint:()=>zt,fromPaths:()=>Mt,guardContinuous:()=>Pt,interpolate:()=>pt,relativePosition:()=>Et,setSegment:()=>Yn,toString:()=>$t,toSvgString:()=>Nt});const Yn=(e,t,r)=>{const n=[...e.segments];return n[t]=r,Mt(...n)},pt=(e,t,r,n)=>{n===void 0&&(n=Pe(e));const o=t*(r?n.totalWidth:n.totalLength);let s=0;const i=r?n.widths:n.lengths;for(const[a,c]of i.entries())if(s+c>=o){let f=(o-s)/c;return f>1&&(f=1),e[a].interpolate(f)}else s+=c;return{x:0,y:0}},zt=(e,t)=>{if(e.length===0)return 0;let r=e.map((n,o)=>({path:n,index:o,distance:n.distanceToPoint(t)}));if(r=Le(r,"distance"),r.length===0)throw new Error("Could not look up distances");return r[0].distance},Et=(e,t,r,n)=>{n===void 0&&(n=Pe(e));let o=e.map((u,f)=>({path:u,index:f,distance:u.distanceToPoint(t)}));if(o=Le(o,"distance"),o.length<0)throw new Error("Point does not intersect with path");const s=o[0];if(s.distance>r)throw new Error(`Point does not intersect with path. Minimum distance: ${s.distance}, threshold: ${r}`);const i=s.path.relativePosition(t,r);let a=0;for(let u=0;u<s.index;u++)a+=n.lengths[u];a+=n.lengths[s.index]*i;const c=a/n.totalLength;return console.log(`acc: ${a} rel: ${c} on path: ${i} path: ${s.index}`),c},Pe=e=>{const t=e.map(s=>s.bbox().width),r=e.map(s=>s.length());let n=0,o=0;for(const s of r)n+=s;for(const s of t)o+=s;return{totalLength:n,totalWidth:o,widths:t,lengths:r}},vt=e=>{const r=e.map(n=>n.bbox()).flatMap(n=>oe(n));return we(...r)},$t=e=>e.map(t=>t.toString()).join(", "),Pt=e=>{let t=We(e[0]);for(let r=1;r<e.length;r++){const n=Un(e[r]);if(!R(n,t))throw new Error(`Path index ${r} does not start at prior path end. Start: ${n.x},${n.y} expected: ${t.x},${t.y}`);t=We(e[r])}},Nt=e=>e.flatMap(t=>t.toSvgString()),Mt=(...e)=>{Pt(e);const t=Pe(e);return Object.freeze({segments:e,length:()=>t.totalLength,nearest:r=>{throw new Error("not implemented")},interpolate:(r,n=!1)=>pt(e,r,n,t),relativePosition:(r,n)=>Et(e,r,n,t),distanceToPoint:r=>zt(e,r),bbox:()=>vt(e),toString:()=>$t(e),toSvgString:()=>Nt(e),kind:"compound"})};var ea={};h(ea,{bbox:()=>vt,computeDimensions:()=>Pe,distanceToPoint:()=>zt,fromPaths:()=>Mt,getEnd:()=>We,getStart:()=>Un,guardContinuous:()=>Pt,interpolate:()=>pt,relativePosition:()=>Et,setSegment:()=>Yn,toString:()=>$t,toSvgString:()=>Nt});const ta=e=>(F(e),e.height*e.width);function ra(e,t,r){let n=typeof t=="number"?t:t.width,o=typeof t=="number"?r:t.height;if(n===void 0)throw new Error("Param 'width' undefined");if(o===void 0)throw new Error("Param 'height' undefined");if(n=e(n,"width"),o=e(o,"height"),typeof t=="object")if(g(t)){const s=e(t.x,"x"),i=e(t.y,"y");return{...t,width:n,height:o,x:s,y:i}}else return{...t,width:n,height:o};return{width:n,height:o}}function Ne(e,t,r,n){if(F(t,"a"),B(r))return T(t)?Object.freeze({...t,x:e(t.x,r.width),y:e(t.y,r.height),width:e(t.width,r.width),height:e(t.height,r.height)}):Object.freeze({...t,width:e(t.width,r.width),height:e(t.height,r.height)});if(typeof r!="number")throw new TypeError(`Expected second parameter of type Rect or number. Got ${JSON.stringify(r)}`);if(typeof n!="number")throw new Error(`Expected third param as height. Got ${JSON.stringify(n)}`);return T(t)?Object.freeze({...t,x:e(t.x,r),y:e(t.y,n),width:e(t.width,r),height:e(t.height,n)}):Object.freeze({...t,width:e(t.width,r),height:e(t.height,n)})}function jt(e,t,r){return g(t)?Object.freeze({...t,x:e(t.x,r),y:e(t.y,r),width:e(t.width,r),height:e(t.height,r)}):Object.freeze({...t,width:e(t.width,r),height:e(t.height,r)})}function Ot(e,t,r){return Object.freeze({...t,width:e(t.width,r),height:e(t.height,r)})}const na=(e,t)=>{const{x:r,y:n,width:o,height:s}=e;switch(t){case"nw":return Object.freeze({x:r,y:n});case"n":return Object.freeze({x:r+o/2,y:n});case"ne":return Object.freeze({x:r+o,y:n});case"sw":return Object.freeze({x:r,y:n+s});case"s":return Object.freeze({x:r+o/2,y:n+s});case"se":return Object.freeze({x:r+o,y:n+s});case"w":return Object.freeze({x:r,y:n+s/2});case"e":return Object.freeze({x:r+o,y:n+s/2});case"center":return Object.freeze({x:r+o/2,y:n+s/2});default:throw new Error(`Unknown direction: ${t}`)}},oa=e=>{const t=Ge(e),r=e.width/2,n=e.height/2;return{relativeToAbsolute:i=>({...i,x:i.x*r+t.x,y:i.y*n+t.y}),absoluteToRelative:i=>({...i,x:(i.x-e.x)/r-1,y:(i.y-e.y)/n-1})}},St=(e,t)=>e/t;function sa(e,t,r){return Ne(St,e,t,r)}function ia(e,t){return jt(St,e,t)}function aa(e,t){return Ot(St,e,t)}const Hn=(e,t)=>{const r=oe(e,t);return $e(...r,r[0])},ca=(e,t)=>{switch(F(e),t){case"top":return y(e)?e.x:0;case"bottom":return y(e)?e.x:0;case"left":return y(e)?e.y:0;case"right":return y(e)?e.x+e.width:e.width}},ua=(e,t)=>{switch(F(e),t){case"top":return y(e)?e.y:0;case"bottom":return y(e)?e.y+e.height:e.height;case"left":return y(e)?e.y:0;case"right":return y(e)?e.y:0}},fa=Object.freeze({width:0,height:0}),da=Object.freeze({x:0,y:0,width:0,height:0}),ya=(e,...t)=>{const r=t.map(f=>f.x),n=t.map(f=>f.y);let o=Math.min(...r,e.x),s=Math.min(...n,e.y),i=Math.max(...r,e.x+e.width),a=Math.max(...n,e.y+e.height),c=Math.max(e.width,i-o),u=Math.max(e.height,a-s);return Object.freeze({...e,x:o,y:s,width:c,height:u})},la=e=>({width:e.clientWidth,height:e.clientHeight});function ha(e,t,r,n){if(r===void 0||n===void 0){if(typeof e!="number")throw new Error("width is not an number");if(typeof t!="number")throw new TypeError("height is not an number");return Object.freeze({width:e,height:t})}if(typeof e!="number")throw new Error("x is not an number");if(typeof t!="number")throw new Error("y is not an number");if(typeof r!="number")throw new Error("width is not an number");if(typeof n!="number")throw new Error("height is not an number");return Object.freeze({x:e,y:t,width:r,height:n})}function xa(e,t,r,n){if(typeof e=="number")if(typeof t=="number"){if(typeof r=="number"&&typeof n=="number")return{x:e,y:t,width:r,height:n};if(B(r))return{x:e,y:t,width:r.width,height:r.height};throw new TypeError("If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect")}else throw new TypeError("If parameter 'a' is a number, expect following parameters to be: y,w,h");else{if(T(e))return e;if(B(e)){if(typeof t=="number"&&typeof r=="number")return{width:e.width,height:e.height,x:t,y:r};if(y(t))return{width:e.width,height:e.height,x:t.x,y:t.y};throw new TypeError("If param 'a' is a Rect, expects following parameters to be x,y")}else if(y(e)){if(typeof t=="number"&&typeof r=="number")return{x:e.x,y:e.y,width:t,height:r};if(B(t))return{x:e.x,y:e.y,width:t.width,height:t.height};throw new TypeError("If parameter 'a' is a Point, expect following params to be: Rect or width,height")}}throw new TypeError("Expect a first parameter to be x,RectPositioned,Rect or Point")}const wa=(e,t)=>{if(e===void 0)throw new Error("a undefined");if(t===void 0)throw new Error("b undefined");return e.width===t.width&&e.height===t.height},ma=(e,t)=>g(e)&&g(t)?R(e,t)?e.width===t.width&&e.height===t.height:!1:!g(e)&&!g(t)?e.width===t.width&&e.height===t.height:!1,ba=e=>(it(e,"rect"),Hn(e).map(t=>z(t))),Rt=(e,t)=>e*t;function ga(e,t,r){return Ne(Rt,e,t,r)}function pa(e,t){return jt(Rt,e,t)}function za(e,t){return Ot(Rt,e,t)}const Ea=(e,t)=>{let{x:r,y:n}=t;return r<e.x?r=e.x:r>e.x+e.width&&(r=e.x+e.width),n<e.y?n=e.y:n>e.y+e.height&&(n=e.y+e.height),Object.freeze({...t,x:r,y:n})},va=Object.freeze({width:NaN,height:NaN}),$a=Object.freeze({x:NaN,y:NaN,width:NaN,height:NaN}),Pa=e=>(F(e),e.height+e.height+e.width+e.width),Na=e=>{const t=Math.max(e.width,e.height);return r=>{if(typeof r=="number")return r/t;if(l(r))return Object.freeze({...r,x:r.x/t,y:r.y/t,z:r.x/t});if(y(r))return Object.freeze({...r,x:r.x/t,y:r.y/t});throw new Error("Param 'value' is neither number nor Point")}},Ma=e=>(e??=Math.random,Object.freeze({x:e(),y:e(),width:e(),height:e()})),Xn=(e,t={})=>{const r=t.randomSource??Math.random,n=t.margin??{x:0,y:0},o=r()*(e.width-n.x-n.x),s=r()*(e.height-n.y-n.y),i={x:o+n.x,y:s+n.y};return g(e)?H(i,e):Object.freeze(i)},ja=(e,t)=>e-t;function Oa(e,t,r){return Ne(ja,e,t,r)}function Sa(e,t,r){const n=typeof t=="number"?t:t.width,o=typeof t=="number"?r:t.height;if(o===void 0)throw new Error("Expected height as third parameter");return{...e,width:e.width-n,height:e.height-o}}function Ra(e,t){let r=0,n=0;g(e)&&(r=e.x,n=e.y);let o=0,s=0;return g(t)&&(o=t.x,s=t.y),Object.freeze({...e,x:r-o,y:n-s,width:e.width-t.width,height:e.height-t.height})}const Aa=(e,t)=>e+t;function Ca(e,t,r){return Ne(Aa,e,t,r)}function Ta(e,t){let r=0,n=0;g(e)&&(r=e.x,n=e.y);let o=0,s=0;return g(t)&&(o=t.x,s=t.y),Object.freeze({...e,x:r+o,y:n+s,width:e.width+t.width,height:e.height+t.height})}function ka(e){if(g(e))return[e.x,e.y,e.width,e.height];if(B(e))return[e.width,e.height];throw new Error(`Param 'rect' is not a rectangle. Got: ${JSON.stringify(e)}`)}var Fa={};h(Fa,{Empty:()=>fa,EmptyPositioned:()=>da,Placeholder:()=>va,PlaceholderPositioned:()=>$a,applyDim:()=>Ot,applyFields:()=>ra,applyMerge:()=>Ne,applyScalar:()=>jt,area:()=>ta,cardinal:()=>na,center:()=>Ge,centerOrigin:()=>oa,corners:()=>oe,distanceFromCenter:()=>ai,distanceFromExterior:()=>mt,divide:()=>sa,divideDim:()=>aa,divideScalar:()=>ia,dividerByLargestDimension:()=>Na,edges:()=>Hn,encompass:()=>ya,fromCenter:()=>pr,fromElement:()=>la,fromNumbers:()=>ha,fromTopLeft:()=>U,getEdgeX:()=>ca,getEdgeY:()=>ua,getRectPositioned:()=>st,getRectPositionedParameter:()=>xa,guard:()=>F,guardDim:()=>K,guardPositioned:()=>it,intersectsPoint:()=>Ee,isEmpty:()=>is,isEqual:()=>ma,isEqualSize:()=>wa,isIntersecting:()=>$n,isPlaceholder:()=>as,isPositioned:()=>g,isRect:()=>B,isRectPositioned:()=>T,lengths:()=>ba,maxFromCorners:()=>Wt,multiply:()=>ga,multiplyDim:()=>za,multiplyScalar:()=>pa,nearestInternal:()=>Ea,perimeter:()=>Pa,random:()=>Ma,randomPoint:()=>Xn,subtract:()=>Oa,subtractOffset:()=>Ra,subtractSize:()=>Sa,sum:()=>Ca,sumOffset:()=>Ta,toArray:()=>ka});const La=Object.freeze({a:{x:0,y:0},b:{x:0,y:0},c:{x:0,y:0}}),qa=Object.freeze({a:{x:NaN,y:NaN},b:{x:NaN,y:NaN},c:{x:NaN,y:NaN}}),Re=(e,t=10,r=Math.PI/2)=>{e||(e=Object.freeze({x:0,y:0}));const n=Ke(e,t,Math.PI- -r/2),o=Ke(e,t,Math.PI-r/2);return{a:n,b:e,c:o}},Ia=(e,t,r={})=>{const n=r.tailLength??10,o=r.tailThickness??Math.max(n/5,5),s=r.angleRadian??0,i=r.arrowSize??Math.max(n/5,15),a=Math.PI/2;let c,u;if(t==="tip")c=Re(e,i,a),u=oe(U({x:c.a.x-n,y:e.y-o/2},n,o));else if(t==="middle"){const w=n+i/2,L=o/2;c=Re({x:e.x+i*1.2,y:e.y},i,a),u=oe(U({x:e.x-w,y:e.y-L},n+i,o))}else u=oe(U({x:e.x,y:e.y-o/2},n,o)),c=Re({x:e.x+n+i*.7,y:e.y},i,a);return A([u[0],u[1],c.a,c.b,c.c,u[2],u[3]],s,e)},M=(e,t="t")=>{if(e===void 0)throw new Error("{$name} undefined");d(e.a,t+".a"),d(e.b,t+".b"),d(e.c,t+".c")},Zn=e=>{if(e===void 0)return!1;const t=e;return!(!y(t.a)||!y(t.b)||!y(t.c))},_a=e=>re(e.a)&&re(e.b)&&re(e.c),Ba=e=>ne(e.a)&&ne(e.b)&&ne(e.c),Da=(e,t)=>R(e.a,t.a)&&R(e.b,t.b)&&R(e.c,t.c),Me=e=>{M(e);const t=Tn([e.a,e.b,e.c],(n,o)=>({x:n.x+o.x,y:n.y+o.y}));return{x:t.x/3,y:t.y/3}},Qn=(e,t={})=>{if(m(e))return Rr(e,t);if(T(e))return Xn(e,t);throw new Error("Unknown shape. Only CirclePositioned and RectPositioned are supported.")},Ja=e=>{if(e===void 0)return Object.freeze({x:.5,y:.5});if(B(e))return Ge(e);if(Zn(e))return Me(e);if(ie(e))return Er(e);throw new Error(`Unknown shape: ${JSON.stringify(e)}`)},Kn=(e,t)=>{if(m(e))return dt(e,t);if(T(e))return $n(e,t);throw new Error(`a or b are unknown shapes. a: ${JSON.stringify(e)} b: ${JSON.stringify(t)}`)},Ga=(e,t=5,r,n=Y,o)=>{b(Q(t,"positive","points"));const s=Math.PI*2/t,i=s/2,a=o?.initialAngleRadian??-Math.PI/2;r===void 0&&(r=e/2);let c=a;const u=[];for(let f=0;f<t;f++){const w=E(e,c,n),L=E(r,c-i,n),Oe=E(r,c+i,n);u.push(L,w),f+1<t&&u.push(Oe),c+=s}return u};var Va={};h(Va,{arrow:()=>Ia,center:()=>Ja,isIntersecting:()=>Kn,randomPoint:()=>Qn,starburst:()=>Ga});var Ua={};h(Ua,{fromPoints:()=>Ya,init:()=>Wn});const Ya=(e,t={})=>{const r=$e(...e);return Wn(r.map(n=>q(n)),t)},Wn=(e,t={})=>{const r=t.maxDistanceFromLine??.1;return o=>{const i=e.map((c,u)=>{const f=c.nearest(o),w=x(o,f);return{positionRelative:c.relativePosition(f,r),path:c,index:u,nearest:f,distance:w,rank:Number.MAX_SAFE_INTEGER}}).filter(c=>c.distance<=r),a=Le(i,"distance");for(let c=0;c<a.length;c++)a[c].rank=c;return a}};var eo={};h(eo,{random:()=>Ha});const Ha=(e,t,r={})=>{if(!Array.isArray(e))throw new Error("Parameter 'circles' is not an array");const n=r.attempts??2e3,o=Le(e,"radius"),s=[],i=(a,c)=>s.some(u=>dt(u,a,c));for(;o.length>0;){const a=o.pop();if(!a)break;const c={...r,margin:{x:a.radius,y:a.radius}};for(let u=0;u<n;u++){const f=Qn(t,c);if(!i(f,a.radius)){s.push(Object.freeze({...a,...f}));break}}}return s};var Xa={};h(Xa,{CirclePacking:()=>eo});var Za={};h(Za,{fromDegrees:()=>Qa});const Qa=(e,t,r=0,n=0,o=360)=>({radiusX:e,radiusY:t,rotation:te(r),startAngle:te(n),endAngle:te(o)});var Ka={};h(Ka,{rdpPerpendicularDistance:()=>tt,rdpShortestDistance:()=>et});const et=(e,t=.1)=>{const r=e[0],n=e.at(-1);if(e.length<3)return e;let o=-1,s=0;for(let i=1;i<e.length-1;i++){const a=ec(e[i],r,n);a>s&&(s=a,o=i)}if(s>t){const i=e.slice(0,o+1),a=e.slice(o),c=et(i,t),u=et(a,t);return[...c.slice(0,-1),...u]}else return[r,n]},tt=(e,t=.1)=>{const r=e[0],n=e.at(-1);if(e.length<3)return e;let o=-1,s=0;for(let i=1;i<e.length-1;i++){const a=Wa(e[i],r,n);a>s&&(s=a,o=i)}if(s>t){const i=e.slice(0,o+1),a=e.slice(o),c=tt(i,t),u=tt(a,t);return[...c.slice(0,-1),...u]}else return[r,n]};function Wa(e,t,r){let n,o,s;return t.x==r.x?n=Math.abs(e.x-t.x):(o=(r.y-t.y)/(r.x-t.x),s=t.y-o*t.x,n=Math.abs(o*e.x-e.y+s)/Math.sqrt(Math.pow(o,2)+1)),n}const ec=(e,t,r)=>{const n=x(t,r);if(n==0)return x(e,t);const o=((e.x-t.x)*(r.x-t.x)+(e.y-t.y)*(r.y-t.y))/n;return o<0?x(e,t):o>1?x(e,r):x(e,{x:t.x+o*(r.x-t.x),y:t.y+o*(r.y-t.y)})};var tc={};h(tc,{Direction:()=>rc,QuadTreeNode:()=>to,quadTree:()=>nc});let rc=(function(e){return e[e.Nw=0]="Nw",e[e.Ne=1]="Ne",e[e.Sw=2]="Sw",e[e.Se=3]="Se",e})({});const nc=(e,t=[],r={})=>{const n={maxItems:r.maxItems??4,maxLevels:r.maxLevels??4},o=new to(void 0,e,0,n);for(const s of t)o.add(s);return o};var to=class ro{#t=[];#e=[];#r;constructor(t,r,n,o){this.boundary=r,this.level=n,this.opts=o,this.#r=t}getLengthChildren(){return this.#e.length}*parents(){let t=this;for(;t.#r!==void 0;)yield t.#r,t=t.#r}getParent(){return this.#r}*children(){for(const t of this.#e)yield t}getValue(){return this.#t}getIdentity(){return this}direction(t){return this.#e[t]}add(t){if(!Kn(this.boundary,t))return!1;if(this.#e.length>0){for(const r of this.#e)r.add(t);return!0}if(this.#t.push(t),this.#t.length>this.opts.maxItems&&this.level<this.opts.maxLevels){this.#e.length===0&&this.#n();for(const r of this.#t)for(const n of this.#e)n.add(r);this.#t=[]}return!0}couldHold(t){return Ee(this.boundary,t)}#n(){const t=this.boundary.width/2,r=this.boundary.height/2,n=this.boundary.x,o=this.boundary.y,i=bt(n+t,o,n,o,n,o+r,n+t,o+r).map(a=>U(a,t,r));this.#e=i.map(a=>new ro(this,a,this.level+1,this.opts))}},oc={};h(oc,{circleRings:()=>dc,circleVogelSpiral:()=>fc,sphereFibonacci:()=>yc});const At=Math.cos,Ct=Math.sin,sc=Math.asin,Tt=Math.sqrt,ic=Math.pow,kt=Math.PI,ac=Math.PI*2,cc=kt*(3-Tt(5)),uc=(1+Tt(5))/2;function*fc(e,t={}){const r=t.maxPoints??5e3,n=t.density??.95,o=t.rotation??0,s=yt(e??{radius:1,x:0,y:0}),i=s.radius;let a=s.radius*wo(n,0,1,.3,.01);t.spacing&&(a=t.spacing);let c=0,u=0,f=0;for(;u<r&&c<i;)c=a*u**.5,f=o+u*2*kt/uc,yield Object.freeze({x:s.x+c*At(f),y:s.y+c*Ct(f)}),u++}function*dc(e,t={}){const r=t.rings??5,n=yt(e??{radius:1,x:0,y:0}),o=1/r,s=t.rotation??0;let i=1;yield Object.freeze({x:n.x,y:n.y});for(let a=o;a<=1;a+=o){const c=Math.round(kt/sc(1/(2*i)));for(const u of mo(0,ac,c+1))yield Object.freeze({x:n.x+a*At(u+s)*n.radius,y:n.y+a*Ct(u+s)*n.radius});i++}}function*yc(e=100,t=0,r){const n=2/e,o=r??{x:0,y:0,z:0,radius:1};for(let s=0;s<e;s++){const i=s*n-1+n/2,a=Tt(1-ic(i,2)),c=(s+1)%e*cc+t,u=At(c)*a,f=Ct(c)*a;yield Object.freeze({x:o.x+u*o.radius,y:o.y+i*o.radius,z:o.z+f*o.radius})}}const je=e=>(M(e),[V(e.a,e.b),V(e.b,e.c),V(e.c,e.a)]),lc=e=>(M(e),Xt(je(e))),Ve=e=>(M(e),$e(e.a,e.b,e.c,e.a)),no=e=>{M(e,"t");const t=Ve(e).map(n=>z(n)),r=(t[0]+t[1]+t[2])/2;return Math.sqrt(r*(r-t[0])*(r-t[1])*(r-t[2]))},oo=(e,t,r)=>{const n=O(t,r),o=(c,u,f,w)=>(f.y-w.y)*c+(w.x-f.x)*u+f.x*w.y-w.x*f.y,s=o(n.x,n.y,e.b,e.c)/o(e.a.x,e.a.y,e.b,e.c),i=o(n.x,n.y,e.c,e.a)/o(e.b.x,e.b.y,e.c,e.a),a=o(n.x,n.y,e.a,e.b)/o(e.c.x,e.c.y,e.a,e.b);return{a:s,b:i,c:a}},hc=(e,t)=>{M(e);const{a:r,b:n,c:o}=e,s=r.x*t.a+n.x*t.b+o.x*t.c,i=r.y*t.a+n.y*t.b+o.y*t.c;if(r.z&&n.z&&o.z){const a=r.z*t.a+n.z*t.b+o.z*t.c;return Object.freeze({x:s,y:i,z:a})}else return Object.freeze({x:s,y:i})},so=(e,t=0)=>{const{a:r,b:n,c:o}=e,s=Math.min(r.x,n.x,o.x)-t,i=Math.max(r.x,n.x,o.x)+t,a=Math.min(r.y,n.y,o.y)-t,c=Math.max(r.y,n.y,o.y)+t;return{x:s,y:a,width:i-s,height:c-a}},xc=e=>(M(e),[e.a,e.b,e.c]),wc=(e,t,r={})=>{b(p(t,"positive","radius")),d(e,"origin");const n=r.initialAngleRadian??0,s=[n,n+N*1/3,n+N*2/3].map(i=>E(t,i,e));return Ft(s)},mc=e=>{if(!Array.isArray(e))throw new Error("coords expected as array");if(e.length!==6)throw new Error(`coords array expected with 6 elements. Got ${e.length}`);return Ft(bt(...e))},Ft=e=>{if(!Array.isArray(e))throw new Error("points expected as array");if(e.length!==3)throw new Error(`points array expected with 3 elements. Got ${e.length}`);return{a:e[0],b:e[1],c:e[2]}},io=e=>(M(e),Ve(e).reduce((t,r)=>t+z(r),0)),bc=e=>{const t=Me(e),r=io(e)/2;return{radius:no(e)/r,...t}},gc=(e,t,r)=>{const n=so(e),o=O(t,r);if(!Ee(n,o))return!1;const s=oo(e,o);return 0<=s.a&&s.a<=1&&0<=s.b&&s.b<=1&&0<=s.c&&s.c<=1},Lt=e=>(M(e),[x(e.a,e.b),x(e.b,e.c),x(e.c,e.a)]),pc=e=>{M(e);const[t,r,n]=Lt(e);return t===r&&r===n},zc=e=>{const[t,r,n]=Lt(e);return t===r||r===n||n===t},ao=e=>je(e).includes(Math.PI/2),Ec=e=>!ao(e),vc=e=>!je(e).some(t=>t>=Math.PI/2),$c=e=>je(e).some(t=>t>Math.PI/2),Pc=(e,t)=>Object.freeze({...e,a:t(e.a,"a"),b:t(e.b,"b"),c:t(e.c,"c")}),Nc=e=>{const[t,r,n]=Ve(e).map(i=>z(i)),o=Me(e);return{radius:t*r*n/Math.sqrt((t+r+n)*(-t+r+n)*(t-r+n)*(t+r-n)),...o}},Mc=(e,t,r)=>t===void 0||t===0?e:(r===void 0&&(r=Me(e)),Object.freeze({...e,a:A(e.a,t,r),b:A(e.b,t,r),c:A(e.c,t,r)})),jc=(e,t,r="b")=>{const n=r==="a"?e.a:r==="b"?e.b:e.c;return Object.freeze({a:A(e.a,t,n),b:A(e.b,t,n),c:A(e.c,t,n)})},Oc=e=>(M(e),[e.a.x,e.a.y,e.b.x,e.b.y,e.c.x,e.c.y]);var co={};h(co,{area:()=>Fc,centerFromA:()=>Rc,centerFromB:()=>Ac,centerFromC:()=>Cc,circumcircle:()=>Lc,fromCenter:()=>Sc,height:()=>Tc,incircle:()=>Ue,perimeter:()=>kc});const Vt=Math.PI*4/3,Ut=Math.PI*2/3,X=e=>typeof e=="number"?e:e.length,Sc=(e,t,r)=>{t||(t=Object.freeze({x:0,y:0}));const n=X(e)/Math.sqrt(3),o=r??Math.PI*1.5,s={x:n*Math.cos(o)+t.x,y:n*Math.sin(o)+t.y},i={x:n*Math.cos(o+Vt)+t.x,y:n*Math.sin(o+Vt)+t.y},a={x:n*Math.cos(o+Ut)+t.x,y:n*Math.sin(o+Ut)+t.y};return Object.freeze({a:i,b:s,c:a})},Rc=(e,t)=>{t||(t=Object.freeze({x:0,y:0}));const r=X(e),{radius:n}=Ue(e);return{x:t.x+r/2,y:t.y-n}},Ac=(e,t)=>{t||(t=Object.freeze({x:0,y:0}));const{radius:r}=Ue(e);return{x:t.x,y:t.y+r*2}},Cc=(e,t)=>{t||(t=Object.freeze({x:0,y:0}));const r=X(e),{radius:n}=Ue(e);return{x:t.x-r/2,y:t.y-n}},Tc=e=>Math.sqrt(3)/2*X(e),kc=e=>X(e)*3,Fc=e=>Math.pow(X(e),2)*Math.sqrt(3)/4,Lc=e=>({radius:Math.sqrt(3)/3*X(e)}),Ue=e=>({radius:Math.sqrt(3)/6*X(e)});var uo={};h(uo,{adjacentFromHypotenuse:()=>Zc,adjacentFromOpposite:()=>Qc,angleAtPointA:()=>Jc,angleAtPointB:()=>Gc,area:()=>Dc,circumcircle:()=>Uc,fromA:()=>qc,fromB:()=>Ic,fromC:()=>_c,height:()=>Ye,hypotenuseFromAdjacent:()=>Wc,hypotenuseFromOpposite:()=>Kc,hypotenuseSegments:()=>He,incircle:()=>Yc,medians:()=>Vc,oppositeFromAdjacent:()=>Hc,oppositeFromHypotenuse:()=>Xc,perimeter:()=>Bc,resolveLengths:()=>j});const qc=(e,t)=>{t||(t=Object.freeze({x:0,y:0}));const r=j(e),n=He(e),o=Ye(e),s={x:t.x,y:t.y},i={x:t.x+r.hypotenuse,y:t.y},a={x:t.x+n[1],y:t.y-o};return{a:s,b:i,c:a}},Ic=(e,t)=>{t||(t=Object.freeze({x:0,y:0}));const r=j(e),n=He(e),o=Ye(e),s={x:t.x,y:t.y},i={x:t.x-r.hypotenuse,y:t.y},a={x:t.x-n[0],y:t.y-o};return{a:i,b:s,c:a}},_c=(e,t)=>{t||(t=Object.freeze({x:0,y:0}));const r=He(e),n=Ye(e),o={x:t.x,y:t.y},s={x:t.x-r[1],y:t.y+n},i={x:t.x+r[0],y:t.y+n};return{a:s,b:i,c:o}},j=e=>{const t=e.adjacent,r=e.opposite,n=e.hypotenuse;if(t!==void 0&&r!==void 0)return{...e,adjacent:t,opposite:r,hypotenuse:Math.hypot(t,r)};if(t&&n)return{...e,adjacent:t,hypotenuse:n,opposite:n*n-t*t};if(r&&n)return{...e,hypotenuse:n,opposite:r,adjacent:n*n-r*r};if(e.opposite&&e.hypotenuse&&e.adjacent)return e;throw new Error("Missing at least two edges")},Ye=e=>{const t=j(e),r=t.opposite*t.opposite/t.hypotenuse,n=t.adjacent*t.adjacent/t.hypotenuse;return Math.sqrt(r*n)},He=e=>{const t=j(e),r=t.opposite*t.opposite/t.hypotenuse,n=t.adjacent*t.adjacent/t.hypotenuse;return[r,n]},Bc=e=>{const t=j(e);return t.adjacent+t.hypotenuse+t.opposite},Dc=e=>{const t=j(e);return t.opposite*t.adjacent/2},Jc=e=>{const t=j(e);return Math.acos((t.adjacent*t.adjacent+t.hypotenuse*t.hypotenuse-t.opposite*t.opposite)/(2*t.adjacent*t.hypotenuse))},Gc=e=>{const t=j(e);return Math.acos((t.opposite*t.opposite+t.hypotenuse*t.hypotenuse-t.adjacent*t.adjacent)/(2*t.opposite*t.hypotenuse))},Vc=e=>{const t=j(e),r=t.adjacent*t.adjacent,n=t.hypotenuse*t.hypotenuse,o=t.opposite*t.opposite;return[Math.sqrt(2*(r+n)-o)/2,Math.sqrt(2*(n+o)-r)/2,Math.sqrt(2*(o+r)-n)/2]},Uc=e=>({radius:j(e).hypotenuse/2}),Yc=e=>{const t=j(e);return{radius:(t.adjacent+t.opposite-t.hypotenuse)/2}},Hc=(e,t)=>Math.tan(e)*t,Xc=(e,t)=>Math.sin(e)*t,Zc=(e,t)=>Math.cos(e)*t,Qc=(e,t)=>t/Math.tan(e),Kc=(e,t)=>t/Math.sin(e),Wc=(e,t)=>t/Math.cos(e);var fo={};h(fo,{apexAngle:()=>eu,area:()=>nu,baseAngle:()=>yo,circumcircle:()=>ou,fromA:()=>au,fromB:()=>cu,fromC:()=>uu,fromCenter:()=>iu,height:()=>Z,incircle:()=>lo,legHeights:()=>tu,medians:()=>su,perimeter:()=>ru});const yo=e=>Math.acos(e.base/(2*e.legs)),eu=e=>{const t=e.legs*e.legs,r=e.base*e.base;return Math.acos((2*t-r)/(2*t))},Z=e=>{const t=e.legs*e.legs,r=e.base*e.base;return Math.sqrt((4*t-r)/4)},tu=e=>{const t=yo(e);return e.base*Math.sin(t)},ru=e=>2*e.legs+e.base,nu=e=>Z(e)*e.base/2,ou=e=>{const t=Z(e),r=t*t,n=e.base*e.base;return{radius:(4*r+n)/(8*t)}},lo=e=>{const t=Z(e);return{radius:e.base*t/(2*e.legs+e.base)}},su=e=>{const t=e.legs*e.legs,r=e.base*e.base,n=Math.sqrt(t+2*r)/2,o=Math.sqrt(4*t-r)/2;return[n,n,o]},iu=(e,t)=>{t||(t=Object.freeze({x:0,y:0}));const r=Z(e),n=lo(e).radius,o=r-n,s={x:t.x-e.base/2,y:t.y+n},i={x:t.x+e.base/2,y:t.y+n},a={x:t.x,y:t.y-o};return{a:s,b:i,c:a}},au=(e,t)=>{t||(t=Object.freeze({x:0,y:0}));const r=Z(e),n={x:t.x,y:t.y},o={x:t.x+e.base,y:t.y},s={x:t.x+e.base/2,y:t.y-r};return{a:n,b:o,c:s}},cu=(e,t)=>{t||(t=Object.freeze({x:0,y:0}));const r=Z(e),n={x:t.x,y:t.y},o={x:t.x-e.base,y:t.y},s={x:t.x-e.base/2,y:t.y-r};return{a:o,b:n,c:s}},uu=(e,t)=>{t||(t=Object.freeze({x:0,y:0}));const r=Z(e),n={x:t.x,y:t.y},o={x:t.x-e.base/2,y:t.y+r},s={x:t.x+e.base/2,y:t.y+r};return{a:o,b:s,c:n}};var fu={};h(fu,{Empty:()=>La,Equilateral:()=>co,Isosceles:()=>fo,Placeholder:()=>qa,Right:()=>uo,angles:()=>je,anglesDegrees:()=>lc,apply:()=>Pc,area:()=>no,barycentricCoord:()=>oo,barycentricToCartestian:()=>hc,bbox:()=>so,centroid:()=>Me,corners:()=>xc,edges:()=>Ve,equilateralFromVertex:()=>Re,fromFlatArray:()=>mc,fromPoints:()=>Ft,fromRadius:()=>wc,guard:()=>M,innerCircle:()=>bc,intersectsPoint:()=>gc,isAcute:()=>vc,isEmpty:()=>_a,isEqual:()=>Da,isEquilateral:()=>pc,isIsosceles:()=>zc,isOblique:()=>Ec,isObtuse:()=>$c,isPlaceholder:()=>Ba,isRightAngle:()=>ao,isTriangle:()=>Zn,lengths:()=>Lt,outerCircle:()=>Nc,perimeter:()=>io,rotate:()=>Mc,rotateByVertex:()=>jc,toFlatArray:()=>Oc});export{Cn as P,Ri as a,cs as b,Qo as c,Xs as g,_i as p,Xt as r,fu as t};
