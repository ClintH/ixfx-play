import{c as f,n as u,g as l,_ as h,f as S,h as P,D as E}from"./src-BeVDUOoq-B6OoJ3p3.js";const x=(r,e=0,t=1)=>{if(Number.isNaN(r))throw new Error("Param 'value' is NaN");if(Number.isNaN(e))throw new Error("Param 'min' is NaN");if(Number.isNaN(t))throw new Error("Param 'max' is NaN");return r<e?e:r>t?t:r},_=(r=0,e=1)=>{if(Number.isNaN(r))throw new Error("Param 'min' is NaN");if(Number.isNaN(e))throw new Error("Param 'max' is NaN");return t=>t>e?e:t<r?r:t};function Z(r,e,t){f(l(r,"positive","decimalPlaces"));let n;{const o=Math.pow(10,r);n=a=>Math.floor(a*o)/o}return n}var g={};h(g,{clamp:()=>c,fromScalar:()=>v,immutable:()=>N,scale:()=>$,scaleUnclamped:()=>A,toScalar:()=>b,towardZero:()=>y});const N=(r=0)=>{if(typeof r>"u")throw new Error("Start value is undefined");const e=typeof r=="number"?r:r.value;if(e>1)throw new Error("Start value cannot be larger than 1");if(e<-1)throw new Error("Start value cannot be smaller than -1");if(Number.isNaN(e))throw new Error("Start value is NaN");const t=e;return{[Symbol.toPrimitive](n){return n==="number"?t:n==="string"?t.toString():!0},value:t,towardZero:n=>N(y(t,n)),add:n=>N(c(t+n)),multiply:n=>N(c(t*n)),inverse:()=>N(-t),interpolate:(n,o)=>N(c(S(n,t,o))),asScalar:(n=1,o=0)=>b(t,n,o)}},b=(r,e=1,t=0)=>{if(typeof r!="number")throw new Error(`Expected v to be a number. Got: ${typeof r}`);if(Number.isNaN(r))throw new Error("Parameter is NaN");return P(r,-1,1,t,e)},v=r=>(f(u(r,"percentage","v")),r*2-1),$=(r,e,t)=>c(E(e,t,-1,1)(r)),A=(r,e,t)=>E(e,t,-1,1)(r),c=r=>{if(typeof r!="number")throw new Error(`Param 'bipolarValue' must be a number. Got: ${typeof r}`);if(Number.isNaN(r))throw new Error("Param 'bipolarValue' is NaN");return r>1?1:r<-1?-1:r},y=(r,e)=>{if(typeof r!="number")throw new Error(`Parameter 'v' must be a number. Got: ${typeof r}`);if(typeof e!="number")throw new Error(`Parameter 'amt' must be a number. Got: ${typeof e}`);if(e<0)throw new Error("Parameter 'amt' must be positive");return r<0?(r+=e,r>0&&(r=0)):r>0&&(r-=e,r<0&&(r=0)),r},d=(r,e,t,n,o,a)=>G(e,t,n,o)(r),G=(r,e,t,n,o,a)=>{f(u(r,"finite","inMin"),u(e,"finite","inMax"));const m=n??1,i=t??0,s=a?_(t,n):void 0;return p=>{if(r===e)return m;const w=(p-r)/(e-r)*(m-i)+i;return s?s(w):w}},T=(r,e={})=>{if(r.length===0)return{total:NaN,min:NaN,max:NaN,avg:NaN,count:NaN};const t=e.nonNumbers??"throw";let n=0,o=Number.MAX_SAFE_INTEGER,a=Number.MIN_SAFE_INTEGER,m=0;for(let i=0;i<r.length;i++){let s=r[i];if(typeof s!="number"){if(t==="ignore")continue;if(t==="throw")throw new Error(`Param 'data' contains a non-number at index: ${i.toString()}`);t==="nan"&&(s=NaN)}Number.isNaN(s)||(o=Math.min(o,s),a=Math.max(a,s),n+=s,m++)}return{total:n,max:a,min:o,count:m,avg:n/m}};var M={};h(M,{array:()=>F,stream:()=>I});const I=(r,e)=>{let t=r??Number.MAX_SAFE_INTEGER,n=e??Number.MIN_SAFE_INTEGER;return f(u(t),u(n)),o=>(f(u(o)),t=Math.min(t,o),n=Math.max(n,o),d(o,t,n))},F=(r,e,t)=>{if(!Array.isArray(r))throw new TypeError(`Param 'values' should be an array. Got: ${typeof r}`);const n=T(r),o=e??n.min,a=t??n.max;return r.map(m=>x(d(m,o,a)))};export{G as a,x as c,Z as r,d as s};
