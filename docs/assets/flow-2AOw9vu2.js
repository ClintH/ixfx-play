import{c as U,g as $,r as G,a as V,_ as z,E as F,F as O,k as B}from"./src-BeVDUOoq-B6OoJ3p3.js";import{c as _,b3 as Q,_ as k,b4 as H,e as J,b5 as R,b6 as W,af as S,b7 as A}from"./src-C7XtfIer-DYL4nwfS.js";const Z=(e,t)=>{if(e===void 0)throw new Error("callback parameter is undefined");const r=_(t);U($(r,"aboveZero","interval"));let n,a=0,o=0,i=0,l="idle";const s=()=>{a=0,globalThis.clearTimeout(n),l="idle"},u=async(h=t,f)=>new Promise((N,I)=>{a=performance.now();const T=_(h),x=$(T,"aboveZero","altTimeoutMs");if(G(x)){I(V(x));return}switch(l){case"scheduled":{c();break}}l="scheduled",n=globalThis.setTimeout(async()=>{if(l!=="scheduled"){console.warn("Timeout skipping execution since state is not 'scheduled'"),s();return}const P=f??[];o++,i++,l="running",await e(performance.now()-a,...P),l="idle",s(),N()},T)}),c=()=>{l!=="idle"&&s()};return{start:u,cancel:c,get runState(){return l},get startCount(){return o},get startCountTotal(){return i}}},oe=(e,t)=>{const r=Z(e,t);return(...n)=>{r.start(void 0,n)}},K=async(e,t={},r)=>{const n=[],a=t.rank??A;let o=Array.isArray(e)?e:[e];t.shuffle&&(o=B(o));for(let i=0;i<o.length;i++){const l=o[i];let s;if(typeof l=="function"?s=await l(r):s=l,s!==void 0&&(n.push(s),n.sort(a)),typeof t.stop<"u"&&t.stop(s,n))break}return t.filter?n.filter(t.filter):n};function*ae(e,t){const r=t.signal??void 0,n=t.count??void 0,a=t.allowUndefined??!1;let o=!1;Array.isArray(e)&&(e=e.values()),t.onStart&&t.onStart();let i=!0,l=0;try{for(;!o;){l++;const s=Q(e);typeof s>"u"&&!a?o=!0:(yield s,n!==void 0&&l>=n&&(o=!0),r?.aborted&&(o=!0))}i=!1}finally{o=!0,t.onComplete&&t.onComplete(i)}}(class M extends k{static shared=new M;_loop;_queue;constructor(){super(),this._queue=H(),this._loop=J(()=>this.processQueue(),100)}enqueue(t){const r=this._queue.enqueue(t);return this._loop.runState==="idle"&&(this.fireEvent("started",{}),this._loop.start()),r}dequeue(){return this._queue.dequeue()}async processQueue(){const t=this._queue.dequeue();if(t===void 0)return this.fireEvent("empty",{}),!1;try{await t()}catch(r){console.error(r)}}clear(){this._queue.length!==0&&(this._queue.clear(),this._loop.cancel(),this.fireEvent("empty",{}))}get isEmpty(){return this._queue.isEmpty}get length(){return this._queue.length}});const v=e=>Object.freeze({value:e.value,visited:[...e.visited],machine:e.machine}),g=(e,t)=>{const[r,n]=C(e);if(!r)throw new Error(n);const a=t??Object.keys(r.states)[0];if(typeof r.states[a]>"u")throw new TypeError(`Initial state ('${a}') not found`);const o=X(r.states);if(o===void 0)throw new Error("Could not normalise transitions");return Object.freeze({value:a,visited:[],machine:Object.freeze(Object.fromEntries(o))})},E=e=>g(e.machine),C=e=>typeof e>"u"?[void 0,"Parameter undefined"]:e===null?[void 0,"Parameter null"]:"states"in e?[e,""]:typeof e=="object"?[{states:e},""]:[void 0,`Unexpected type: ${typeof e}. Expected object`],m=e=>p(e).length===0,b=e=>{j(e);const t=e.machine[e.value];return t.length===1&&t[0].state===null?[]:t},p=e=>b(e).map(r=>r.state),q=e=>{const t=r=>{if(r===null)return{state:null};if(typeof r=="string")return{state:r};if(typeof r=="object"&&"state"in r){const n=r.state;if(typeof n!="string")throw new TypeError(`Target 'state' field is not a string. Got: ${typeof n}`);return"preconditions"in r?{state:n,preconditions:r.preconditions}:{state:n}}else throw new Error(`Unexpected type: ${typeof r}. Expected string or object with 'state' field.`)};if(Array.isArray(e)){let r=!1;const n=e.map(a=>{const o=t(a);if(!o)throw new Error("Invalid target");return r=r||o.state===null,o});if(r&&n.length>1)throw new Error("Cannot have null as an possible state");return n}else{const r=t(e);return r?[r]:void 0}},X=e=>{const t=new Map;for(const[r,n]of Object.entries(e)){if(typeof r>"u")throw new TypeError("Top-level undefined state");if(typeof n>"u")throw new TypeError(`Undefined target state for ${r}`);if(t.has(r))throw new Error(`State defined twice: ${r}`);if(r.includes(" "))throw new Error("State names cannot contain spaces");t.set(r,[])}for(const[r,n]of Object.entries(e)){const a=q(n);if(a===void 0)throw new Error("Could not normalise target");if(a!==null){const o=new Set;for(const i of a){if(o.has(i.state))throw new Error(`Target state '${i.state}' already exists for '${r}'`);if(o.add(i.state),i.state!==null&&!t.has(i.state))throw new Error(`Target state '${i.state}' is not defined as a top-level state. Defined under: '${r}'`)}t.set(r,a)}}return t},j=e=>{if(typeof e>"u")throw new TypeError("Param 'state' is undefined");if(typeof e.value!="string")throw new TypeError("Existing state is not a string")},w=(e,t)=>(j(e),y(e,t),Object.freeze({value:t,machine:e.machine,visited:F([e.visited,[e.value]])})),D=e=>{const t=b(e).at(0);if(!t||t.state===null)throw new Error(`Not possible to move to a next state from '${e.value}`);return w(e,t.state)},L=(e,t)=>{try{return y(e,t),!0}catch{return!1}},y=(e,t)=>{if(t===null)throw new Error("Cannot transition to null state");if(typeof t>"u")throw new Error("Cannot transition to undefined state");if(typeof t!="string")throw new TypeError(`Parameter 'toState' should be a string. Got: ${typeof t}`);const r=p(e);if(r.length===0)throw new Error("Machine is in terminal state");if(!r.includes(t))throw new Error(`Target state '${t}' not available at current state '${e.value}'. Possible states: ${r.join(", ")}`)},Y=(...e)=>{const t={};if(!Array.isArray(e))throw new Error("Expected array of strings");if(e.length<=2)throw new Error("Expects at least two states");for(let r=0;r<e.length;r++){const n=e[r];if(typeof n!="string")throw new TypeError(`Expected array of strings. Got type '${typeof n}' at index ${r.toString()}`);t[n]=r===e.length-1?null:e[r+1]}return t},ee=(...e)=>{const t={};if(!Array.isArray(e))throw new Error("Expected array of strings");if(e.length<2)throw new Error("Expects at least two states");for(const[r,n]of e.entries()){if(typeof n!="string")throw new TypeError(`Expected array of strings. Got type '${typeof n}' at index ${r.toString()}`);t[n]=[]}for(let r=0;r<e.length;r++){const n=t[e[r]];r===e.length-1?e.length>1?n.push(e[r-1]):t[e[r]]=null:(n.push(e[r+1]),r>0&&n.push(e[r-1]))}return t};async function te(e,t){const r=Array.isArray(t)?{handlers:t}:t,n=R(r.debug,{category:"StateMachineDriver"}),a=new Map;for(const s of r.handlers){const u=Array.isArray(s.if)?s.if:[s.if];for(const c of u){if(typeof c!="string")throw new TypeError(`Expected single or array of strings for the 'if' field. Got: '${typeof c}'.`);if(a.has(c))throw new Error(`Multiple handlers defined for state '${c}'. There should be at most one.`);a.set(c,s)}}const o={rank:(s,u)=>A(s.score??0,u.score??0),shuffle:r.shuffleHandlers??!1};let i=g(e);for(const[s]of a)if(typeof i.machine[s]>"u"&&s!=="__fallback")throw new Error(`StateMachineDriver handler references a state ('${s}') which is not defined on the machine. Therefore this handler will never run.'`);return{reset:()=>{i=E(i)},getValue:()=>i.value,run:async()=>{n(`Run. State: ${i.value}`);const s=i.value;let u=a.get(s);if(u===void 0&&(n(`  No handler for state '${s}', trying __fallback`),u=a.get("__fallback")),u===void 0){n("  No __fallback handler");return}const c=u.resultChoice==="first"?{...o,stop:d=>d?"reset"in d||"next"in d&&d.next!==void 0:!1}:o,h=await K(u.then,c,i);n(`  In state '${i.value}' results: ${h.length}. Choice: ${u.resultChoice}`);let f;switch(u.resultChoice??"highest"){case"highest":{f=h.at(-1);break}case"first":{f=h[0];break}case"lowest":{f=h.at(0);break}case"random":{f=O(h);break}default:throw new Error(`Unknown 'resultChoice' option: ${u.resultChoice}. Expected highest, first, lowest or random`)}return n(`  Chosen result: ${JSON.stringify(f)}`),f?.reset?i=E(i):f&&f.next&&(typeof f.next=="boolean"?i=D(i):(n(JSON.stringify(h)),i=w(i,f.next))),i},to:s=>(i=w(i,s),i)}}var re=class extends k{#e;#n;#i;#t=!1;#s=!1;#r=W();constructor(e,t={}){super(),this.#i=t.debug??!1,this.#e=g(e,t.initial),this.#n=v(this.#e)}#o(e){this.#s!==e&&(this.#s=e,e?(this.#t=!0,setTimeout(()=>{this.#t&&(this.#t=!1,this.fireEvent("stop",{state:this.#e.value}))},2)):this.#t=!1)}get statesPossible(){return p(this.#e)}get statesDefined(){return Object.keys(this.#e.machine)}next(){const e=p(this.#e);return e.length===0?null:(this.state=e[0],e[0])}get isDone(){return m(this.#e)}reset(){this.#o(!1),this.#e=v(this.#n),this.#r=S()}validateTransition(e){y(this.#e,e)}isValid(e){return L(this.#e,e)}set state(e){const t=this.#e.value;e!==this.#e.value&&(this.#e=w(this.#e,e),this.#i&&console.log(`StateMachine: ${t} -> ${e}`),this.#r=S(),setTimeout(()=>{this.fireEvent("change",{newState:e,priorState:t})},1),m(this.#e)&&this.#o(!0))}get state(){return this.#e.value}get changedAt(){return this.#r()}get elapsed(){return this.#r()}},ne={};z(ne,{StateMachineWithEvents:()=>re,cloneState:()=>v,driver:()=>te,fromList:()=>Y,fromListBidirectional:()=>ee,init:()=>g,isDone:()=>m,isValidTransition:()=>L,next:()=>D,normaliseTargets:()=>q,possible:()=>p,possibleTargets:()=>b,reset:()=>E,to:()=>w,validateMachine:()=>C,validateTransition:()=>y});export{oe as d,ae as r};
