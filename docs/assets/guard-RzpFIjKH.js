const n=r=>i(r)&&!Number.isNaN(r.z)?!1:Number.isNaN(r.x)||Number.isNaN(r.y);function t(r,e="Point"){if(r===void 0)throw new Error(`'${e}' is undefined. Expected {x,y} got ${JSON.stringify(r)}`);if(r===null)throw new Error(`'${e}' is null. Expected {x,y} got ${JSON.stringify(r)}`);if(r.x===void 0)throw new Error(`'${e}.x' is undefined. Expected {x,y} got ${JSON.stringify(r)}`);if(r.y===void 0)throw new Error(`'${e}.y' is undefined. Expected {x,y} got ${JSON.stringify(r)}`);if(typeof r.x!="number")throw new TypeError(`'${e}.x' must be a number. Got ${typeof r.x}`);if(typeof r.y!="number")throw new TypeError(`'${e}.y' must be a number. Got ${typeof r.y}`);if(r.z!==void 0){if(typeof r.z!="number")throw new TypeError(`${e}.z must be a number. Got: ${typeof r.z}`);if(Number.isNaN(r.z))throw new Error(`'${e}.z' is NaN. Got: ${JSON.stringify(r)}`)}if(r.x===null)throw new Error(`'${e}.x' is null`);if(r.y===null)throw new Error(`'${e}.y' is null`);if(Number.isNaN(r.x))throw new Error(`'${e}.x' is NaN`);if(Number.isNaN(r.y))throw new Error(`'${e}.y' is NaN`)}function f(r){return!(r===void 0||r===null||r.x===void 0||r.y===void 0)}const i=r=>!(r===void 0||r===null||r.x===void 0||r.y===void 0||r.z===void 0),u=r=>i(r)&&r.z!==0?!1:r.x===0&&r.y===0,s=r=>i(r)&&!Number.isNaN(r.z)?!1:Number.isNaN(r.x)&&Number.isNaN(r.y);export{f as a,s as b,n as c,u as d,t as g,i};
