import{t as Tt,_ as F,c as V,s as ar,d as ee,e as cr,f as ke,g as Vt,n as k,h as ae,j as ue,w as lr,r as ur,a as fr,i as dr,b as pr,k as mr}from"./src-BeVDUOoq-B6OoJ3p3.js";import{i as Pt,k as be,l as H,r as hr,m as vr,o as J,p as gr,q as wt,u as St,E as S,v as U,x as j,y as Fe,z as De,A as fe,B as yr,C as kt,F as br,G as Ft,H as wr,I as Sr,J as Er,K as Dt,L as Nt,M as Lt,N as Ot,O as Mt,P as Rt,c as P,Q as we,R as Ar,U as xr,S as $r,T as Ne,V as jt,W as _t,X as zt,Y as Ir,Z as Tr,_ as Vr,$ as Pr,a0 as Se,a1 as Ee,a2 as kr,a3 as Fr,a4 as Dr,a5 as qt,w as Nr,D as Ct,h as Lr,a as Bt,b as xe,d as Or,t as q,e as Le,n as Mr,f as Rr,g as Et,j as Ut,a6 as jr,a7 as _r,a8 as Wt,s as zr,a9 as qr,aa as Cr,ab as Br,ac as Ur,ad as Wr}from"./src-C7XtfIer-DYL4nwfS.js";import{a as Gr,r as Hr,m as At,c as ie}from"./records-Cei7yF1D-Dejnhz0L.js";import{i as Gt}from"./is-integer-BmMnD0ra-CbN5m7X_.js";import{s as Jr,r as C}from"./src-sHR31-XU-C1xj0KeO.js";import{t as Xr,f as xt,a as $e,b as Kr,c as Yr}from"./src-DtTSywET-tUv0MHeI.js";var Zr={};F(Zr,{applyChanges:()=>Qr,compareData:()=>Q,getField:()=>Ht,getPaths:()=>es,getPathsAndData:()=>Ve,updateByPath:()=>Oe});const $t=(e,t)=>{if(e===void 0)throw new Error("Param 'target' is undefined");if(e===null)throw new Error("Param 'target' is null");if(typeof e!="object")throw new Error(`Param 'target' is not an object (got: ${typeof e})`);if(t){const n=[];for(const r in e){const s=e[r];Tt(s)&&n.push([r,s])}return n}else return Object.entries(e)};function*Q(e,t,n={}){if(typeof e>"u"){yield{path:n.pathPrefix??"",value:t,state:"added"};return}if(typeof t>"u"){yield{path:n.pathPrefix??"",previous:e,value:void 0,state:"removed"};return}const r=n.asPartial??!1,s=n.skipInstances??new WeakSet,o=n.undefinedValueMeansRemoved??!1,i=n.pathPrefix??"",a=n.deepEntries??!1,c=n.eq??Pt,u=n.includeMissingFromA??!1,l=n.includeParents??!1;if(be(e)&&be(t)){e!==t&&(yield{path:i,value:t,previous:e,state:"change"});return}if(be(t)){yield{path:i,value:t,previous:e,state:"change"};return}const f=$t(e,a),v=new Set;for(const[g,m]of f){v.add(g);const p=g in t,d=t[g];if(typeof m=="object"&&m!==null){if(s.has(m))continue;if(s.add(m),p){if(d===void 0)throw new Error(`Pathed.compareData Value for key ${g} is undefined`);{const h=[...Q(m,d,{...n,skipInstances:s,pathPrefix:i+g+"."})];if(h.length>0){for(const y of h)yield y;l&&(yield{path:i+g,value:t[g],previous:m,state:"change"})}}}else{if(r)continue;yield{path:i+g,value:void 0,previous:m,state:"removed"}}}else{const h=i+g;if(p)d===void 0&&o?yield{path:h,previous:m,value:void 0,state:"removed"}:c(m,d,h)||(yield{path:h,previous:m,value:d,state:"change"});else{if(r)continue;yield{path:h,previous:m,value:void 0,state:"removed"}}}}if(u){const g=$t(t,a);for(const[m,p]of g)v.has(m)||(yield{path:i+m,previous:void 0,value:p,state:"added"})}}const Qr=(e,t)=>{for(const n of t)e=Oe(e,n.path,n.value);return e},Oe=(e,t,n,r=!1)=>{if(t===void 0)throw new Error("Parameter 'path' is undefined");if(typeof t!="string")throw new Error(`Parameter 'path' should be a string. Got: ${typeof t}`);if(e===void 0)throw new Error("Parameter 'target' is undefined");if(e===null)throw new Error("Parameter 'target' is null");const s=t.split(".");return Ie(e,s,n,r)},Ie=(e,t,n,r)=>{if(t.length===0){if(r)return n;if(Array.isArray(e)&&!Array.isArray(n))throw new Error(`Expected array value, got: '${JSON.stringify(n)}'. Set allowShapeChange=true to ignore.`);if(!Array.isArray(e)&&Array.isArray(n))throw new Error(`Unexpected array value, got: '${JSON.stringify(n)}'. Set allowShapeChange=true to ignore.`);if(typeof e!=typeof n)throw new Error(`Cannot reassign object type. (${typeof e} -> ${typeof n}). Set allowShapeChange=true to ignore.`);if(typeof e=="object"&&!Array.isArray(e)){const i=Gr(e,n);if(i.a.length>0)throw new Error(`New value is missing key(s): ${i.a.join(",")}`);if(i.b.length>0)throw new Error(`New value cannot add new key(s): ${i.b.join(",")}`)}return n}const s=t.shift();if(!s)return n;if(Gt(s)&&Array.isArray(e)){const i=Number.parseInt(s);if(i>=e.length&&!r)throw new Error(`Array index ${i.toString()} is outside of the existing length of ${e.length.toString()}. Use allowShapeChange=true to permit this.`);const a=[...e];return a[i]=Ie(a[i],t,n,r),a}else if(s in e){const i={...e};return i[s]=Ie(i[s],t,n,r),i}else throw new Error(`Path ${s} not found in data`)},Ht=(e,t,n=".")=>{if(typeof t!="string")throw new Error(`Param 'path' ought to be a string. Got: '${typeof t}'`);if(t.length===0)throw new Error("Param string 'path' is empty");if(e===void 0)throw new Error("Param 'object' is undefined");if(e===null)throw new Error("Param 'object' is null");const r=t.split(n);return Te(e,r,t)},Te=(e,t,n)=>{if(e===void 0)return{success:!1,error:`Param 'object' is undefined. Position: ${n}`};if(t.length===0)return{success:!1,error:`Path has been exhausted. position: ${n}`};const r=t.shift();if(!r)return{success:!1,error:`Unexpected empty split path. Position: ${n}`};if(Gt(r)&&Array.isArray(e)){const o=Number.parseInt(r);return typeof e[o]>"u"?{success:!1,error:`Index '${o}' does not exist. Length: ${e.length}. Position: ${n}`}:t.length===0?{value:e[o],success:!0}:Te(e[o],t,t.join("."))}else return typeof e=="object"&&r in e?t.length===0?{value:e[r],success:!0}:Te(e[r],t,t.join(".")):{success:!1,error:`Path '${r}' not found. Position: ${n}`}};function*es(e,t=!1){if(e==null)return;const n=Hr(e);for(const r of n){if(r.nodeValue===void 0&&t)continue;let s=r.name;r.ancestors.length>0&&(s=r.ancestors.join(".")+"."+s),yield s}}function*Ve(e,t=!1,n=Number.MAX_SAFE_INTEGER,r=""){e!==null&&e!==void 0&&(yield*Jt(e,r,t,n))}function*Jt(e,t,n=!1,r){if(!(r<=0)&&typeof e=="object")for(const s of Object.entries(e)){const o=(t.length>0?t+".":"")+s[0],i=s[1];(n&&typeof i!="object"||!n)&&(yield{path:o,value:i}),yield*Jt(i,o,n,r-1)}}function Xt(e,t={}){V(Vt(e,"aboveZero","totalTicks"));const n=t.exclusiveStart??!1,r=t.exclusiveEnd??!1,s=t.cycleLimit??Number.MAX_SAFE_INTEGER,o=n?1:0,i=r?e-1:e;let a=0,c=t.startAt??o;if(t.startAtRelative){let u=e;n&&u--,r&&u--,c=Math.round(t.startAtRelative*u)}return u=>{if(u&&(u.resetAt!==void 0&&(c=u.resetAt),u.resetAtRelative!==void 0&&(c=Math.floor(u.resetAtRelative*e))),a>=s)return 1;const l=c/e;return c++,c>i&&(a++,c=o),l}}function W(e,t={}){const n=t.cycleLimit??Number.MAX_SAFE_INTEGER,r=1;let s=t.startAt??performance.now(),o=0;const i=P(e,1e3);return t.startAtRelative&&(V(k(t.startAtRelative,"percentage","startAtRelative")),s=performance.now()-i*t.startAtRelative),a=>{if(a&&(a.resetAt!==void 0&&(s=a.resetAt,s===0&&(s=performance.now())),a.resetAtRelative!==void 0&&(V(k(a.resetAtRelative,"percentage","resetAtRelative")),s=performance.now()-i*a.resetAtRelative)),o>=n)return r;const c=performance.now(),u=c-s;return u>=i&&(o+=Math.floor(u/i),s=c,o>=n)?r:u%i/i}}function Kt(e,t={}){const n=6e4/e;return W(n,t)}function Me(e,t={}){const n=1e3/e;return W(n,t)}const Yt=(e,t={})=>{const n=e/1e3;let r=t.min??Number.MIN_SAFE_INTEGER,s=t.max??Number.MAX_SAFE_INTEGER;const o=t.clamp??!1;if(o&&t.max)throw new Error("Use either 'max' or 'clamp', not both.");o&&(s=e);let i=performance.now();return()=>{const a=performance.now(),c=a-i;i=a;const u=n*c;return u>s?s:u<r?r:u}},ts=(e,t={})=>Yt(e/60,t);var Zt={};F(Zt,{bpm:()=>Kt,elapsed:()=>W,hertz:()=>Me,perMinute:()=>ts,perSecond:()=>Yt,ticks:()=>Xt});var Qt={};F(Qt,{saw:()=>os,sine:()=>ns,sineBipolar:()=>rs,square:()=>is,triangle:()=>ss});const en=Math.PI*2;function*ns(e){if(e===void 0)throw new TypeError("Parameter 'timerOrFreq' is undefined");for(typeof e=="number"&&(e=H(e));;)yield(Math.sin(e.elapsed*en)+1)/2}function*rs(e){if(e===void 0)throw new TypeError("Parameter 'timerOrFreq' is undefined");for(typeof e=="number"&&(e=H(e));;)yield Math.sin(e.elapsed*en)}function*ss(e){for(typeof e=="number"&&(e=H(e));;){let t=e.elapsed;t<.5?t*=2:t=2-t*2,yield t}}function*os(e){if(e===void 0)throw new TypeError("Parameter 'timerOrFreq' is undefined");for(typeof e=="number"&&(e=H(e));;)yield e.elapsed}function*is(e){for(typeof e=="number"&&(e=H(e));;)yield e.elapsed<.5?0:1}const as=Math.pow,cs=1/Math.sqrt(2*Math.PI),tn=(e=.4)=>n=>{const r=cs/e;let s=-2.5,o=(n-.5)/e;o*=o,s*=o;const i=r*as(Math.E,s);return i>1?1:i<0?0:i};var Re={};F(Re,{arch:()=>fs,backIn:()=>ks,backInOut:()=>Ns,backOut:()=>Fs,bell:()=>Rs,bounceIn:()=>Ms,bounceInOut:()=>_s,bounceOut:()=>le,circIn:()=>Vs,circInOut:()=>Ds,circOut:()=>Ps,cubicIn:()=>ws,cubicOut:()=>Ss,elasticIn:()=>Ls,elasticInOut:()=>js,elasticOut:()=>Os,expoIn:()=>xs,expoInOut:()=>Ts,expoOut:()=>$s,quadIn:()=>vs,quadInOut:()=>bs,quadOut:()=>gs,quartIn:()=>Es,quartOut:()=>As,quintIn:()=>ls,quintInOut:()=>Is,quintOut:()=>us,sineIn:()=>ms,sineInOut:()=>ys,sineOut:()=>hs,smootherstep:()=>ps,smoothstep:()=>ds});const ce=Math.sqrt,E=Math.pow,nn=Math.cos,X=Math.PI,te=Math.sin,le=e=>e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375,ls=e=>e*e*e*e*e,us=e=>1-E(1-e,5),fs=e=>e*(1-e)*4,ds=e=>e*e*(3-2*e),ps=e=>(e*(e*6-15)+10)*e*e*e,ms=e=>1-nn(e*X/2),hs=e=>te(e*X/2),vs=e=>e*e,gs=e=>1-(1-e)*(1-e),ys=e=>-(nn(X*e)-1)/2,bs=e=>e<.5?2*e*e:1-E(-2*e+2,2)/2,ws=e=>e*e*e,Ss=e=>1-E(1-e,3),Es=e=>e*e*e*e,As=e=>1-E(1-e,4),xs=e=>e===0?0:E(2,10*e-10),$s=e=>e===1?1:1-E(2,-10*e),Is=e=>e<.5?16*e*e*e*e*e:1-E(-2*e+2,5)/2,Ts=e=>e===0?0:e===1?1:e<.5?E(2,20*e-10)/2:(2-E(2,-20*e+10))/2,Vs=e=>1-ce(1-E(e,2)),Ps=e=>ce(1-E(e-1,2)),ks=e=>2.70158*e*e*e-1.70158*e*e,Fs=e=>1+2.70158*E(e-1,3)+1.70158*E(e-1,2),Ds=e=>e<.5?(1-ce(1-E(2*e,2)))/2:(ce(1-E(-2*e+2,2))+1)/2,Ns=e=>{const n=2.5949095;return e<.5?E(2*e,2)*((n+1)*2*e-n)/2:(E(2*e-2,2)*((n+1)*(e*2-2)+n)+2)/2},Ls=e=>{const t=2*X/3;return e===0?0:e===1?1:-E(2,10*e-10)*te((e*10-10.75)*t)},Os=e=>{const t=2*X/3;return e===0?0:e===1?1:E(2,-10*e)*te((e*10-.75)*t)+1},Ms=e=>1-le(1-e),Rs=tn(),js=e=>{const t=2*X/4.5;return e===0?0:e===1?1:e<.5?-(E(2,20*e-10)*te((20*e-11.125)*t))/2:E(2,-20*e+10)*te((20*e-11.125)*t)/2+1},_s=e=>e<.5?(1-le(1-2*e))/2:(1+le(2*e-1))/2,zs=(e=0,t=0)=>{const r={x:ae(e,-1,1,0,1),y:ae(e,-1,1,1,0)};let s=we(Math.abs(e),S,r);e!==0&&t>0&&(e>0?s=we(t,s,{x:0,y:r.x*2}):s=we(t,s,{x:r.y*2,y:0}));const o=Ar(S,xr,s,r),i=$r(o);return a=>i(a)},rn=(e,t)=>{V(ue(e,"fn"));let n;return()=>(typeof n>"u"&&(n=zt(t,{clampValue:!0})),e(n()))},sn=(e,t)=>{V(ue(e,"fn"));const n=Ne(),r=P(t);if(r===void 0)throw new Error("Param 'duration' not provided");const s=jt(r,{timer:n,clampValue:!0});return _t(e,s)},on=(e,t)=>{V(ue(e,"fn"));let n;return()=>(typeof n>"u"&&(n=Ir(t,{clampValue:!0})),e(n()))},an=(e,t)=>{V(ue(e,"fn"));const n=Tr(),r=jt(t,{timer:n,clampValue:!0});return _t(e,r)};var cn={};F(cn,{Named:()=>Re,create:()=>qs,get:()=>de,getEasingNames:()=>Us,line:()=>zs,tickEasing:()=>Bs,ticks:()=>un,time:()=>ln,timeEasing:()=>Cs});const qs=e=>{const n=re(e.name??"quintIn")??e.fn;if(typeof n>"u")throw new Error("Either 'name' or 'fn' must be set");if("duration"in e)return ln(n,e.duration);if("ticks"in e)return un(n,e.ticks);throw new Error("Expected 'duration' or 'ticks' in options")},Cs=(e,t)=>{const n=re(e);return sn(n,t)},ln=(e,t)=>{const n=re(e);return rn(n,t)},un=(e,t)=>{const n=re(e);return on(n,t)},Bs=(e,t)=>{const n=re(e);return an(n,t)},re=e=>{const t=typeof e=="function"?e:de(e);if(typeof t>"u")throw typeof e=="string"?new Error(`Easing function not found: '${e}'`):new Error("Easing function not found");return t};let Y;const de=function(e){V(ar(e,"non-empty","easingName"));const t=fn().get(e.toLowerCase());if(t===void 0)throw new Error(`Easing not found: '${e}'`);return t};function fn(){if(Y===void 0){Y=new Map;for(const[e,t]of Object.entries(Re))Y.set(e.toLowerCase(),t);return Y}else return Y}function*Us(){yield*fn().keys()}const dn=Object.freeze({attack:["decay","release"],decay:["sustain","release"],sustain:["release"],release:["complete"],complete:null}),Z=Object.freeze({attackDuration:600,decayDuration:200,releaseDuration:800,shouldLoop:!1});var pn=class extends Vr{#e;#s;#t;#r;#n;#o=!1;#i=!1;attackDuration;decayDuration;releaseDuration;decayDurationTotal;shouldLoop;constructor(e={}){super(),this.attackDuration=e.attackDuration??Z.attackDuration,this.decayDuration=e.decayDuration??Z.decayDuration,this.releaseDuration=e.releaseDuration??Z.releaseDuration,this.shouldLoop=e.shouldLoop??Z.shouldLoop,this.#e=new Pr(dn,{initial:"attack"}),this.#e.addEventListener("change",t=>{t.newState==="release"&&this.#n&&this.#t?.reset(),super.fireEvent("change",t)}),this.#e.addEventListener("stop",t=>{super.fireEvent("complete",t)}),this.#s=()=>Ne(),this.#r=this.#n=!1,this.decayDurationTotal=this.attackDuration+this.decayDuration}dispose(){this.#o||this.#e.dispose()}get isDisposed(){return this.#o}switchStateIfNeeded(e){if(this.#t===void 0)return!1;let t=this.#t.elapsed;const n=this.#n&&!this.#r;let r=!1,s=this.#e.state;do switch(r=!1,s=this.#e.state,s){case"attack":{(t>this.attackDuration||n)&&(this.#e.next(),r=!0);break}case"decay":{(t>this.decayDurationTotal||n)&&(this.#e.next(),r=!0);break}case"sustain":{(!this.#r||n)&&(t=0,this.#e.next(),this.#t.reset(),r=!0);break}case"release":{t>this.releaseDuration&&(this.#e.next(),r=!0);break}case"complete":this.shouldLoop&&e&&this.trigger(this.#n)}while(r&&s!=="complete");return r}computeRaw(e=!0,t=!0){if(this.#t===void 0)return[void 0,0,this.#e.state];e&&this.switchStateIfNeeded(t);const n=this.#e.state,r=this.#t.elapsed;let s=0;const o=this.#e.state;switch(o){case"attack":{s=r/this.attackDuration;break}case"decay":{s=(r-this.attackDuration)/this.decayDuration;break}case"sustain":{s=1;break}case"release":{s=Math.min(r/this.releaseDuration,1);break}case"complete":return["complete",1,n];default:throw new Error(`State machine in unknown state: ${o}`)}return[o,s,n]}get isDone(){return this.#e.isDone}onTrigger(){}trigger(e=!1){this.onTrigger(),this.#i=!0,this.#e.reset(),this.#t=this.#s(),this.#r=e,this.#n=e}get hasTriggered(){return this.#i}compute(){}release(){this.isDone||!this.#n||(this.#r=!1,this.compute())}};const R=Object.freeze({attackBend:-1,decayBend:-.3,releaseBend:-.3,peakLevel:1,initialLevel:0,sustainLevel:.6,releaseLevel:0,retrigger:!1});var mn=class{adsr;constructor(e){this.adsr=e}next(...e){this.adsr.hasTriggered||this.adsr.trigger();const t=this.adsr.compute();return{value:t[1],done:t[0]==="complete"}}get[Symbol.toStringTag](){return"Generator"}},je=class extends pn{attackPath;decayPath;releasePath;initialLevel;peakLevel;releaseLevel;sustainLevel;attackBend;decayBend;releaseBend;initialLevelOverride;retrigger;releasedAt;constructor(e={}){super(e),this.retrigger=e.retrigger??R.retrigger,this.initialLevel=e.initialLevel??R.initialLevel,this.peakLevel=e.peakLevel??R.peakLevel,this.releaseLevel=e.releaseLevel??R.releaseLevel,this.sustainLevel=e.sustainLevel??R.sustainLevel,this.attackBend=e.attackBend??R.attackBend,this.releaseBend=e.releaseBend??R.releaseBend,this.decayBend=e.decayBend??R.decayBend;const t=1;this.attackPath=Se(Ee({x:0,y:this.initialLevel},{x:t,y:this.peakLevel},-this.attackBend)),this.decayPath=Se(Ee({x:0,y:this.peakLevel},{x:t,y:this.sustainLevel},-this.decayBend)),this.releasePath=Se(Ee({x:0,y:this.sustainLevel},{x:t,y:this.releaseLevel},-this.releaseBend))}onTrigger(){if(this.initialLevelOverride=void 0,!this.retrigger){const[e,t,n]=this.compute(!0,!1);!Number.isNaN(t)&&t>0&&(this.initialLevelOverride=t)}}[Symbol.iterator](){return new mn(this)}get value(){return this.compute(!0)[1]}compute(e=!0,t=!0){const[n,r]=super.computeRaw(e,t);if(n===void 0)return[void 0,NaN,NaN];let s;switch(n){case"attack":{s=this.attackPath.interpolate(r).y,this.initialLevelOverride!==void 0&&(s=ae(s,0,1,this.initialLevelOverride,1)),this.releasedAt=s;break}case"decay":{s=this.decayPath.interpolate(r).y,this.releasedAt=s;break}case"sustain":{s=this.sustainLevel,this.releasedAt=s;break}case"release":{s=this.releasePath.interpolate(r).y,this.releasedAt!==void 0&&(s=ae(s,0,this.sustainLevel,0,this.releasedAt));break}case"complete":{s=this.releaseLevel,this.releasedAt=void 0;break}default:throw new Error(`Unknown state: ${n}`)}return[n,s,r]}},hn={};F(hn,{Adsr:()=>je,AdsrBase:()=>pn,AdsrIterator:()=>mn,adsr:()=>Ws,adsrIterable:()=>Gs,adsrStateTransitions:()=>dn,defaultAdsrOpts:()=>R,defaultAdsrTimingOpts:()=>Z});const Ws=(e={})=>{const t=new je(e),n=t.releaseLevel,r=t[Symbol.iterator]();return()=>hr(r,{overrideWithLast:!0,value:n})};async function*Gs(e){const t=new je(e.env),n=e.sampleRateMs??100;t.trigger();const r=vr(()=>t.value,{while:()=>!t.isDone,delay:n,signal:e.signal});for await(const s of r)yield s}var vn={};F(vn,{accelerationForce:()=>Zs,angleFromAccelerationForce:()=>bn,angleFromVelocityForce:()=>wn,angularForce:()=>yn,apply:()=>Ys,attractionForce:()=>Xs,computeAccelerationToTarget:()=>Sn,computeAttractionForce:()=>gn,computePositionFromAngle:()=>En,computePositionFromVelocity:()=>ze,computeVelocity:()=>_e,constrainBounce:()=>Js,guard:()=>Hs,magnitudeForce:()=>Qs,nullForce:()=>eo,orientationForce:()=>io,pendulumForce:()=>ro,springForce:()=>no,targetForce:()=>Ks,velocityForce:()=>to});const Hs=(e,t="t")=>{if(e===void 0)throw new Error(`Parameter ${t} is undefined. Expected ForceAffected`);if(e===null)throw new Error(`Parameter ${t} is null. Expected ForceAffected`);if(typeof e!="object")throw new TypeError(`Parameter ${t} is type ${typeof e}. Expected object of shape ForceAffected`)},Js=(e,t=1)=>{e||(e={width:1,height:1});const n=wt(e,"left"),r=wt(e,"right"),s=St(e,"top"),o=St(e,"bottom");return i=>{const a=ze(i.position??S,i.velocity??S);let c=i.velocity??S,{x:u,y:l}=a;return u>r?(u=r,c=U(j(c,t),"x")):u<n&&(u=n,c=U(j(c,t),"x")),l>o?(l=o,c=j(U(c,"y"),t)):a.y<s&&(l=s,c=U(j(c,t),"y")),Object.freeze({...i,position:{x:u,y:l},velocity:c})}},Xs=(e,t,n={})=>r=>{let s=r.acceleration??S;for(const o of e){if(o===r)continue;const i=gn(o,r,t,n);s=J(s,i)}return{...r,acceleration:s}},gn=(e,t,n,r={})=>{if(e.position===void 0)throw new Error("attractor.position not set");if(t.position===void 0)throw new Error("attractee.position not set");const s=r.min??.01,o=r.max??.7,i=Fe(De(e.position,t.position)),a=ee(fe(i),s,o);return j(i,n*(e.mass??1)*(t.mass??1)/(a*a))},Ks=(e,t={})=>r=>{const s=Sn(e,r.position??{x:.5,y:.5},t);return{...r,acceleration:J(r.acceleration??S,s)}},Ys=(e,...t)=>{if(e===void 0)throw new Error("t parameter is undefined");for(const o of t)o!=null&&(e=typeof o=="function"?o(e):{...e,acceleration:J(e.acceleration??S,o)});const n=_e(e.acceleration??S,e.velocity??S),r=ze(e.position??S,n);return{...e,position:r,velocity:n,acceleration:S}},Zs=(e,t="ignored")=>n=>Object.freeze({...n,acceleration:pe(e,n,t)}),pe=(e,t,n="ignored")=>{let r;switch(n){case"dampen":{r=s=>kr(e,s,s);break}case"multiply":{r=s=>Ft(e,s,s);break}case"ignored":{r=s=>e;break}default:throw new Error(`Unknown 'mass' parameter '${n}. Expected 'dampen', 'multiply' or 'ignored'`)}return J(t.acceleration??S,r(t.mass??1))},Qs=(e,t="ignored")=>n=>{if(n.velocity===void 0)return n;const r=fe(Fe(n.velocity)),s=e*r*r,o=j(U(n.velocity),s);return Object.freeze({...n,acceleration:pe(o,n,t)})},eo=e=>e,to=(e,t)=>{const n=yr(U,r=>j(r,e));return r=>{if(r.velocity===void 0)return r;const s=n(r.velocity);return Object.freeze({...r,acceleration:pe(s,r,t)})}},yn=()=>e=>{const t=e.angularAcceleration??0,n=e.angularVelocity??0,r=e.angle??0,s=n+t,o=r+s;return Object.freeze({...e,angle:o,angularVelocity:s,angularAcceleration:0})},bn=(e=20)=>t=>{const n=t.acceleration??S;return Object.freeze({...t,angularAcceleration:n.x*e})},wn=(e=1)=>t=>{const n=kt(t.velocity??S);return Object.freeze({...t,angle:e<1?cr(e,t.angle??0,n):n})},no=(e,t=.5,n=2e-4,r=.999)=>s=>{const o=De(s.position??S,e),i=fe(o),a=Math.abs(t-i),c=br(o,Fe,v=>j(v,-n*a)),u=pe(c,s,"dampen"),l=_e(u??S,s.velocity??S),f=Ft(l,r,r);return{...s,velocity:f,acceleration:S}},ro=(e,t={})=>n=>{e||(e={x:0,y:0});const r=t.length??fe(e,n.position??S),s=t.speed??.001,o=t.damping??.995;let i=n.angle;i===void 0&&(n.position?i=kt(e,n.position)-Math.PI/2:i=0);const a=-1*s/r*Math.sin(i),c=(n.angularVelocity??0)+a;return i+=c,Object.freeze({angularVelocity:c*o,angle:i,position:En(r,i+Math.PI/2,e)})},_e=(e,t,n)=>{const r=J(t,e);return n===void 0?r:wr(r,n)},Sn=(e,t,n={})=>{const r=n.diminishBy??.001,s=De(e,t);return n.range&&Sr(Er(s),n.range)===-2?S:j(s,r)},ze=(e,t)=>J(e,t),En=(e,t,n)=>gr(e,t,n),so=yn(),oo=bn(),io=(e=.5)=>{const t=wn(e);return n=>(n=so(n),n=oo(n),n=t(n),n)},ao=(e,t)=>n=>{const r=1-n,s=r*r,o=n*n,i=o*n;return 3*e*s*n+3*t*r*o+i},co=e=>{let t=performance.now();return{update:(s=1)=>{const o=performance.now()-t,i=e*o%1;return t=performance.now(),(s+i)%1},reset:()=>{t=performance.now()}}},It=Math.PI*2;function qe(e,t,n,r){let s,o="clamp";const i=l=>(s&&(l=s(l)),o===void 0||o==="clamp"?l=ee(l):o==="wrap"&&(l>1?l=l%1:l<0&&(l=1+l%1)),l),a=(l,f,v)=>(V(k(f,"","a"),k(v,"","b"),k(l,"","amount")),l=i(l),(1-l)*f+l*v),c=(l={})=>{if(l.easing){const f=de(l.easing);if(!f)throw new Error(`Easing function '${l.easing}' not found`);s=f}else if(l.transform){if(typeof l.transform!="function")throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof l.transform}`);s=l.transform}o=l.limits??"clamp"},u=(l,f,v)=>(1-l)*f+l*v;if(typeof e!="number")throw new TypeError(`First param is expected to be a number. Got: ${typeof e}`);if(typeof t=="number"){let l,f;if(n===void 0||typeof n=="object")return l=e,f=t,c(n),v=>a(v,l,f);if(typeof n=="number")return l=t,f=n,c(r),a(e,l,f);throw new Error("Values for 'a' and 'b' not defined")}else if(t===void 0||typeof t=="object"){const l=i(e);return c(t),V(k(l,"","amount")),(f,v)=>u(l,f,v)}}const lo=(e,t=0,n=1,r=0,s)=>{let o=r;return(i,a)=>{if(i!==void 0&&(n=i),a!==void 0&&(t=a),o>=1)return n;const c=qe(o,t,n,s);return o+=e,c}},uo=(e,t,n,r)=>{const s=lr(n-t,0,It);return qe(e,t,t+(s>Math.PI?s-It:s),r)},fo=(e,t=0,n=1,r)=>{const s=zt(e,{clampValue:!0});return(o,i)=>{const a=s();return o!==void 0&&(n=o),i!==void 0&&(t=i),a>=1?n:qe(a,t,n,r)}},po=e=>{const{relative:t,absolute:n}=e,r=e.clamped??!1,s=e.source??Math.random;if(n!==void 0)return o=>{const i=s()*n*2-n,a=o+i;return r?ee(a,0,o):a};if(t!==void 0)return o=>{const i=o*t,a=s()*i*2-i,c=o+a;return r?ee(c,0,o):c};throw new Error("Either absolute or relative fields expected")},mo=(e={})=>{const t=e.clamped??!0;let n=s=>0;if(e.absolute!==void 0){V(k(e.absolute,t?"percentage":"bipolar","opts.absolute"));const s=Fr({min:-e.absolute,max:e.absolute,source:e.source});n=o=>o+s()}else{if(e.relative===void 0)throw new TypeError("Either absolute or relative jitter amount is required.");{const s=e.relative??.1;V(k(s,t?"percentage":"bipolar","opts.relative")),n=o=>o+Dr({min:-Math.abs(s*o),max:Math.abs(s*o),source:e.source})}}return s=>{V(k(s,t?"percentage":"bipolar","value"));let o=n(s);return t&&(o=ee(o)),o}},ho=(e,t,n)=>{const r=n*e;return(1-e)*t+t*r},An=(e,t,n)=>r=>ke(e,t(r),n(r)),vo=(e,t)=>n=>An(n,e,t)(n),go=e=>e,yo=function(e=.1,t,n,r,s){return typeof t>"u"&&(t=0),typeof n>"u"&&(n=1),typeof r>"u"&&(r=t),V(k(e,"bipolar","interval"),k(n,"bipolar","end"),k(r,"bipolar","offset"),k(t,"bipolar","start")),xn(e,t,n,r,s)},xn=function*(e,t,n,r,s){if(t===void 0)throw new Error("Parameter 'lower' is undefined");if(e===void 0)throw new Error("Parameter 'interval' is undefined");if(n===void 0)throw new Error("Parameter 'upper' is undefined");if(s===void 0&&e<=1&&e>=0?s=10/e:typeof s>"u"&&(s=1234),Number.isNaN(e))throw new Error("interval parameter is NaN");if(Number.isNaN(t))throw new Error("lower parameter is NaN");if(Number.isNaN(n))throw new Error("upper parameter is NaN");if(Number.isNaN(r))throw new Error("upper parameter is NaN");if(t>=n)throw new Error("lower must be less than upper");if(e===0)throw new Error("Interval cannot be zero");const o=n-t;if(Math.abs(e)>=o)throw new Error(`Interval should be between -${o} and ${o}`);let i=e>0;if(n=Math.floor(n*s),t=Math.floor(t*s),e=Math.floor(Math.abs(e*s)),e===0)throw new Error(`Interval is zero (rounding: ${s})`);if(r=r===void 0?t:Math.floor(r*s),r>n||r<t)throw new Error(`Start (${r/s}) must be within lower (${t/s}) and upper (${n/s})`);let a=r;yield a/s;let c=!0;for(;;)a=a+(i?e:-e),i&&a>=n?(i=!1,a=n,a===n&&c&&(a=t,i=!0)):!i&&a<=t&&(i=!0,a=t,a===t&&c&&(a=n,i=!1)),yield a/s,c=!1};function*$n(e={},t){t===void 0?t=Ne():typeof t=="number"&&(t=H(t));const n=In(e);let r=e.countdown??10;for(;r>0;){const s=n(t.elapsed/1e3);yield s,s===1?r--:r=100}}function bo(e={},t){const n=$n(e,t);return()=>{const r=n.next();return r.done?1:r.value}}const In=(e={})=>{const r=e.mass??1,s=e.stiffness??100,o=e.soft??!1,i=e.damping??10,a=e.velocity??.1,c=1;if(o||1<=i/(2*Math.sqrt(s*r))){const u=-Math.sqrt(s/r),l=-u*c-a;return f=>1-(c+f*l)*Math.E**(f*u)}else{const u=Math.sqrt(4*r*s-i**2),l=(i*c-2*r*a)/u,f=.5*u/r,v=-(.5*i)/r;return g=>1-(Math.cos(g*f)*c+Math.sin(g*f)*l)*Math.E**(g*v)}},wo=(e,t,n={})=>{switch(e){case"elapsed":return()=>W(t,n);case"bpm":return()=>Kt(t,n);case"hertz":return()=>Me(t,n);default:throw new Error(`Unknown source '${e}'. Expected: 'elapsed', 'hertz' or 'bpm'`)}};function Tn(e=1){e=1/e;const t=e/2;return n=>Math.abs(n%e-t)}function Vn(e=1){e=1/e;const t=e/2;return n=>n%e<t?1:0}function Pn(e=1){return e=e*(Math.PI*2),t=>(Math.sin(t*e)+1)/2}function kn(e=1){return e=e*(Math.PI*2),t=>Math.abs(Math.sin(t*e))}function Fn(e=1){return e=e*(Math.PI*2),t=>Math.sin(t*e)}function So(e){const t=e.shape??"sine",n=e.invert??!1,r=e.period??1;let s;V(Vt(r,"aboveZero","period"));const o={...e};if(e.ticks)s=Xt(e.ticks,o);else if(e.hertz)s=Me(e.hertz,o);else if(e.millis)s=W(e.millis,o);else if(e.source)s=e.source;else{const a=e.secs??5;s=W(a*1e3,o)}let i;switch(t){case"saw":i=a=>a;break;case"sine":i=Pn(r);break;case"sine-bipolar":i=Fn(r);break;case"square":i=Vn(r);break;case"triangle":i=Tn(r);break;case"arc":i=kn(r);break;default:throw new Error(`Unknown wave shape '${t}'. Expected: sine, sine-bipolar, saw, triangle, arc or square`)}return Dn(s,i,n)}function Dn(e,t,n=!1){return r=>{let s=e(r?.clock);return r?.override&&(s=r.override),s=t(s),n&&(s=1-s),s}}const Eo=(e,t,n)=>(e*(n-1)+t)/n,Ao=(e="quadIn")=>Nn(e)(),Nn=(e="quadIn")=>{const t=typeof e=="string"?{easing:e}:e,n=t.source??Math.random,r=t.easing??"quadIn",s=de(r);if(typeof s>"u")throw new Error(`Easing function '${r}' not found.`);return()=>{const i=n();return s(i)}};var xo={};F(xo,{Easings:()=>cn,Envelopes:()=>hn,Forces:()=>vn,Oscillators:()=>Qt,Sources:()=>Zt,arcShape:()=>kn,crossfade:()=>vo,cubicBezierShape:()=>ao,drift:()=>co,gaussian:()=>tn,interpolate:()=>ke,interpolateAngle:()=>uo,interpolatorInterval:()=>fo,interpolatorStepped:()=>lo,jitter:()=>mo,jitterAbsolute:()=>po,mix:()=>ho,mixModulators:()=>An,noop:()=>go,pingPong:()=>xn,pingPongPercent:()=>yo,sineBipolarShape:()=>Fn,sineShape:()=>Pn,spring:()=>$n,springShape:()=>In,springValue:()=>bo,squareShape:()=>Vn,tickModulator:()=>an,ticks:()=>on,time:()=>rn,timeModulator:()=>sn,timingSourceFactory:()=>wo,triangleShape:()=>Tn,wave:()=>So,waveFromSource:()=>Dn,weighted:()=>Ao,weightedAverage:()=>Eo,weightedSource:()=>Nn});var Ce=class extends Error{constructor(e){super(e),this.name="CancelError"}};function $o(...e){return t=>{let n=t;for(const r of e)try{n=r(n)}catch(s){if(s instanceof Ce)break;throw s}return n}}function Io(e){return t=>t===void 0?t:e(t)}function To(){return e=>{if(e===void 0)throw new Ce("cancel");return e}}function Vo(e){return t=>t===void 0?e():t}const Po=(e,t)=>e===t,ko=e=>typeof e=="string"?e:JSON.stringify(e);function Fo(e){let t;return n=>{if(n!==t)return t=n,n}}function Do(e){const t=[];return typeof e>"u"&&(e=Po),n=>{if(n!==void 0){for(const r of t)if(e(r,n))return;return t.push(n),n}}}function No(e){const t=new Set;return typeof e>"u"&&(e=ko),n=>{if(n===void 0)return;const r=e(n);if(!t.has(r))return t.add(r),n}}var Lo={};F(Lo,{CancelError:()=>Ce,average:()=>Rt,cancelIfUndefined:()=>To,flow:()=>$o,ifNotUndefined:()=>Io,ifUndefined:()=>Vo,max:()=>Mt,min:()=>Ot,rank:()=>Lt,seenLastToUndefined:()=>Fo,seenToUndefined:()=>Do,seenToUndefinedByKey:()=>No,sum:()=>Nt,tally:()=>Dt});function G(e){return e.value!==void 0?!1:"signal"in e&&e.signal!==void 0}function D(e){return e.value!==void 0?!1:"signal"in e&&e.signal==="done"}function A(e){return e.value!==void 0}const Ln=e=>se(e)?"ping"in e:!1,z=e=>se(e)?"last"in e&&e.last()!==void 0:!1,se=e=>typeof e!="object"||e===null?!1:"on"in e&&"onValue"in e,Be=e=>se(e)?"set"in e:!1,On=e=>!(typeof e!="object"||!("source"in e)||!("annotate"in e)),T=(e,...t)=>n=>e(n,...t),Ue=e=>"value"in e,We=e=>"fn"in e,Ge=e=>Bt(e),Mn=e=>typeof e!="object"?!1:!!(Ue(e)||We(e)||Ge(e));function Rn(e){if(Ue(e))return[e.value,!1];if(We(e)){const t=e.fn();return t===void 0?[void 0,!0]:[t,!1]}if(Ge(e)){const t=e.gen.next();return t.done?[void 0,!0]:[t.value,!1]}throw new Error("Invalid trigger. Missing 'value' or 'fn' fields")}function jn(e,t={}){const n=t.maximumRepeats??Number.MAX_SAFE_INTEGER,r=t.closeOnError??!0,s=t.interval?P(t.interval):-1;let o=t.manual??!1;if(t.interval===void 0&&t.manual===void 0&&(o=!0),o&&t.interval)throw new Error("If option 'manual' is set, option 'interval' cannot be used");const i=P(t.predelay,0),a=t.lazy??"very",c=t.signal,u=new AbortController,l=h=>{u.abort(h)};let f=0,v=!1;const g=h=>{d.dispose(h),v=!1,p&&p.cancel()},m=async()=>{if(!v)return!1;if(i&&await Rr(i),f>=n)return g(`Maximum repeats reached ${n.toString()}`),!1;try{if(c?.aborted)return g(`Signal (${c.aborted})`),!1;const h=await e(l);return f++,d.set(h),!0}catch(h){return r?(g(`Function error: ${Et(h)}`),!1):(d.signal("warn",Et(h)),!0)}},p=o?void 0:Le(async()=>{if(!await m())return!1;if(u.signal.aborted)return g(`callback function aborted (${u.signal.reason})`),!1},s),d=_({lazy:a,onStart(){v=!0,p&&p.start()},onStop(){v=!1,p&&p.cancel()}});return a==="never"&&p&&p.start(),{...d,ping:m}}function Pe(e,t={}){const n=t.lazy??"very",r=t.traceLifecycle?g=>{console.log(`Rx.From.iterator ${g}`)}:g=>{},s=P(t.readInterval,5),o=P(t.readTimeout,300*1e3),i=t.whenStopped??"continue";let a,c,u=Or({idle:["wait_for_next"],wait_for_next:["processing_result","stopping","disposed"],processing_result:["queued","disposed","stopping"],queued:["wait_for_next","disposed","stopping"],stopping:"idle",disposed:null},"idle");const l=()=>{r("onExternalSignal"),c?.abort(t.signal?.reason)};t.signal&&t.signal.addEventListener("abort",l,{once:!0});const f=async()=>{r(`read. State: ${u.value}`),c=new AbortController;try{u=q(u,"wait_for_next");const g=await Mr(a,{signal:c.signal,millis:o});if(u=q(u,"processing_result"),c.abort("nextWithTimeout completed"),g.done&&(r("read v.done true"),v.dispose("Generator complete"),u=q(u,"disposed")),u.value==="stopping"){r("read. sm.value = stopping"),u=q(u,"idle");return}if(u.value==="disposed"){r("read. sm.value = disposed");return}v.set(g.value)}catch(g){v.dispose(`Generator error: ${g.toString()}`);return}u.value==="processing_result"?(u=q(u,"queued"),r(`scheduling read. State: ${u.value}`),setTimeout(f,s)):u=q(u,"idle")},v=_({...t,lazy:n,onStart(){r(`onStart state: ${u.value} whenStopped: ${i}`),u.value==="idle"&&((u.value==="idle"&&i==="reset"||a===void 0)&&(a=xe(e)?e[Symbol.asyncIterator]():e[Symbol.iterator]()),f())},onStop(){r(`onStop state: ${u.value} whenStopped: ${i}`),u=q(u,"stopping"),i==="reset"&&(r("onStop reiniting iterator"),a=xe(e)?e[Symbol.asyncIterator]():e[Symbol.iterator]())},onDispose(g){r(`onDispose (${g})`),c?.abort(`Rx.From.iterator disposed (${g})`),t.signal&&t.signal.removeEventListener("abort",l)}});return v}const w=(e,t={})=>{if(se(e))return e;const n=t.generator??{lazy:"initial",interval:5},r=t.function??{lazy:"very"};if(Array.isArray(e))return Pe(e.values(),n);if(typeof e=="function")return jn(e,r);if(typeof e=="object"){if(On(e))return e.source;if(Bt(e)||xe(e))return Pe(e,n)}throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${typeof e}`)};function He(e,t){let n=t;return e.onValue(r=>{n=r}),{...e,last(){return n},resetCachedValue(){n=void 0}}}function $(e,t){const n=t.lazy??"initial",r=t.disposeIfSourceDone??!0,s=t.onValue??(f=>{}),o=w(e);let i;const a=t.debugLabel?`[${t.debugLabel}]`:"",c=()=>{i!==void 0&&(i(),i=void 0,t.onStop&&t.onStop())},l=_({...t,lazy:n,onStart:()=>{i===void 0&&(t.onStart&&t.onStart(),i=o.on(f=>{G(f)?f.signal==="done"?(c(),l.signal(f.signal,f.context),r&&l.dispose(`Upstream source ${a} has completed (${f.context??""})`)):l.signal(f.signal,f.context):A(f)&&s(f.value)}))},onStop:c});return l}function Oo(e){const t=_(e);return He(t,e.initialValue)}function _(e){const t=e.lazy??"initial",n=e.onStop??(()=>{}),r=e.onStart??(()=>{});e.debugLabel&&`${e.debugLabel}`;const s=x({...e,onFirstSubscribe(){t!=="never"&&r()},onNoSubscribers(){t==="very"&&n()}});return t==="never"&&r(),s}function x(e={}){let t,n=!1,r=!1,s=!0;const o=e.onFirstSubscribe??void 0,i=e.onNoSubscribers??void 0,a=e.debugLabel?`[${e.debugLabel}]`:"",c=()=>{t!==void 0&&t.isEmpty&&(s||(s=!0,r=!1,i&&i()))},u=l=>{if(n)throw new Error(`Disposed, cannot subscribe ${a}`);t===void 0&&(t=new Ct);const f=t.add(l);return s=!1,r||(r=!0,o&&o()),()=>{t?.remove(f),c()}};return{dispose:l=>{n||(t?.notify({value:void 0,signal:"done",context:`Disposed: ${l}`}),n=!0,e.onDispose&&e.onDispose(l))},isDisposed:()=>n,removeAllSubscribers:()=>{t?.clear(),c()},set:l=>{if(n)throw new Error(`${a} Disposed, cannot set`);t?.notify({value:l})},signal:(l,f)=>{if(n)throw new Error(`${a} Disposed, cannot signal`);t?.notify({signal:l,value:void 0,context:f})},on:l=>u(l),onValue:l=>u(v=>{A(v)&&l(v.value)})}}const Je=(e,t)=>{let n,r;if(typeof t=="string"&&(r={query:t}),typeof t=="object"&&("nodeName"in t?r={el:t}:r=t),r===void 0)throw new TypeError("Missing element as second parameter or option");if("el"in r)n=r.el;else if("query"in r)n=document.querySelector(r.query);else throw new TypeError("Options does not include 'el' or 'query' fields");if(n==null)throw new Error("Element could not be resolved.");const s=w(e),o=Jr(r.asHtml?"innerHTML":"textContent",n);return s.onValue(a=>{o(a)})},N=e=>({on:e.on,dispose:e.dispose,isDisposed:e.isDisposed,onValue:e.onValue});function Xe(e,t,n={}){const r=$(e,{...n,onValue(s){const o=t(s);r.set({value:s,annotation:o})}});return N(r)}function Ke(e,t){const n=w(e),r=t(n);return ge({value:n,annotation:r})}function Ye(e,t={}){const n=new Wt,r=t.quantity??0,s=t.returnRemainder??!0,o={...t,onStop(){if(s&&!n.isEmpty){const u=n.toArray();n.clear(),i.set(u)}},onValue(u){n.enqueue(u),r>0&&n.length>=r&&a(),c!==void 0&&c.runState==="idle"&&c.start()}},i=$(e,o),a=()=>{if(n.isEmpty)return;c!==void 0&&c.start();const u=n.toArray();n.clear(),setTimeout(()=>{i.set(u)})},c=t.elapsed?qt(a,t.elapsed):void 0;return N(i)}function L(e,t,n={}){const r=n.traceInput??!1,s=n.traceOutput??!1,o=$(e,{lazy:"initial",...n,onValue(i){const a=t(i);r&&s?console.log(`Rx.Ops.transform input: ${JSON.stringify(i)} output: ${JSON.stringify(a)}`):r?console.log(`Rx.Ops.transform input: ${JSON.stringify(i)}`):s&&console.log(`Rx.Ops.transform output: ${JSON.stringify(a)}`),o.set(a)}});return N(o)}const _n=e=>L(e,t=>{const n=[];for(const r in t){const s=t[r];Tt(s)&&n.push([r,s])}return Object.fromEntries(n)});function Ze(e,t={}){const n=x(),r=t.onSourceDone??"break",s=[],o=e.map(l=>w(l)),i=()=>{},a=o.map(l=>i),c=o.map(l=>!1),u=()=>{for(const l of a)l()};for(const[l,f]of o.entries())s[l]=void 0,a[l]=f.on(v=>{if(D(v)){if(c[l]=!0,a[l](),a[l]=i,r==="break"){u(),n.dispose("Source has completed and 'break' is set");return}c.includes(!1)||(u(),n.dispose("All sources completed"))}else A(v)&&(s[l]=v.value,n.set([...s]))});return{dispose:n.dispose,isDisposed:n.isDisposed,on:n.on,onValue:n.onValue}}function oe(e,t={}){const n=t.eq??Pt,r=x(),s=x(),o=[];let i=e,a=!1;const c=m=>{const p=[...Q(i??{},m,{...t,includeMissingFromA:!0})];p.length!==0&&(i=m,r.set(m),s.set(p))},u=(m,p)=>{for(const[d,h,y]of o)d(m)&&y.notify({fieldName:m,pattern:h,value:p})},l={asPartial:!0,includeParents:!0},f=m=>{if(i===void 0){i=m,r.set(i);for(const[p,d]of Object.entries(m))u(p,d);return i}else{const p=[...Q(i,m,l)];if(p.length===0)return i;i={...i,...m},r.set(i),s.set(p);for(const d of p)u(d.path,d.value);return i}};return{dispose:m=>{a||(s.dispose(m),r.dispose(m),a=!0)},isDisposed(){return a},updateField:(m,p)=>{if(i===void 0)throw new Error("Cannot update value when it has not already been set");const d=Ht(i,m);if(ur(d))throw fr(d);if(n(d.value,p,m))return;let h=[...Q(d.value,p,{...t,includeMissingFromA:!0})];h=h.map(I=>I.path.length>0?{...I,path:m+"."+I.path}:{...I,path:m});const y=Oe(i,m,p,!0);i=y,r.set(y),s.set(h),u(m,p)},last:()=>i,on:r.on,onValue:r.onValue,onDiff:s.onValue,onField(m,p){const d=Nr(m),h=new Ct;o.push([d,m,h]);const y=h.add(p);return()=>h.remove(y)},set:c,update:f}}function me(e,t={}){const n=t.disposeSources??!0,r=oe(void 0),s=t.onSourceDone??"break",o=t.emitInitial??!0;let i=!1;const a=new Map;for(const[m,p]of Object.entries(e)){const d="last"in p?p.last():void 0,h={source:w(p),done:!1,data:d,off:()=>{}};a.set(m,h)}const c=Object.fromEntries(Object.entries(a).map(m=>[m[0],m[1].source])),u=()=>zr(a,m=>!m.done),l=()=>{for(const m of a.values())m.off()},f=()=>{const m={};for(const[p,d]of a)d.data!==void 0&&(m[p]=d.data);return m},v=()=>{i=!0;const m=f();r.set(m)},g=m=>{m.off=m.source.on(p=>{if(D(p)){if(m.done=!0,m.off(),m.off=()=>{},s==="break"){l(),r.dispose("Source has completed and 'break' is behaviour");return}u()||(l(),r.dispose("All sources completed"))}else A(p)&&(m.data=p.value,v())})};for(const m of a.values())g(m);return!i&&o&&v(),{...r,hasSource(m){return a.has(m)},replaceSource(m,p){const d=a.get(m);if(d===void 0)throw new Error(`Field does not exist: '${m}'`);d.off();const h=w(p);d.source=h,g(d)},setWith(m){const p={};for(const[d,h]of Object.entries(m)){const y=a.get(d);y!==void 0&&(Be(y.source)&&(y.source.set(h),p[d]=h),y.data=h)}return p},sources:c,last(){return f()},dispose(m){if(l(),r.dispose(m),n)for(const p of a.values())p.source.dispose("Part of disposed mergeToObject")}}}function zn(e,t){let n,r;z(e)&&(r=n=e.last());const s=()=>{if(n===void 0&&r!==void 0)n=r,o.set(n);else if(n!==void 0&&r!==void 0){const i=t(n,r);n=i,o.set(i)}},o=$(e,{lazy:"very",debugLabel:"computeWithPrevious",onValue(i){r=i,s()}});return r&&s(),{...N(o),ping:()=>{r!==void 0&&s()}}}function qn(e,t={}){const n=P(t.elapsed,50);let r;const s=qt(()=>{const i=r;i&&(o.set(i),r=void 0)},n),o=$(e,{...t,onValue(i){r=i,s.start()}});return N(o)}function Qe(e){return t=>qn(t,e)}const Cn=e=>{let t=0;return L(e,n=>{const r=t===0?0:Date.now()-t;return t=Date.now(),r})};function he(e,t,n={}){const r=n.fallbackFieldValue,s=n.fallbackObject,o=$(e,{disposeIfSourceDone:!0,...n,onValue(i){let a;t in i?a=i[t]:s&&t in s&&(a=s[t]),a===void 0&&(a=r),a!==void 0&&o.set(a)}});return N(o)}function et(e,t,n){if(typeof t!="function")throw new TypeError("Param 'predicate' should be a function");const r=$(e,{...n,onValue(s){t(s)&&r.set(s)}});return N(r)}function Bn(e,t,n){if(typeof t!="function")throw new TypeError("Param 'predicate' should be a function");const r=$(e,{...n,onValue(s){t(s)||r.set(s)}});return N(r)}function Un(e,t={}){const n=t.amount??.1,r=t.snapAt??.99,s=ke(n,t);return zn(e,(o,i)=>{const a=s(o,i);return i>o&&a/i>=r?i:a})}function tt(e,t){const n=Mt();return K(n,"max",e,t)}function nt(e,t){const n=Ot();return K(n,"min",e,t)}function rt(e,t){const n=Rt();return K(n,"average",e,t)}function st(e,t){const n=Nt();return K(n,"sum",e,t)}function ot(e,t={}){const n=t.countArrayItems??!0,r=Dt(n);return K(r,"tally",e,t)}function Wn(e,t,n){const r=Lt(t,n);return K(r,"rank",e,n)}function K(e,t,n,r={}){const s=r.annotate;let o;const i=r.skipUndefined??!0,a=r.skipIdentical??!0,c=$(n,{...r,onValue(u){const l=e(u);if(!(l===void 0&&i)&&!(a&&l===o))if(o=l,s){const f={value:u};f[t]=l,c.set(f)}else c.set(l)}});return N(c)}const Gn=(...e)=>{const t=x(),n=[],r=s=>{for(const o of e)o.isDisposed||o.dispose(s);for(const o of n)o();t.dispose(s)};for(let s=0;s<e.length;s++)n.push(e[s].on(o=>{const i=s===e.length-1;A(o)?i?t.set(o.value):e[s+1].set(o.value):D(o)&&r("Upstream disposed")}));return{on:t.on,onValue:t.onValue,dispose(s){r(s)},isDisposed(){return t.isDisposed()}}};function Hn(e,t={}){const n=t.order??"default";if(!t.at&&!t.predicate)throw new Error("Options must have 'predicate' or 'at' fields");let r=o=>o;n==="random"?r=mr:typeof n=="function"&&(r=o=>o.toSorted(n));const s=$(e,{onValue(o){if(o=r(o),t.predicate)for(const i of o)t.predicate(i)&&s.set(i);else t.at&&s.set(o.at(t.at))}});return s}const it=(e,t={})=>{const n=t.quantity??2,r=[],s=w(e);for(let o=0;o<n;o++)r.push($(s,{disposeIfSourceDone:!0,lazy:"initial"}));return r},at=(e,t)=>{const n=w(e),r={};for(const s of t)r[s]=$(n,{lazy:"initial",disposeIfSourceDone:!0});return r},ct=(e,t,n={})=>{const r=n.match??"first",s=w(e);let o=!1;const i={};for(const u of Object.keys(t))i[u]=x();const a=()=>{if(!o){c(),o=!0;for(const u of Object.values(i))u.dispose("switcher source dispose")}},c=s.on(u=>{if(A(u)){for(const[l,f]of Object.entries(t))if(f(u.value)&&(i[l].set(u.value),r==="first"))break}else D(u)&&a()});return i};function ve(e,t={}){const n=t.onSourceDone??"break",r=t.finalValue??"undefined",s=P(t.maximumWait,2e3);let o;const i=[],a=e.map(d=>({finalData:void 0,done:!1,source:w(d),unsub:()=>{}})),c=()=>{for(const d of a)d.unsub(),d.unsub=()=>{}},u=()=>{for(let d=0;d<i.length;d++)if(!(n==="allow"&&a[d].done)&&i[d]===void 0)return!1;return!0},l=()=>a.some(d=>!d.done),f=()=>{for(let d=0;d<i.length;d++)r==="last"&&a[d].done||(i[d]=void 0)},v=()=>{g(`Sync timeout exceeded (${s.toString()})`)},g=d=>{o&&clearTimeout(o),c(),p.dispose(d)},m=()=>{o=setTimeout(v,s);for(const[d,h]of a.entries())i[d]=void 0,h.unsub=h.source.on(y=>{if(G(y)){if(y.signal==="done"){if(h.finalData=i[d],h.unsub(),h.done=!0,h.unsub=()=>{},r==="undefined"&&(i[d]=void 0),n==="break"){g(`Source '${d.toString()}' done, and onSourceDone:'break' is set`);return}if(!l()){g("All sources done");return}}return}i[d]=y.value,u()&&(p.set([...i]),f(),o&&clearTimeout(o),o=setTimeout(v,s))})},p=x({onFirstSubscribe(){c(),m()},onNoSubscribers(){o&&clearTimeout(o),c()}});return{dispose:p.dispose,isDisposed:p.isDisposed,on:p.on,onValue:p.onValue}}function ge(e,t={}){const n=Object.keys(e),r=Object.values(e),s=ve(r,t);return L(s,i=>jr(n,i))}function lt(e,...t){const n=w(e),r=Process.flow(...t);return n.onValue(s=>{r(s)}),n}function ut(e,t){const n=w(e);return n.onValue(r=>{t.set(r)}),n}const ft=(e,...t)=>{for(const n of t)e=n(e);return e};function dt(e,t={}){const n=P(t.elapsed,0);let r=performance.now(),s;const o=$(e,{...t,onValue(a){s=a,i()}}),i=()=>{const a=performance.now();n>0&&a-r>n&&(r=a,s!==void 0&&o.set(s))};return N(o)}function pt(e,t){let n;const r=t.immediate??!0,s=t.repeat??!1,o=P(t.interval,1e3);if(!Mn(t))throw new Error("Param 'options' does not contain trigger 'value' or 'fn' fields");const i=()=>{const[c,u]=Rn(t);if(u)a.dispose("Trigger completed");else{if(a.isDisposed())return;a.set(c),s&&(n=setTimeout(i,o))}},a=$(e,{disposeIfSourceDone:!0,onValue(c){n&&clearTimeout(n),n=setTimeout(i,o),a.set(c)},onDispose(){n&&clearTimeout(n)}});return r&&!n&&(n=setTimeout(i,o)),a}function mt(e,t){let n;const r=w(e),s=t.abort,o=P(t,1e3),i=()=>{if(s?.aborted||r.isDisposed()){c();return}Ln(r)&&r.ping(),n=setTimeout(i,o)},a=()=>{n&&clearTimeout(n)},c=r.on(u=>{A(u)?(a(),n=setTimeout(i,o)):D(u)&&(c(),a())});return n=setTimeout(i,o),r}function Mo(e,t,n={}){const r=n.lazy??"initial",s=n.signal,o=w(e),i=n.gate??(v=>!0);let a,c;s&&s.addEventListener("abort",()=>{f(`Abort signal ${s.reason}`)},{once:!0});const u=x({onFirstSubscribe(){r!=="never"&&a===void 0&&l()},onNoSubscribers(){r==="very"&&a!==void 0&&(a(),a=void 0)}}),l=()=>{a=o.on(v=>{D(v)?f("Upstream closed"):G(v)?u.signal(v.signal):A(v)&&i(v.value)&&t.ping()}),c=t.on(v=>{D(v)?f("Downstream closed"):G(v)?u.signal(v.signal,v.context):A(v)&&u.set(v.value)})},f=v=>{u.dispose(v),a&&a(),c&&c()};return r==="never"&&l(),u}function Jn(e,t){let n=t.initial;const r=$(e,{...t,onValue(o){n=o,r.set(o)}});return{...N(r),last(){return n}}}const Ro=(e,t={})=>{if(Array.isArray(e))return Xn(e,t)},Xn=(e,t={})=>{const n=t.lazy??"initial",r=t.signal,s=t.whenStopped??"continue",o=t.debugLifecycle??!1,i=[...e];if(n!=="very"&&s==="reset")throw new Error(`whenStopped:'reset' has no effect with 'lazy:${n}'. Use lazy:'very' instead.`);const a=P(t.interval,5);let c=0,u=i[0];const l=_({...t,lazy:n,onStart(){o&&console.log("Rx.readFromArray:onStart"),f.start()},onStop(){o&&console.log(`Rx.readFromArray:onStop. whenStopped: ${s} index: ${c}`),f.cancel(),s==="reset"&&(c=0)}}),f=Le(()=>{if(r?.aborted)return l.dispose(`Signalled (${r.reason})`),!1;if(u=i[c],c++,l.set(u),c===i.length)return l.dispose("Source array complete"),!1},a);return n||f.start(),{dispose:l.dispose,isDisposed:l.isDisposed,isDone(){return c===i.length},last(){return u},on:l.on,onValue:l.onValue}};function Kn(e=[],t={}){const n=t.eq??Ut,r=x(),s=x();let o=e,i=!1;const a=p=>{ie(o,p,n),o=p,r.set([...p])},c=(p,d)=>{o[p]=d,r.set([...o])},u=p=>{o=[...o,p],r.set([...o]);const d=["add",o.length-1,p];s.set([d])},l=p=>{const d=pr(o,p);if(d.length===o.length)return;const h=ie(o,d,n);o=d,r.set([...o]),s.set(h.summary)},f=p=>{const d=o.filter(I=>!p(I)),h=o.length-d.length,y=ie(o,d,n);return o=d,r.set([...o]),s.set(y.summary),h},v=(p,d)=>{const h=dr(o,p,d),y=ie(o,h,n);o=h,r.set([...o]),s.set(y.summary)};return{dispose:p=>{i||(r.dispose(p),i=!0)},isDisposed(){return i},last:()=>o,on:r.on,onArray:s.on,onValue:r.onValue,setAt:c,push:u,deleteAt:l,deleteWhere:f,insertAt:v,set:a}}function jo(e){let t=e;const n=x(),r=s=>{t=s,n.set(s)};return{dispose:n.dispose,isDisposed:n.isDisposed,last:()=>t,on:n.on,onValue:n.onValue,set:r}}function _o(e={}){const t=e.lazy??"initial",n=P(e.interval,1e3),r=e.amount??1,s=e.offset??0;let o=0,i=s;const a=l=>{u.dispose(l)},c=Le(()=>{if(e.signal?.aborted)return a(`Aborted (${e.signal.reason})`),!1;if(u.set(i),i+=1,o++,o>=r)return a("Limit reached"),!1},n),u=_({onStart(){c.start()},onStop(){c.cancel()},onDispose(){c.cancel()},lazy:t});return u}function zo(e,t,n={}){const r=n.ignoreIdentical??!0,s=n.eq??Ut,o=me(t),i=u=>{const l=c.last(),f=e(u);if(f!==void 0){if(r&&l!==void 0&&s(f,l))return f;c.set(f)}return f},a=$(o,{...n,onValue(u){i(u)}}),c=He(a,e(o.last()));return c}function qo(e,t,n,r,s={}){const o={};return o[n]=r,he(ne(e,t,o,s),n,s)}function ne(e,t,n,r={}){let s;if(typeof e=="string"){if(s=document.querySelector(e),s===null)throw new Error(`Target query did not resolve to an element. Query: '${e}'`)}else s=e;if(s===null)throw new Error("Param 'targetOrQuery' is null");const o=r.debugLifecycle??!1,i=r.debugFiring??!1;r.diff;const a=r.lazy??!1;n===void 0&&(n={});const c=oe(n,{deepEntries:!0});let u=!1,l=!1;const f=m=>{i&&console.log(`Reactive.event '${t}' firing '${JSON.stringify(m)}`),c.set(m)},v=()=>{u&&(u=!1,s.removeEventListener(t,f),o&&console.log(`Rx.From.event remove '${t}'`))},g=()=>{u||(u=!0,s.addEventListener(t,f),o&&console.log(`Rx.From.event add '${t}'`))};return a||g(),{last:()=>(a&&g(),c.last()),dispose:m=>{l||(l=!0,v(),c.dispose(m))},isDisposed(){return l},on:m=>(a&&g(),c.on(m)),onValue:m=>(a&&g(),c.onValue(m))}}function ht(e,t,n={}){let r;if(typeof e=="string"){if(r=document.querySelector(e),r===null)throw new Error(`Target query did not resolve to an element. Query: '${e}'`)}else r=e;if(r===null)throw new Error("Param 'targetOrQuery' is null");const s=n.debugLifecycle??!1,o=n.debugFiring??!1,i=n.fireInitial??!1;let a=0;const c=Lr(),u=_({lazy:n.lazy??"very",onStart(){r.addEventListener(t,l),s&&console.log(`Rx.From.eventTrigger add '${t}'`),i&&a===0&&((s||o)&&console.log("Rx.From.eventTrigger: firing initial"),l())},onStop(){r.removeEventListener(t,l),s&&console.log(`Rx.From.eventTrigger remove '${t}'`)}}),l=f=>{o&&console.log(`Rx.From.eventTrigger '${t}' triggered'`),u.set({sinceLast:c(),total:++a})};return u}function Co(...e){return Yn(e)}function Yn(e,t={}){let n=[];const r=_({...t,onStart(){for(const s of e)n.push(s.onValue(o=>{r.set(o)}))},onStop(){for(const s of n)s();n=[]}});return r}function Bo(e){let t=e;const n=x(),r=s=>{t=s,n.set(s)};return{dispose:n.dispose,isDisposed:n.isDisposed,last:()=>t,on:n.on,onValue:n.onValue,set:r}}const Zn=Symbol("Rx"),Qn=e=>{const t=oe(e);return{proxy:new Proxy(e,{set(r,s,o,i){const a=Array.isArray(r);if(a&&s==="length")return!0;if(typeof s=="string"&&t.updateField(s,o),a&&typeof s=="string"){const c=Number.parseInt(s);if(!Number.isNaN(c))return r[c]=o,!0}return r[s]=o,!0}}),rx:t}},Uo=e=>{const t=Kn(e);return{proxy:new Proxy(e,{set(r,s,o,i){if(s==="length")return!0;if(typeof s!="string")throw new Error(`Expected numeric index, got type: ${typeof s} value: ${JSON.stringify(s)}`);const a=Number.parseInt(s);if(Number.isNaN(a))throw new Error(`Expected numeric index, got: '${s}'`);return t.setAt(a,o),r[a]=o,!0}}),rx:t}},Wo=e=>{const{proxy:t,rx:n}=Qn(e),r=t;return r[Zn]=n,r};function vt(e){const t=er(e);return{dispose:t.dispose,isDisposed:t.isDisposed,on:t.on,onValue:t.onValue}}function er(e){let t=()=>{};const n=yt({onFirstSubscribe(){t=e(n)},onNoSubscribers(){t&&t()}});return{...n,onValue:r=>n.on(s=>{A(s)&&r(s.value)})}}function Go(e){let t=e;const n=x(),r=s=>{t=s,n.set(s)};return{dispose:n.dispose,isDisposed:n.isDisposed,last:()=>t,on:n.on,onValue:n.onValue,set:r}}var tr={};F(tr,{array:()=>Xn,arrayObject:()=>Kn,arrayProxy:()=>Uo,boolean:()=>jo,count:()=>_o,derived:()=>zo,event:()=>ne,eventField:()=>qo,eventTrigger:()=>ht,func:()=>jn,iterator:()=>Pe,merged:()=>Co,mergedWithOptions:()=>Yn,number:()=>Bo,object:()=>oe,objectProxy:()=>Qn,objectProxySymbol:()=>Wo,observable:()=>vt,observableWritable:()=>er,of:()=>Ro,string:()=>Go});function Ho(e){const t=yt({onNoSubscribers(){e.removeEventListener("removed",n),e.removeEventListener("enqueue",r)},onFirstSubscribe(){e.addEventListener("removed",n),e.addEventListener("enqueue",r),t.set(e.toArray())}}),n=o=>{t.set(o.finalData)},r=o=>{t.set(o.finalData)};return{...t,set:o=>{e.enqueue(...o)}}}var nr={};F(nr,{asResponsive:()=>Ho});function Jo(e){let t=_r();const n=x();return{dispose:n.dispose,isDisposed:n.isDisposed,graph:t,on:n.on,onValue:n.onValue}}async function gt(e,t={}){const n=t.limit??Number.MAX_SAFE_INTEGER,r=P(t.maximumWait,10*1e3),s=t.underThreshold??"partial",o=[],i=w(e);return new Promise((c,u)=>{const l=()=>{if(clearTimeout(f),v(),o.length<n&&s==="throw"){u(new Error(`Threshold not reached. Wanted: ${n} got: ${o.length}. Maximum wait: ${r}`));return}if(o.length<n&&s==="fill")for(let g=0;g<n;g++)o[g]===void 0&&(o[g]=t.fillValue);c(o)},f=setTimeout(()=>{l()},r),v=i.on(g=>{D(g)?l():A(g)&&(o.push(g.value),o.length===n&&l())})})}async function rr(e,t={}){const n=t.limit??Number.MAX_SAFE_INTEGER,r=t.maximumWait??5*1e3,s=await gt(e,{limit:n,maximumWait:r,underThreshold:"partial"});if(t.limit&&s.length<t.limit)throw new Error(`Threshold not reached. Wanted: ${t.limit}, got ${s.length}`);return s}async function*Xo(e){const t=w(e);let n=a=>{},r=a=>{};const s=()=>new Promise((a,c)=>{n=a,r=c});let o=s(),i=!0;for(t.on(a=>{A(a)?(n(a.value),o=s()):D(a)&&(i=!1,r("Source has completed"))});i;)yield await o}function b(e){return{source:w(e),enacts:{setHtmlText:t=>Je(e,t)},annotate:t=>{const n=Xe(e,t);return b(n)},annotateWithOp:t=>{const n=Ke(e,t);return b(n)},chunk:t=>b(Ye(e,t)),debounce:(t={})=>b(qn(e,t)),field:(t,n={})=>{const r=he(e,t,n);return b(r)},filter:(t,n)=>b(et(e,t,n)),combineLatestToArray:(t,n={})=>{const r=[e,...t];return b(Ze(r,n))},combineLatestToObject:(t,n)=>{const r=n.name??"source",s={...t};return s[r]=e,b(me(s,n))},min:(t={})=>b(nt(e,t)),max:(t={})=>b(tt(e,t)),average:(t={})=>b(rt(e,t)),sum:(t={})=>b(st(e,t)),tally:(t={})=>b(ot(e,t)),split:(t={})=>it(e,t).map(r=>b(r)),splitLabelled:(...t)=>{const n=at(e,t);return At(n,s=>b(s.value))},switcher:(t,n={})=>{const r=ct(e,t,n);return At(r,o=>b(o.value))},syncToArray:(t,n={})=>{const r=[e,...t].map(o=>w(o)),s=ve(r,n);return b(s)},syncToObject:(t,n={})=>{const r=n.name??"source",s={...t};return s[r]=e,b(ge(s,n))},tapProcess:(...t)=>(lt(e,...t),b(e)),tapStream:t=>(ut(e,t),b(e)),tapOps:(t,...n)=>(ft(t,...n),b(t)),throttle:(t={})=>b(dt(e,t)),transform:(t,n={})=>b(L(e,t,n)),timeoutValue:t=>b(pt(e,t)),timeoutPing:t=>b(mt(e,t)),toArray:t=>gt(e,t),toArrayOrThrow:t=>rr(e,t),onValue:t=>{w(e).on(r=>{A(r)&&t(r.value)})}}}var Ko={};F(Ko,{Collections:()=>nr,From:()=>tr,Ops:()=>ei,Sinks:()=>Qo,annotate:()=>Xe,annotateWithOp:()=>Ke,average:()=>rt,cache:()=>He,chunk:()=>Ye,cloneFromFields:()=>_n,combineLatestToArray:()=>Ze,combineLatestToObject:()=>me,computeWithPrevious:()=>zn,debounce:()=>Qe,drop:()=>Bn,elapsed:()=>Cn,field:()=>he,filter:()=>et,hasLast:()=>z,initLazyStream:()=>_,initLazyStreamWithInitial:()=>Oo,initStream:()=>x,initUpstream:()=>$,interpolate:()=>Un,isPingable:()=>Ln,isReactive:()=>se,isTrigger:()=>Mn,isTriggerFunction:()=>We,isTriggerGenerator:()=>Ge,isTriggerValue:()=>Ue,isWrapped:()=>On,isWritable:()=>Be,manual:()=>yt,max:()=>tt,messageHasValue:()=>A,messageIsDoneSignal:()=>D,messageIsSignal:()=>G,min:()=>nt,opify:()=>T,pipe:()=>Gn,prepare:()=>Jo,rank:()=>Wn,resolveSource:()=>w,resolveTriggerValue:()=>Rn,run:()=>Yo,setHtmlText:()=>Je,singleFromArray:()=>Hn,split:()=>it,splitLabelled:()=>at,sum:()=>st,switcher:()=>ct,symbol:()=>Zn,syncToArray:()=>ve,syncToObject:()=>ge,takeNextValue:()=>ti,tally:()=>ot,tapOps:()=>ft,tapProcess:()=>lt,tapStream:()=>ut,throttle:()=>dt,timeoutPing:()=>mt,timeoutValue:()=>pt,to:()=>ni,toArray:()=>gt,toArrayOrThrow:()=>rr,toGenerator:()=>Xo,transform:()=>L,valueToPing:()=>Mo,withValue:()=>Jn,wrap:()=>b,writable:()=>Zo});function Yo(e,...t){let n=w(e);for(const r of t)n=r(n);return n}function Zo(e,...t){let n=w(e);const r=n;for(const o of t)n=o(n);return{...n,set(o){if(Be(r))r.set(o);else throw new Error("Original source is not writable")}}}function yt(e={}){const t=x(e);return{dispose:t.dispose,isDisposed:t.isDisposed,set(n){t.set(n)},on:t.on,onValue:t.onValue}}const Qo={setHtmlText:e=>t=>{Je(t,e)}},ei={annotate:e=>T(Xe,e),annotateWithOp:e=>T(Ke,e),chunk:e=>t=>Ye(t,e),cloneFromFields:()=>e=>_n(e),combineLatestToArray:(e={})=>t=>Ze(t,e),combineLatestToObject:(e={})=>t=>me(t,e),drop:e=>T(Bn,e),elapsed:()=>T(Cn),field:(e,t={})=>n=>he(n,e,t),filter:e=>T(et,e),interpolate:e=>T(Un,e),min:e=>T(nt,e),max:e=>T(tt,e),sum:e=>T(st,e),average:e=>T(rt,e),tally:e=>T(ot,e),rank:(e,t)=>T(Wn,e,t),pipe:(...e)=>t=>{const r=[w(t),...e];return Gn(...r)},singleFromArray:(e={})=>t=>Hn(t,e),split:(e={})=>t=>it(t,e),splitLabelled:e=>t=>at(t,e),switcher:(e,t={})=>n=>ct(n,e,t),syncToArray:(e={})=>t=>ve(t,e),syncToObject:(e={})=>t=>ge(t,e),tapProcess:e=>t=>lt(t,e),tapStream:e=>t=>ut(t,e),tapOps:(...e)=>t=>ft(t,...e),throttle:e=>T(dt,e),timeoutValue:e=>t=>pt(t,e),timeoutPing:e=>t=>mt(t,e),transform:(e,t={})=>n=>L(n,e,t),withValue:e=>T(Jn,e)};async function ti(e,t=1e3){const n=w(e);let r=()=>{},s;return new Promise((i,a)=>{r=n.on(c=>{s&&clearTimeout(s),A(c)?(r(),i(c.value)):D(c)&&(a(new Error(`Source closed. ${c.context??""}`)),r())}),s=setTimeout(()=>{s=void 0,r(),a(new Error(`Timeout waiting for value (${JSON.stringify(t)})`))},P(t))})}const ni=(e,t,n,r=!1)=>{const s=e.on(o=>{if(A(o)){const i=n?n(o.value):o.value;t.set(i)}else D(o)&&(s(),r&&t.dispose(`Source closed (${o.context??""})`))});return s},ri=(e,t)=>{if(e===null)throw new Error("Param 'elem' is null. Expected element to observe");if(e===void 0)throw new Error("Param 'elem' is undefined. Expected element to observe");const n=vt(r=>{const s=new ResizeObserver(o=>{r.set(o)});return s.observe(e),()=>{s.unobserve(e)}});return Qe({elapsed:t??100})(n)},si=e=>Qe({elapsed:e??100})(ne(window,"resize",{innerWidth:0,innerHeight:0})),oi=(e=document.documentElement)=>vt(n=>{const r=new MutationObserver(o=>{n.set(o)}),s={attributeFilter:["class"],attributes:!0};return r.observe(e,s),()=>{r.disconnect()}});function ii(e){let t=e;const n=x(),r=s=>{t=s,n.set(s)};return{dispose:n.dispose,isDisposed:n.isDisposed,last:()=>t,on:n.on,onValue:n.onValue,set:r,setHsl:s=>{r(s)}}}function ai(e,t={}){const n=bt(e,t),r=n.el,s=t.relative??!1,o=t.inverted??!1,i=L(n,c=>Number.parseFloat(c));return s&&(r.max=o?"0":"1",r.min=o?"1":"0",r.hasAttribute("step")||(r.step="0.1")),r.getAttribute("type")===null&&(r.type="range"),{...i,last(){return Number.parseFloat(n.last())},set:c=>{n.set(c.toString())}}}function ci(e,t={}){const n=bt(e,{...t,upstreamFilter:s=>typeof s=="object"?$e(s):s});return{...L(n,s=>xt(s,{scalar:!0,ensureSafe:!0})),last(){return xt(n.last(),{scalar:!0,ensureSafe:!0})},set(s){n.set(Xr(s))}}}function bt(e,t={}){const n=typeof e=="string"?document.querySelector(e):e;if(n===null&&typeof e=="string")throw new Error(`Element query could not be resolved '${e}'`);if(n===null)throw new Error("targetOrQuery is null");const r=C(e),o=(t.when??"changed")==="changed"?"change":"input",i=t.emitInitialValue??!1,a=t.fallbackValue??"",c=t.upstreamSource;let u=()=>{},l=t.attributeName,f=t.fieldName;f===void 0&&l===void 0&&(l=f="value");const v=()=>{let h;return l&&(h=r.getAttribute(l)),f&&(h=r[f]),h==null&&(h=a),h},g=h=>{l&&r.setAttribute(l,h),f&&(r[f]=h)},m=h=>{h=t.upstreamFilter?t.upstreamFilter(h):h,g(h)};c&&(u=c.onValue(m),z(c)&&m(c.last()));const p=ht(r,o,{fireInitial:i,debugFiring:t.debugFiring??!1,debugLifecycle:t.debugLifecycle??!1}),d=L(p,h=>v());return{...d,el:r,last(){return v()},set(h){g(h)},dispose(h){u(),d.dispose(h),p.dispose(h)}}}function li(e,t={}){const n=C(e),s=(t.when??"changed")==="changed"?"change":"input",o=t.emitInitialValue??!1,i=t.upstreamSource,a=new Map;let c=()=>{};const u=()=>{const p=new FormData(n),d=[];for(const[y,I]of p.entries()){const B=I.toString();let O=a.get(y);if(!O){const M=l(y,B);M&&(M.type==="range"||M.type==="number"?O="number":M.type==="color"?O="colour":M.type==="checkbox"&&(I==="true"||I==="on")?O="boolean":O="string",a.set(y,O))}if(O==="number")d.push([y,Number.parseFloat(B)]);else if(O==="boolean"){const M=B==="true";d.push([y,M])}else if(O==="colour"){const M=$e(B);d.push([y,Yr(M,{scalar:!1})])}else d.push([y,I.toString()])}for(const y of n.querySelectorAll('input[type="checkbox"]'))!y.checked&&y.value==="true"&&d.push([y.name,!1]);return Object.fromEntries(d)},l=(p,d)=>{const h=n.querySelector(`[name="${p}"]`);if(!h){console.warn(`Form does not contain an element with name="${p}"`);return}if(h.type==="radio"){const y=n.querySelector(`[name="${p}"][value="${d}"]`);if(!y){console.warn(`Form does not contain radio option for name=${p} value=${d}`);return}return y}return h},f=(p,d)=>{const h=l(p,d);if(h&&(h.nodeName==="INPUT"||h.nodeName==="SELECT")){if(h.type==="color")typeof d=="object"&&(d=$e(d));else if(h.type==="checkbox")if(typeof d=="boolean"){h.checked=d;return}else console.warn(`Rx.Sources.domForm: Trying to set non boolean type to a checkbox. Name: ${p} Value: ${d} (${typeof d})`);else if(h.type==="radio"){h.checked=!0;return}h.value=d}},v=p=>{for(const[d,h]of Object.entries(p)){let y=a.get(d);y||(y=typeof h,y==="object"&&(Kr(h),y="colour"),a.set(d,y));const I=t.upstreamFilter?t.upstreamFilter(d,h):h;f(d,I)}};i&&(c=i.onValue(v),z(i)&&v(i.last()));const g=ht(n,s,{fireInitial:o,debugFiring:t.debugFiring??!1,debugLifecycle:t.debugLifecycle??!1}),m=L(g,p=>u());return{...m,el:n,last(){return u()},set:v,setNamedValue:f,dispose(p){c(),m.dispose(p),g.dispose(p)}}}function ui(e){const t=[...document.querySelectorAll(e)];return oe(t)}const fi=(e,t,n={})=>ye(e,t,{...n,elField:"textContent"}),di=(e,t,n={})=>ye(e,t,{...n,elField:"value",attribName:"value"}),pi=(e,t,n={})=>ye(e,t,{...n,elField:"innerHTML"}),ye=(e,t,...n)=>{if(t===null)throw new Error("Param 'elOrQuery' is null");if(t===void 0)throw new Error("Param 'elOrQuery' is undefined");const r=C(t);let s=[];n.length===0?s.push({elField:"textContent"}):s=[...n];const o=s.map(i=>"element"in i?i:{...i,element:r});return ir(e,...o)},mi=(e,t)=>{const n=sr(e);return r=>{n(r,t)}},sr=e=>{if(e.elField!==void 0||e.cssVariable===void 0&&e.attribName===void 0&&e.cssProperty===void 0&&e.textContent===void 0&&e.htmlContent===void 0){const t=e.elField??"textContent";return(n,r)=>{r[t]=n}}if(e.attribName!==void 0){const t=e.attribName;return(n,r)=>{r.setAttribute(t,n)}}if(e.textContent)return(t,n)=>{n.textContent=t};if(e.htmlContent)return(t,n)=>{n.innerHTML=t};if(e.cssVariable!==void 0){let t=e.cssVariable;return t.startsWith("--")||(t="--"+t),(n,r)=>{r.style.setProperty(t,n)}}return e.cssProperty!==void 0?(t,n)=>{n.style[e.cssProperty]=t}:(t,n)=>{}},or=e=>{if(!(!e.transform&&!e.transformValue)){if(e.transformValue){if(e.sourceField===void 0)throw new Error("Expects 'sourceField' to be set when 'transformValue' is set");return t=>{const n=t[e.sourceField];return e.transformValue(n)}}else if(e.transform){if(e.sourceField!==void 0)throw new Error("If 'transform' is set, 'sourceField' is ignored");return t=>e.transform(t)}}},ir=(e,...t)=>{const n=t.map(i=>{if(i.element&&i.element!==void 0)return i;if(i.query)return{...i,element:C(i.query)};throw new Error(`Unable to resolve element. Missing 'element' or 'query' values on bind. ${JSON.stringify(i)}`)}),r=n.map(i=>({update:mi(i,i.element),transformer:or(i),sourceField:i.sourceField})),s=i=>{for(const a of r)if(a.transformer)a.update(a.transformer(i));else{const c=a.sourceField?i[a.sourceField]:i;typeof c=="object"?(a.sourceField,a.update(JSON.stringify(c))):a.update(c)}},o=e.on(i=>{A(i)?s(i.value):G(i)&&console.warn(i)});return z(e)&&s(e.last()),{remove:i=>{if(o(),i)for(const a of n)a.element.remove()}}},hi=(e,t,n)=>{const r=C(t),s=i=>{n(i,r)},o=e.on(i=>{A(i)?(console.log(i),s(i.value)):console.warn(i)});return z(e)&&s(e.last()),{remove:i=>{o(),i&&r.remove()}}},vi=(e,t,n,r={})=>{if(t===null)throw new Error("Param 'elOrQuery' is null");if(t===void 0)throw new Error("Param 'elOrQuery' is undefined");const s=C(t),o=c=>{n(c,s)},i=e.onDiff(c=>{o(c)}),a=()=>{z(e)&&r.initial&&r.initial(e.last(),s)};return a(),{refresh:()=>{a()},remove:c=>{i(),c&&s.remove()}}},gi=(e,t)=>{const n=t.container?C(t.container):document.body,r=t.defaultTag??"div",s=new Map,o=new Map;for(const[f,v]of Object.entries(t.binds??{})){const g=v.tagName??r;o.set(f,{...v,update:sr(v),transform:or(v),tagName:g,path:f})}const i=f=>{const v=Br(o,Ur(f));if(v!==void 0)return v;if(!f.includes("."))return o.get("_root")};function*a(f){for(const v of Wr(f))o.has(v)&&(yield o.get(v));o.has("_root")&&f.includes(".")&&(yield o.get("_root"))}const c=(f,v)=>{const g=Ae(f);console.log(`Rx.Dom.elements.create: ${f} rooted: ${g} value: ${JSON.stringify(v)}`);const m=i(Ae(f));let p=r;m?.tagName&&(p=m.tagName);const d=document.createElement(p);d.setAttribute("data-path",f),u(f,d,v);let h;for(const y of a(g))if(y?.nestChildren){const I=qr(f,"."),B=y.path.replace("_root",I);if(h=s.get(B),h!==void 0)break}(h??n).append(d),s.set(f,d),console.log(`Added el: ${f}`)},u=(f,v,g)=>{console.log(`Rx.dom.update path: ${f} value:`,g);const m=i(Ae(f));m===void 0?(typeof g=="object"&&(g=JSON.stringify(g)),v.textContent=g):(m.transform&&(g=m.transform(g)),m.update(g,v))},l=f=>{const v=new Wt({},f);let g=v.dequeue();const m=new Set;for(;g!==void 0;){const p=g.path;if(!("previous"in g)||g.previous===void 0){console.log(`Rx.Dom.elements.changes no previous. path: ${p}`),c(p,g.value);const d=[...Ve(g.value,!1,Number.MAX_SAFE_INTEGER,p)];console.log(d);for(const h of d)m.has(h.path)||(v.enqueue(h),m.add(h.path))}else if(g.value===void 0){const d=s.get(p);d===void 0?console.warn(`No element to delete? ${p} `):(console.log(`Rx.Dom.elements.changes delete ${p}`),d.remove())}else{const d=s.get(p);d===void 0?(console.warn(`Rx.Dom.elements.changes No element to update ? ${p} `),c(p,g.value)):u(p,d,g.value)}g=v.dequeue()}};if(e.onDiff(f=>{l(f)}),z(e)){const f=e.last();l([...Ve(f,!1,1)])}},Ae=e=>{const t=Cr(e,".");return t===e?"_root":"_root."+t};function yi(){const e=()=>({width:window.innerWidth,height:window.innerHeight}),t=ne(window,"resize",{lazy:"very",transform:()=>e()}),n=ne(window,"pointermove",{lazy:"very",transform:s=>{if(s===void 0)return{x:0,y:0};const o=s;return{x:o.x,y:o.y}}});return{dispose:(s="Reactive.win.dispose")=>{t.dispose(s),n.dispose(s)},size:t,pointer:n}}var bi={};F(bi,{bind:()=>ir,bindDiffUpdate:()=>vi,bindElement:()=>ye,bindHtml:()=>pi,bindText:()=>fi,bindUpdate:()=>hi,bindValueText:()=>di,browserResizeObservable:()=>ri,colour:()=>ii,cssClassChange:()=>oi,domForm:()=>li,domHslInputValue:()=>ci,domInputValue:()=>bt,domNumberInputValue:()=>ai,elements:()=>gi,fromDomQuery:()=>ui,win:()=>yi,windowResize:()=>si});export{Q as c,Ht as g,bi as r,Oe as u};
