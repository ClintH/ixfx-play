const o=(n,e,t)=>{const l=e.length+t.length,r=n.discardPolicy??"additions",c=n.capacity??l,i=l-c;switch(n.debug&&console.log(`Stack.push: stackLen: ${e.length} potentialLen: ${l} toRemove: ${i} policy: ${r}`),r){case"additions":return n.debug&&console.log(`Stack.push:DiscardAdditions: stackLen: ${e.length} slice: ${l-c} toAddLen: ${t.length}`),e.length===n.capacity?e:[...e,...t.slice(0,t.length-i)];case"newer":return i>=e.length?t.slice(Math.max(0,t.length-c),Math.min(t.length,c)+1):(n.debug&&console.log(` from orig: ${JSON.stringify(e.slice(0,e.length-i))}`),[...e.slice(0,e.length-i),...t.slice(0,Math.min(t.length,c-i+1))]);case"older":return[...e,...t].slice(i);default:throw new Error(`Unknown discard policy ${r}`)}},s=(n,e,...t)=>{const l=e.length+t.length;return n.capacity&&l>n.capacity?o(n,e,t):[...e,...t]},a=(n,e)=>{if(e.length===0)throw new Error("Stack is empty");return e.slice(0,-1)},h=(n,e)=>e.at(-1),g=(n,e)=>e.length===0,u=(n,e)=>n.capacity?e.length>=n.capacity:!1;export{h as a,a as b,u as c,g as i,s as p};
