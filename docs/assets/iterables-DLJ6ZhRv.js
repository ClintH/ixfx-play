import{_ as h,c as ne,g as te,l as oe}from"./src-BeVDUOoq-B6OoJ3p3.js";import{c as p,e as re,ae as I,f as w,K as ae,L as ie,M as se,N as fe,O as ce,af as g,P as ue,s as A,ag as le,ah as ye}from"./src-C7XtfIer-DYL4nwfS.js";const N=n=>typeof n!="object"||n===null?!1:Symbol.asyncIterator in n,T=n=>typeof n!="object"||n===null?!1:Symbol.iterator in n;var de={};h(de,{asCallback:()=>Fe,chunks:()=>me,concat:()=>ve,dropWhile:()=>we,equals:()=>he,every:()=>$e,fill:()=>ge,filter:()=>ke,find:()=>Ie,flatten:()=>xe,forEach:()=>_e,fromArray:()=>F,fromIterable:()=>q,last:()=>Ee,map:()=>Ae,max:()=>Ve,min:()=>Ne,nextWithTimeout:()=>S,reduce:()=>Te,repeat:()=>be,slice:()=>qe,some:()=>Pe,toArray:()=>x,unique:()=>De,uniqueByValue:()=>Ge,until:()=>pe,withDelay:()=>Se,zip:()=>Me});async function*F(n,t=1){for(const e of n)yield e,await w(t)}async function*q(n,t=1){for await(const e of n)yield e,await w(t)}async function*me(n,t){let e=[];for await(const o of n)e.push(o),e.length===t&&(yield e,e=[]);e.length>0&&(yield e)}async function*ve(...n){for await(const t of n)yield*t}async function*we(n,t){for await(const e of n)t(e)||(yield e)}const pe=async(n,t)=>{for await(const e of n){const o=await t();if(typeof o=="boolean"&&!o)break}},be=async function*(n,t){const e=typeof t=="number"?t:Number.POSITIVE_INFINITY,o=typeof t=="number"?void 0:t;let r=e;for(;;){for await(const a of n())if(yield a,o?.aborted)break;if(Number.isFinite(e)&&(r--,r===0)||o?.aborted)break}};async function he(n,t,e){const o=n[Symbol.asyncIterator](),r=t[Symbol.asyncIterator]();for(;;){const a=await o.next(),i=await r.next();if(e!==void 0){if(!e(a.value,i.value))return!1}else if(a.value!==i.value)return!1;if(a.done??i.done)return a.done&&i.done}}async function $e(n,t){for await(const e of n)if(!await t(e))return!1;return!0}async function*ge(n,t){for await(const e of n)yield t}async function*ke(n,t){for await(const e of n)await t(e)&&(yield e)}async function Ie(n,t){for await(const e of n)if(await t(e))return e}async function*xe(n){for await(const t of n)if(typeof t=="object"){if(Array.isArray(t))for(const e of t)yield e;else if(N(t))for await(const e of t)yield e;else if(T(t))for(const e of t)yield e}else yield t}const _e=async function(n,t,e={}){const o=e.interval;if(Array.isArray(n))for(const r of n){const a=await t(r);if(typeof a=="boolean"&&!a)break;o&&await w(o)}else for await(const r of n){const a=await t(r);if(typeof a=="boolean"&&!a)break;o&&await w(o)}};async function Ee(n,t={}){const e=t.abort;let o;for await(const r of n){if(e?.aborted)return;o=r}return o}async function*Ae(n,t){for await(const e of n)yield t(e)}async function*Ve(n,t=((e,o)=>e>o)){let e;for await(const o of n){if(e===void 0){e=o,yield e;continue}t(o,e)&&(e=o,yield o)}}async function*Ne(n,t=(e,o)=>e>o){let e;for await(const o of n){if(e===void 0){e=o,yield e;continue}t(e,o)&&(e=o,yield o)}return e}async function Te(n,t,e){for await(const o of n)e=t(e,o);return e}async function Fe(n,t,e){for await(const o of n)t(o);e&&e()}async function*qe(n,t=0,e=Number.POSITIVE_INFINITY){console.log(`Async slice start: ${t}`);const o=n[Symbol.asyncIterator]();if(e<t)throw new Error("Param 'end' should be more than 'start'");for(;t>0;t--,e--)await o.next();for await(const r of n)if(e-- >0)yield r;else break}async function*Se(n,t){for(const e of n)await w(t),yield e}async function S(n,t){const e=p(t,1e3),o=await Promise.race([(async()=>{await w({millis:e,signal:t.signal})})(),(async()=>await n.next())()]);if(o===void 0)throw new Error("Timeout");return o}async function Pe(n,t){for await(const e of n)if(await t(e))return!0;return!1}async function x(n,t={}){const e=[],o=n[Symbol.asyncIterator](),r=Date.now(),a=t.limit??Number.POSITIVE_INFINITY,i=t.while,f=p(t.elapsed,Number.POSITIVE_INFINITY);for(;e.length<a&&Date.now()-r<f&&!(i&&!i(e.length));){const u=await o.next();if(u.done)break;e.push(u.value)}return e}async function*De(n){const t=[],e=Array.isArray(n)?n:[n];for await(const o of e)for await(const r of o)t.includes(r)||(t.push(r),yield r)}async function*Ge(n,t=I,e=new Set){for await(const o of n){const r=t(o);e.has(r)||(e.add(r),yield o)}}async function*Me(...n){const t=n.map(e=>e[Symbol.asyncIterator]());for(;;){const e=await Promise.all(t.map(o=>o.next()));if(e.some(o=>o.done))return;yield e.map(o=>o.value)}}function*Oe(n,t=0,e=Number.POSITIVE_INFINITY){if(e<t)throw new Error("Param 'end' should be more than 'start'");if(t<0)throw new Error("Param 'start' should be at least 0");let o=0;for(const r of n){if(o<t){o++;continue}if(o>e)break;yield r,o++}}function Re(n,t,e){for(const o of n)e=t(e,o);return e}var Ce={};h(Ce,{asCallback:()=>Ye,chunks:()=>Xe,chunksOverlapping:()=>He,concat:()=>Ke,dropWhile:()=>Ue,equals:()=>Je,every:()=>Qe,fill:()=>en,filter:()=>tn,find:()=>on,first:()=>ze,flatten:()=>rn,forEach:()=>nn,fromArray:()=>vn,fromIterable:()=>dn,last:()=>Be,map:()=>an,max:()=>sn,min:()=>fn,next:()=>Ze,reduce:()=>Re,repeat:()=>un,slice:()=>Oe,some:()=>cn,toArray:()=>mn,unique:()=>ln,uniqueByValue:()=>je,until:()=>We,yieldNumber:()=>Le,zip:()=>yn});function*je(n,t=I,e=new Set){for(const o of n){const r=t(o);e.has(r)||(e.add(r),yield o)}}function Ye(n,t,e){for(const o of n)t(o);e&&e()}function Le(n,t){return()=>{const e=n.next().value;return e===void 0?t:e}}function ze(n){for(const t of n)return t}function Be(n){let t;for(const e of n)t=e;return t}function*He(n,t){if(t<=1)throw new Error("Size should be at least 2");let e=[];for(const o of n)e.push(o),e.length===t&&(yield e,e=[e.at(-1)]);e.length<=1||e.length>0&&(yield e)}function*Xe(n,t){let e=[];for(const o of n)e.push(o),e.length===t&&(yield e,e=[]);e.length>0&&(yield e)}function*Ke(...n){for(const t of n)yield*t}function*Ue(n,t){for(const e of n)t(e)||(yield e)}const We=(n,t)=>{for(const e of n){const o=t();if(typeof o=="boolean"&&!o)break}},Ze=n=>()=>{const t=n.next();if(!t.done)return t.value};function Je(n,t,e){for(;;){const o=n.next(),r=t.next();if(e!==void 0){if(!e(o.value,r.value))return!1}else if(o.value!==r.value)return!1;if(o.done??r.done)return o.done&&r.done}}function Qe(n,t){for(const e of n)if(!t(e))return!1;return!0}function*en(n,t){for(const e of n)yield t}function nn(n,t){for(const e of n){const o=t(e);if(typeof o=="boolean"&&!o)break}}function*tn(n,t){for(const e of n)t(e)&&(yield e)}function on(n,t){for(const e of n)if(t(e))return e}function*rn(n){for(const t of n)if(typeof t=="object"){if(Array.isArray(t))for(const e of t)yield e;else if(T(t))for(const e of t)yield e}else yield t}function*an(n,t){for(const e of n)yield t(e)}function*sn(n,t=(e,o)=>e>o){let e;for(const o of n){if(e===void 0){e=o,yield e;continue}t(o,e)&&(e=o,yield e)}return e}function*fn(n,t=(e,o)=>e>o){let e;for(const o of n)e===void 0&&(e=o,yield e),t(e,o)&&(e=o,yield e)}function cn(n,t){for(const e of n)if(t(e))return!0;return!1}function*un(n,t){const e=typeof t=="number"?t:Number.POSITIVE_INFINITY,o=typeof t=="number"?void 0:t;let r=e;for(;;){for(const a of n())if(yield a,o?.aborted)break;if(Number.isFinite(e)&&(r--,r===0)||o?.aborted)break}}function*ln(n){const t=[];let e=[];e=Array.isArray(n)?n:[n];for(const o of e)for(const r of o)t.includes(r)||(t.push(r),yield r)}function*yn(...n){const t=n.map(e=>e[Symbol.iterator]());for(;;){const e=t.map(o=>o.next());if(e.some(o=>o.done))return;yield e.map(o=>o.value)}}function*dn(n){for(const t of n)yield t}function mn(n,t={}){const e=[],o=Date.now(),r=t.while,a=t.limit??Number.POSITIVE_INFINITY,i=p(t.elapsed,Number.POSITIVE_INFINITY);for(const f of n){if(r&&!r(e.length)||e.length>=a||Date.now()-o>i)break;e.push(f)}return e}function*vn(n){for(const t of n)yield t}function k(n){return"_type"in n?n._type==="GenFactoryNoInput":!1}function*wn(n){yield n}async function*pn(n){yield n,await w(1)}function l(n){if(Array.isArray(n)){const t=n.values();return t._name="arrayInput",t}else{if(typeof n=="number"||typeof n=="boolean"||typeof n=="string")return wn(n);if(typeof n=="function")return n()}return n}function _(n){if(n!==void 0)return Array.isArray(n)?F(n):typeof n=="number"||typeof n=="boolean"||typeof n=="string"?pn(n):typeof n=="function"?n():N(n)?n:q(n)}function bn(n){if(typeof n=="string"){const t=document.querySelector(n);if(!t)throw new Error(`Element not found '${n}'`);return t}return n}var P={};h(P,{perValue:()=>$n,query:()=>gn});const hn=n=>{const t=n??(o=>o),e=new Map;return{has(o){return e.has(t(o))},get(o){return e.get(t(o))},set(o,r){e.set(t(o),r)},entries(){return e.entries()},delete(o){e.delete(o)}}};function $n(n={}){const t=n.byReference,e=n.tagName??"div";if(t&&n.key)throw new Error("byReference and key options are mutually exclusive");const o=t?void 0:n.key??I,r=hn(o),a=n.parentEl??document.body,i=bn(a),f=new Set;async function*u(y){for await(const c of l(y)){let s=r.get(c);s||(s=document.createElement(e),r.set(c,s),n.beforeInsert&&n.beforeInsert(s),i.append(s),n.afterInsert&&n.afterInsert(s)),f.add(s),yield{el:s,value:c}}for(const[c,s]of r.entries())f.has(s)||(n.beforeRemove&&n.beforeRemove(s),s.remove(),r.delete(c))}return u._name="dom.perValue",u}function gn(n={}){const t=n.baseElement??document;async function*e(o){const r=l(o);for await(const a of r)for(const i of t.querySelectorAll(a))yield i}return e._name="dom.query",e}var D={};h(D,{average:()=>X,chunk:()=>U,debounce:()=>j,delay:()=>C,drop:()=>Z,duration:()=>R,filter:()=>W,max:()=>z,min:()=>L,rank:()=>B,rankArray:()=>H,reduce:()=>O,sum:()=>K,take:()=>M,tally:()=>Y,transform:()=>G});function G(n){async function*t(e){e=l(e);for await(const o of e)yield n(o)}return t._name="transform",t}function M(n){async function*t(e){e=l(e);let o=0;for await(const r of e){if(++o>n)break;yield r}}return t._name="take",t}function O(n){async function*t(e){e=l(e);for await(const o of e)yield n(o)}return t._name="reduce",t}function R(n){const t=p(n,0);async function*e(o){o=l(o);const r=g();for await(const a of o){if(r()>t)break;yield a}}return e._name="duration",e}function C(n){const t=p(n.before,0),e=p(n.after,0);async function*o(r){r=l(r);for await(const a of r)t>0&&await w(t),yield a,e>0&&await w(e)}return o._name="delay",o}function j(n){const t=p(n,0);async function*e(o){o=l(o);let r=g();for await(const a of o)r()<t||(yield a,r=g())}return e._name="debounce",e}function Y(n=!0){async function*t(e){e=l(e);const o=ae(n);for await(const r of e)yield o(r)}return t._name="tally",t}function L(){async function*n(t){t=l(t);const e=fe();for await(const o of t){const r=e(o);r!==void 0&&(yield r)}}return n._name="min",n}function z(){async function*n(t){t=l(t);const e=ce();for await(const o of t){const r=e(o);r!==void 0&&(yield r)}}return n._name="max",n}function B(n,t={}){async function*e(o){o=l(o);const r=se(n,t);for await(const a of o){const i=r(a);i!==void 0&&(yield i)}}return e._name="rank",e}function H(n,t={}){const e=t.includeType,o=t.emitEqualRanked??!1,r=t.emitRepeatHighest??!1,a=t.withinArrays??!1;async function*i(f){f=l(f);let u;for await(const y of f){let c=!1;a&&(u=void 0);for(const s of y)if(!(e&&typeof s!==e))if(u===void 0)u=s,c=!0;else{const d=n(s,u);d=="a"?(u=s,c=!0):(d==="eq"&&o||r)&&(c=!0)}c&&u&&(yield u)}}return i._name="rankArray",i}function X(){async function*n(t){t=l(t);const e=ue();for await(const o of t){const r=e(o);r!==void 0&&(yield r)}}return n._name="average",n}function K(){async function*n(t){t=l(t);const e=ie();for await(const o of t){const r=e(o);r!==void 0&&(yield r)}}return n._name="total",n}function U(n,t=!0){ne(te(n,"aboveZero","size"));async function*e(o){o=l(o);let r=[];for await(const a of o)r.push(a),r.length>=n&&(yield r,r=[]);t&&r.length>0&&(yield r)}return e._name="chunk",e}function W(n){async function*t(e){e=l(e);for await(const o of e)n(o)&&(yield o)}return t._name="filter",t}function Z(n){async function*t(e){e=l(e);for await(const o of e)n(o)||(yield o)}return t._name="drop",t}function kn(n,t=5){async function*e(){for(const o of n)await w(t),yield o}return e._name="fromArray",e._type="GenFactoryNoInput",e}function In(n,t){async function*e(){for(;;)yield await ye(n,t)}return e._name="event",e._type="GenFactoryNoInput",e}function J(n){async function*t(){for(;;){const e=await n();if(typeof e>"u")break;yield e}}return t._name="fromFunction",t._type="GenFactoryNoInput",t}function xn(n){async function*t(){for await(const e of n)yield e}return t._name="fromIterable",t._type="GenFactoryNoInput",t}function _n(n){const t=p(n.interval,0),e=n.asClockTime??!1,o=n.loops??Number.MAX_SAFE_INTEGER;let r=0;const a=p(n.elapsed,Number.MAX_SAFE_INTEGER);async function*i(){const f=g();for(;r<o&&f()<a;){yield e?Date.now():f();const u=r*t-f();await w(Math.max(0,t+u)),r++}}return i._name="timestamp",i._type="GenFactoryNoInput",i}var Q={};h(Q,{array:()=>kn,event:()=>In,func:()=>J,iterable:()=>xn,timestamp:()=>_n});async function En(n,t){const e=typeof t=="function"?t():t;for await(const o of e)n.push(o)}async function An(n,t={}){const e=typeof n=="function"?n():n;return x(e,t)}async function Vn(n,t,e){const o=typeof n=="function"?n():n;for await(const r of o)t(r);e&&e()}function Nn(n){let t;const e=typeof n=="function"?n():n;async function o(){const r=await e.next();if(!r.done)return t=r.value,t}return o}function Tn(n,t){let e=t,o=!1;const r=typeof n=="function"?n():n;function a(){return o||(o=!0,r.next().then(i=>{e=i.value,o=!1}).catch(i=>{throw o=!1,i})),e}return a}async function*Fn(n,t={}){const e=t.onSourceDone??"break",o=t.finalValue??"undefined",r=t.afterEmit??"last",a=n.map((c,s)=>({waiting:void 0,index:s,gen:l(c),done:!1,lastValue:void 0})),i=()=>!a.some(c=>!c.done),f=()=>a.some(c=>c.waiting!==void 0),u=c=>!c.some(s=>s!==void 0);let y=[];for(;;){const c=[];for(const m of a){if(m.done)continue;if(m.waiting!==void 0){c.push(m.waiting);continue}const v=Promise.resolve((async()=>{if(m.done)return m;const $=await m.gen.next();return m.waiting=void 0,$.done?(m.done=!0,o==="undefined"&&(m.lastValue=void 0)):m.lastValue=$.value,m})());m.waiting=v,c.push(v)}const s=await Promise.race(c);if("done"in s){if(s.done&&e==="break")break}else throw new Error("Missing 'done' property");const d=a.map(m=>m.lastValue);if(d.length===0)return;const b=u(d);if(b&&!f())return;if(!oe(y,d)&&!b&&(y=d,yield d),r==="undefined")for(const m of a)m.waiting===void 0&&(m.lastValue=void 0);if(i())break}}async function*qn(n,t={}){const e=t.onSourceDone??"break",o=t.finalValue??"undefined",r=t.afterEmit??"last",a=new Map;for(const[s,d]of Object.entries(n))a.set(s,{gen:l(d),done:!1,lastValue:void 0,waiting:void 0,key:s});const i=()=>!A(a,s=>!s.done),f=()=>A(a,s=>s.waiting!==void 0),u=s=>{for(const d of Object.values(s))if(d!==void 0)return!1;return!0},y=()=>{const s={};for(const[d,b]of a)s[d]=b.lastValue;return s};let c;for(;;){const s=[];for(const v of a.values()){if(v.done)continue;if(v.waiting!==void 0){s.push(v.waiting);continue}const $=Promise.resolve((async()=>{if(v.done)return v;const E=await v.gen.next();return v.waiting=void 0,E.done?(v.done=!0,o==="undefined"&&(v.lastValue=void 0)):v.lastValue=E.value,v})());v.waiting=$,s.push($)}const d=await Promise.race(s);if("done"in d){if(d.done&&e==="break")break}else throw new Error("Result missing 'done' property");const b=y(),m=u(b);if(m&&!f())return;if(!le(c,b)&&!m&&(c=b,yield b),r==="undefined")for(const v of a.values())v.waiting===void 0&&(v.lastValue=void 0);if(i())break}}const V=n=>n._name??n.name;function Sn(){const n=[];let t;const e=r=>{r===void 0&&(r=t);let a=_(r);for(const i of n)if(a===void 0)if(k(i))a=i();else throw new Error(`Function '${V(i)}' requires input. Provide it to the function, or call 'input' earlier.`);else a=i(a);return a},o={rankArray:(r,a)=>(n.push(H(r,a)),o),rank:(r,a)=>(n.push(B(r,a)),o),transform:r=>(n.push(G(r)),o),reduce:r=>(n.push(O(r)),o),drop:r=>(n.push(Z(r)),o),delay:r=>(n.push(C(r)),o),duration:r=>(n.push(R(r)),o),debounce:r=>(n.push(j(r)),o),fromFunction:r=>(n.push(J(r)),o),take:r=>(n.push(M(r)),o),chunk:(r,a=!0)=>(n.push(U(r,a)),o),filter:r=>(n.push(W(a=>r(a))),o),min:()=>(n.push(L()),o),max:()=>(n.push(z()),o),average:()=>(n.push(X()),o),sum:()=>(n.push(K()),o),tally:r=>(n.push(Y(r)),o),input(r){return t=r,o},asGenerator:e,asAsync(r){let a=r??t;for(const i of n)if(a===void 0&&k(i))a=i();else{if(a===void 0)throw new Error(`Function '${V(i)}' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);a=i(a)}return o},asArray:async r=>{const a=e(r);return await x(a)},firstOutput:async r=>(await e(r).next()).value,lastOutput:async r=>{const a=e(r);let i;for await(const f of a)i=f;return i}};return o}var Pn=class{#e=[];enqueue(n){this.#e.push(n)}dequeue(){return this.#e.shift()}};async function*Dn(...n){const t=n.map(f=>_(f)),e=new Pn;let o=0;const r=async f=>{if(f===void 0){o++;return}const u=await f.next();u.done?o++:(e.enqueue(u.value),setTimeout(()=>r(f),1))};for(const f of t)setTimeout(()=>r(f),1);const a=10;let i=1;for(;o<t.length;){const f=e.dequeue();f===void 0?i=Math.min(i+1,10):(yield f,i=1),await w(a*i)}}async function*ee(...n){let t;for(const e of n)t=typeof e=="function"?e(t??[]):l(e);if(t!==void 0)for await(const e of t)yield e}async function*Gn(n,t,e,o,r,a,i){let f;const u=arguments;for(const y of u)typeof y=="function"?f=y(f??[]):f=l(y);if(f!==void 0)for await(const y of f)yield y}function Mn(...n){return e=>ee(e,...n)}async function On(n,t){return(await n([t]).next()).value}async function*Rn(n,t={}){const e=t.onSourceDone??"break",o=p(t.maximumWait,2e3),r=t.finalValue??"undefined",a=n.map(c=>({seq:0,lastValue:void 0,gen:l(c),done:!1})),i={millis:o};let f=0;const u=()=>!a.some(c=>!c.done);let y=!0;for(;y;){f++;for(const c of a){if(c.done){c.seq=f;continue}const s=await S(c.gen,i);if(s.done){if(c.done=!0,c.seq=f,r==="undefined"&&(c.lastValue=void 0),e==="break")return}else c.lastValue=s.value,c.seq=f}if(y){const c=a.filter(s=>s.seq===f).map(s=>s.lastValue);if(c.length===0||!c.some(s=>typeof s<"u"))return;yield c}u()&&(y=!1)}}var Cn={};h(Cn,{Dom:()=>P,From:()=>Q,Links:()=>D,addToArray:()=>En,asArray:()=>An,asCallback:()=>Vn,asPromise:()=>Nn,asValue:()=>Tn,combineLatestToArray:()=>Fn,combineLatestToObject:()=>qn,isGenFactoryNoInput:()=>k,lazy:()=>Sn,mergeFlat:()=>Dn,prepare:()=>Mn,resolveToAsyncGen:()=>_,resolveToGen:()=>l,run:()=>Gn,runN:()=>ee,single:()=>On,syncToArray:()=>Rn});const Ln=n=>{const t=p(n.delay,10);let e;const o=n.onValue;let r="stopped";const a=re(async()=>{if(e){const s=await e.next();if(s.done)return r="stopped",!1;const d=o(s.value);return typeof d=="boolean"?(d||(r="stopped"),d):!0}else return r="stopped",!1},t),i=()=>{r!=="stopped"&&(e=void 0,a.cancel(),r="stopped")},f=()=>{r!=="paused"&&(a.cancel(),r="paused")},u=()=>{r!=="running"&&(e||y(),r="running",a.start())},y=()=>{if(n.iterator)e=n.iterator();else throw new Error("No source iterator")};return{start:u,cancel:i,restart:()=>{y(),u()},pause:f,get state(){return r}}};export{de as a,Ln as i};
