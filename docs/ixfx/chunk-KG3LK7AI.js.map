{"version":3,"sources":["../node_modules/json5/dist/index.js","../src/rx/index.ts","../src/rx/Util.ts","../src/rx/sources/Function.ts","../src/rx/sources/Iterator.ts","../src/rx/ResolveSource.ts","../src/rx/InitStream.ts","../src/rx/ToReadable.ts","../src/rx/ops/Annotate.ts","../src/rx/ops/Batch.ts","../src/rx/ops/Transform.ts","../src/rx/ops/CloneFromFields.ts","../src/rx/ops/CombineLatestToArray.ts","../src/data/Pathed.ts","../src/data/Util.ts","../src/rx/sources/Object.ts","../src/rx/ops/CombineLatestToObject.ts","../src/rx/ops/Debounce.ts","../src/rx/ops/Elapsed.ts","../src/rx/ops/Field.ts","../src/rx/ops/Filter.ts","../src/rx/ops/Math.ts","../src/rx/ops/Pipe.ts","../src/rx/ops/SingleFromArray.ts","../src/rx/ops/Split.ts","../src/rx/ops/Switcher.ts","../src/rx/ops/SyncToArray.ts","../src/rx/ops/SyncToObject.ts","../src/data/Process.ts","../src/rx/ops/Tap.ts","../src/rx/ops/Throttle.ts","../src/rx/ops/TimeoutTrigger.ts","../src/rx/ops/WithValue.ts","../src/dom/SetProperty.ts","../src/rx/sinks/Dom.ts","../src/rx/Chain.ts","../src/data/graphs/DirectedGraph.ts","../src/data/Table.ts","../src/rx/Graph.ts","../src/rx/Types.ts","../src/rx/ToArray.ts","../src/rx/ToGenerator.ts","../src/data/MapObject.ts","../src/rx/Wrap.ts","../src/rx/Count.ts","../src/rx/Dom.ts","../src/text/Segments.ts","../src/rx/sources/index.ts","../src/rx/sources/Array.ts","../src/rx/sources/ArrayObject.ts","../src/rx/sources/Boolean.ts","../src/rx/sources/Event.ts","../src/data/index.ts","../src/data/Bipolar.ts","../src/data/Correlate.ts","../src/data/Flip.ts","../src/data/FrequencyMutable.ts","../src/data/IntervalTracker.ts","../src/data/KeysToNumbers.ts","../src/data/MovingAverage.ts","../src/data/Normalise.ts","../src/data/MonitorChanges.ts","../src/data/ObjectTracker.ts","../src/data/PointTracker.ts","../src/data/Pool.ts","../src/data/Proportion.ts","../src/data/ResolveFields.ts","../src/data/Softmax.ts","../src/data/TrackUnique.ts","../src/data/graphs/index.ts","../src/data/graphs/UndirectedGraph.ts","../src/visual/index.ts","../src/visual/Drawing.ts","../src/visual/Plot2.ts","../src/visual/SceneGraph.ts","../src/geometry/rect/Clamp.ts","../src/visual/ScaleCanvas.ts","../src/dom/DomRx.ts","../src/dom/CanvasSizing.ts","../src/visual/Palette.ts","../src/visual/BipolarView.ts","../src/visual/PlotOld.ts","../src/dom/index.ts","../src/dom/CanvasHelper.ts","../src/dom/Css.ts","../src/dom/CssVariables.ts","../src/dom/DataTable.ts","../src/dom/DataDisplay.ts","../src/dom/DragDrop.ts","../src/dom/El.ts","../src/dom/ElementSizing.ts","../src/dom/ErrorHandler.ts","../src/dom/ShadowDom.ts","../src/dom/Log.ts","../src/dom/InlineConsole.ts","../src/dom/PointerVisualise.ts","../src/dom/Query.ts","../src/dom/Util.ts","../src/rx/sources/Dom.ts","../src/rx/sources/FunctionPinged.ts","../src/rx/sources/Number.ts","../src/rx/sources/ObjectProxy.ts","../src/rx/sources/Observable.ts","../src/rx/sources/String.ts"],"sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.JSON5 = factory());\n}(this, (function () { 'use strict';\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar _global = createCommonjsModule(function (module) {\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self\n\t  // eslint-disable-next-line no-new-func\n\t  : Function('return this')();\n\tif (typeof __g == 'number') { __g = global; } // eslint-disable-line no-undef\n\t});\n\n\tvar _core = createCommonjsModule(function (module) {\n\tvar core = module.exports = { version: '2.6.5' };\n\tif (typeof __e == 'number') { __e = core; } // eslint-disable-line no-undef\n\t});\n\tvar _core_1 = _core.version;\n\n\tvar _isObject = function (it) {\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n\tvar _anObject = function (it) {\n\t  if (!_isObject(it)) { throw TypeError(it + ' is not an object!'); }\n\t  return it;\n\t};\n\n\tvar _fails = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (e) {\n\t    return true;\n\t  }\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar _descriptors = !_fails(function () {\n\t  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n\t});\n\n\tvar document = _global.document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar is = _isObject(document) && _isObject(document.createElement);\n\tvar _domCreate = function (it) {\n\t  return is ? document.createElement(it) : {};\n\t};\n\n\tvar _ie8DomDefine = !_descriptors && !_fails(function () {\n\t  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;\n\t});\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tvar _toPrimitive = function (it, S) {\n\t  if (!_isObject(it)) { return it; }\n\t  var fn, val;\n\t  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }\n\t  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) { return val; }\n\t  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n\tvar dP = Object.defineProperty;\n\n\tvar f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n\t  _anObject(O);\n\t  P = _toPrimitive(P, true);\n\t  _anObject(Attributes);\n\t  if (_ie8DomDefine) { try {\n\t    return dP(O, P, Attributes);\n\t  } catch (e) { /* empty */ } }\n\t  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported!'); }\n\t  if ('value' in Attributes) { O[P] = Attributes.value; }\n\t  return O;\n\t};\n\n\tvar _objectDp = {\n\t\tf: f\n\t};\n\n\tvar _propertyDesc = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\tvar _hide = _descriptors ? function (object, key, value) {\n\t  return _objectDp.f(object, key, _propertyDesc(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tvar _has = function (it, key) {\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n\tvar id = 0;\n\tvar px = Math.random();\n\tvar _uid = function (key) {\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n\tvar _library = false;\n\n\tvar _shared = createCommonjsModule(function (module) {\n\tvar SHARED = '__core-js_shared__';\n\tvar store = _global[SHARED] || (_global[SHARED] = {});\n\n\t(module.exports = function (key, value) {\n\t  return store[key] || (store[key] = value !== undefined ? value : {});\n\t})('versions', []).push({\n\t  version: _core.version,\n\t  mode: _library ? 'pure' : 'global',\n\t  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'\n\t});\n\t});\n\n\tvar _functionToString = _shared('native-function-to-string', Function.toString);\n\n\tvar _redefine = createCommonjsModule(function (module) {\n\tvar SRC = _uid('src');\n\n\tvar TO_STRING = 'toString';\n\tvar TPL = ('' + _functionToString).split(TO_STRING);\n\n\t_core.inspectSource = function (it) {\n\t  return _functionToString.call(it);\n\t};\n\n\t(module.exports = function (O, key, val, safe) {\n\t  var isFunction = typeof val == 'function';\n\t  if (isFunction) { _has(val, 'name') || _hide(val, 'name', key); }\n\t  if (O[key] === val) { return; }\n\t  if (isFunction) { _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); }\n\t  if (O === _global) {\n\t    O[key] = val;\n\t  } else if (!safe) {\n\t    delete O[key];\n\t    _hide(O, key, val);\n\t  } else if (O[key]) {\n\t    O[key] = val;\n\t  } else {\n\t    _hide(O, key, val);\n\t  }\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, TO_STRING, function toString() {\n\t  return typeof this == 'function' && this[SRC] || _functionToString.call(this);\n\t});\n\t});\n\n\tvar _aFunction = function (it) {\n\t  if (typeof it != 'function') { throw TypeError(it + ' is not a function!'); }\n\t  return it;\n\t};\n\n\t// optional / simple context binding\n\n\tvar _ctx = function (fn, that, length) {\n\t  _aFunction(fn);\n\t  if (that === undefined) { return fn; }\n\t  switch (length) {\n\t    case 1: return function (a) {\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function (a, b) {\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function (a, b, c) {\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\tvar PROTOTYPE = 'prototype';\n\n\tvar $export = function (type, name, source) {\n\t  var IS_FORCED = type & $export.F;\n\t  var IS_GLOBAL = type & $export.G;\n\t  var IS_STATIC = type & $export.S;\n\t  var IS_PROTO = type & $export.P;\n\t  var IS_BIND = type & $export.B;\n\t  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];\n\t  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});\n\t  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n\t  var key, own, out, exp;\n\t  if (IS_GLOBAL) { source = name; }\n\t  for (key in source) {\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    // export native or passed\n\t    out = (own ? target : source)[key];\n\t    // bind timers to global for call from export context\n\t    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;\n\t    // extend global\n\t    if (target) { _redefine(target, key, out, type & $export.U); }\n\t    // export\n\t    if (exports[key] != out) { _hide(exports, key, exp); }\n\t    if (IS_PROTO && expProto[key] != out) { expProto[key] = out; }\n\t  }\n\t};\n\t_global.core = _core;\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library`\n\tvar _export = $export;\n\n\t// 7.1.4 ToInteger\n\tvar ceil = Math.ceil;\n\tvar floor = Math.floor;\n\tvar _toInteger = function (it) {\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tvar _defined = function (it) {\n\t  if (it == undefined) { throw TypeError(\"Can't call method on  \" + it); }\n\t  return it;\n\t};\n\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tvar _stringAt = function (TO_STRING) {\n\t  return function (that, pos) {\n\t    var s = String(_defined(that));\n\t    var i = _toInteger(pos);\n\t    var l = s.length;\n\t    var a, b;\n\t    if (i < 0 || i >= l) { return TO_STRING ? '' : undefined; }\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n\tvar $at = _stringAt(false);\n\t_export(_export.P, 'String', {\n\t  // 21.1.3.3 String.prototype.codePointAt(pos)\n\t  codePointAt: function codePointAt(pos) {\n\t    return $at(this, pos);\n\t  }\n\t});\n\n\tvar codePointAt = _core.String.codePointAt;\n\n\tvar max = Math.max;\n\tvar min = Math.min;\n\tvar _toAbsoluteIndex = function (index, length) {\n\t  index = _toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n\tvar fromCharCode = String.fromCharCode;\n\tvar $fromCodePoint = String.fromCodePoint;\n\n\t// length should be 1, old FF problem\n\t_export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n\t  // 21.1.2.2 String.fromCodePoint(...codePoints)\n\t  fromCodePoint: function fromCodePoint(x) {\n\t    var arguments$1 = arguments;\n\t // eslint-disable-line no-unused-vars\n\t    var res = [];\n\t    var aLen = arguments.length;\n\t    var i = 0;\n\t    var code;\n\t    while (aLen > i) {\n\t      code = +arguments$1[i++];\n\t      if (_toAbsoluteIndex(code, 0x10ffff) !== code) { throw RangeError(code + ' is not a valid code point'); }\n\t      res.push(code < 0x10000\n\t        ? fromCharCode(code)\n\t        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n\t      );\n\t    } return res.join('');\n\t  }\n\t});\n\n\tvar fromCodePoint = _core.String.fromCodePoint;\n\n\t// This is a generated file. Do not edit.\n\tvar Space_Separator = /[\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/;\n\tvar ID_Start = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE83\\uDE86-\\uDE89\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\n\tvar ID_Continue = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF9\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE83\\uDE86-\\uDE99\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/;\n\n\tvar unicode = {\n\t\tSpace_Separator: Space_Separator,\n\t\tID_Start: ID_Start,\n\t\tID_Continue: ID_Continue\n\t};\n\n\tvar util = {\n\t    isSpaceSeparator: function isSpaceSeparator (c) {\n\t        return typeof c === 'string' && unicode.Space_Separator.test(c)\n\t    },\n\n\t    isIdStartChar: function isIdStartChar (c) {\n\t        return typeof c === 'string' && (\n\t            (c >= 'a' && c <= 'z') ||\n\t        (c >= 'A' && c <= 'Z') ||\n\t        (c === '$') || (c === '_') ||\n\t        unicode.ID_Start.test(c)\n\t        )\n\t    },\n\n\t    isIdContinueChar: function isIdContinueChar (c) {\n\t        return typeof c === 'string' && (\n\t            (c >= 'a' && c <= 'z') ||\n\t        (c >= 'A' && c <= 'Z') ||\n\t        (c >= '0' && c <= '9') ||\n\t        (c === '$') || (c === '_') ||\n\t        (c === '\\u200C') || (c === '\\u200D') ||\n\t        unicode.ID_Continue.test(c)\n\t        )\n\t    },\n\n\t    isDigit: function isDigit (c) {\n\t        return typeof c === 'string' && /[0-9]/.test(c)\n\t    },\n\n\t    isHexDigit: function isHexDigit (c) {\n\t        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)\n\t    },\n\t};\n\n\tvar source;\n\tvar parseState;\n\tvar stack;\n\tvar pos;\n\tvar line;\n\tvar column;\n\tvar token;\n\tvar key;\n\tvar root;\n\n\tvar parse = function parse (text, reviver) {\n\t    source = String(text);\n\t    parseState = 'start';\n\t    stack = [];\n\t    pos = 0;\n\t    line = 1;\n\t    column = 0;\n\t    token = undefined;\n\t    key = undefined;\n\t    root = undefined;\n\n\t    do {\n\t        token = lex();\n\n\t        // This code is unreachable.\n\t        // if (!parseStates[parseState]) {\n\t        //     throw invalidParseState()\n\t        // }\n\n\t        parseStates[parseState]();\n\t    } while (token.type !== 'eof')\n\n\t    if (typeof reviver === 'function') {\n\t        return internalize({'': root}, '', reviver)\n\t    }\n\n\t    return root\n\t};\n\n\tfunction internalize (holder, name, reviver) {\n\t    var value = holder[name];\n\t    if (value != null && typeof value === 'object') {\n\t        if (Array.isArray(value)) {\n\t            for (var i = 0; i < value.length; i++) {\n\t                var key = String(i);\n\t                var replacement = internalize(value, key, reviver);\n\t                if (replacement === undefined) {\n\t                    delete value[key];\n\t                } else {\n\t                    Object.defineProperty(value, key, {\n\t                        value: replacement,\n\t                        writable: true,\n\t                        enumerable: true,\n\t                        configurable: true,\n\t                    });\n\t                }\n\t            }\n\t        } else {\n\t            for (var key$1 in value) {\n\t                var replacement$1 = internalize(value, key$1, reviver);\n\t                if (replacement$1 === undefined) {\n\t                    delete value[key$1];\n\t                } else {\n\t                    Object.defineProperty(value, key$1, {\n\t                        value: replacement$1,\n\t                        writable: true,\n\t                        enumerable: true,\n\t                        configurable: true,\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    return reviver.call(holder, name, value)\n\t}\n\n\tvar lexState;\n\tvar buffer;\n\tvar doubleQuote;\n\tvar sign;\n\tvar c;\n\n\tfunction lex () {\n\t    lexState = 'default';\n\t    buffer = '';\n\t    doubleQuote = false;\n\t    sign = 1;\n\n\t    for (;;) {\n\t        c = peek();\n\n\t        // This code is unreachable.\n\t        // if (!lexStates[lexState]) {\n\t        //     throw invalidLexState(lexState)\n\t        // }\n\n\t        var token = lexStates[lexState]();\n\t        if (token) {\n\t            return token\n\t        }\n\t    }\n\t}\n\n\tfunction peek () {\n\t    if (source[pos]) {\n\t        return String.fromCodePoint(source.codePointAt(pos))\n\t    }\n\t}\n\n\tfunction read () {\n\t    var c = peek();\n\n\t    if (c === '\\n') {\n\t        line++;\n\t        column = 0;\n\t    } else if (c) {\n\t        column += c.length;\n\t    } else {\n\t        column++;\n\t    }\n\n\t    if (c) {\n\t        pos += c.length;\n\t    }\n\n\t    return c\n\t}\n\n\tvar lexStates = {\n\t    default: function default$1 () {\n\t        switch (c) {\n\t        case '\\t':\n\t        case '\\v':\n\t        case '\\f':\n\t        case ' ':\n\t        case '\\u00A0':\n\t        case '\\uFEFF':\n\t        case '\\n':\n\t        case '\\r':\n\t        case '\\u2028':\n\t        case '\\u2029':\n\t            read();\n\t            return\n\n\t        case '/':\n\t            read();\n\t            lexState = 'comment';\n\t            return\n\n\t        case undefined:\n\t            read();\n\t            return newToken('eof')\n\t        }\n\n\t        if (util.isSpaceSeparator(c)) {\n\t            read();\n\t            return\n\t        }\n\n\t        // This code is unreachable.\n\t        // if (!lexStates[parseState]) {\n\t        //     throw invalidLexState(parseState)\n\t        // }\n\n\t        return lexStates[parseState]()\n\t    },\n\n\t    comment: function comment () {\n\t        switch (c) {\n\t        case '*':\n\t            read();\n\t            lexState = 'multiLineComment';\n\t            return\n\n\t        case '/':\n\t            read();\n\t            lexState = 'singleLineComment';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    multiLineComment: function multiLineComment () {\n\t        switch (c) {\n\t        case '*':\n\t            read();\n\t            lexState = 'multiLineCommentAsterisk';\n\t            return\n\n\t        case undefined:\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t    },\n\n\t    multiLineCommentAsterisk: function multiLineCommentAsterisk () {\n\t        switch (c) {\n\t        case '*':\n\t            read();\n\t            return\n\n\t        case '/':\n\t            read();\n\t            lexState = 'default';\n\t            return\n\n\t        case undefined:\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t        lexState = 'multiLineComment';\n\t    },\n\n\t    singleLineComment: function singleLineComment () {\n\t        switch (c) {\n\t        case '\\n':\n\t        case '\\r':\n\t        case '\\u2028':\n\t        case '\\u2029':\n\t            read();\n\t            lexState = 'default';\n\t            return\n\n\t        case undefined:\n\t            read();\n\t            return newToken('eof')\n\t        }\n\n\t        read();\n\t    },\n\n\t    value: function value () {\n\t        switch (c) {\n\t        case '{':\n\t        case '[':\n\t            return newToken('punctuator', read())\n\n\t        case 'n':\n\t            read();\n\t            literal('ull');\n\t            return newToken('null', null)\n\n\t        case 't':\n\t            read();\n\t            literal('rue');\n\t            return newToken('boolean', true)\n\n\t        case 'f':\n\t            read();\n\t            literal('alse');\n\t            return newToken('boolean', false)\n\n\t        case '-':\n\t        case '+':\n\t            if (read() === '-') {\n\t                sign = -1;\n\t            }\n\n\t            lexState = 'sign';\n\t            return\n\n\t        case '.':\n\t            buffer = read();\n\t            lexState = 'decimalPointLeading';\n\t            return\n\n\t        case '0':\n\t            buffer = read();\n\t            lexState = 'zero';\n\t            return\n\n\t        case '1':\n\t        case '2':\n\t        case '3':\n\t        case '4':\n\t        case '5':\n\t        case '6':\n\t        case '7':\n\t        case '8':\n\t        case '9':\n\t            buffer = read();\n\t            lexState = 'decimalInteger';\n\t            return\n\n\t        case 'I':\n\t            read();\n\t            literal('nfinity');\n\t            return newToken('numeric', Infinity)\n\n\t        case 'N':\n\t            read();\n\t            literal('aN');\n\t            return newToken('numeric', NaN)\n\n\t        case '\"':\n\t        case \"'\":\n\t            doubleQuote = (read() === '\"');\n\t            buffer = '';\n\t            lexState = 'string';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    identifierNameStartEscape: function identifierNameStartEscape () {\n\t        if (c !== 'u') {\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t        var u = unicodeEscape();\n\t        switch (u) {\n\t        case '$':\n\t        case '_':\n\t            break\n\n\t        default:\n\t            if (!util.isIdStartChar(u)) {\n\t                throw invalidIdentifier()\n\t            }\n\n\t            break\n\t        }\n\n\t        buffer += u;\n\t        lexState = 'identifierName';\n\t    },\n\n\t    identifierName: function identifierName () {\n\t        switch (c) {\n\t        case '$':\n\t        case '_':\n\t        case '\\u200C':\n\t        case '\\u200D':\n\t            buffer += read();\n\t            return\n\n\t        case '\\\\':\n\t            read();\n\t            lexState = 'identifierNameEscape';\n\t            return\n\t        }\n\n\t        if (util.isIdContinueChar(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('identifier', buffer)\n\t    },\n\n\t    identifierNameEscape: function identifierNameEscape () {\n\t        if (c !== 'u') {\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t        var u = unicodeEscape();\n\t        switch (u) {\n\t        case '$':\n\t        case '_':\n\t        case '\\u200C':\n\t        case '\\u200D':\n\t            break\n\n\t        default:\n\t            if (!util.isIdContinueChar(u)) {\n\t                throw invalidIdentifier()\n\t            }\n\n\t            break\n\t        }\n\n\t        buffer += u;\n\t        lexState = 'identifierName';\n\t    },\n\n\t    sign: function sign$1 () {\n\t        switch (c) {\n\t        case '.':\n\t            buffer = read();\n\t            lexState = 'decimalPointLeading';\n\t            return\n\n\t        case '0':\n\t            buffer = read();\n\t            lexState = 'zero';\n\t            return\n\n\t        case '1':\n\t        case '2':\n\t        case '3':\n\t        case '4':\n\t        case '5':\n\t        case '6':\n\t        case '7':\n\t        case '8':\n\t        case '9':\n\t            buffer = read();\n\t            lexState = 'decimalInteger';\n\t            return\n\n\t        case 'I':\n\t            read();\n\t            literal('nfinity');\n\t            return newToken('numeric', sign * Infinity)\n\n\t        case 'N':\n\t            read();\n\t            literal('aN');\n\t            return newToken('numeric', NaN)\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    zero: function zero () {\n\t        switch (c) {\n\t        case '.':\n\t            buffer += read();\n\t            lexState = 'decimalPoint';\n\t            return\n\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\n\t        case 'x':\n\t        case 'X':\n\t            buffer += read();\n\t            lexState = 'hexadecimal';\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * 0)\n\t    },\n\n\t    decimalInteger: function decimalInteger () {\n\t        switch (c) {\n\t        case '.':\n\t            buffer += read();\n\t            lexState = 'decimalPoint';\n\t            return\n\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    decimalPointLeading: function decimalPointLeading () {\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalFraction';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    decimalPoint: function decimalPoint () {\n\t        switch (c) {\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalFraction';\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    decimalFraction: function decimalFraction () {\n\t        switch (c) {\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    decimalExponent: function decimalExponent () {\n\t        switch (c) {\n\t        case '+':\n\t        case '-':\n\t            buffer += read();\n\t            lexState = 'decimalExponentSign';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalExponentInteger';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    decimalExponentSign: function decimalExponentSign () {\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalExponentInteger';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    decimalExponentInteger: function decimalExponentInteger () {\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    hexadecimal: function hexadecimal () {\n\t        if (util.isHexDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'hexadecimalInteger';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    hexadecimalInteger: function hexadecimalInteger () {\n\t        if (util.isHexDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    string: function string () {\n\t        switch (c) {\n\t        case '\\\\':\n\t            read();\n\t            buffer += escape();\n\t            return\n\n\t        case '\"':\n\t            if (doubleQuote) {\n\t                read();\n\t                return newToken('string', buffer)\n\t            }\n\n\t            buffer += read();\n\t            return\n\n\t        case \"'\":\n\t            if (!doubleQuote) {\n\t                read();\n\t                return newToken('string', buffer)\n\t            }\n\n\t            buffer += read();\n\t            return\n\n\t        case '\\n':\n\t        case '\\r':\n\t            throw invalidChar(read())\n\n\t        case '\\u2028':\n\t        case '\\u2029':\n\t            separatorChar(c);\n\t            break\n\n\t        case undefined:\n\t            throw invalidChar(read())\n\t        }\n\n\t        buffer += read();\n\t    },\n\n\t    start: function start () {\n\t        switch (c) {\n\t        case '{':\n\t        case '[':\n\t            return newToken('punctuator', read())\n\n\t        // This code is unreachable since the default lexState handles eof.\n\t        // case undefined:\n\t        //     return newToken('eof')\n\t        }\n\n\t        lexState = 'value';\n\t    },\n\n\t    beforePropertyName: function beforePropertyName () {\n\t        switch (c) {\n\t        case '$':\n\t        case '_':\n\t            buffer = read();\n\t            lexState = 'identifierName';\n\t            return\n\n\t        case '\\\\':\n\t            read();\n\t            lexState = 'identifierNameStartEscape';\n\t            return\n\n\t        case '}':\n\t            return newToken('punctuator', read())\n\n\t        case '\"':\n\t        case \"'\":\n\t            doubleQuote = (read() === '\"');\n\t            lexState = 'string';\n\t            return\n\t        }\n\n\t        if (util.isIdStartChar(c)) {\n\t            buffer += read();\n\t            lexState = 'identifierName';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    afterPropertyName: function afterPropertyName () {\n\t        if (c === ':') {\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    beforePropertyValue: function beforePropertyValue () {\n\t        lexState = 'value';\n\t    },\n\n\t    afterPropertyValue: function afterPropertyValue () {\n\t        switch (c) {\n\t        case ',':\n\t        case '}':\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    beforeArrayValue: function beforeArrayValue () {\n\t        if (c === ']') {\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        lexState = 'value';\n\t    },\n\n\t    afterArrayValue: function afterArrayValue () {\n\t        switch (c) {\n\t        case ',':\n\t        case ']':\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    end: function end () {\n\t        // This code is unreachable since it's handled by the default lexState.\n\t        // if (c === undefined) {\n\t        //     read()\n\t        //     return newToken('eof')\n\t        // }\n\n\t        throw invalidChar(read())\n\t    },\n\t};\n\n\tfunction newToken (type, value) {\n\t    return {\n\t        type: type,\n\t        value: value,\n\t        line: line,\n\t        column: column,\n\t    }\n\t}\n\n\tfunction literal (s) {\n\t    for (var i = 0, list = s; i < list.length; i += 1) {\n\t        var c = list[i];\n\n\t        var p = peek();\n\n\t        if (p !== c) {\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t    }\n\t}\n\n\tfunction escape () {\n\t    var c = peek();\n\t    switch (c) {\n\t    case 'b':\n\t        read();\n\t        return '\\b'\n\n\t    case 'f':\n\t        read();\n\t        return '\\f'\n\n\t    case 'n':\n\t        read();\n\t        return '\\n'\n\n\t    case 'r':\n\t        read();\n\t        return '\\r'\n\n\t    case 't':\n\t        read();\n\t        return '\\t'\n\n\t    case 'v':\n\t        read();\n\t        return '\\v'\n\n\t    case '0':\n\t        read();\n\t        if (util.isDigit(peek())) {\n\t            throw invalidChar(read())\n\t        }\n\n\t        return '\\0'\n\n\t    case 'x':\n\t        read();\n\t        return hexEscape()\n\n\t    case 'u':\n\t        read();\n\t        return unicodeEscape()\n\n\t    case '\\n':\n\t    case '\\u2028':\n\t    case '\\u2029':\n\t        read();\n\t        return ''\n\n\t    case '\\r':\n\t        read();\n\t        if (peek() === '\\n') {\n\t            read();\n\t        }\n\n\t        return ''\n\n\t    case '1':\n\t    case '2':\n\t    case '3':\n\t    case '4':\n\t    case '5':\n\t    case '6':\n\t    case '7':\n\t    case '8':\n\t    case '9':\n\t        throw invalidChar(read())\n\n\t    case undefined:\n\t        throw invalidChar(read())\n\t    }\n\n\t    return read()\n\t}\n\n\tfunction hexEscape () {\n\t    var buffer = '';\n\t    var c = peek();\n\n\t    if (!util.isHexDigit(c)) {\n\t        throw invalidChar(read())\n\t    }\n\n\t    buffer += read();\n\n\t    c = peek();\n\t    if (!util.isHexDigit(c)) {\n\t        throw invalidChar(read())\n\t    }\n\n\t    buffer += read();\n\n\t    return String.fromCodePoint(parseInt(buffer, 16))\n\t}\n\n\tfunction unicodeEscape () {\n\t    var buffer = '';\n\t    var count = 4;\n\n\t    while (count-- > 0) {\n\t        var c = peek();\n\t        if (!util.isHexDigit(c)) {\n\t            throw invalidChar(read())\n\t        }\n\n\t        buffer += read();\n\t    }\n\n\t    return String.fromCodePoint(parseInt(buffer, 16))\n\t}\n\n\tvar parseStates = {\n\t    start: function start () {\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        push();\n\t    },\n\n\t    beforePropertyName: function beforePropertyName () {\n\t        switch (token.type) {\n\t        case 'identifier':\n\t        case 'string':\n\t            key = token.value;\n\t            parseState = 'afterPropertyName';\n\t            return\n\n\t        case 'punctuator':\n\t            // This code is unreachable since it's handled by the lexState.\n\t            // if (token.value !== '}') {\n\t            //     throw invalidToken()\n\t            // }\n\n\t            pop();\n\t            return\n\n\t        case 'eof':\n\t            throw invalidEOF()\n\t        }\n\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // throw invalidToken()\n\t    },\n\n\t    afterPropertyName: function afterPropertyName () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'punctuator' || token.value !== ':') {\n\t        //     throw invalidToken()\n\t        // }\n\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        parseState = 'beforePropertyValue';\n\t    },\n\n\t    beforePropertyValue: function beforePropertyValue () {\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        push();\n\t    },\n\n\t    beforeArrayValue: function beforeArrayValue () {\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        if (token.type === 'punctuator' && token.value === ']') {\n\t            pop();\n\t            return\n\t        }\n\n\t        push();\n\t    },\n\n\t    afterPropertyValue: function afterPropertyValue () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'punctuator') {\n\t        //     throw invalidToken()\n\t        // }\n\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        switch (token.value) {\n\t        case ',':\n\t            parseState = 'beforePropertyName';\n\t            return\n\n\t        case '}':\n\t            pop();\n\t        }\n\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // throw invalidToken()\n\t    },\n\n\t    afterArrayValue: function afterArrayValue () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'punctuator') {\n\t        //     throw invalidToken()\n\t        // }\n\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        switch (token.value) {\n\t        case ',':\n\t            parseState = 'beforeArrayValue';\n\t            return\n\n\t        case ']':\n\t            pop();\n\t        }\n\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // throw invalidToken()\n\t    },\n\n\t    end: function end () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'eof') {\n\t        //     throw invalidToken()\n\t        // }\n\t    },\n\t};\n\n\tfunction push () {\n\t    var value;\n\n\t    switch (token.type) {\n\t    case 'punctuator':\n\t        switch (token.value) {\n\t        case '{':\n\t            value = {};\n\t            break\n\n\t        case '[':\n\t            value = [];\n\t            break\n\t        }\n\n\t        break\n\n\t    case 'null':\n\t    case 'boolean':\n\t    case 'numeric':\n\t    case 'string':\n\t        value = token.value;\n\t        break\n\n\t    // This code is unreachable.\n\t    // default:\n\t    //     throw invalidToken()\n\t    }\n\n\t    if (root === undefined) {\n\t        root = value;\n\t    } else {\n\t        var parent = stack[stack.length - 1];\n\t        if (Array.isArray(parent)) {\n\t            parent.push(value);\n\t        } else {\n\t            Object.defineProperty(parent, key, {\n\t                value: value,\n\t                writable: true,\n\t                enumerable: true,\n\t                configurable: true,\n\t            });\n\t        }\n\t    }\n\n\t    if (value !== null && typeof value === 'object') {\n\t        stack.push(value);\n\n\t        if (Array.isArray(value)) {\n\t            parseState = 'beforeArrayValue';\n\t        } else {\n\t            parseState = 'beforePropertyName';\n\t        }\n\t    } else {\n\t        var current = stack[stack.length - 1];\n\t        if (current == null) {\n\t            parseState = 'end';\n\t        } else if (Array.isArray(current)) {\n\t            parseState = 'afterArrayValue';\n\t        } else {\n\t            parseState = 'afterPropertyValue';\n\t        }\n\t    }\n\t}\n\n\tfunction pop () {\n\t    stack.pop();\n\n\t    var current = stack[stack.length - 1];\n\t    if (current == null) {\n\t        parseState = 'end';\n\t    } else if (Array.isArray(current)) {\n\t        parseState = 'afterArrayValue';\n\t    } else {\n\t        parseState = 'afterPropertyValue';\n\t    }\n\t}\n\n\t// This code is unreachable.\n\t// function invalidParseState () {\n\t//     return new Error(`JSON5: invalid parse state '${parseState}'`)\n\t// }\n\n\t// This code is unreachable.\n\t// function invalidLexState (state) {\n\t//     return new Error(`JSON5: invalid lex state '${state}'`)\n\t// }\n\n\tfunction invalidChar (c) {\n\t    if (c === undefined) {\n\t        return syntaxError((\"JSON5: invalid end of input at \" + line + \":\" + column))\n\t    }\n\n\t    return syntaxError((\"JSON5: invalid character '\" + (formatChar(c)) + \"' at \" + line + \":\" + column))\n\t}\n\n\tfunction invalidEOF () {\n\t    return syntaxError((\"JSON5: invalid end of input at \" + line + \":\" + column))\n\t}\n\n\t// This code is unreachable.\n\t// function invalidToken () {\n\t//     if (token.type === 'eof') {\n\t//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)\n\t//     }\n\n\t//     const c = String.fromCodePoint(token.value.codePointAt(0))\n\t//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)\n\t// }\n\n\tfunction invalidIdentifier () {\n\t    column -= 5;\n\t    return syntaxError((\"JSON5: invalid identifier character at \" + line + \":\" + column))\n\t}\n\n\tfunction separatorChar (c) {\n\t    console.warn((\"JSON5: '\" + (formatChar(c)) + \"' in strings is not valid ECMAScript; consider escaping\"));\n\t}\n\n\tfunction formatChar (c) {\n\t    var replacements = {\n\t        \"'\": \"\\\\'\",\n\t        '\"': '\\\\\"',\n\t        '\\\\': '\\\\\\\\',\n\t        '\\b': '\\\\b',\n\t        '\\f': '\\\\f',\n\t        '\\n': '\\\\n',\n\t        '\\r': '\\\\r',\n\t        '\\t': '\\\\t',\n\t        '\\v': '\\\\v',\n\t        '\\0': '\\\\0',\n\t        '\\u2028': '\\\\u2028',\n\t        '\\u2029': '\\\\u2029',\n\t    };\n\n\t    if (replacements[c]) {\n\t        return replacements[c]\n\t    }\n\n\t    if (c < ' ') {\n\t        var hexString = c.charCodeAt(0).toString(16);\n\t        return '\\\\x' + ('00' + hexString).substring(hexString.length)\n\t    }\n\n\t    return c\n\t}\n\n\tfunction syntaxError (message) {\n\t    var err = new SyntaxError(message);\n\t    err.lineNumber = line;\n\t    err.columnNumber = column;\n\t    return err\n\t}\n\n\tvar stringify = function stringify (value, replacer, space) {\n\t    var stack = [];\n\t    var indent = '';\n\t    var propertyList;\n\t    var replacerFunc;\n\t    var gap = '';\n\t    var quote;\n\n\t    if (\n\t        replacer != null &&\n\t        typeof replacer === 'object' &&\n\t        !Array.isArray(replacer)\n\t    ) {\n\t        space = replacer.space;\n\t        quote = replacer.quote;\n\t        replacer = replacer.replacer;\n\t    }\n\n\t    if (typeof replacer === 'function') {\n\t        replacerFunc = replacer;\n\t    } else if (Array.isArray(replacer)) {\n\t        propertyList = [];\n\t        for (var i = 0, list = replacer; i < list.length; i += 1) {\n\t            var v = list[i];\n\n\t            var item = (void 0);\n\n\t            if (typeof v === 'string') {\n\t                item = v;\n\t            } else if (\n\t                typeof v === 'number' ||\n\t                v instanceof String ||\n\t                v instanceof Number\n\t            ) {\n\t                item = String(v);\n\t            }\n\n\t            if (item !== undefined && propertyList.indexOf(item) < 0) {\n\t                propertyList.push(item);\n\t            }\n\t        }\n\t    }\n\n\t    if (space instanceof Number) {\n\t        space = Number(space);\n\t    } else if (space instanceof String) {\n\t        space = String(space);\n\t    }\n\n\t    if (typeof space === 'number') {\n\t        if (space > 0) {\n\t            space = Math.min(10, Math.floor(space));\n\t            gap = '          '.substr(0, space);\n\t        }\n\t    } else if (typeof space === 'string') {\n\t        gap = space.substr(0, 10);\n\t    }\n\n\t    return serializeProperty('', {'': value})\n\n\t    function serializeProperty (key, holder) {\n\t        var value = holder[key];\n\t        if (value != null) {\n\t            if (typeof value.toJSON5 === 'function') {\n\t                value = value.toJSON5(key);\n\t            } else if (typeof value.toJSON === 'function') {\n\t                value = value.toJSON(key);\n\t            }\n\t        }\n\n\t        if (replacerFunc) {\n\t            value = replacerFunc.call(holder, key, value);\n\t        }\n\n\t        if (value instanceof Number) {\n\t            value = Number(value);\n\t        } else if (value instanceof String) {\n\t            value = String(value);\n\t        } else if (value instanceof Boolean) {\n\t            value = value.valueOf();\n\t        }\n\n\t        switch (value) {\n\t        case null: return 'null'\n\t        case true: return 'true'\n\t        case false: return 'false'\n\t        }\n\n\t        if (typeof value === 'string') {\n\t            return quoteString(value, false)\n\t        }\n\n\t        if (typeof value === 'number') {\n\t            return String(value)\n\t        }\n\n\t        if (typeof value === 'object') {\n\t            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)\n\t        }\n\n\t        return undefined\n\t    }\n\n\t    function quoteString (value) {\n\t        var quotes = {\n\t            \"'\": 0.1,\n\t            '\"': 0.2,\n\t        };\n\n\t        var replacements = {\n\t            \"'\": \"\\\\'\",\n\t            '\"': '\\\\\"',\n\t            '\\\\': '\\\\\\\\',\n\t            '\\b': '\\\\b',\n\t            '\\f': '\\\\f',\n\t            '\\n': '\\\\n',\n\t            '\\r': '\\\\r',\n\t            '\\t': '\\\\t',\n\t            '\\v': '\\\\v',\n\t            '\\0': '\\\\0',\n\t            '\\u2028': '\\\\u2028',\n\t            '\\u2029': '\\\\u2029',\n\t        };\n\n\t        var product = '';\n\n\t        for (var i = 0; i < value.length; i++) {\n\t            var c = value[i];\n\t            switch (c) {\n\t            case \"'\":\n\t            case '\"':\n\t                quotes[c]++;\n\t                product += c;\n\t                continue\n\n\t            case '\\0':\n\t                if (util.isDigit(value[i + 1])) {\n\t                    product += '\\\\x00';\n\t                    continue\n\t                }\n\t            }\n\n\t            if (replacements[c]) {\n\t                product += replacements[c];\n\t                continue\n\t            }\n\n\t            if (c < ' ') {\n\t                var hexString = c.charCodeAt(0).toString(16);\n\t                product += '\\\\x' + ('00' + hexString).substring(hexString.length);\n\t                continue\n\t            }\n\n\t            product += c;\n\t        }\n\n\t        var quoteChar = quote || Object.keys(quotes).reduce(function (a, b) { return (quotes[a] < quotes[b]) ? a : b; });\n\n\t        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);\n\n\t        return quoteChar + product + quoteChar\n\t    }\n\n\t    function serializeObject (value) {\n\t        if (stack.indexOf(value) >= 0) {\n\t            throw TypeError('Converting circular structure to JSON5')\n\t        }\n\n\t        stack.push(value);\n\n\t        var stepback = indent;\n\t        indent = indent + gap;\n\n\t        var keys = propertyList || Object.keys(value);\n\t        var partial = [];\n\t        for (var i = 0, list = keys; i < list.length; i += 1) {\n\t            var key = list[i];\n\n\t            var propertyString = serializeProperty(key, value);\n\t            if (propertyString !== undefined) {\n\t                var member = serializeKey(key) + ':';\n\t                if (gap !== '') {\n\t                    member += ' ';\n\t                }\n\t                member += propertyString;\n\t                partial.push(member);\n\t            }\n\t        }\n\n\t        var final;\n\t        if (partial.length === 0) {\n\t            final = '{}';\n\t        } else {\n\t            var properties;\n\t            if (gap === '') {\n\t                properties = partial.join(',');\n\t                final = '{' + properties + '}';\n\t            } else {\n\t                var separator = ',\\n' + indent;\n\t                properties = partial.join(separator);\n\t                final = '{\\n' + indent + properties + ',\\n' + stepback + '}';\n\t            }\n\t        }\n\n\t        stack.pop();\n\t        indent = stepback;\n\t        return final\n\t    }\n\n\t    function serializeKey (key) {\n\t        if (key.length === 0) {\n\t            return quoteString(key, true)\n\t        }\n\n\t        var firstChar = String.fromCodePoint(key.codePointAt(0));\n\t        if (!util.isIdStartChar(firstChar)) {\n\t            return quoteString(key, true)\n\t        }\n\n\t        for (var i = firstChar.length; i < key.length; i++) {\n\t            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {\n\t                return quoteString(key, true)\n\t            }\n\t        }\n\n\t        return key\n\t    }\n\n\t    function serializeArray (value) {\n\t        if (stack.indexOf(value) >= 0) {\n\t            throw TypeError('Converting circular structure to JSON5')\n\t        }\n\n\t        stack.push(value);\n\n\t        var stepback = indent;\n\t        indent = indent + gap;\n\n\t        var partial = [];\n\t        for (var i = 0; i < value.length; i++) {\n\t            var propertyString = serializeProperty(String(i), value);\n\t            partial.push((propertyString !== undefined) ? propertyString : 'null');\n\t        }\n\n\t        var final;\n\t        if (partial.length === 0) {\n\t            final = '[]';\n\t        } else {\n\t            if (gap === '') {\n\t                var properties = partial.join(',');\n\t                final = '[' + properties + ']';\n\t            } else {\n\t                var separator = ',\\n' + indent;\n\t                var properties$1 = partial.join(separator);\n\t                final = '[\\n' + indent + properties$1 + ',\\n' + stepback + ']';\n\t            }\n\t        }\n\n\t        stack.pop();\n\t        indent = stepback;\n\t        return final\n\t    }\n\t};\n\n\tvar JSON5 = {\n\t    parse: parse,\n\t    stringify: stringify,\n\t};\n\n\tvar lib = JSON5;\n\n\tvar es5 = lib;\n\n\treturn es5;\n\n})));\n","/* eslint-disable @typescript-eslint/unbound-method */\n//#region imports\nimport type { Reactive, ReactiveOrSource, ReactiveWritable, ReactiveOp, InitStreamOptions, WithValueOptions, CombineLatestOptions, RxValueTypes, RxValueTypeObject, PipeSet } from \"./Types.js\";\nimport { messageHasValue, messageIsDoneSignal, opify } from \"./Util.js\";\nimport * as OpFns from './ops/index.js';\nimport { initStream } from \"./InitStream.js\";\nimport { type Interval, intervalToMs } from '../flow/IntervalType.js';\nimport { resolveSource } from './ResolveSource.js';\nimport type { BatchOptions, DebounceOptions, FieldOptions, SingleFromArrayOptions, SplitOptions, FilterPredicate, SwitcherOptions, SyncOptions, ThrottleOptions } from \"./ops/Types.js\";\nimport type { TimeoutTriggerOptions } from \"./sources/Types.js\";\nimport * as SinkFns from './sinks/index.js';\nimport type { RankFunction, RankOptions } from \"../data/Types.js\";\nexport * from './Chain.js';\n\n//#endregion\n\n//#region exports\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './Graph.js';\nexport * from './Types.js';\nexport * from './ToArray.js';\nexport * from './ToGenerator.js';\nexport * from './Util.js';\nexport * from './Wrap.js';\nexport * from './ResolveSource.js';\nexport * from './Count.js';\nexport * as Dom from './Dom.js';\nexport * as From from './sources/index.js';\n//#endregion\n\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns \n */\nexport function manual<V>(options: Partial<InitStreamOptions> = {}): Reactive<V> & ReactiveWritable<V> {\n  const events = initStream<V>(options);\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    set(value: V) {\n      events.set(value);\n    },\n    on: events.on,\n    onValue: events.onValue\n  };\n}\n\nexport const Sinks = {\n  setHtmlText: (options: SinkFns.SetHtmlOptions) => {\n    return (source: ReactiveOrSource<string>) => {\n      SinkFns.setHtmlText(source, options);\n    }\n  }\n}\n\nexport const Ops = {\n  /**\n * Annotates values with the result of a function.\n * The input value needs to be an object.\n * \n * For every value `input` emits, run it through `annotator`, which should\n * return the original value with additional fields.\n * \n * Conceptually the same as `transform`, just with typing to enforce result\n * values are V & TAnnotation\n * @param annotator \n * @returns \n */\n  annotate: <V, TAnnotation>(annotator: (input: V) => V & TAnnotation) => opify(OpFns.annotate, annotator),\n  /**\n   * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n   * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n   * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n   * \n   * ```js\n   * // Emit values from an array\n   * const r1 = Rx.run(\n   *  Rx.From.array([ 1, 2, 3 ]),\n   *  Rx.Ops.annotateWithOp(\n   *    // Add the 'max' operator to emit the largest-seen value\n   *    Rx.Ops.sum()\n   *  )\n   * );\n   * const data = await Rx.toArray(r1);\n   * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n   * ```\n   * @param annotatorOp \n   * @returns \n   */\n  annotateWithOp: <TIn, TAnnotation>(annotatorOp: ReactiveOp<TIn, TAnnotation>) => opify(OpFns.annotateWithOp, annotatorOp),\n  /**\n   * Takes a stream of values and batches them up (by quantity or time elapsed),\n   * emitting them as an array.\n   * @param options \n   * @returns \n   */\n  batch: <V>(options: Partial<BatchOptions>): ReactiveOp<V, Array<V>> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.batch(source, options);\n    }\n  },\n\n  cloneFromFields: <V>(): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.cloneFromFields(source);\n    }\n  },\n  /**\n * Merges values from several sources into a single source that emits values as an array.\n * @param options \n * @returns \n */\n  combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (sources: T) => {\n      return OpFns.combineLatestToArray(sources, options);\n    }\n  },\n  /**\n   * Merges values from several sources into a single source that emits values as an object.\n   * @param options\n   * @returns \n   */\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (reactiveSources: T) => {\n      return OpFns.combineLatestToObject(reactiveSources, options);\n    }\n  },\n  /**\n * Debounce values from the stream. It will wait until a certain time\n * has elapsed before emitting latest value.\n * \n * Effect is that no values are emitted if input emits faster than the provided\n * timeout.\n * \n * See also: throttle\n * @param options \n * @returns \n */\n  debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.debounce(source, options);\n    }\n  },\n  elapsed: <V>(): ReactiveOp<V, number> => opify(OpFns.elapsed),\n  /**\n   * Yields the value of a field from an input stream of values.\n   * Eg if the source reactive emits `{ colour: string, size: number }`,\n   * we might use `field` to pluck out the `colour` field, thus returning\n   * a stream of string values.\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource extends object, TFieldType>(fieldName: keyof TSource, options: FieldOptions<TSource, TFieldType>) => {\n    return (source: ReactiveOrSource<TSource>) => {\n      return OpFns.field(source, fieldName, options);\n    }\n  },\n  /**\n   * Filters the input stream, only re-emitting values that pass the predicate\n   * @param predicate \n   * @returns \n   */\n  filter: <V>(predicate: (value: V) => boolean) => opify(OpFns.filter, predicate),\n  /**\n * Outputs the minimum numerical value of the stream.\n * A value is only emitted when minimum decreases.\n * @returns \n */\n  min: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, number>(OpFns.min, options),\n  /**\n   * Outputs the maxium numerical value of the stream.\n   * A value is only emitted when maximum increases.\n   * @returns \n   */\n  max: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, number>(OpFns.max, options),\n  sum: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, number>(OpFns.sum, options),\n  average: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, number>(OpFns.average, options),\n  tally: <TIn>(options?: OpFns.TallyOptions) => opify<TIn, number>(OpFns.tally, options),\n  rank: <TIn>(rank: RankFunction<TIn>, options?: RankOptions & OpFns.OpMathOptions) => opify<TIn>(OpFns.rank, rank, options),\n\n  pipe: <TInput, TOutput>(...streams: Array<Reactive<any> & ReactiveWritable<any>>) => {\n    return (source: ReactiveOrSource<TInput>) => {\n      const resolved = resolveSource(source);\n      const s = [ resolved, ...streams ] as PipeSet<TInput, TOutput>;\n      return OpFns.pipe(...s);\n    }\n  },\n\n  singleFromArray: <V>(options: Partial<SingleFromArrayOptions<V>> = {}) => {\n    return (source: ReactiveOrSource<Array<V>>) => {\n      return OpFns.singleFromArray(source, options)\n    }\n  },\n\n  split: <V>(options: Partial<SplitOptions> = {}) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.split(source, options);\n    }\n  },\n  splitLabelled: <V>(labels: Array<string>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.splitLabelled(source, labels);\n    }\n  },\n  switcher: <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n    return (source: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n      return OpFns.switcher(source, cases, options);\n    }\n  },\n  syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypes<T>> => {\n      return OpFns.syncToArray(reactiveSources, options);\n    }\n  },\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypeObject<T>> => {\n      return OpFns.syncToObject(reactiveSources, options);\n    }\n  },\n  tapProcess: <In>(processor: ((value: In) => any)): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapProcess(source, processor);\n    }\n  },\n  tapStream: <In>(divergedStream: ReactiveWritable<In>): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapStream(source, divergedStream);\n    }\n  },\n  tapOps: <In, Out>(...ops: Array<ReactiveOp<In, Out>>) => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapOps(source, ...ops);\n    }\n  },\n\n  /**\n * Throttle values from the stream.\n * Only emits a value if some minimum time has elapsed.\n * @param options \n * @returns \n */\n  throttle: <V>(options: Partial<ThrottleOptions>) => opify<V>(OpFns.throttle, options),\n  /**\n   * Trigger a value if 'source' does not emit a value within an interval.\n   * Trigger value can be a fixed value, result of function, or step through an iterator.\n   * @param options \n   * @returns \n   */\n  timeoutTrigger: <V, TTriggerValue>(options: TimeoutTriggerOptions<TTriggerValue>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutTrigger<V, TTriggerValue>(source, options);\n    }\n  },\n  transform: <In, Out>(transformer: ((value: In) => Out), options: Partial<OpFns.TransformOpts> = {}): ReactiveOp<In, Out> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.transform(source, transformer, options);\n    }\n  },\n\n  /**\n  * Reactive where last (or a given initial) value is available to read\n  * @param opts \n  * @returns \n  */\n  withValue: <V>(opts: Partial<WithValueOptions<V>>): ReactiveOp<V, V> => {\n    return opify<V>(OpFns.withValue, opts);\n  },\n} as const;\n\n\n// export const chain = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       // @ts-expect-error\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n// export const chainStream = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>): ReactiveStream<TIn, TOut> => {\n//   const stream = manual<TIn>();\n//   const c = chain(...ops);\n//   const x = c(stream);\n//   return x;\n// }\n\n\n\n// function chainx<TIn, TOut>(...ops: Array<ReactiveOp<any, any>>) {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\nexport function cache<T>(r: Reactive<T>, initialValue: T) {\n  let lastValue: T = initialValue;\n  r.onValue(value => {\n    lastValue = value;\n  });\n  return {\n    ...r,\n    last() {\n      return lastValue\n    },\n    reset() {\n      // @ts-expect-error\n      lastValue = undefined;\n    }\n  }\n}\n\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n\n//   r.onValue(value => {\n//     lastValue = value;\n//   });\n\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n * \n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n * \n * Throws an error if the source closes without\n * a value or the timeout is reached.\n * \n * @param source \n * @param maximumWait \n * @returns \n */\nexport async function takeNextValue<V>(source: ReactiveOrSource<V>, maximumWait: Interval = 1000): Promise<V> {\n  const rx = resolveSource(source);\n  let off = () => {/** no-op */ };\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const p = new Promise<V>((resolve, reject) => {\n    off = rx.on(message => {\n      if (watchdog) clearTimeout(watchdog);\n      if (messageHasValue(message)) {\n        off();\n        resolve(message.value);\n      } else {\n        if (messageIsDoneSignal(message)) {\n          reject(new Error(`Source closed. ${ message.context ?? `` }`));\n          off();\n        }\n      }\n    });\n\n    watchdog = setTimeout(() => {\n      watchdog = undefined;\n      off();\n      reject(new Error(`Timeout waiting for value (${ JSON.stringify(maximumWait) })`))\n    }, intervalToMs(maximumWait));\n  });\n  return p;\n}\n\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n * \n * Returns a function to unsubcribe A->B\n * @param a \n * @param b \n * @param transform \n */\nexport const to = <TA, TB>(a: Reactive<TA>, b: ReactiveWritable<TB>, transform?: (valueA: TA) => TB, closeBonA = false) => {\n  const unsub = a.on(message => {\n    if (messageHasValue(message)) {\n      const value = transform ? transform(message.value) : message.value as TB;\n      b.set(value);\n    } else if (messageIsDoneSignal(message)) {\n      unsub();\n      if (closeBonA) {\n        b.dispose(`Source closed (${ message.context ?? `` })`);\n      }\n    } else {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      console.warn(`Unsupported message: ${ JSON.stringify(message) }`);\n    }\n\n  });\n  return unsub;\n}","import { isIterable } from \"../iterables/Iterable.js\";\nimport type { Passed, PassedSignal, PassedValue, Reactive, ReactiveDiff, ReactiveInitial, ReactiveOrSource, ReactiveWritable, Wrapped } from \"./Types.js\";\nimport type { Trigger, TriggerValue, TriggerFunction, TriggerGenerator } from \"./sources/Types.js\";\n\nexport function messageIsSignal<V>(message: Passed<V> | PassedSignal): message is PassedSignal {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal !== undefined) return true;\n  return false;\n}\n\nexport function messageIsDoneSignal<V>(message: Passed<V> | PassedSignal): boolean {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal === `done`) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v \n * @returns \n */\nexport function messageHasValue<V>(v: Passed<V> | PassedSignal): v is PassedValue<V> {\n  if (v.value !== undefined) return true;\n  return false;\n}\n\n\nexport const hasLast = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last`) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx \n * @returns \n */\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  if (rx === null) return false;\n  return (`on` in rx && `onValue` in rx)\n}\n\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx \n * @returns \n */\n// export const isDisposable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveDisposable<V> => {\n//   if (!isReactive(rx)) return false;\n//   return (`isDisposed` in rx && `dispose` in rx);\n// }\n\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx \n * @returns \n */\nexport const isWritable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveWritable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`set` in rx) return true;\n  return false;\n}\n\nexport const isWrapped = <T>(v: any): v is Wrapped<T> => {\n  if (typeof v !== `object`) return false;\n  if (!(`source` in v)) return false;\n  if (!(`annotateElapsed` in v)) return false;\n  return true;\n}\n\nexport const opify = <TIn, TOut = TIn>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => Reactive<TOut>, ...args: Array<any>) => {\n  return (source: ReactiveOrSource<TIn>) => {\n    return fn(source, ...args);\n  }\n}\n\nexport const isTriggerValue = <V>(t: Trigger<V>): t is TriggerValue<V> => (`value` in t);\nexport const isTriggerFunction = <V>(t: Trigger<V>): t is TriggerFunction<V> => (`fn` in t);\nexport const isTriggerGenerator = <V>(t: Trigger<V>): t is TriggerGenerator<V> => isIterable(t);\nexport const isTrigger = <V>(t: any): t is Trigger<V> => {\n  if (typeof t !== `object`) return false;\n  if (isTriggerValue(t)) return true;\n  if (isTriggerFunction(t)) return true;\n  if (isTriggerGenerator(t)) return true;\n  return false;\n}\n\nexport type ResolveTriggerValue<V> = [ value: V, false ];\nexport type ResolveTriggerDone = [ undefined, true ];\n\n/**\n * Resolves a trigger value.\n * \n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n * \n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t \n * @returns \n */\nexport function resolveTriggerValue<V>(t: Trigger<V>): ResolveTriggerDone | ResolveTriggerValue<V> {\n  if (isTriggerValue(t)) return [ t.value, false ];\n  if (isTriggerFunction(t)) {\n    const v = t.fn();\n    if (v === undefined) return [ undefined, true ];\n    return [ v, false ];\n  }\n  if (isTriggerGenerator(t)) {\n    const v = t.gen.next();\n    if (v.done) return [ undefined, true ];\n    return [ v.value, false ];\n  }\n  throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}","import { getErrorMessage } from \"../../debug/GetErrorMessage.js\";\nimport { continuously } from \"../../flow/Continuously.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport type { FunctionFunction, FunctionOptions } from \"./Types.js\";\n\n\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n * \n * See also {@link Rx.From.pinged} to trigger a function whenever another Reactive emits a value.\n * \n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n * \n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it. \n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n * \n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n * \n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber \n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback \n * @param options \n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport function func<V>(callback: FunctionFunction<V>, options: Partial<FunctionOptions> = {}) {\n  const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n  const closeOnError = options.closeOnError ?? true;\n  const interval = intervalToMs(options.interval, 1);\n  const loop = options.interval !== undefined;\n  const predelay = intervalToMs(options.predelay, 1);\n  const lazy = options.lazy ?? `very`;\n  const signal = options.signal;\n\n  const internalAbort = new AbortController();\n  const internalAbortCallback = (reason: string) => { internalAbort.abort(reason) };\n  let sentResults = 0;\n  if (options.maximumRepeats && !loop) throw new Error(`'maximumRepeats' has no purpose if 'loop' is not set to true`);\n\n\n\n  // const events = initStream<V>({\n  //   onFirstSubscribe() {\n  //     if (run.runState === `idle`) run.start();\n  //   },\n  //   onNoSubscribers() {\n  //     console.log(`Rx.fromFunction onNoSubscribers. lazy: ${ lazy }`);\n  //     if (lazy === `very`) {\n  //       run.cancel();\n  //     }\n  //   },\n  // })\n\n  const done = (reason: string) => {\n    //console.log(`Rx.fromFunction done ${ reason }`);\n    events.dispose(reason);\n    run.cancel();\n  }\n\n  const run = continuously(async () => {\n    if (predelay) await sleep(predelay);\n\n    try {\n      if (signal?.aborted) {\n        done(`Signal (${ signal.aborted })`);\n        return false;\n      }\n      const value = await callback(internalAbortCallback);\n      events.set(value);\n      sentResults++;\n\n    } catch (error) {\n      if (closeOnError) {\n        done(`Function error: ${ getErrorMessage(error) }`);\n        return false;\n      } else {\n        events.signal(`warn`, getErrorMessage(error));\n      }\n    }\n    if (!loop) {\n      done(`fromFunction done`);\n      return false; // Stop loop\n    }\n    if (internalAbort.signal.aborted) {\n      done(`callback function aborted (${ internalAbort.signal.reason })`);\n      return false\n    }\n    if (sentResults >= maximumRepeats) {\n      done(`Maximum repeats reached ${ maximumRepeats.toString() }`);\n      return false; // Stop loop\n    }\n\n  }, interval);\n\n  const events = initLazyStream<V>({\n    lazy,\n    onStart() {\n      run.start();\n    },\n    onStop() {\n      run.cancel();\n    },\n  });\n\n  if (lazy === `never`) run.start();\n  return events;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { nextWithTimeout } from \"../../iterables/IterableAsync.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport { isAsyncIterable } from \"../../iterables/Iterable.js\";\nimport type { Reactive } from \"../Types.js\";\nimport type { GeneratorOptions } from \"./Types.js\";\nimport { StateMachine } from \"../../flow/index.js\";\n\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen \n * @returns \n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n * \n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source \n */\nexport function iterator<V>(source: IterableIterator<V> | Array<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>, options: Partial<GeneratorOptions> = {}): Reactive<V> {\n  const lazy = options.lazy ?? `very`;\n  const log = options.traceLifecycle ? (message: string) => { console.log(`Rx.From.iterator ${ message }`); } : (_: string) => {/* no-up */ }\n\n  const readIntervalMs = intervalToMs(options.readInterval, 5);\n  const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n  const whenStopped = options.whenStopped ?? `continue`;\n\n  let iterator: IterableIterator<V> | AsyncIterableIterator<V> | undefined;\n  //let reading = false;\n  let ourAc: AbortController | undefined;\n  let sm = StateMachine.init({\n    idle: [ `wait_for_next` ],\n    wait_for_next: [ `processing_result`, `stopping`, `disposed` ],\n    processing_result: [ `queued`, `disposed`, `stopping` ],\n    queued: [ `wait_for_next`, `disposed`, `stopping` ],\n    stopping: `idle`,\n    // eslint-disable-next-line unicorn/no-null\n    disposed: null\n  }, `idle`);\n\n  const onExternalSignal = () => {\n    log(`onExternalSignal`);\n    ourAc?.abort(options.signal?.reason);\n  }\n  if (options.signal) {\n    options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n  };\n\n  const read = async () => {\n    log(`read. State: ${ sm.value }`);\n    ourAc = new AbortController();\n    try {\n      sm = StateMachine.to(sm, `wait_for_next`);\n      // @ts-expect-error\n      const v = await nextWithTimeout(iterator, { signal: ourAc.signal, millis: readTimeoutMs });\n      sm = StateMachine.to(sm, `processing_result`);\n      ourAc?.abort(`nextWithTimeout completed`);\n\n      if (v.done) {\n        log(`read v.done true`);\n        events.dispose(`Generator complete`);\n        //reading = false;\n        sm = StateMachine.to(sm, `disposed`);\n      }\n      //if (!reading) return;\n      if (sm.value === `stopping`) {\n        log(`read. sm.value = stopping`)\n        sm = StateMachine.to(sm, `idle`);\n        return;\n      }\n      if (sm.value === `disposed`) {\n        log(`read. sm.value = disposed`);\n        return;\n      }\n      events.set(v.value);\n\n    } catch (error) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      events.dispose(`Generator error: ${ (error as any).toString() }`);\n      return;\n    }\n    //if (events.isDisposed()) return;\n    //if (!reading) return;\n\n    if (sm.value === `processing_result`) {\n      sm = StateMachine.to(sm, `queued`);\n      log(`scheduling read. State: ${ sm.value }`);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(read, readIntervalMs);\n    } else {\n      sm = StateMachine.to(sm, `idle`);\n    }\n  }\n\n  const events = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      log(`onStart state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      if (sm.value !== `idle`) return;\n      if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n      //reading = true;\n      void read();\n    },\n    onStop() {\n      log(`onStop state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      //reading = false;\n      sm = StateMachine.to(sm, `stopping`);\n      if (whenStopped === `reset`) {\n        log(`onStop reiniting iterator`);\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n    },\n    onDispose(reason: string) {\n      log(`onDispose (${ reason })`);\n      ourAc?.abort(`Rx.From.iterator disposed (${ reason })`);\n      if (options.signal) options.signal.removeEventListener(`abort`, onExternalSignal);\n    },\n  });\n\n  // const readingStart = () => {\n\n  // }\n  //if (!lazy) readingStart();\n\n  // return {\n  //   on: events.on,\n  //   value: events.value,\n  //   dispose: events.dispose,\n  //   isDisposed: events.isDisposed\n  // }\n  return events;\n}\n","import { isAsyncIterable, isIterable } from \"../iterables/Iterable.js\";\nimport { func } from \"./sources/Function.js\";\nimport { iterator } from \"./sources/Iterator.js\";\nimport type { GeneratorOptions, FunctionOptions } from \"./sources/Types.js\";\nimport type { Reactive, ReactiveOrSource } from \"./Types.js\";\nimport { isReactive, isWrapped } from \"./Util.js\";\n\nexport type ResolveSourceOptions = {\n  /**\n   * Options when creating a reactive from a generator\n   * Default:  `{ lazy: true, interval: 5 }`\n   */\n  generator: GeneratorOptions\n  /**\n   * Options when creating a reactive from a function.\n   */\n  function: FunctionOptions\n}\n\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n * \n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source \n * @returns \n */\nexport const resolveSource = <V>(source: ReactiveOrSource<V>, options: Partial<ResolveSourceOptions> = {}): Reactive<V> => {\n  if (isReactive(source)) return source;\n  const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 }\n  const functionOptions = options.function ?? { lazy: `very` }\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (Array.isArray(source)) {\n    return iterator(source.values(), generatorOptions);\n  } else if (typeof source === `function`) {\n    return func<V>(source, functionOptions)\n  } else if (typeof source === `object`) {\n    //console.log(`resolveSource is object`);\n    if (isWrapped<V>(source)) {\n      //console.log(`resolveSource is object - wrapped`);\n      return source.source;\n    }\n    if (isIterable(source) || isAsyncIterable(source)) {\n      //console.log(`resolveSource is object - iterable`);\n      return iterator(source, generatorOptions);\n    }\n  }\n  throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${ typeof source }`);\n}","import { type Dispatch, DispatchList } from \"../flow/DispatchList.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport type { InitLazyStreamInitedOptions, InitLazyStreamOptions, InitStreamOptions, Passed, ReactiveInitial, ReactiveOrSource, ReactiveStream, SignalKinds, UpstreamOptions } from \"./Types.js\";\nimport { messageHasValue, messageIsSignal } from \"./Util.js\";\nimport { cache } from \"./index.js\";\n\n\n/**\n * @ignore\n * @param upstreamSource \n * @param options \n * @returns \n */\nexport const initUpstream = <In, Out>(upstreamSource: ReactiveOrSource<In>, options: Partial<UpstreamOptions<In>>): ReactiveStream<Out> => {\n  const lazy = options.lazy ?? `initial`;\n  const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n  const onValue = options.onValue ?? ((_v: In) => {/** no-op */ })\n  const source = resolveSource(upstreamSource);\n  let unsub: undefined | (() => void);\n\n  const start = () => {\n    if (unsub !== undefined) return;\n\n    if (options.onStart) options.onStart();\n    unsub = source.on(value => {\n      if (messageIsSignal(value)) {\n        if (value.signal === `done`) {\n          stop();\n          if (disposeIfSourceDone) events.dispose(`Upstream source has completed (${ value.context ?? `` })`);\n        } else {\n          events.through(value);\n        }\n      } else if (messageHasValue(value)) {\n        onValue(value.value);\n      }\n    });\n  }\n\n  const stop = () => {\n    if (unsub === undefined) return;\n    unsub();\n    unsub = undefined;\n    if (options.onStop) options.onStop();\n  }\n\n  const events = initLazyStream<Out>({\n    ...options,\n    lazy,\n    onStart() {\n      start();\n    },\n    onStop() {\n      stop();\n    }\n  });\n  return events;\n}\n\n\nexport function initLazyStreamWithInitial<V>(options: InitLazyStreamInitedOptions<V>): ReactiveStream<V> & ReactiveInitial<V> {\n  return cache<V>(initLazyStream<V>(options), options.initialValue) as ReactiveStream<V> & ReactiveInitial<V>;\n}\n\nexport function initLazyStream<V>(options: InitLazyStreamOptions): ReactiveStream<V> {\n  const lazy = options.lazy ?? `initial`;\n  const onStop = options.onStop ?? (() => { /* no-op*/ })\n  const onStart = options.onStart ?? (() => {/* no-op*/ })\n\n  const events = initStream<V>({\n    ...options,\n    onFirstSubscribe() {\n      if (lazy !== `never`) onStart();\n    },\n    onNoSubscribers() {\n      if (lazy === `very`) onStop();\n    },\n  });\n  if (lazy === `never`) onStart();\n  return events;\n}\n\n/**\n * @ignore\n * @param options \n * @returns \n */\nexport function initStream<V>(options: Partial<InitStreamOptions> = {}): ReactiveStream<V> {\n  let dispatcher: DispatchList<Passed<V>> | undefined;\n  let disposed = false;\n  let firstSubscribe = false;\n  let emptySubscriptions = true;\n  const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n  const onNoSubscribers = options.onNoSubscribers ?? undefined;\n\n  const isEmpty = () => {\n    if (dispatcher === undefined) return;\n    if (!dispatcher.isEmpty) return;\n    if (!emptySubscriptions) {\n      emptySubscriptions = true;\n      firstSubscribe = false;\n      if (onNoSubscribers) onNoSubscribers();\n    }\n  }\n\n  const subscribe = (handler: Dispatch<Passed<V>>) => {\n    if (disposed) throw new Error(`Disposed, cannot subscribe`);\n    if (dispatcher === undefined) dispatcher = new DispatchList();\n    const id = dispatcher.add(handler);\n    emptySubscriptions = false;\n    if (!firstSubscribe) {\n      firstSubscribe = true;\n      if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n    }\n    return () => {\n      dispatcher?.remove(id);\n      isEmpty();\n    }\n  }\n\n  return {\n    dispose: (reason: string) => {\n      if (disposed) return;\n      dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${ reason }` });\n      disposed = true;\n      if (options.onDispose) options.onDispose(reason);\n    },\n    isDisposed: () => {\n      return disposed\n    },\n    reset: () => {\n      dispatcher?.clear();\n      isEmpty();\n    },\n    set: (v: V) => {\n      if (disposed) throw new Error(`Disposed, cannot set`);\n      dispatcher?.notify({ value: v });\n    },\n    through: (pass: Passed<V>) => {\n      if (disposed) throw new Error(`Disposed, cannot through`);\n      dispatcher?.notify(pass)\n    },\n    signal: (signal: SignalKinds, context?: string) => {\n      if (disposed) throw new Error(`Disposed, cannot signal`);\n      dispatcher?.notify({ signal, value: undefined, context });\n    },\n    on: (handler: Dispatch<Passed<V>>) => subscribe(handler),\n    onValue: (handler: (value: V) => void) => {\n      const unsub = subscribe(message => {\n        if (messageHasValue(message)) {\n          handler(message.value);\n        }\n      });\n      return unsub;\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveStream } from \"./Types.js\";\n\n/***\n * Returns a read-only version of `stream`\n */\nexport const toReadable = <V>(stream: ReactiveStream<V>): Reactive<V> => ({\n  on: stream.on,\n  dispose: stream.dispose,\n  isDisposed: stream.isDisposed,\n  onValue: stream.onValue\n});\n","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveOp } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { TransformOpts } from \"./Types.js\";\nimport { resolveSource, syncToObject } from \"../index.js\";\n\n/**\n * Annotates values from `source`. Output values will be\n * in the form `{ value: TIn, annotation: TAnnotation }`.\n * Where `TIn` is the type of the input, and `TAnnotation` is\n * the return type of the annotator function.\n * \n * Example calculating area from width & height:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const annotated = Rx.Ops.annotate(data, v => {\n *  return { area: v.w * v.h }\n * });\n * const data = await Rx.toArray(annotated);\n * // Data =  [ { value: { w:1, h:3 }, annotation: { area:3 } } ...]\n * ```\n * \n * If you would rather annotate and have values merge with the input,\n * use `transform`:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const withArea = Rx.Ops.transform(data, v => {\n *  return { ...v, area: v.w * v.h }\n * });\n * const data = await Rx.toArray(withArea);\n * // Data =  [ { w:1, h:3, area:3 }, ...]\n * ```\n */\nexport function annotate<In, TAnnotation>(input: ReactiveOrSource<In>, annotator: (value: In) => TAnnotation, options: Partial<TransformOpts> = {}): Reactive<{ value: In, annotation: TAnnotation }> {\n  const upstream = initUpstream<In, { value: In, annotation: TAnnotation }>(input, {\n    ...options,\n    onValue(value) {\n      const annotation = annotator(value);\n      upstream.set({ value, annotation });\n    },\n  })\n  return toReadable(upstream);\n}\n\n/**\n * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n * \n * ```js\n * const data = Rx.From.array([ 1, 2, 3 ]);\n * const annotated = Rx.Ops.annotateWithOp(data, Rx.Ops.sum());\n * const data = await annotated.toArray(annotated);\n * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n * ```\n * @param annotatorOp Operator to generate annotations\n * @param input Input stream\n * @returns \n */\nexport function annotateWithOp<In, TAnnotation>(input: ReactiveOrSource<In>, annotatorOp: ReactiveOp<In, TAnnotation>): Reactive<{ value: In, annotation: TAnnotation }> {\n\n  const inputStream = resolveSource(input);\n\n  // Create annotations from input\n  const stream = annotatorOp(inputStream);\n\n  const synced = syncToObject({\n    value: inputStream,\n    annotation: stream\n  })\n  return synced as Reactive<{ value: In, annotation: TAnnotation }>;\n}\n\n","import { QueueMutable } from \"../../collections/index.js\";\nimport { timeout } from \"../../flow/Timeout.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { BatchOptions } from \"./Types.js\";\n\n/**\n * Queue from `source`, emitting when thresholds are reached. \n * The resulting Reactive produces arrays.\n * \n * Can use a combination of elapsed time or number of data items.\n * \n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in batches of 5 items\n * batch(source, { quantity: 5 });\n * // Emit data every second\n * batch(source, { elapsed: 1000 });\n * ```\n * @param batchSource \n * @param options \n * @returns \n */\nexport function batch<V>(batchSource: ReactiveOrSource<V>, options: Partial<BatchOptions> = {}): Reactive<Array<V>> {\n  const queue = new QueueMutable<V>();\n  const quantity = options.quantity ?? 0;\n  //const logic = options.logic ?? `or`;\n  const returnRemainder = options.returnRemainder ?? true;\n\n  //let lastFire = performance.now();\n  const upstreamOpts = {\n    ...options,\n    onStop() {\n      if (returnRemainder && !queue.isEmpty) {\n        const data = queue.toArray();\n        queue.clear();\n        upstream.set(data);\n      }\n    },\n    onValue(value: V) {\n      queue.enqueue(value);\n      if (quantity > 0 && queue.length >= quantity) {\n        // Reached quantity limit\n        send();\n      }\n      // Start timer\n      if (timer !== undefined && timer.runState === `idle`) {\n        timer.start();\n      }\n    },\n  }\n  const upstream = initUpstream<V, Array<V>>(batchSource, upstreamOpts);\n\n  const send = () => {\n    if (queue.isEmpty) return;\n\n    // Reset timer\n    if (timer !== undefined) timer.start();\n\n    // Fire queued data\n    const data = queue.toArray();\n    queue.clear();\n    upstream.set(data);\n  }\n\n  const timer = options.elapsed ? timeout(send, options.elapsed) : undefined\n\n  // const trigger = () => {\n  //   const now = performance.now();\n  //   let byElapsed = false;\n  //   let byLimit = false;\n  //   if (elapsed > 0 && (now - lastFire > elapsed)) {\n  //     lastFire = now;\n  //     byElapsed = true;\n  //   }\n  //   if (limit > 0 && queue.length >= limit) {\n  //     byLimit = true;\n  //   }\n  //   if (logic === `or` && (!byElapsed && !byLimit)) return;\n  //   if (logic === `and` && (!byElapsed || !byLimit)) return;\n\n  //   send();\n  // }\n\n  return toReadable(upstream);\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport type { Reactive, ReactiveOrSource } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { TransformOpts } from \"./Types.js\";\n\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(input: ReactiveOrSource<In>, transformer: (value: In) => Out, options: Partial<TransformOpts> = {}): Reactive<Out> {\n  const traceInput = options.traceInput ?? false;\n  const traceOutput = options.traceOutput ?? false;\n\n  const upstream = initUpstream<In, Out>(input, {\n    lazy: `initial`,\n    ...options,\n    onValue(value) {\n      const t = transformer(value);\n      if (traceInput && traceOutput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) } output: ${ JSON.stringify(t) }`);\n      } else if (traceInput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) }`);\n      } else if (traceOutput) {\n        console.log(`Rx.Ops.transform output: ${ JSON.stringify(t) }`);\n      }\n\n      upstream.set(t);\n    },\n  })\n  return toReadable(upstream);\n}\n\n","\nimport { isPlainObjectOrPrimitive } from \"../../util/GuardObject.js\";\nimport type { ReactiveOrSource } from \"../Types.js\";\nimport { transform } from \"./Transform.js\";\n\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param input \n * @returns \n */\nexport const cloneFromFields = <In>(source: ReactiveOrSource<In>) => {\n  return transform<In, In>(source, (v): In => {\n    const entries: Array<[ key: string, value: any ]> = [];\n    for (const field in v) {\n      const value = (v)[ field ];\n      if (isPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return Object.fromEntries(entries) as In;\n  })\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypes } from \"../Types.js\";\nimport { messageIsDoneSignal, messageHasValue } from \"../Util.js\";\n\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n * \n * See {@link combineLatestToObject} to combine streams by name into an object, rather than array.\n * \n * ```\n * const sources = [\n *  Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToArray(sources);\n * r.onValue(value => {\n *  // Value will be an array of last value from each source:\n *  // [number,number]  \n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n * \n * Note: unlike RxJS's `combineLatest`, does not wait for each source to emit once\n * before emitting first value.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToArray<const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): Reactive<RxValueTypes<T>> {\n  const event = initStream<RxValueTypes<T>>();\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const data: Array<RxValueTypes<T> | undefined> = [];\n  const sources = reactiveSources.map(source => resolveSource(source));\n  const noop = () => {/** no-op */ };\n  const sourceOff = sources.map(_ => noop);\n  const doneSources = sources.map(_ => false);\n\n  const unsub = () => {\n    for (const v of sourceOff) { v() }\n  }\n\n  for (const [ index, v ] of sources.entries()) {\n    data[ index ] = undefined;\n    sourceOff[ index ] = v.on(message => {\n      if (messageIsDoneSignal(message)) {\n        doneSources[ index ] = true;\n        sourceOff[ index ]();\n        sourceOff[ index ] = noop;\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is set`);\n          return;\n        }\n        if (!doneSources.includes(false)) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        data[ index ] = message.value;\n        event.set([ ...data ] as RxValueTypes<T>);\n      }\n    });\n  }\n\n  return {\n    dispose: event.dispose,\n    isDisposed: event.isDisposed,\n    on: event.on,\n    onValue: event.onValue\n  }\n}\n","import * as TraversableObject from '../collections/tree/TraverseObject.js';\nimport { isPrimitive } from '../IsPrimitive.js';\nimport { isPlainObjectOrPrimitive } from '../util/GuardObject.js';\nimport { isInteger } from '../util/IsInteger.js';\nimport { isEqualContextString, type IsEqualContext } from './Util.js';\nimport { compareKeys } from './Compare.js';\n\nexport type PathData<V> = {\n  path: string\n  value: V\n}\n\nexport type PathDataChange<V> = PathData<V> & {\n  previous?: V\n  state: `change` | `added` | `removed`\n}\n\nexport type CompareDataOptions<V> = {\n  pathPrefix: string\n  /**\n   * Comparison function for values. By default uses\n   * JSON.stringify() to compare by value.\n   */\n  eq: IsEqualContext<V>\n  /**\n   * If true, inherited fields are also compared.\n   * This is necessary for events, for example.\n   * \n   * Only plain-object values are used, the other keys are ignored.\n   */\n  deepEntries: boolean\n\n  /**\n   * If _true_, includes fields that are present in B, but missing in A.\n   * _False_ by default.\n   */\n  includeMissingFromA: boolean\n\n  /**\n   * If _true_, emits a change under the path of a parent if its child has changed.\n   * If _false_ (default) only changed keys are emitted.\n   * \n   * Eg if data is: \n   * `{ colour: { h:0.5, s: 0.3, l: 0.5 }}`\n   * and we compare with:\n   * `{ colour: { h:1, s: 0.3, l: 0.5 }}`\n   * \n   * By default only 'colour.h' is emitted. If _true_ is set, 'colour' and 'colour.h' is emitted.\n   */\n  includeParents: boolean\n}\n\nconst getEntries = <V extends Record<string, any>>(target: V, deepProbe: boolean) => {\n  if (deepProbe) {\n    const entries: Array<[ key: string, value: any ]> = [];\n    for (const field in target) {\n      const value = (target as any)[ field ];\n      if (isPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return entries;\n  } else {\n    return Object.entries(target);\n  }\n}\n\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n * \n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * @param a \n * @param b \n * @param pathPrefix \n * @param options\n * @returns \n */\nexport function* compareData<V extends Record<string, any>>(a: V, b: V, options: Partial<CompareDataOptions<V>> = {}): Generator<PathDataChange<any>> {\n  if (a === undefined) {\n    yield {\n      path: options.pathPrefix ?? ``,\n      value: b,\n      state: `added`\n    };\n    return;\n  }\n  if (b === undefined) {\n    yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` }\n    return;\n  }\n  const pathPrefix = options.pathPrefix ?? ``;\n  const deepEntries = options.deepEntries ?? false;\n  const eq = options.eq ?? isEqualContextString;\n  const includeMissingFromA = options.includeMissingFromA ?? false;\n  const includeParents = options.includeParents ?? false;\n  //const changes: Array<PathDataChange<any>> = [];\n\n  //console.log(`Immutable.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n\n  if (isPrimitive(a) && isPrimitive(b)) {\n    if (a !== b) yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n\n  const entriesA = getEntries(a, deepEntries);\n  const entriesAKeys = new Set<string>();\n  for (const [ key, valueA ] of entriesA) {\n    entriesAKeys.add(key);\n    //console.log(`Immutable.compareDataA key: ${ key } valueA: ${ JSON.stringify(valueA) }`);\n    if (typeof valueA === `object`) {\n      const sub = [ ...compareData(valueA, b[ key ], {\n        ...options,\n        pathPrefix: pathPrefix + key + `.`\n      }) ];\n      if (sub.length > 0) {\n        for (const s of sub) yield s;\n        if (includeParents) {\n          yield { path: pathPrefix + key, value: b[ key ], previous: valueA, state: `change` };\n        }\n      }\n    } else {\n      const subPath = pathPrefix + key;\n      if (key in b) {\n        const valueB = b[ key ];\n        if (!eq(valueA, valueB, subPath)) {\n          //console.log(`  value changed. A: ${ valueA } B: ${ valueB } subPath: ${ subPath }`)\n          yield { path: subPath, previous: valueA, value: valueB, state: `change` };\n        }\n      } else {\n        yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n      }\n    }\n  }\n\n  if (includeMissingFromA) {\n    const entriesB = getEntries(b, deepEntries);\n    for (const [ key, valueB ] of entriesB) {\n      if (entriesAKeys.has(key)) continue;\n      // Key in B that's not in A\n      //console.log(`Immutable.compareDataB key: ${ key } value: ${ valueB }`);\n      yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n    }\n  }\n}\n\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source \n * @param changes \n */\nexport const applyChanges = <V extends Record<string, any>>(source: V, changes: Array<PathDataChange<any>>): V => {\n  for (const change of changes) {\n    source = updateByPath(source, change.path, change.value);\n  }\n  return source;\n}\n\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n * \n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n * \n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n * \n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n * \n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter \n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n * \n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n * \n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns \n */\nexport const updateByPath = <V extends Record<string, any>>(target: V, path: string, value: any, allowShapeChange = false): V => {\n  if (path === undefined) throw new Error(`Parameter 'path' is undefined`);\n  if (typeof path !== `string`) throw new Error(`Parameter 'path' should be a string. Got: ${ typeof path }`);\n  if (target === undefined) throw new Error(`Parameter 'target' is undefined`);\n  if (target === null) throw new Error(`Parameter 'target' is null`);\n\n  const split = path.split(`.`);\n  const r = updateByPathImpl(target, split, value, allowShapeChange);\n  return r as V;\n}\n\nconst updateByPathImpl = (o: any, split: Array<string>, value: any, allowShapeChange: boolean): any => {\n  if (split.length === 0) {\n    //console.log(`Immutable.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n\n    if (allowShapeChange) return value; // yolo\n\n    if (Array.isArray(o) && !Array.isArray(value)) throw new Error(`Expected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n    if (!Array.isArray(o) && Array.isArray(value)) throw new Error(`Unexpected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n\n    if (typeof o !== typeof value) throw new Error(`Cannot reassign object type. (${ typeof o } -> ${ typeof value }). Set allowShapeChange=true to ignore.`);\n\n    // Make sure new value has the same set of keys\n    if (typeof o === `object` && !Array.isArray(o)) {\n      const c = compareKeys(o, value);\n      if (c.a.length > 0) {\n        throw new Error(`New value is missing key(s): ${ c.a.join(`,`) }`);\n      }\n      if (c.b.length > 0) {\n        throw new Error(`New value cannot add new key(s): ${ c.b.join(`,`) }`);\n      }\n    }\n    return value;\n  }\n  const start = split.shift();\n  if (!start) return value;\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(o)) {\n    const index = Number.parseInt(start);\n    if (index >= o.length && !allowShapeChange) throw new Error(`Array index ${ index.toString() } is outside of the existing length of ${ o.length.toString() }. Use allowShapeChange=true to permit this.`);\n    const copy = [ ...o ];\n    copy[ index ] = updateByPathImpl(copy[ index ], split, value, allowShapeChange);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return copy;\n  } else if (start in o) {\n    const copy = { ...o };\n    copy[ start ] = updateByPathImpl(copy[ start ], split, value, allowShapeChange);\n    return copy;\n  } else {\n    throw new Error(`Path ${ start } not found in data`);\n  }\n}\n\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // 'Thom'\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`); // `green`\n * ```\n * \n * Returns _undefined_ if path could not be resolved.\n * \n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object \n * @param path \n * @returns \n */\nexport const getField = <V>(object: Record<string, any>, path: string): V => {\n  if (typeof path !== `string`) throw new Error(`Parameter 'path' ought to be a string. Got: '${ typeof path }'`);\n  if (path.length === 0) throw new Error(`Parameter 'path' is empty`);\n  if (object === undefined) throw new Error(`Parameter 'object' is undefined`);\n  if (object === null) throw new Error(`Parameter 'object' is null`);\n\n  const split = path.split(`.`);\n  const v = getFieldImpl<V>(object, split);\n  return v;\n}\n\nconst getFieldImpl = <V>(object: Record<string, any>, split: Array<string>): V => {\n  if (object === undefined) throw new Error(`Parameter 'object' is undefined`);\n  if (split.length === 0) throw new Error(`Path run out`);\n  const start = split.shift();\n  if (!start) throw new Error(`Unexpected empty split path`);\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n    const index = Number.parseInt(start); //start.slice(1, -1));\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (split.length === 0) {\n      return object[ index ] as V;\n    } else {\n      return getFieldImpl(object[ index ], split);\n    }\n  } else if (start in object) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (split.length === 0) {\n      return object[ start ] as V;\n    } else {\n      return getFieldImpl(object[ start ], split);\n    }\n  } else {\n    throw new Error(`Path '${ start }' not found in data`);\n  }\n}\n\n\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, not results are returned.\n * \n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included. \n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object: object | null, onlyLeaves = false): Generator<string> {\n  if (object === undefined || object === null) return;\n  const iter = TraversableObject.depthFirst(object);\n  for (const c of iter) {\n    if (c.nodeValue === undefined && onlyLeaves) continue;\n    let path = c.name;\n    if (c.ancestors.length > 0) path = c.ancestors.join(`.`) + `.` + path;\n    yield path;\n  }\n};\n\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [ \n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns \n */\nexport function* getPathsAndData(o: object, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``): Generator<PathData<any>> {\n  if (o === null) return;\n  if (o === undefined) return;\n  yield* getPathsAndDataImpl(o, prefix, maxDepth);\n}\n\nfunction* getPathsAndDataImpl(o: object, prefix: string, maxDepth: number): Generator<PathData<any>> {\n  if (maxDepth <= 0) return;\n  if (typeof o !== `object`) return;\n  for (const entries of Object.entries(o)) {\n    const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[ 0 ];\n    yield { path: sub, value: entries[ 1 ] };\n    yield* getPathsAndDataImpl(entries[ 1 ], sub, maxDepth - 1);\n  }\n}","import * as JSON5 from 'json5';\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<any> = (a: any, b: any, _path: string): boolean => {\n  return JSON5.stringify(a) === JSON5.stringify(b);\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { DispatchList } from \"../../flow/DispatchList.js\";\nimport * as Immutable from \"../../data/Pathed.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveDiff, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\nimport type { ObjectOptions } from \"./Types.js\";\nimport { isEqualContextString } from \"src/data/Util.js\";\n\ntype ObjectFieldHandler = (value: any, fieldName: string) => void\nexport function object<V extends Record<string, any>>(initialValue: V, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveInitial<V>;\nexport function object<V extends Record<string, any>>(initialValue: undefined, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n\n\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n * \n * Changing the wrapped object directly does not update the Reactive. \n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n * \n * Consider using {@link Rx.From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.on(value => {\n *  const changed = value.value;\n * });\n * o.set({ name: `mary`, level: 3 });\n * \n * // `on` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n * \n * Use `last()` to get the most recently set value.\n * \n * `onDiff` subscribes to a rough diff of the object.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n * \n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n * \n * You can also listen to updates on a field via `onField`.\n * ```js\n * o.onField(`name`, value => {\n *  // Called whenever the 'name' field is updated\n * });\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns \n */\nexport function object<V extends Record<string, any>>(initialValue?: V, options: Partial<ObjectOptions<V>> = {}): ReactiveDiff<V> & (ReactiveInitial<V> | ReactiveNonInitial<V>) {\n  const eq = options.eq ?? isEqualContextString;\n  const setEvent = initStream<V>();\n  const diffEvent = initStream<Array<Immutable.PathDataChange<any>>>();\n\n  const fieldChangeEvents = new Map<string, DispatchList<ObjectFieldHandler>>;\n\n  let value: V | undefined = initialValue;\n  let disposed = false;\n\n  const set = (v: V) => {\n    const diff = [ ...Immutable.compareData(value ?? {} as V, v, { ...options, includeMissingFromA: true }) ];\n    if (diff.length === 0) return;\n    value = v;\n    setEvent.set(v);\n    diffEvent.set(diff);\n\n  }\n\n  const fireFieldUpdate = (field: string, value: any) => {\n    const l = fieldChangeEvents.get(field.toLowerCase());\n    if (l === undefined) return;\n    l.notify(value);\n  }\n\n  const update = (toMerge: Partial<V>) => {\n    //console.log(`Rx.From.object update: toMerge: ${ JSON.stringify(toMerge) } value: ${ JSON.stringify(value) }`);\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (value === undefined) {\n      value = toMerge as V;\n      setEvent.set(value);\n      for (const [ k, v ] of Object.entries(toMerge as V)) {\n        fireFieldUpdate(k, v);\n      }\n      return value;\n    } else {\n      const diff = [ ...Immutable.compareData(value, toMerge) ];\n      const diffWithoutRemoved = diff.filter(d => d.state !== `removed`);\n      if (diffWithoutRemoved.length === 0) return value; // No changes\n      value = {\n        ...value,\n        ...toMerge\n      }\n      //console.log(`diff: ${ JSON.stringify(diff) }`);\n      setEvent.set(value);\n      diffEvent.set(diff);\n      for (const d of diffWithoutRemoved) {\n        fireFieldUpdate(d.path, d.value);\n      }\n      return value;\n    }\n  }\n\n  const updateField = (path: string, valueForField: any) => {\n    if (value === undefined) throw new Error(`Cannot update value when it has not already been set`);\n    //console.log(`Rx.fromObject.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n\n    const existing = Immutable.getField<any>(value, path);\n    //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n    if (eq(existing, valueForField, path)) {\n      //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n      return;\n    }\n    let diff = [ ...Immutable.compareData(existing, valueForField, { ...options, includeMissingFromA: true }) ];\n    diff = diff.map(d => {\n      if (d.path.length > 0) return { ...d, path: path + `.` + d.path };\n      return { ...d, path };\n    })\n\n    //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n    const o = Immutable.updateByPath(value, path, valueForField, true);\n    value = o;\n    //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n\n    setEvent.set(o);\n    diffEvent.set(diff);\n    fireFieldUpdate(path, valueForField);\n    //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n  }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  return {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    /**\n     * Update a field.\n     * Exception is thrown if field does not exist\n     */\n    updateField,\n    last: () => value,\n    on: setEvent.on,\n    onValue: setEvent.onValue,\n    onDiff: diffEvent.onValue,\n    onField(fieldName: string, handler: (value: any, fieldName: string) => void) {\n      let listeners = fieldChangeEvents.get(fieldName.toLowerCase());\n      if (listeners === undefined) {\n        listeners = new DispatchList();\n        fieldChangeEvents.set(fieldName.toLowerCase(), listeners);\n      }\n      const id = listeners.add((value) => {\n        setTimeout(() => { handler(value, fieldName) }, 1);\n      });\n      return () => listeners.remove(id);\n    },\n    /**\n     * Set the whole object\n     */\n    set,\n    /**\n     * Update the object with a partial set of fields and values\n     */\n    update\n  }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { Maps } from \"../../collections/index.js\"\nimport { initStream } from \"../InitStream.js\"\nimport { resolveSource } from \"../ResolveSource.js\"\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypeObject, ReactiveInitial, RxValueTypeRx, ReactiveDiff } from \"../Types.js\"\nimport { messageIsDoneSignal, messageHasValue, isWritable } from \"../Util.js\"\nimport { object } from \"../sources/Object.js\"\n\nexport type CombineLatestToObject<T extends Record<string, ReactiveOrSource<any>>> = {\n  hasSource: (field: string) => boolean,\n  replaceSource: (field: Extract<keyof T, string>, source: ReactiveOrSource<any>) => void\n  /**\n   * Reactive sources being combined\n   */\n  sources: RxValueTypeRx<T>\n  /**\n   * Updates writable sources with values.\n   * @param data \n   * @returns Keys and values set to writable source(s)\n   */\n  setWith: (data: Partial<RxValueTypeObject<T>>) => Partial<RxValueTypeObject<T>>\n} & ReactiveDiff<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>>;\n\n/**\n * Monitors input reactive values, storing values as they happen to an object.\n * Whenever a new value is emitted, the whole object is sent out, containing current\n * values from each source (or _undefined_ if not yet emitted)\n * \n * See {@link combineLatestToArray} to combine streams by name into an array instead.\n * \n * ```\n * const sources = {\n *  fast: Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  slow: Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToObject(sources);\n * r.onValue(value => {\n *  // 'value' will be an object containing the labelled latest\n *  // values from each source.\n *  // { fast: number, slow: number }\n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * This source ends if all source streams end.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): CombineLatestToObject<T> {// { sources: RxValueTypeRx<T> } & Reactive<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>> {\n  type State<V> = {\n    source: Reactive<V>\n    done: boolean\n    data: V | undefined\n    off: () => void\n  }\n  const disposeSources = options.disposeSources ?? true;\n  const event = object<RxValueTypeObject<T>>(undefined);\n  const onSourceDone = options.onSourceDone ?? `break`;\n\n  const states = new Map<string, State<any>>();\n  for (const [ key, source ] of Object.entries(reactiveSources)) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const initialData = (`last` in source) ? (source as any).last() : undefined;\n    const s: State<any> = {\n      source: resolveSource(source),\n      done: false,\n      data: initialData,\n      off: () => { /** no-op */ }\n    }\n    states.set(key, s);\n  }\n  const sources = Object.fromEntries(Object.entries(states).map(entry => [ entry[ 0 ], entry[ 1 ].source ])) as RxValueTypeRx<T>;\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const someUnfinished = () => Maps.some(states, v => !v.done);\n\n  const unsub = () => {\n    //console.log(`Rx.MergeToObject.unsub states: ${ [ ...states.keys() ].join(`,`) }`);\n    for (const state of states.values()) state.off();\n  }\n\n  const getData = () => {\n    const r = {};\n    for (const [ key, state ] of states) {\n      const d = state.data;\n      if (d !== undefined) {\n        (r as any)[ key ] = state.data;\n      }\n    }\n    return r as RxValueTypeObject<T>;\n  }\n\n  const wireUpState = (state: State<any>) => {\n    state.off = state.source.on(message => {\n      if (messageIsDoneSignal(message)) {\n        state.done = true;\n        state.off();\n        state.off = () => {/**no-op */ }\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is behaviour`);\n          return;\n        }\n        if (!someUnfinished()) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        state.data = message.value;\n        event.set(getData());\n      }\n    });\n  }\n\n  for (const state of states.values()) {\n    wireUpState(state);\n  }\n\n  return {\n    ...event,\n    hasSource(field: string) {\n      return states.has(field)\n    },\n    replaceSource(field, source) {\n      const state = states.get(field);\n      if (state === undefined) throw new Error(`Field does not exist: '${ field }'`);\n      state.off();\n      const s = resolveSource(source);\n      state.source = s;\n      wireUpState(state);\n    },\n    setWith(data) {\n      let written = {};\n      for (const [ key, value ] of Object.entries(data)) {\n        const state = states.get(key);\n        if (state !== undefined) {\n          if (isWritable(state.source)) {\n            state.source.set(value);\n            (written as any)[ key ] = value;\n          }\n          state.data = value;\n        }\n      }\n      return written;\n    },\n    sources,\n    last() {\n      return getData()\n    },\n    dispose(reason: string) {\n      unsub();\n      event.dispose(reason);\n      if (disposeSources) {\n        for (const v of states.values()) {\n          v.source.dispose(`Part of disposed mergeToObject`)\n        }\n      }\n    }\n  }\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { timeout } from \"../../flow/Timeout.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { DebounceOptions } from \"./Types.js\";\n\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n * \n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n * \n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n * \n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source \n * @param options \n * @returns \n */\nexport function debounce<V>(source: ReactiveOrSource<V>, options: Partial<DebounceOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 50);\n  let lastValue: V | undefined;\n\n  const timer = timeout(() => {\n    const v = lastValue;\n    if (v) {\n      upstream.set(v);\n      lastValue = undefined;\n    }\n  }, elapsed);\n\n  const upstream = initUpstream<V, V>(source, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      timer.start();\n    }\n  });\n  return toReadable(upstream);\n}\n\n","import type { ReactiveOrSource } from \"../Types.js\";\nimport { transform } from \"./Transform.js\";\n\n/**\n * Emits time in milliseconds since last message.\n * If it is the first value, 0 is used.\n * @param input \n * @param transformer \n * @param options \n * @returns \n */\nexport const elapsed = <In>(input: ReactiveOrSource<In>) => {\n  let last = 0;\n  return transform<In, number>(input, (_ignored) => {\n    const elapsed = last === 0 ? 0 : Date.now() - last;\n    last = Date.now();\n    return elapsed;\n  });\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { FieldOptions } from \"./Types.js\";\n\n/**\n * From a source value, yields a field from it. Only works\n * if stream values are objects.\n * \n * If a source value doesn't have that field, it is skipped.\n *\n * @returns \n */\nexport function field<TIn extends object, TFieldType>(fieldSource: ReactiveOrSource<TIn>, fieldName: keyof TIn, options: Partial<FieldOptions<TIn, TFieldType>> = {}): Reactive<TFieldType> {\n  const fallbackFieldValue = options.fallbackFieldValue;\n  const fallbackObject = options.fallbackObject;\n\n  const upstream = initUpstream<TIn, TFieldType>(fieldSource, {\n    disposeIfSourceDone: true,\n    ...options,\n    onValue(value) {\n      let v: TFieldType | undefined;\n      // 1. Try to read from value\n      if (fieldName in value) {\n        v = value[ fieldName ] as TFieldType;\n      } else if (fallbackObject && fieldName in fallbackObject) {\n        // 2. Read from fallback object\n        v = fallbackObject[ fieldName ] as TFieldType;\n      }\n      // 3. Use fallback value\n      if (v === undefined) {\n        v = fallbackFieldValue;\n      }\n      if (v !== undefined) {\n        upstream.set(v);\n      }\n    },\n  })\n  return toReadable(upstream);\n}","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, InitStreamOptions, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { FilterPredicate } from \"./Types.js\";\n\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport function filter<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n\n\n/**\n * Drops all values where `predicate` function returns _true_.\n */\nexport function drop<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (!predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { Reactive, ReactiveOrSource } from \"../Types.js\";\nimport * as BasicProcessors from '../../data/BasicProcessors.js';\nimport type { Process } from \"../../data/Process.js\";\nimport type { OpAsAnnotation, OpMathOptions } from \"./Types.js\";\nimport type { RankFunction, RankOptions } from \"../../data/Types.js\";\n\nexport function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function max(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, max: number }>;\nexport function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, max: number }> {\n  const p = BasicProcessors.max();\n  return process(p, `max`, input, options);\n}\n\nexport function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function min(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, min: number }>;\nexport function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, min: number }> {\n  const p = BasicProcessors.min();\n  return process(p, `min`, input, options);\n}\n\nexport function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function average(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, average: number }>;\nexport function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, average: number }> {\n  const p = BasicProcessors.average();\n  return process(p, `average`, input, options);\n}\n\nexport function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function sum(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, sum: number }>;\nexport function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, sum: number }> {\n  const p = BasicProcessors.sum();\n  return process(p, `sum`, input, options);\n}\n\nexport type TallyOptions = OpMathOptions & {\n  countArrayItems: boolean\n}\n\nexport function tally(input: ReactiveOrSource<any>, options: Partial<TallyOptions>): Reactive<number>;\nexport function tally<TIn>(input: ReactiveOrSource<TIn>, options: OpAsAnnotation & Partial<TallyOptions>): Reactive<{ value: TIn, tally: number }>;\nexport function tally<TIn>(input: ReactiveOrSource<TIn>, options: Partial<TallyOptions> = {}): Reactive<number> | Reactive<{ value: TIn, tally: number }> {\n  const countArrayItems = options.countArrayItems ?? true;\n  const p = BasicProcessors.tally(countArrayItems);\n  return process(p, `tally`, input, options);\n}\n\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn>;\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: OpAsAnnotation & Partial<RankOptions & OpMathOptions>): Reactive<{ value: TIn, rank: TIn }>;\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn> | Reactive<{ value: TIn, rank: TIn }> {\n  const p = BasicProcessors.rank(rank, options);\n  return process(p, `rank`, input, options);\n}\n\nfunction process(processor: Process<any, any>, annotationField: string, input: ReactiveOrSource<any>, options: OpMathOptions = {}) {\n  const annotate = options.annotate;\n  let previous: number | undefined;\n  const skipUndefined = options.skipUndefined ?? true;\n  const skipIdentical = options.skipIdentical ?? true;\n  const upstream = initUpstream<any, any>(input, {\n    ...options,\n    onValue(value) {\n      const x = processor(value);\n      if (x === undefined && skipUndefined) return;\n      if (skipIdentical && x === previous) return;\n      previous = x;\n      if (annotate) {\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const ret: any = { value };\n        ret[ annotationField ] = x;\n        upstream.set(ret);\n      } else {\n        upstream.set(x);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n\n//todo testing for annotation and non - annotated\n\n\n// rankArray\n\n// chunk, reduce\n\n// debounce, delay\n\n// duration, take","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { PipeSet, Reactive, Passed } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../Util.js\";\n\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n * \n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams \n * @returns \n */\nexport const pipe = <TInput, TOutput>(...streams: PipeSet<TInput, TOutput>): Reactive<TOutput> => {\n  const event = initStream<TOutput>();\n  const unsubs: Array<() => void> = [];\n  const performDispose = (reason: string) => {\n    for (const s of streams) {\n      if (!s.isDisposed) s.dispose(reason);\n    }\n    for (const s of unsubs) {\n      s();\n    }\n    event.dispose(reason);\n  }\n\n  for (let index = 0; index < streams.length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    unsubs.push(streams[ index ].on((message: Passed<unknown>) => {\n      const isLast = index === streams.length - 1;\n      if (messageHasValue(message)) {\n        if (isLast) {\n          // Last stream, send to output\n          event.set(message.value as TOutput);\n        } else {\n          // @ts-expect-error\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          streams[ index + 1 ].set(message.value);\n        }\n      } else if (messageIsDoneSignal(message)) {\n        performDispose(`Upstream disposed`);\n      }\n    }));\n  }\n  return {\n    on: event.on,\n    onValue: event.onValue,\n    dispose(reason) {\n      performDispose(reason);\n    },\n    isDisposed() {\n      return event.isDisposed();\n    },\n  };\n}","import { shuffle } from \"../../collections/arrays/Random.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport type { SingleFromArrayOptions } from \"./Types.js\";\n\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n * \n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n * \n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, { \n *  predicate: v => v % 2 === 0\n * });\n * \n * // Selects a random value from source\n * singleFromArray(source, { \n *  order: `random`,\n *  at: 0\n * });\n * ```\n * \n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns \n */\nexport function singleFromArray<V>(source: ReactiveOrSource<Array<V>>, options: Partial<SingleFromArrayOptions<V>> = {}): Reactive<V> {\n  const order = options.order ?? `default`;\n  if (!options.at && !options.predicate) throw new Error(`Options must have 'predicate' or 'at' fields`);\n\n  let preprocess = (values: Array<V>) => values;\n  if (order === `random`) preprocess = shuffle;\n  else if (typeof order === `function`) preprocess = (values) => values.toSorted(order);\n\n  const upstream = initUpstream<Array<V>, V>(source, {\n    onValue(values) {\n      values = preprocess(values);\n      if (options.predicate) {\n        for (const v of values) {\n          if (options.predicate(v)) {\n            upstream.set(v);\n          }\n        }\n      } else if (options.at) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        upstream.set(values.at(options.at)!);\n      }\n    },\n  });\n  return upstream;\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, ReactiveStream, Reactive } from \"../Types.js\";\nimport type { SplitOptions } from \"./Types.js\";\n\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n * \n * See also {@link splitLabelled} to split into named streams.\n * @param source \n * @param quantity \n * @returns \n */\nexport const split = <T>(r: ReactiveOrSource<T>, options: Partial<SplitOptions> = {}) => {\n  const quantity = options.quantity ?? 2;\n  const outputs: Array<ReactiveStream<T>> = [];\n  const source = resolveSource(r);\n  for (let index = 0; index < quantity; index++) {\n    outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: `initial` }));\n  }\n  return outputs;\n}\n\n/**\n * Splits `source` into several duplicated streams. \n * Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const [a,b,c] = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n * \n * See also {@link split} to get an unlabelled split\n * @param source \n * @param labels \n * @returns \n */\nexport const splitLabelled = <T, K extends PropertyKey>(r: ReactiveOrSource<T>, labels: Array<K>): Record<K, Reactive<T>> => {\n  const source = resolveSource(r);\n  const t: Partial<Record<K, Reactive<T>>> = {}\n  for (const label of labels) {\n    t[ label ] = initUpstream(source, { lazy: `initial`, disposeIfSourceDone: true });\n  }\n  return t as Record<K, Reactive<T>>;\n}","import { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveStream } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../Util.js\";\nimport type { FilterPredicate, SwitcherOptions } from \"./Types.js\";\n\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n * \n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n * \n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n * \n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n * \n * If `source` closes, all the output streams will be closed as well.\n * @param reactiveOrSource \n * @param cases \n * @param options \n * @returns \n */\nexport const switcher = <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(reactiveOrSource: ReactiveOrSource<TValue>, cases: TRec, options: Partial<SwitcherOptions> = {}): Record<TLabel, Reactive<TValue>> => {\n  // return (r: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n  const match = options.match ?? `first`;\n  const source = resolveSource(reactiveOrSource);\n  let disposed = false;\n  // Setup output streams\n  const t: Partial<Record<TLabel, ReactiveStream<TValue>>> = {}\n  for (const label of Object.keys(cases)) {\n    (t as any)[ label ] = initStream<TValue>();\n  }\n\n  const performDispose = () => {\n    if (disposed) return;\n    unsub();\n    disposed = true;\n    for (const stream of Object.values(t)) {\n      (stream as ReactiveStream<any>).dispose(`switcher source dispose`);\n    }\n  }\n\n  // Listen to source\n  const unsub = source.on(message => {\n    // Got a value\n    if (messageHasValue(message)) {\n      for (const [ lbl, pred ] of Object.entries(cases)) {\n        if (pred(message.value)) {\n          ((t as any)[ lbl ] as ReactiveStream<TValue>).set(message.value);\n          if (match === `first`) break;\n        }\n      }\n    } else if (messageIsDoneSignal(message)) {\n      performDispose();\n    }\n  })\n  return t as Record<TLabel, Reactive<TValue>>;\n  // }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypes } from \"../Types.js\";\nimport { messageIsSignal } from \"../Util.js\";\nimport type { SyncOptions } from \"./Types.js\";\n\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n * \n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n * \n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n * \n * Only complete results are sent. For example if source A & B finish and source C is still producing values,\n * synchronisation is not possible because A & B stopped producing values. Thus the stream will self-terminate\n * after `maximumWait` (2 seconds). The newer values from C are lost.\n */\nexport function syncToArray<const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypes<T>> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const finalValue = options.finalValue ?? `undefined`;\n  const maximumWait = intervalToMs(options.maximumWait, 2000);\n\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  type State<V> = {\n    done: boolean,\n    finalData: V | undefined,\n    source: Reactive<V>\n    unsub: () => void\n  }\n\n  const data: Array<RxValueTypes<T> | undefined> = [];\n  //const finalData: Array<RxValueTypes<T> | undefined> = [];\n\n  // Resolve sources\n  //const sources = reactiveSources.map(source => resolveSource(source));\n  //const noop = () => {/*no-op*/ }\n  //const sourcesUnsub: Array<Unsubscriber> = sources.map(_ => noop);\n\n  const states: Array<State<any>> = reactiveSources.map(source => ({\n    finalData: undefined,\n    done: false,\n    source: resolveSource(source),\n    unsub: () => {/**no-op */ }\n  }));\n\n\n  const unsubscribe = () => {\n    for (const s of states) {\n      s.unsub();\n      s.unsub = () => {/**no-op */ }\n    }\n  }\n\n  const isDataSetComplete = () => {\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < data.length; index++) {\n      if (onSourceDone === `allow` && states[ index ].done) continue;\n      if (data[ index ] === undefined) return false;\n    }\n    return true;\n  }\n\n  const hasIncompleteSource = () => states.some(s => !s.done);\n  const resetDataSet = () => {\n    for (let index = 0; index < data.length; index++) {\n      if (finalValue === `last` && states[ index ].done) continue; // Don't overwrite\n      data[ index ] = undefined;\n    }\n  }\n\n  const onWatchdog = () => {\n    done(`Sync timeout exceeded (${ maximumWait.toString() })`);\n  }\n\n  const done = (reason: string) => {\n    if (watchdog) clearTimeout(watchdog);\n    unsubscribe();\n    event.dispose(reason);\n  }\n\n  const init = () => {\n    watchdog = setTimeout(onWatchdog, maximumWait);\n\n    for (const [ index, state ] of states.entries()) {\n      data[ index ] = undefined; // init array positions to be undefined\n\n      state.unsub = state.source.on(valueChanged => {\n        if (messageIsSignal(valueChanged)) {\n          if (valueChanged.signal === `done`) {\n            state.finalData = data[ index ];\n            state.unsub();\n            state.done = true;\n            state.unsub = () => { /** no-op */ }\n            if (finalValue === `undefined`) data[ index ] = undefined;\n            if (onSourceDone === `break`) {\n              done(`Source '${ index.toString() }' done, and onSourceDone:'break' is set`);\n              return;\n            }\n            if (!hasIncompleteSource()) {\n              done(`All sources done`);\n              return;\n            }\n          }\n          return;\n        }\n        data[ index ] = valueChanged.value;\n\n        if (isDataSetComplete()) {\n          // All array elements contain values\n          // Emit data and reset\n          event.set([ ...data ] as RxValueTypes<T>);\n          resetDataSet();\n          if (watchdog) clearTimeout(watchdog);\n          watchdog = setTimeout(onWatchdog, maximumWait);\n        }\n      });\n    }\n  }\n\n  const event = initStream<RxValueTypes<T>>({\n    onFirstSubscribe() {\n      unsubscribe();\n      init();\n    },\n    onNoSubscribers() {\n      if (watchdog) clearTimeout(watchdog);\n      unsubscribe();\n\n    },\n  });\n\n  return {\n    dispose: event.dispose,\n    isDisposed: event.isDisposed,\n    on: event.on,\n    onValue: event.onValue\n  }\n\n}\n","import { zipKeyValue } from \"../../collections/map/MapFns.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypeObject } from \"../Types.js\";\nimport { syncToArray } from \"./SyncToArray.js\";\nimport { transform } from \"./Transform.js\";\nimport type { SyncOptions } from \"./Types.js\";\n\nexport function syncToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypeObject<T>> {\n  const keys = Object.keys(reactiveSources)\n  const values = Object.values(reactiveSources);\n\n  const s = syncToArray(values, options);\n  const st = transform(s, (streamValues) => {\n    return zipKeyValue(keys, streamValues);\n  });\n  return st as Reactive<RxValueTypeObject<T>>;\n}","export type Process<TIn, TOut> = (value: TIn) => TOut;\nexport type ProcessFactory<TIn, TOut> = () => Process<TIn, TOut>;\n\nexport type Processors1<T1, T2> = [\n  Process<T1, T2>\n]\n\nexport type Processors2<T1, T2, T3> = [\n  Process<T1, T2>,\n  Process<T2, T3>\n]\n\nexport type Processors3<T1, T2, T3, T4> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>\n]\n\nexport type Processors4<T1, T2, T3, T4, T5> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>,\n  Process<T4, T5>\n]\n\nexport type Processors5<T1, T2, T3, T4, T5, T6> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>,\n  Process<T4, T5>,\n  Process<T5, T6>\n]\nexport type Processors<T1, T2, T3, T4, T5, T6> = Processors1<T1, T2> | Processors2<T1, T2, T3> | Processors3<T1, T2, T3, T4> | Processors4<T1, T2, T3, T4, T5> | Processors5<T1, T2, T3, T4, T5, T6>;\n\nexport function processChain<T1, T2>(...processors: [ Process<T1, T2> ]): (value: T1) => T2;\nexport function processChain<T1, T2, T3>(...processors: [ Process<T1, T2>, Process<T2, T3> ]): (value: T1) => T3;\nexport function processChain<T1, T2, T3, T4>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4> ]): (value: T1) => T4;\nexport function processChain<T1, T2, T3, T4, T5>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4>, Process<T4, T5> ]): (value: T1) => T5;\nexport function processChain<T1, T2, T3, T4, T5, T6>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4>, Process<T4, T5>, Process<T5, T6> ]): (value: T1) => T6;\n\n/**\n * Creates a chain of data processors (up to 5 are supported).\n * The chain is encapsulated in a function that accepts an input value an returns an output.\n * \n * ```js\n * const p = processChain(\n *  (value:string) => value.tUpperCase(), // Convert to uppercase\n *  (value:string) => value.at(0) === 'A) // If first letter is an A, return true\n * );\n * p('apple'); // True\n * ```\n * \n * Each processing function is expected to take in one input value and return one value.\n * @param processors \n * @returns \n */\nexport function processChain<T1, T2, T3, T4, T5, T6>(...processors: Processors<T1, T2, T3, T4, T5, T6>): (value: T1) => T2 | T3 | T4 | T5 | T6 {\n  return (value: T1) => {\n    let v = value;\n    for (const p of processors) {\n      // @ts-expect-error\n      v = p(v);\n    }\n    return v as T2 | T3 | T4 | T5 | T6;\n  }\n}\n\n// const test = processors(\n//   (value: string) => { return 1 },\n//   (value: number) => value > 1\n// )\n// const testResult = test(`hello`);\n\n\n","import { processChain, type Processors } from \"../../data/Process.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveWritable, ReactiveOp } from \"../Types.js\";\n\n/**\n * 'Taps' the values from 'input', passing them to the 'process' function.\n * Return stream is the input stream, unaffected by what 'process' does.\n * @param input Input stream\n * @param processors List of processors\n * @returns \n */\nexport function tapProcess<In, T2, T3, T4, T5, T6>(input: ReactiveOrSource<In>, ...processors: Processors<In, T2, T3, T4, T5, T6>): Reactive<In> {\n  const inputStream = resolveSource(input);\n\n  // @ts-expect-error\n  const chain = processChain(...processors);\n  inputStream.onValue(value => {\n    chain(value);\n  });\n  return inputStream;\n}\n\n/**\n * 'Taps' the values from 'input', passing them to 'diverged'\n * Returns the original input stream, unaffected by what 'diverged' does.\n * @param input Input stream\n * @param diverged Stream to write to \n * @returns \n */\nexport function tapStream<In>(input: ReactiveOrSource<In>, diverged: ReactiveWritable<In>): Reactive<In> {\n  const inputStream = resolveSource(input);\n  inputStream.onValue(value => {\n    diverged.set(value);\n  });\n  return inputStream;\n}\n\n/**\n * Create a parallel 'tap' of processing\n * @param input Input stream\n * @param ops Series of ops to process data\n * @returns \n */\nexport const tapOps = <TIn, TOut>(input: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>): Reactive<TOut> => {\n  for (const op of ops) {\n    // @ts-expect-error\n    input = op(input);\n  }\n  return input as any as Reactive<TOut>;\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ThrottleOptions } from \"./Types.js\";\n\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n * \n * Throttle will fire on the first value received.\n * \n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n * \n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration, \n * even if the source stops sending.\n * @param options \n * @returns \n */\nexport function throttle<V>(throttleSource: ReactiveOrSource<V>, options: Partial<ThrottleOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 0);\n  let lastFire = performance.now();\n  let lastValue: V | undefined;\n\n  const upstream = initUpstream<V, V>(throttleSource, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      trigger();\n    },\n  });\n\n  const trigger = () => {\n    const now = performance.now();\n    if (elapsed > 0 && (now - lastFire > elapsed)) {\n      lastFire = now;\n      if (lastValue !== undefined) {\n        upstream.set(lastValue);\n      }\n    }\n  }\n\n\n  return toReadable(upstream);\n\n}\n","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { isTrigger, resolveTriggerValue } from \"../Util.js\";\nimport type { TimeoutTriggerOptions } from \"../sources/Types.js\";\n\n/**\n * Emits a value if `source` does not emit a value after `interval`\n * has elapsed. For example, this allows you to reset a reactive to some\n * 'zero' state if nothing is going on.\n * \n * If `source` emits faster than the `interval`, it won't get triggered.\n * \n * Default for 'timeout': 1000s.\n * \n * ```js\n * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n * const r = Rx.timeoutTrigger(source, { value: 'hello', interval: { mins: 1 } });\n * ```\n * \n * Can also emit results from a function or generator\n * ```js\n * // Emits a random number if 'source' doesn't emit a value after 500ms\n * const r = Rx.timeoutTrigger(source, { fn: Math.random, interval: 500 });\n * ```\n * \n * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n * Otherwise it won't start until it observes the first value from `source`.\n * @param source \n * @param options \n */\nexport function timeoutTrigger<TSource, TTriggerValue>(source: ReactiveOrSource<TSource>, options: TimeoutTriggerOptions<TTriggerValue>): Reactive<TSource | TTriggerValue> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  const immediate = options.immediate ?? true;\n  const repeat = options.repeat ?? false;\n  const timeoutMs = intervalToMs(options.interval, 1000);\n  if (!isTrigger(options)) {\n    throw new Error(`Param 'options' does not contain trigger 'value' or 'fn' fields`);\n  }\n\n  // Send value from trigger\n  const sendFallback = () => {\n    const [ value, done ] = resolveTriggerValue(options);\n    if (done) {\n      events.dispose(`Trigger completed`);\n    } else {\n      if (events.isDisposed()) return;\n      events.set(value);\n      if (repeat) {\n        timer = setTimeout(sendFallback, timeoutMs);\n      }\n    }\n  }\n\n  const events = initUpstream<TSource, TSource | TTriggerValue>(source, {\n    disposeIfSourceDone: true,\n    // Received a value from upstream source\n    onValue(v) {\n      // Reset timeout\n      if (timer) clearTimeout(timer);\n      timer = setTimeout(sendFallback, timeoutMs);\n      // Emit value\n      events.set(v);\n    },\n    onDispose() {\n      if (timer) clearTimeout(timer);\n    },\n  });\n\n  if (immediate && !timer) {\n    timer = setTimeout(sendFallback, timeoutMs);\n  }\n  return events;\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, WithValueOptions, ReactiveInitial } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\n\n/**\n * A reactive where the last value can be read at any time.\n * An initial value must be provided.\n * ```js\n * const r = Rx.withValue(source, { initial: `hello` });\n * r.last(); // Read last value\n * ```\n * @param input \n * @param options \n * @returns \n */\nexport function withValue<In>(input: ReactiveOrSource<In>, options: WithValueOptions<In>): ReactiveInitial<In> {\n  let lastValue: In | undefined = options.initial;\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      upstream.set(value);\n    },\n  })\n\n  const readable = toReadable(upstream);\n  return {\n    ...readable,\n    // @ts-expect-error\n    last() {\n      return lastValue;\n    },\n  }\n}","import { resolveEls, type QueryOrElements } from \"./ResolveEl.js\";\n\nexport function setText(selectors: QueryOrElements): (value: any) => string;\nexport function setText(selectors: QueryOrElements, value?: any): string;\nexport function setText(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`textContent`, selectors, value)\n};\n\nexport function setHtml(selectors: QueryOrElements): (value: any) => string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`innerHTML`, selectors, value)\n};\n\nexport function setProperty(property: string, selectors: QueryOrElements): (value: any) => string;\nexport function setProperty(property: string, selectors: QueryOrElements, value: any): string;\n\nexport function setProperty(property: string, selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  let elements: Array<HTMLElement> = [];\n  const set = (v: any) => {\n    const typ = typeof v;\n    const vv = (typ === `string` || typ === `number` || typ === `boolean`) ? v as string :\n      JSON.stringify(v);\n\n    if (elements.length === 0) {\n      elements = resolveEls(selectors);\n    }\n    for (const element of elements) {\n      (element as any)[ property ] = vv;\n    }\n    return vv;\n  }\n  return value === undefined ? set : set(value);\n};","import { setProperty } from \"../../dom/SetProperty.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource } from \"../Types.js\";\n\nexport type SetHtmlOptionsQuery = {\n  query: string\n}\n\nexport type SetHtmlOptionsElement = {\n  el: HTMLElement\n}\n\nexport type SetHtmlOptions = (SetHtmlOptionsQuery | SetHtmlOptionsElement) & {\n  /**\n   * If _true_ .innerHTML is used\n   * If _false_ (default) .textContent is used\n   */\n  asHtml?: boolean;\n};\n\n/**\n * Values from `input` are set to the textContent/innerHTML of an element.\n * ```js\n * const rxSource = Rx.From.string('hello');\n * const rxSet = Rx.Sinks.setHtmlText(rxSource, { query: })\n * ```\n * @param input \n * @param options \n */\nexport const setHtmlText = (input: ReactiveOrSource<any>, optionsOrElementOrQuery: SetHtmlOptions | string | HTMLElement) => {\n  let el: HTMLElement | null | undefined;\n  let options: SetHtmlOptions | undefined;\n  if (typeof optionsOrElementOrQuery === `string`) {\n    options = { query: optionsOrElementOrQuery };\n  }\n  if (typeof optionsOrElementOrQuery === `object`) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (`nodeName` in optionsOrElementOrQuery) {\n      options = { el: optionsOrElementOrQuery };\n    } else {\n      options = optionsOrElementOrQuery;\n    }\n  }\n  if (options === undefined) throw new TypeError(`Missing element as second parameter or option`);\n  if (`el` in options) {\n    el = options.el;\n  } else if (`query` in options) {\n    el = document.querySelector<HTMLElement>(options.query);\n  } else {\n    throw new TypeError(`Options does not include 'el' or 'query' fields`);\n  }\n  if (el === null || el === undefined) throw new Error(`Element could not be resolved.`);\n\n  const stream = resolveSource(input);\n  const setter = setProperty(options.asHtml ? `innerHTML` : `textContent`, el);\n  const off = stream.onValue(value => {\n    setter(value)\n  });\n  return off;\n}","import { resolveSource } from \"./ResolveSource.js\"\nimport type { Reactive, ReactiveOp, ReactiveOrSource } from \"./Types.js\"\nimport { isWritable } from \"./Util.js\"\n\nexport type OpChain1<T1, T2> = [\n  ReactiveOp<T1, T2>\n]\n\nexport type OpChain2<T1, T2, T3> = [\n  ReactiveOp<T1, T2>,\n  ReactiveOp<T2, T3>\n]\n\nexport type OpChain3<T1, T2, T3, T4> = [\n  ReactiveOp<T1, T2>,\n  ReactiveOp<T2, T3>,\n  ReactiveOp<T3, T4>\n]\n\nexport type OpChain4<T1, T2, T3, T4, T5> = [\n  ReactiveOp<T1, T2>,\n  ReactiveOp<T2, T3>,\n  ReactiveOp<T3, T4>,\n  ReactiveOp<T4, T5>\n]\n\nexport type OpChain5<T1, T2, T3, T4, T5, T6> = [\n  ReactiveOp<T1, T2>,\n  ReactiveOp<T2, T3>,\n  ReactiveOp<T3, T4>,\n  ReactiveOp<T4, T5>,\n  ReactiveOp<T5, T6>\n]\nexport type OpChain<T1, T2, T3, T4, T5, T6> = OpChain1<T1, T2> | OpChain2<T1, T2, T3> | OpChain3<T1, T2, T3, T4> | OpChain4<T1, T2, T3, T4, T5> | OpChain5<T1, T2, T3, T4, T5, T6>;\n\nexport function chainer<T1, T2>(...ops: [ ReactiveOp<T1, T2> ]): (source: ReactiveOrSource<T1>) => Reactive<T2>;\nexport function chainer<T1, T2, T3>(...ops: OpChain2<T1, T2, T3>): (source: ReactiveOrSource<T1>) => Reactive<T3>;\nexport function chainer<T1, T2, T3, T4>(...ops: OpChain3<T1, T2, T3, T4>): (source: ReactiveOrSource<T1>) => Reactive<T4>;\nexport function chainer<T1, T2, T3, T4, T5>(...ops: OpChain4<T1, T2, T3, T4, T5>): (source: ReactiveOrSource<T1>) => Reactive<T5>;\nexport function chainer<T1, T2, T3, T4, T5, T6>(...ops: OpChain5<T1, T2, T3, T4, T5, T6>): (source: ReactiveOrSource<T1>) => Reactive<T6>;\n\n/**\n * Creates a chainer of data ops (up to 5 are supported).\n * The chainer is encapsulated in a function that accepts an input value an returns an output.\n * \n * ```js\n * const p = chainer(\n *  (value:string) => value.tUpperCase(), // Convert to uppercase\n *  (value:string) => value.at(0) === 'A) // If first letter is an A, return true\n * );\n * p('apple'); // True\n * ```\n * \n * Each processing function is expected to take in one input value and return one value.\n * @param ops \n * @returns \n */\nexport function chainer<T1, T2, T3, T4, T5, T6>(...ops: Array<ReactiveOp<any, any>>): (source: ReactiveOrSource<T1>) => Reactive<T2 | T3 | T4 | T5 | T6> {\n  // return (value: T1) => {\n  //   let v = value;\n  //   for (const op of ops) {\n  //     // @ts-expect-error\n  //     v = p(v);\n  //   }\n  //   return v as T2 | T3 | T4 | T5 | T6;\n  // }\n  return (source: ReactiveOrSource<T1>) => {\n    for (const op of ops) {\n      source = op(source);\n    }\n    return source as Reactive<T2 | T3 | T4 | T5 | T6>;\n  }\n}\n\nexport function run<T1, T2>(source: ReactiveOrSource<T1>, ...ops: OpChain1<T1, T2>): Reactive<T2>;\nexport function run<T1, T2, T3>(source: ReactiveOrSource<T1>, ...ops: OpChain2<T1, T2, T3>): Reactive<T3>;\nexport function run<T1, T2, T3, T4>(source: ReactiveOrSource<T1>, ...ops: OpChain3<T1, T2, T3, T4>): Reactive<T4>;\nexport function run<T1, T2, T3, T4, T5>(source: ReactiveOrSource<T1>, ...ops: OpChain4<T1, T2, T3, T4, T5>): Reactive<T5>;\nexport function run<T1, T2, T3, T4, T5, T6>(source: ReactiveOrSource<T1>, ...ops: OpChain5<T1, T2, T3, T4, T5, T6>): Reactive<T6>;\n\n\n/**\n * Connects `source` to serially-connected set of ops. Values thus\n * flow from `source` to each op in turn.\n * \n * Returned result is the final reactive.\n * \n * @param source \n * @param ops \n * @returns \n */\nexport function run<T1, T2, T3, T4, T5, T6>(source: ReactiveOrSource<T1>, ...ops: OpChain1<T1, T2> | OpChain2<T1, T2, T3> | OpChain3<T1, T2, T3, T4> | OpChain4<T1, T2, T3, T4, T5> | OpChain5<T1, T2, T3, T4, T5, T6>): Reactive<T2 | T3 | T4 | T5 | T6> {\n  let s = resolveSource(source);\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n  //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n  //return raw(source);\n}\n\nexport function runHead<T1, T2>(source: ReactiveOrSource<T1>, ...ops: OpChain1<T1, T2>): Reactive<T2>;\nexport function runHead<T1, T2, T3>(source: ReactiveOrSource<T1>, ...ops: OpChain2<T1, T2, T3>): Reactive<T3>;\nexport function runHead<T1, T2, T3, T4>(source: ReactiveOrSource<T1>, ...ops: OpChain3<T1, T2, T3, T4>): Reactive<T4>;\nexport function runHead<T1, T2, T3, T4, T5>(source: ReactiveOrSource<T1>, ...ops: OpChain4<T1, T2, T3, T4, T5>): Reactive<T5>;\nexport function runHead<T1, T2, T3, T4, T5, T6>(source: ReactiveOrSource<T1>, ...ops: OpChain5<T1, T2, T3, T4, T5, T6>): Reactive<T6>;\n\n\n/**\n * Connects `source` to serially-connected set of ops. Values thus\n * flow from `source` to each op in turn.\n * \n * Returned result is the final reactive.\n * \n * @param source \n * @param ops \n * @returns \n */\nexport function runHead<T1, T2, T3, T4, T5, T6>(source: ReactiveOrSource<T1>, ...ops: OpChain1<T1, T2> | OpChain2<T1, T2, T3> | OpChain3<T1, T2, T3, T4> | OpChain4<T1, T2, T3, T4, T5> | OpChain5<T1, T2, T3, T4, T5, T6>): Reactive<T2 | T3 | T4 | T5 | T6> {\n  let originalSource = resolveSource(source);\n  let s = originalSource;\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  const rr = s as Reactive<T2 | T3 | T4 | T5 | T6>;\n  if (isWritable(originalSource)) {\n    return {\n      ...rr,\n      set(value: T1) {\n        originalSource.set(value);\n      }\n    } as any as Reactive<T2 | T3 | T4 | T5 | T6>\n  } else {\n    return rr;\n  }\n  //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n  //return raw(source);\n}","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { QueueMutable, StackMutable } from \"../../collections/index.js\"\nimport { PriorityMutable } from \"../../collections/queue/PriorityMutable.js\"\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { NumberMap } from \"../../collections/map/NumberMap.js\"\nimport * as Sync from \"../../iterables/IterableSync.js\"\nimport { Table } from \"../Table.js\"\n\nexport type DistanceCompute = (graph: DirectedGraph, edge: Edge) => number;\n\n/**\n * Vertex. These are the _nodes_ of the graph. Immutable.\n * \n * They keep track of all of their outgoing edges, and\n * a unique id.\n * \n * Ids are used for accessing/updating vertices as well as in the\n * {@link Edge} type. They must be unique.\n */\nexport type Vertex = Readonly<{\n  out: ReadonlyArray<Edge>\n  id: string\n}>\n\n/**\n * Edge. Immutable.\n * \n * Only encodes the destination vertex. The from\n * is known since edges are stored on the from vertex.\n */\nexport type Edge = Readonly<{\n  /**\n   * Vertex id edge connects to (ie. destination)\n   */\n  id: string,\n  /**\n   * Optional weight of edge\n   */\n  weight?: number\n}>\n\n/**\n * Create a vertex with given id\n * @param id \n * @returns \n */\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id,\n    out: []\n  }\n}\n\n/**\n * Options for connecting vertices\n */\nexport type ConnectOptions = Readonly<{\n  /**\n   * From, or source of connection\n   */\n  from: string\n  /**\n   * To, or destination of connection. Can be multiple vertices for quick use\n   */\n  to: string | Array<string>\n  /**\n   * If true, edges in opposite direction are made as well\n   */\n  bidi?: boolean\n  /**\n   * Weight for this connection (optional)\n   */\n  weight?: number\n}>\n\n/**\n * Directed graph. Immutable\n * \n * Consists of {@link Vertex|vertices}, which all have zero or more outgoing {@link Edge|Edges}.\n */\nexport type DirectedGraph = Readonly<{\n  vertices: IMapImmutable<string, Vertex>\n}>\n\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph \n * @returns \n */\nexport function toAdjacencyMatrix(graph: DirectedGraph): Table<boolean> {\n  const v = [ ...graph.vertices.values() ];\n  //const m: Array<Array<boolean>> = [];\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // const row: Array<boolean> = [];\n  // for (let index = 0; index < v.length; index++) {\n  //   row[ index ] = false;\n  // }\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    //m[ i ] = [ ...row ];\n    table.setRow(i, v.length, false);\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      if (ii.out.some(o => o.id === jj.id)) {\n        //m[ i ][ j ] = true;\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: DirectedGraph | Iterable<Vertex>): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: DirectedGraph | Iterable<Vertex>): Array<string> => {\n  const r: Array<string> = [];\n  const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n\n  for (const v of vertices) {\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const str = debugDumpVertex(v);\n    r.push(...str.map(line => ` ${ line }`));\n  }\n  return r;\n}\n\n\nexport const distance = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Iterate over all the edges in the graph\n * @param graph \n */\nexport function* edges(graph: DirectedGraph) {\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    for (const edge of vertex.out) {\n      yield edge;\n    }\n  }\n}\n\n/**\n * Iterate over all the vertices of the graph\n * @param graph \n */\nexport function* vertices(graph: DirectedGraph) {\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    yield vertex;\n  }\n}\n\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns \n */\nexport function* adjacentVertices(graph: DirectedGraph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of vertex.out) {\n    const edgeV = graph.vertices.get(edge.id);\n    if (edgeV === undefined) throw new Error(`Could not find vertex: ${ edge.id }`);\n    yield edgeV;\n  }\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n * \n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns \n */\nexport const vertexHasOut = (vertex: Vertex, outIdOrVertex: string | Vertex): boolean => {\n  if (vertex === undefined) return false;\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return vertex.out.some(edge => edge.id === outId);\n}\n\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph \n * @param vertex \n * @returns \n */\nexport const hasNoOuts = (graph: DirectedGraph, vertex: string | Vertex): boolean => {\n  const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n  if (context === undefined) return false;\n  return context.out.length === 0;\n}\n\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOnlyOuts = (graph: DirectedGraph, vertex: string | Vertex, ...outIdOrVertex: Array<string | Vertex>): boolean => {\n  const context = resolveVertex(graph, vertex);\n  const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n\n  if (outs.length !== context.out.length) {\n    //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n    return false;\n  }\n  for (const out of outs) {\n    //console.log(`Testing ${ context.id } -> ${ out.id }`);\n    if (!hasOut(graph, context, out)) {\n      //console.log(`  no`);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOut = (graph: DirectedGraph, vertex: string | Vertex, outIdOrVertex: string | Vertex): boolean => {\n  const context = resolveVertex(graph, vertex);\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return context.out.some(edge => edge.id === outId);\n}\n\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrCreate = (graph: DirectedGraph, id: string): Readonly<{ graph: DirectedGraph, vertex: Vertex }> => {\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrFail = (graph: DirectedGraph, id: string): Vertex => {\n  const v = graph.vertices.get(id);\n  if (v === undefined) throw new Error(`Vertex '${ id }' not found in graph`);\n  return v;\n}\n\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns \n */\nexport const updateGraphVertex = (graph: DirectedGraph, vertex: Vertex): DirectedGraph => {\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph \n * @param edge \n * @returns \n */\nexport const distanceDefault = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n * \n * If edge was not there, original graph is returned.\n * @param graph \n * @param from \n * @param to \n * @returns \n */\nexport function disconnect(graph: DirectedGraph, from: string | Vertex, to: string | Vertex): DirectedGraph {\n  const fromV = resolveVertex(graph, from);\n  const toV = resolveVertex(graph, to);\n\n  return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n    ...fromV,\n    out: fromV.out.filter(t => t.id !== toV.id)\n  }) : graph;\n}\n\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph \n * @param from \n * @param to \n * @param weight \n * @returns \n */\nexport function connectTo(graph: DirectedGraph, from: string, to: string, weight?: number): { graph: DirectedGraph, edge: Edge } {\n  const fromResult = getOrCreate(graph, from);\n  graph = fromResult.graph;\n  const toResult = getOrCreate(graph, to);\n  graph = toResult.graph;\n\n  const edge: Edge = {\n    id: to,\n    weight\n  }\n\n  if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n    graph = updateGraphVertex(graph, {\n      ...fromResult.vertex,\n      // Add new edge to list of edges for this node\n      out: [ ...fromResult.vertex.out, edge ]\n    });\n  }\n  return { graph, edge }\n}\n\n/**\n * Connect from -> to. By default unidirectional.\n * Returns a new graph with the connection\n * @param graph \n * @param options \n * @returns \n */\nexport function connect(graph: DirectedGraph, options: ConnectOptions): DirectedGraph {\n  const { to, weight, from } = options;\n  const bidi = options.bidi ?? false;\n  const toList = Array.isArray(to) ? to : [ to ];\n\n  // Connect from -> to\n  for (const toSingle of toList) {\n    const result = connectTo(graph, from, toSingle, weight);\n    graph = result.graph;\n  }\n\n  if (!bidi) return graph;\n\n  // Bidirectional connection\n  // Connect to -> from\n  for (const toSingle of toList) {\n    const result = connectTo(graph, toSingle, from, weight);\n    graph = result.graph;\n  }\n  return graph;\n}\n\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v \n * @returns \n */\nconst debugDumpVertex = (v: Vertex): Array<string> => {\n  const r = [\n    v.id\n  ]\n  const stringForEdge = (edge: Edge) => edge.weight === undefined ? edge.id : `${ edge.id } (${ edge.weight })`\n\n  // for (const edge of v.in) {\n  //   r.push(` <- ${ stringForEdge(edge) }`);\n  // }\n  for (const edge of v.out) {\n    r.push(` -> ${ stringForEdge(edge) }`);\n  }\n  if (v.out.length === 0) r[ 0 ] += ` (terminal)`;\n\n  return r;\n}\n\n/**\n * Returns _true_ if a->b or b->a\n * @param graph \n * @param a \n * @param b \n * @returns \n */\nexport function areAdjacent(graph: DirectedGraph, a: Vertex, b: Vertex) {\n  if (hasOut(graph, a, b.id)) return true;\n  if (hasOut(graph, b, a.id)) return true;\n}\n\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph \n * @param idOrVertex \n * @returns \n */\nfunction resolveVertex(graph: DirectedGraph, idOrVertex: string | Vertex): Vertex {\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph \n * @param startIdOrVertex \n * @param targetIdOrVertex \n * @returns \n */\nexport function* bfs(graph: DirectedGraph, startIdOrVertex: string | Vertex, targetIdOrVertex?: string | Vertex) {\n  const start = resolveVertex(graph, startIdOrVertex);\n  const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n\n  const queue = new QueueMutable<Vertex>();\n  const seen = new Set<string>();\n  queue.enqueue(start);\n  while (!queue.isEmpty) {\n    const v = queue.dequeue()!;\n    yield v;\n    if (target !== undefined && target === v) return;\n    for (const edge of adjacentVertices(graph, v)) {\n      if (!seen.has(edge.id)) {\n        seen.add(edge.id);\n        queue.enqueue(resolveVertex(graph, edge.id));\n      }\n    }\n  }\n}\n\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph \n * @param startIdOrVertex \n */\nexport function* dfs(graph: DirectedGraph, startIdOrVertex: string | Vertex) {\n  const source = resolveVertex(graph, startIdOrVertex);\n\n  const s = new StackMutable<Vertex>();\n  const seen = new Set<string>();\n  s.push(source);\n  while (!s.isEmpty) {\n    const v = s.pop();\n    if (v === undefined) continue;\n    if (!seen.has(v.id)) {\n      seen.add(v.id);\n      yield v;\n      for (const edge of v.out) {\n        const destination = graph.vertices.get(edge.id);\n        if (destination) {\n          s.push(destination);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph \n * @param sourceOrId \n * @returns \n */\nexport const pathDijkstra = (graph: DirectedGraph, sourceOrId: Vertex | string) => {\n  const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n  if (source === undefined) throw new Error(`source vertex not found`);\n\n  const distances = new Map<string, number>();\n  const previous = new Map<string, Vertex | null>();\n\n  distances.set(source.id, 0);\n\n  const pq = new PriorityMutable<string>();\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const v of vertices) {\n    if (v.id !== source.id) {\n      distances.set(v.id, Number.MAX_SAFE_INTEGER);\n      // eslint-disable-next-line unicorn/no-null\n      previous.set(v.id, null);\n    }\n    pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n  }\n\n  while (!pq.isEmpty) {\n    const u = pq.dequeueMin();\n    if (u === undefined) throw new Error(`Bug. Queue unexpectedly empty`);\n    const vertexU = graph.vertices.get(u)!;\n    for (const neighbour of vertexU.out) {\n      //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n      const alt = distances.get(u)! + distance(graph, neighbour);\n      if (alt < distances.get(neighbour.id)!) {\n        distances.set(neighbour.id, alt);\n        previous.set(neighbour.id, vertexU);\n        pq.changePriority(neighbour.id, alt, true);\n      }\n    }\n  }\n\n  const pathTo = (id: string): Array<Edge> => {\n    const path: Array<Edge> = [];\n    while (true) {\n      if (id === source.id) break;\n      const v = previous.get(id);\n      if (v === undefined || v === null) throw new Error(`Id not present: ${ id }`);\n      path.push({ id, weight: distances.get(id) });\n      id = v.id;\n    }\n    return path;\n  }\n  return {\n    distances, previous, pathTo\n  }\n}\n\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph \n * @returns \n */\nexport const clone = (graph: DirectedGraph): DirectedGraph => {\n  const g: DirectedGraph = {\n    vertices: immutableMap<string, Vertex>([ ...graph.vertices.entries() ])\n  }\n  return g;\n}\n\n/**\n * Create a graph\n * @param initialConnections \n * @returns \n */\nexport const graph = (...initialConnections: Array<ConnectOptions>): DirectedGraph => {\n  let g: DirectedGraph = {\n    vertices: immutableMap()\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\n/**\n * Internal type for Tarjan algorithm\n */\ntype TarjanVertex = Vertex & {\n  lowlink: number\n  index: number\n  onStack: boolean\n}\n\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph \n */\nexport function isAcyclic(graph: DirectedGraph): boolean {\n  const cycles = getCycles(graph);\n  return cycles.length === 0;\n}\n\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph \n */\nexport function topologicalSort(graph: DirectedGraph): DirectedGraph {\n  const indegrees = new NumberMap(0);\n\n  // Increment indegrees for each edge leading to a vertex\n  for (const edge of edges(graph)) {\n    indegrees.add(edge.id, 1);\n  }\n\n  // Enqueue all vertices with an indegree of 0\n  const queue = new QueueMutable<Vertex>();\n  let vertexCount = 0;\n  for (const vertex of vertices(graph)) {\n    if (indegrees.get(vertex.id) === 0) {\n      queue.enqueue(vertex);\n    }\n    vertexCount++;\n  }\n\n  const topOrder: Array<Vertex> = [];\n  while (!queue.isEmpty) {\n    // Add to topological order\n    const u = queue.dequeue()!;\n    topOrder.push(u);\n\n    // Iterate through neighbours\n    for (const neighbour of u.out) {\n      const result = indegrees.subtract(neighbour.id, 1);\n      if (result === 0) {\n        queue.enqueue(graph.vertices.get(neighbour.id)!);\n      }\n    }\n  }\n\n  if (topOrder.length !== vertexCount) {\n    throw new Error(`Graph contains cycles`);\n  }\n  return graphFromVertices(topOrder);\n}\n\n/**\n * Create a graph from an iterable of vertices\n * @param vertices \n * @returns \n */\nexport function graphFromVertices(vertices: Iterable<Vertex>): DirectedGraph {\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const keyValues = Sync.map(vertices, f => {\n    return [ f.id, f ] as [ string, Vertex ]\n  });\n  const m = immutableMap<string, Vertex>([ ...keyValues ]);\n  return {\n    vertices: m\n  }\n}\n\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph \n * @returns \n */\nexport function getCycles(graph: DirectedGraph): Array<Array<Vertex>> {\n  let index = 0;\n  const stack = new StackMutable<TarjanVertex>();\n  const vertices = new Map<string, TarjanVertex>();\n  const scc: Array<Array<Vertex>> = [];\n\n  for (const v of graph.vertices.values()) {\n    vertices.set(v.id, {\n      ...v,\n      lowlink: Number.NaN,\n      index: Number.NaN,\n      onStack: false\n    });\n  }\n\n  const strongConnect = (vertex: TarjanVertex) => {\n    vertex.index = index;\n    vertex.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertex.onStack = true;\n\n    for (const edge of vertex.out) {\n      const edgeV = vertices.get(edge.id)!;\n      if (Number.isNaN(edgeV.index)) {\n        strongConnect(edgeV);\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      } else if (edgeV.onStack) {\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      }\n    }\n\n    if (vertex.lowlink === vertex.index) {\n      const stronglyConnected: Array<Vertex> = [];\n      let w: TarjanVertex | undefined;\n      while (vertex !== w) {\n        w = stack.pop()!;\n        w.onStack = false;\n        stronglyConnected.push({ id: w.id, out: w.out });\n\n      }\n      if (stronglyConnected.length > 1)\n        scc.push(stronglyConnected);\n    }\n  }\n\n  for (const v of vertices.values()) {\n    if (Number.isNaN(v.index)) {\n      strongConnect(v);\n    }\n  }\n  return scc;\n}\n\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph \n * @returns \n */\nexport function transitiveReduction(graph: DirectedGraph) {\n  for (const u of vertices(graph)) {\n    for (const v of adjacentVertices(graph, u)) {\n      for (const v1 of dfs(graph, v)) {\n        if (v.id === v1.id) continue;\n        if (hasOut(graph, u, v1)) {\n          const g = disconnect(graph, u, v1);\n          return transitiveReduction(g);\n        }\n      }\n    }\n  }\n  return graph;\n}","\nexport class Table<V> {\n  rows: Array<Array<V | undefined>> = [];\n  rowLabels: Array<string> = [];\n  colLabels: Array<string> = [];\n\n  labelColumns(...labels: Array<string>) {\n    this.colLabels = labels;\n  }\n\n  labelColumn(columnNumber: number, label: string) {\n    this.colLabels[ columnNumber ] = label;\n  }\n\n  getColumnLabelIndex(label: string): number | undefined {\n    for (const [ index, l ] of this.colLabels.entries()) {\n      if (l === label) return index;\n    }\n  }\n\n  print() {\n    console.table([ ...this.rowsWithLabelsObject() ]);\n  }\n\n  *rowsWithLabelsArray() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsArray(index);\n      yield labelledRow;\n    }\n  }\n\n  /**\n   * Return a copy of table as nested array\n   * ```js\n   * const t = new Table();\n   * // add stuff\n   * // ...\n   * const m = t.asArray();\n   * for (const row of m) {\n   *  for (const colValue of row) {\n   *    // iterate over all column values for this row\n   *  }\n   * }\n   * ```\n   * \n   * Alternative: get value at row Y and column X\n   * ```js\n   * const value = m[y][x];\n   * ```\n   * @returns \n   */\n  asArray(): Array<Array<V | undefined>> {\n    const r: Array<Array<V | undefined>> = [];\n    for (const row of this.rows) {\n      if (row === undefined) r.push([]);\n      else r.push([ ...row ]);\n    }\n    return r;\n  }\n\n  /**\n   * Return the number of rows\n   */\n  get rowCount() {\n    return this.rows.length;\n  }\n\n  /**\n   * Return the maximum number of columns in any row\n   */\n  get columnCount() {\n    const lengths = this.rows.map(row => row.length);\n    return Math.max(...lengths);\n  }\n\n  *rowsWithLabelsObject() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsObject(index);\n      yield labelledRow;\n    }\n  }\n\n  labelRows(...labels: Array<string>) {\n    this.rowLabels = labels;\n  }\n\n  appendRow(...data: Array<V | undefined>) {\n    this.rows.push(data);\n  }\n\n  getRowWithLabelsArray(rowNumber: number): Array<[ label: string | undefined, value: V | undefined ]> | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    return row.map((value, index) => [ this.colLabels.at(index), value ]);\n  }\n\n  /**\n   * Return a row of objects. Keys use the column labels.\n   * \n   * ```js\n   * const row = table.getRowWithLabelsObject(10);\n   * // eg:\n   * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n   * ```\n   * @param rowNumber \n   * @returns \n   */\n  getRowWithLabelsObject(rowNumber: number): object | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    const object = {};\n    for (let index = 0; index < this.colLabels.length; index++) {\n      const label = this.colLabels.at(index) ?? index.toString();\n      // @ts-expect-error\n      object[ label ] = row[ index ];\n    }\n    return object;\n  }\n\n  /**\n   * Gets or creates a row at `rowNumber`.\n   * @param rowNumber \n   * @returns \n   */\n  private getOrCreateRow(rowNumber: number): Array<V | undefined> {\n    let row = this.rows.at(rowNumber);\n    if (row === undefined) {\n      row = [];\n      this.rows[ rowNumber ] = row;\n    }\n    return row;\n  }\n\n  /**\n   * Gets the values at `rowNumber`\n   * @param rowNumber \n   * @returns \n   */\n  row(rowNumber: number): Array<V | undefined> | undefined {\n    return this.rows.at(rowNumber);\n  }\n\n  /**\n   * Set the value of row,column to `value`\n   * @param rowNumber \n   * @param columnNumber \n   * @param value \n   */\n  set(rowNumber: number, columnNumber: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    row[ columnNumber ] = value;\n  }\n\n  get(rowNumber: number, column: number | string) {\n    const row = this.getOrCreateRow(rowNumber);\n    const index = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n    if (index === undefined) throw new Error(`Column not found: ${ column }`);\n    return row[ index ];\n  }\n\n  /**\n   * For a given row number, set all the columns to `value`.\n   * `cols` gives the number of columns to set\n   * @param rowNumber \n   * @param cols \n   * @param value \n   */\n  setRow(rowNumber: number, cols: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    for (let columnNumber = 0; columnNumber < cols; columnNumber++) {\n      row[ columnNumber ] = value;\n    }\n  }\n}","import * as DiGraph from \"../data/graphs/DirectedGraph.js\";\nimport { initStream } from \"./InitStream.js\";\nimport type { Reactive } from \"./Types.js\";\ntype RxNodeBase = {\n  type: `primitive` | `rx` | `object`\n}\n\ntype RxNodeRx = RxNodeBase & {\n  type: `rx`,\n  value: Reactive<any>\n}\n\ntype RxNodePrimitive = RxNodeBase & {\n  type: `primitive`,\n  value: any\n}\n\ntype RxNode = RxNodeRx | RxNodePrimitive;\n\nfunction isReactive(o: object): o is Reactive<any> {\n  if (typeof o !== `object`) return false;\n  if (`on` in o) {\n    return (typeof o.on === `function`);\n  }\n  return false;\n}\n\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param _rx \n */\nexport function prepare<V extends Record<string, any>>(_rx: V): Reactive<V> {\n  let g = DiGraph.graph();\n  const nodes = new Map<string, RxNode>();\n  const events = initStream<V>();\n\n  const process = (o: object, path: string) => {\n    for (const [ key, value ] of Object.entries(o)) {\n      const subPath = path + `.` + key;\n      g = DiGraph.connect(g, {\n        from: path,\n        to: subPath\n      });\n      if (isReactive(value)) {\n        nodes.set(subPath, { value, type: `rx` });\n        value.on(v => {\n          console.log(`Reactive.prepare value: ${ JSON.stringify(v) } path: ${ subPath }`);\n        });\n      } else {\n        const valueType = typeof value;\n        // eslint-disable-next-line unicorn/prefer-switch\n        if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n          nodes.set(subPath, { type: `primitive`, value });\n        } else if (valueType === `object`) {\n          process(value, subPath)\n        } else if (valueType === `function`) {\n          console.log(`Reactive.process - not handling functions`);\n        }\n      }\n    }\n  }\n\n  // const produce = () => {\n  //   Object.fromEntries(entries);\n  // }\n\n  // process(rx, `_root`);\n  // console.log(DiGraph.dumpGraph(g));\n\n  // console.log(`--- Map ---`);\n\n  // for (const entries of nodes.entries()) {\n  //   console.log(entries[ 0 ]);\n  //   console.log(entries[ 1 ]);\n  //   console.log(``)\n  // }\n\n\n  const returnValue = {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dispose: events.dispose,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    isDisposed: events.isDisposed,\n    graph: g,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: events.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    onValue: events.onValue\n  }\n  return returnValue;\n}\n\n","import type { Primitive } from '../PrimitiveTypes.js';\nimport type { Interval } from '../flow/IntervalType.js';\nimport * as Immutable from '../data/Pathed.js';\nimport type { BatchOptions, DebounceOptions, FieldOptions, FilterPredicate, SplitOptions, SyncOptions, SwitcherOptions, TransformOpts, ThrottleOptions, OpMathOptions } from './ops/Types.js';\nimport type { TimeoutTriggerOptions } from './sources/Types.js';\nimport type { SetHtmlOptions } from './sinks/Dom.js';\nimport type { Processors } from '../data/Process.js';\nimport type { TallyOptions } from './ops/Math.js';\nimport type { ChangeRecord } from '../data/Compare.js';\n\n\nexport type CombineLatestOptions = {\n  /**\n   * If _true_, disposes all the merged sources when the merged reactive closes.\n   * Default: _true_.\n   */\n  disposeSources: boolean\n  /**\n   * How to handle when a source ends.\n   * * 'allow': continue combined stream, last value for done stream will kept\n   * * 'break': stop combined stream\n   * \n   * Default: 'break'\n   */\n  onSourceDone: `allow` | `break`\n}\n\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\nexport const symbol = Symbol(`Rx`);\n\nexport type SignalKinds = `done` | `warn`;\nexport type Passed<V> = {\n  value: V | undefined\n  signal?: SignalKinds\n  context?: string\n}\n\nexport type PassedSignal = Passed<any> & {\n  value: undefined\n  signal: SignalKinds\n  context: string\n}\n\nexport type PassedValue<V> = Passed<V> & {\n  value: V\n}\n\nexport type UpstreamOptions<In> = {\n  lazy: Lazy\n  /**\n   * If _true_ (default), we dispose the underlying stream if the upstream closes. This happens after onStop() is called.\n   */\n  disposeIfSourceDone: boolean\n  onValue: (v: In) => void\n  /**\n   * Called just before we subscribe to source\n   * @returns \n   */\n  onStart: () => void\n  /**\n   * Called after we unsubscribe from source\n   * @returns\n   */\n  onStop: () => void\n\n  onDispose: (reason: string) => void\n}\n\n\n//export type Processor = <TIn, TOptions>(source: ReactiveOrSource<TIn>) => (options: TOptions) => () => void;\n\n/**\n * Wrapped Reactive for object-oriented access\n */\nexport type Wrapped<TIn> = {\n  enacts: {\n    setHtmlText: (options: SetHtmlOptions) => () => void\n  }\n  source: Reactive<TIn>,\n\n  /**\n   * Annotate values with output from the `annotation` function.\n   * Returned values will be in the form `{ value:TIn, annotation:TAnnotation }`\n   * @param transformer \n   * @returns \n   */\n  annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation) => Wrapped<{ value: TIn, annotation: TAnnotation }>\n  /**\n  * Accumulate a batch of values, emitted as an array\n  * @param options \n  * @returns \n  */\n  batch: (options: Partial<BatchOptions>) => Wrapped<Array<TIn>>\n\n  debounce: (options: Partial<DebounceOptions>) => Wrapped<TIn>\n\n\n  /**\n   * Pluck and emit a single field from values\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>>) => Wrapped<TFieldType>\n  /**\n   * Throws away values that don't match `predicate`\n   * @param predicate \n   * @param options \n   * @returns \n   */\n  filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => Wrapped<TIn>\n\n  combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(sources: T, options: Partial<CombineLatestOptions>) => Wrapped<RxValueTypes<T>>\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name: string } & Partial<CombineLatestOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  min: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  max: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  average: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  sum: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  tally: (options?: Partial<TallyOptions>) => Wrapped<number>\n\n  /**\n   * Converts one source stream into two, with values being emitted by both\n   * @param options \n   * @returns \n   */\n  split: (options?: Partial<SplitOptions>) => Array<Wrapped<TIn>>\n  /**\n * Emits values when this stream and any additional streams produce a value. The resulting stream is\n * thus an array of values, each source at a given index.\n * Waits to output a value until each stream has produced a value. Thus, the pace is determined by\n * the slowest stream.\n * @returns \n */\n  syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options?: Partial<SyncOptions>) => Wrapped<[ TIn, ...RxValueTypes<T> ]>\n\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options?: { name?: string } & Partial<SyncOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  /**\n   * Creates new streams for each case, sending values to the stream if they match the filter predicate\n   * @param cases \n   * @param options \n   * @returns \n   */\n  switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions>) => Record<TLabel, Wrapped<TIn>>\n  /**\n   * Creates new streams for each case\n   * @param labels \n   * @returns \n   */\n  splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => Record<K, Wrapped<TIn>>\n  /**\n   * Taps the stream, passing values to one or more 'processor' functions.\n   * This processing essentially happens in parallel, not affecting the main stream.\n   * \n   * ```js\n   * // Stream of pointermove events with {x:0,y:0} as default\n   * const move = Rx.From.event(document.body, `pointermove`, {x:0,y:0});\n   * // Wrap it for fluent access\n   * const ptr = Rx.wrap(move)\n   *  .tapProcess(\n   *    // Create a string representation\n   *    v => `${v.x},${v.y}`\n   *    // Set to DOM\n   *    v => {\n   *      document.getElementById(`coords`).innerText = v;\n   *    }\n   *   )\n   *  .onValue(value => {\n   *    // 'value' will be original PointerEvent, since .tapProcess happened in parallel,\n   *    // not affecting stream\n   *  });\n   * ```\n   * @param processors One-five processing functions\n   * @returns \n   */\n  tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => Wrapped<TIn>\n  tapStream: (divergedStream: ReactiveWritable<TIn>) => Wrapped<TIn>\n  tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>) => Wrapped<TIn>\n  /**\n   * Transforms all values\n   * @param transformer \n   * @param options \n   * @returns \n   */\n  transform: <TOut>(transformer: (value: TIn) => TOut, options?: Partial<TransformOpts>) => Wrapped<TOut>\n  /**\n   * Only allow values through if a minimum of time has elapsed. Throws away values.\n   * Ie. converts a fast stream into a slower one.\n   * @param options \n   * @returns \n   */\n  throttle: (options: Partial<ThrottleOptions>) => Wrapped<TIn>\n  timeoutTrigger: <TTriggerValue>(options: TimeoutTriggerOptions<TTriggerValue>) => Wrapped<TIn | TTriggerValue>\n  /**\n   * Copies values from source into an array, throwing\n   * an error if expected number of items is not reached\n   * @param options \n   * @returns \n   */\n  toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn>>\n  /**\n   * Copies values from source into an array.\n   * @param options \n   * @returns \n   */\n  toArray: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn | undefined>>\n  /**\n   * Listen for values\n   * @param callback \n   * @returns \n   */\n  onValue: (callback: (value: TIn) => void) => void\n\n}\n\nexport type ToArrayOptions<V> = {\n  /**\n   * Maximim time to wait for `limit` to be reached. 10s by default.\n   */\n  maximumWait: Interval\n  /**\n   * Number of items to read\n   */\n  limit: number\n  /**\n   * Behaviour if threshold is not reached.\n   * partial: return partial results\n   * throw: throw an error\n   * fill: fill remaining array slots with `fillValue`\n   */\n  underThreshold: `partial` | `throw` | `fill`\n  /**\n   * Value to fill empty slots with if `underThreshold = 'fill'`.\n   */\n  fillValue: V\n}\n\n/**\n * Laziness\n * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n * * very: only begins on first subscriber. Stops looping if there are no subscribers\n * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n */\nexport type Lazy = `initial` | `never` | `very`\nexport type InitLazyStreamOptions = Partial<InitStreamOptions> & {\n  lazy: Lazy\n  onStart: () => void\n  onStop: () => void\n};\n\nexport type InitLazyStreamInitedOptions<T> = InitLazyStreamOptions & {\n  initialValue: T\n}\n\nexport type CountOptions = { lazy: Lazy, amount: number, offset: number, interval: Interval, signal: AbortSignal }\n\n\nexport type ReactiveOrSource<V> = Wrapped<V> | Reactive<V> | IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V> | Array<V> | (() => V)\n\nexport type BindUpdateOpts<V> = {\n  initial: (v: V, el: HTMLElement) => void,\n  binds: Record<string, DomBindValueTarget & {\n    transform?: (value: any) => string\n  }>\n}\n\nexport type Reactive<V> = {\n  /**\n   * Subscribes to a reactive. Receives\n   * data as well as signals. Use `value` if you\n   * just care about values.\n   * \n   * Return result unsubscribes.\n   * \n   * ```js\n   * const unsub = someReactive.on(msg => {\n   *    // Do something with msg.value\n   * });\n   * \n   * unsub(); // Unsubscribe\n   * ```\n   * @param handler \n   */\n  on(handler: (value: Passed<V>) => void): Unsubscriber\n  onValue(handler: (value: V) => void): Unsubscriber\n\n  dispose(reason: string): void\n  isDisposed(): boolean\n  set?(value: V): void\n\n}\n\nexport type Unsubscriber = () => void;\n\nexport type ReactiveNonInitial<V> = Reactive<V> & {\n  last(): V | undefined\n}\n\nexport type ReactiveWritable<V> = Reactive<V> & {\n  set(value: V): void\n}\n\nexport type ReactiveInitial<V> = Reactive<V> & {\n  last(): V\n}\n\nexport type ReactiveFinite = {\n  isDone(): boolean\n}\n\nexport type ReactiveArray<V> = ReactiveWritable<Array<V>> & {\n  push(value: V): void\n  deleteAt(index: number): void\n  deleteWhere(filter: (value: V) => boolean): number\n  setAt(index: number, value: V): void\n  insertAt(index: number, value: V): void\n  onArray(handler: (changes: Passed<Array<ChangeRecord<number>>>) => void): () => void\n}\n\nexport type ReactiveDiff<V> = Reactive<V> & ReactiveWritable<V> & {\n  /**\n   * Notifies when the value of `fieldName` is changed.\n   * \n   * Use the returned function to unsubscribe.\n   * @param fieldName \n   * @param handler \n   */\n  onField(fieldName: string, handler: (value: any, fieldName: string) => void): () => void\n  /**\n   * Notifies of which field(s) were changed.\n   * If you just care about the whole, changed data use the `value` event.\n   * \n   * Use the returned function to unsubscribe.\n   * @param handler \n   */\n  onDiff(changes: (changes: Array<Immutable.PathDataChange<any>>) => void): () => void\n  /**\n   * Updates the reactive with some partial key-value pairs.\n   * Keys omitted are left the same as the current value.\n   * @param changedPart \n   * @returns Returns new value\n   */\n  update(changedPart: Record<string, any>): V\n  /**\n   * Updates a particular field by its path\n   * @param field \n   * @param value \n   */\n  updateField(field: string, value: any): void\n}\n\nexport type ReactiveStream<V> = Reactive<V> & ReactiveWritable<V> & {\n  through(message: Passed<V>): void\n  /**\n   * Removes all the subscribers from this stream.\n   */\n  reset(): void\n  /**\n   * Dispatches a signal\n   * @param signal \n   * @param context \n   */\n  signal(signal: SignalKinds, context?: string): void\n}\n\nexport type DomBindValueTarget = {\n  /**\n   * If _true_ `innerHTML` is set (a shortcut for elField:`innerHTML`)\n   */\n  htmlContent?: boolean\n  /**\n   * If _true_, 'textContent' is set (a shortcut for elField:'textContext')\n   */\n  textContent?: boolean\n  /**\n   * If set, this DOM element field is set. Eg 'textContent'\n   */\n  elField?: string\n  /**\n   * If set, this DOM attribute is set, Eg 'width'\n   */\n  attribName?: string\n  /**\n   * If set, this CSS variable is set, Eg 'hue' (sets '--hue')\n   */\n  cssVariable?: string\n  /**\n   * If set, this CSS property is set, Eg 'background-color'\n   */\n  cssProperty?: string\n}\n\nexport type ElementBind = {\n  /**\n   * Tag name for this binding.\n   * Overrides `defaultTag`\n   */\n  tagName?: string\n  /**\n   * If _true_, sub-paths are appended to element, rather than `container`\n   */\n  nestChildren?: boolean\n  transform?: (value: any) => string\n}\nexport type ElementsOptions = {\n  container: HTMLElement | string\n  defaultTag: string,\n  binds: Record<string, DomBindValueTarget & ElementBind>\n}\n\nexport type DomBindTargetNode = {\n  query?: string\n  element?: HTMLElement\n}\n\nexport type DomBindTargetNodeResolved = {\n  element: HTMLElement\n}\n\nexport type DomBindUnresolvedSource<TSource, TDestination> = DomBindTargetNode & DomBindSourceValue<TSource, TDestination> & DomBindValueTarget;\nexport type DomBindResolvedSource<TSource, TDestination> = DomBindTargetNodeResolved & DomBindSourceValue<TSource, TDestination> & DomBindValueTarget;\n\nexport type DomBindSourceValue<TSource, TDestination> = {\n  twoway?: boolean\n  /**\n   * Field from source value to pluck and use.\n   * This will also be the value passed to the transform\n   */\n  sourceField?: keyof TSource\n  transform?: (input: TSource) => TDestination\n  transformValue?: (input: any) => TDestination\n}\n\nexport type DomBindInputOptions<TSource, TDestination> = DomBindSourceValue<TSource, TDestination> & {\n  transformFromInput: (input: TDestination) => TSource\n}\n\n// export type PipeSet<In, Out> = [\n//   Reactive<In>,\n//   ...Array<Reactive<any> & ReactiveWritable<any>>,\n//   ReactiveWritable<Out> & Reactive<any>\n// ]\nexport type PipeSet<In, Out> = [\n  Reactive<In>,\n  ...Array<Reactive<any> & ReactiveWritable<any>>\n]\n\nexport type InitStreamOptions = {\n  /**\n   * Optional label to associate with this stream. Useful for debugging.\n   */\n  debugLabel: string\n  onFirstSubscribe: () => void\n  onNoSubscribers: () => void\n  onDispose: (reason: string) => void\n}\n\n\n\nexport type DomCreateOptions = {\n  tagName: string\n  parentEl: string | HTMLElement\n}\n\nexport type PipeDomBinding = {\n  /**\n   * Remove binding and optionally delete element(s) (false by default)\n   */\n  remove(deleteElements: boolean): void\n}\n\n\n/**\n * WithValue stream options\n */\nexport type WithValueOptions<V> = Partial<InitStreamOptions> & {\n  /**\n   * Initial value\n   */\n  initial: V,\n  /**\n   * Laziness\n   */\n  lazy?: Lazy\n}\n\n\n\n\nexport type ResolveOptions = {\n  /**\n   * How many times to return value or call function.\n   * If _infinite_ is set to true, this value is ignored\n   */\n  loops: number\n  /**\n   * If _true_ loops forever\n   */\n  infinite: boolean\n  /**\n   * Delay before value\n   */\n  interval: Interval\n\n  lazy: Lazy\n}\n\nexport type ReactiveOpInit<TIn, TOut, TOpts> = (options: Partial<TOpts>) => ReactiveOp<TIn, TOut>\nexport type ReactiveOp<TIn, TOut> = (source: ReactiveOrSource<TIn>) => Reactive<TOut>\n\nexport type ReactiveOpLinks<In, Out> = [\n  ReactiveOrSource<In>,\n  ...Array<ReactiveOp<any, any>>,\n  ReactiveOp<any, Out>\n]\n\nexport type RxValueTypes<T extends ReadonlyArray<ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    never };\n\nexport type RxValueTypeObject<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V :\n    T[ K ] extends Wrapped<infer V> ? V :\n    T[ K ] extends Generator<infer V> ? V :\n    T[ K ] extends AsyncGenerator<infer V> ? V :\n    T[ K ] extends IterableIterator<infer V> ? V :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V :\n    T[ K ] extends Array<infer V> ? V :\n    never };\n\nexport type RxValueTypeObjectOrUndefined<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    never };\n\nexport type RxValueTypeRx<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? Reactive<V> :\n    T[ K ] extends Wrapped<infer V> ? Reactive<V> :\n    T[ K ] extends Generator<infer V> ? Reactive<V> :\n    T[ K ] extends AsyncGenerator<infer V> ? Reactive<V> :\n    T[ K ] extends IterableIterator<infer V> ? Reactive<V> :\n    T[ K ] extends AsyncIterableIterator<infer V> ? Reactive<V> :\n    T[ K ] extends Array<infer V> ? Reactive<V> :\n    never };\n\nexport type PrimitiveValueTypeObject<T extends Record<string, Primitive>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number | undefined :\n    T[ K ] extends string ? string | undefined :\n    T[ K ] extends boolean ? boolean | undefined :\n    T[ K ] extends bigint ? bigint | undefined :\n    never };\n\n\n","import { intervalToMs } from \"../flow/IntervalType.js\";\nimport type { ReactiveOrSource, ToArrayOptions } from \"./Types.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./Util.js\";\n\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n * \n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n * \n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n * \n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArray<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V | undefined>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = intervalToMs(options.maximumWait, 10 * 1000);\n  const underThreshold = options.underThreshold ?? `partial`\n  const read: Array<V | undefined> = [];\n\n  const rx = resolveSource(source);\n\n  const promise = new Promise<Array<V | undefined>>((resolve, reject) => {\n    const done = () => {\n      clearTimeout(maxWait)\n      unsub();\n      if (read.length < limit && underThreshold === `throw`) {\n        reject(new Error(`Threshold not reached. Wanted: ${ limit } got: ${ read.length }. Maximum wait: ${ maximumWait }`));\n        return;\n      }\n      if (read.length < limit && underThreshold === `fill`) {\n        for (let index = 0; index < limit; index++) {\n          if (read[ index ] === undefined) {\n            //console.log(`Rx.toArray filling at index: ${ index }`);\n            read[ index ] = options.fillValue;\n          }\n        }\n      }\n      resolve(read);\n    }\n\n    const maxWait = setTimeout(() => {\n      done();\n    }, maximumWait);\n\n    const unsub = rx.on(message => {\n      //console.log(`Rx.toArray: ${ JSON.stringify(message) }`);\n      if (messageIsDoneSignal(message)) {\n        done();\n      } else if (messageHasValue(message)) {\n        read.push(message.value);\n        //console.log(`Rx.toArray read buffer: ${ JSON.stringify(read) }`);\n        if (read.length === limit) {\n          done();\n        }\n      }\n    });\n  });\n\n  return promise;\n}\n\n\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n * \n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArrayOrThrow<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = options.maximumWait ?? 5 * 1000;\n  const v = await toArray(source, { limit, maximumWait, underThreshold: `partial` });\n\n  // There was a limit, but it wasn't reached\n  if (options.limit && v.length < options.limit) throw new Error(`Threshold not reached. Wanted: ${ options.limit }, got ${ v.length }`);\n\n  // Otherwise, we may have been reading for a specified duration\n  return v as Array<V>;\n\n}","import { resolveSource } from \"./ResolveSource.js\";\nimport type { ReactiveOrSource } from \"./Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./Util.js\";\n\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n * \n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n * \n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ``` \n * \n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n * \n * // Execution continues here immediately\n * ```\n * @param source \n */\nexport async function* toGenerator<V>(source: ReactiveOrSource<V>): AsyncGenerator<V> {\n  const s = resolveSource(source);\n  let promiseResolve: ((value: V | PromiseLike<V>) => void) = (_) => {/** noop */ };\n  let promiseReject: ((reason: string) => void) = (_) => {/** no-op */ }\n\n  const promiseInit = () => (new Promise<V>((resolve, reject) => {\n    promiseResolve = resolve;\n    promiseReject = reject;\n  }));\n  let promise = promiseInit();\n  let keepRunning = true;\n\n  s.on(message => {\n    if (messageHasValue(message)) {\n      promiseResolve(message.value);\n      promise = promiseInit();\n    } else if (messageIsDoneSignal(message)) {\n      keepRunning = false;\n      promiseReject(`Source has completed`);\n    }\n  });\n\n  while (keepRunning) {\n    yield await promise;\n  }\n}\n","import { compareValuesShallow } from \"src/iterables/CompareValues.js\";\nimport type { RecursiveReplace, RemapObjectPropertyType } from \"../TsUtil.js\";\nimport { compareData } from \"./Compare.js\";\nimport * as Pathed from './Pathed.js';\n\n/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n * \n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const mapObjectShallow = <\n  TSource extends Record<string, any>,\n  TFieldValue,\n>(\n  // eslint-disable-next-line indent\n  object: TSource,\n  // eslint-disable-next-line indent\n  mapFunction: (args: MapObjectArgs) => TFieldValue\n  // eslint-disable-next-line indent\n): RemapObjectPropertyType<TSource, TFieldValue> => {\n  type MapResult = [ field: string, value: TFieldValue ];\n  const entries = Object.entries(object);\n  const mapped = entries.map(([ sourceField, sourceFieldValue ], index) => [\n    sourceField,\n    mapFunction({ value: sourceFieldValue, field: sourceField, index }),\n  ]) as Array<MapResult>;\n  // @ts-expect-error\n  return Object.fromEntries(mapped);\n};\n\nexport type MapObjectArgs = {\n  field: string\n  value: any\n  index: number\n}\n\n\n","import * as Ops from \"./ops/index.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport { toArray, toArrayOrThrow } from \"./ToArray.js\";\nimport type { ReactiveOrSource, Wrapped, ToArrayOptions, InitStreamOptions, Reactive, RxValueTypes, CombineLatestOptions, ReactiveOp, } from \"./Types.js\";\nimport type { BatchOptions, FieldOptions, FilterPredicate, DebounceOptions, SwitcherOptions, SplitOptions, ThrottleOptions, TransformOpts, SyncOptions, } from './ops/Types.js'\nimport type { TimeoutTriggerOptions } from './sources/Types.js'\nimport { messageHasValue } from \"./Util.js\";\nimport { mapObjectShallow } from '../data/MapObject.js';\nimport * as Enacts from './sinks/index.js';\nimport type { Processors } from \"../data/Process.js\";\n\n/**\n * Wrap a reactive source to allow for chained\n * function calls.\n * \n * Example:\n * For every `pointerup` event on the body, batch the events over\n * periods of 200ms, get the number of events in that period,\n * and print it out.\n * \n * eg. detecting single or double-clicks\n * ```js\n * wrap(Rx.fromEvent<{ x: number, y: number }>(document.body, `pointerup`))\n *  .batch({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .onValue(v => { console.log(v) });\n * ```\n * @param source \n * @returns \n */\nexport function wrap<TIn>(source: ReactiveOrSource<TIn>): Wrapped<TIn> {\n  return {\n    source: resolveSource(source),\n    enacts: {\n      setHtmlText: (options) => {\n        return Enacts.setHtmlText(source, options);\n      },\n    },\n    annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation): Wrapped<{ value: TIn, annotation: TAnnotation }> => {\n      const a = Ops.annotate<TIn, TAnnotation>(source, transformer);\n      return wrap(a);\n    },\n    batch: (options: Partial<BatchOptions>): Wrapped<Array<TIn>> => {\n      const w = wrap<Array<TIn>>(Ops.batch(source, options));\n      return w;\n    },\n    debounce: (options: Partial<DebounceOptions> = {}) => {\n      return wrap(Ops.debounce<TIn>(source, options));\n    },\n    field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>> = {}) => {\n      // Ops.field requires TIn extends object\n      // Would be good if `wrap` returns different versions depending on TIn, so .field\n      // would not be present at all if we had Reactive<number>, for example\n      // @ts-expect-error\n      const f = Ops.field<TIn, TFieldType>(source, fieldName, options);\n      return wrap<TFieldType>(f);\n    },\n    filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => {\n      return wrap(Ops.filter(source, predicate, options));\n    },\n    combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(sources: T, options: Partial<CombineLatestOptions> = {}) => {\n      const srcs = [ source, ...sources ] as any as T;\n      return wrap(Ops.combineLatestToArray(srcs, options));\n    },\n    combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<CombineLatestOptions>) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.combineLatestToObject(o, options));\n    },\n    min: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.min(source, options));\n    },\n    max: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.max(source, options));\n    },\n    average: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.average(source, options));\n    },\n    sum: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.sum(source, options));\n    },\n    tally: (options: Partial<Ops.TallyOptions> = {}) => {\n      return wrap(Ops.tally(source, options));\n    },\n    split: (options: Partial<SplitOptions> = {}) => {\n      const streams = Ops.split<TIn>(source, options).map(v => wrap(v));\n      return streams;\n    },\n    splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => {\n      const l = Ops.splitLabelled<TIn, keyof TIn>(source, labels);\n      const m = mapObjectShallow<typeof l, Wrapped<TIn>>(l, args => wrap(args.value as Reactive<TIn>)) as Record<K, Wrapped<TIn>>;\n      return m;\n    },\n    switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n      const s = Ops.switcher<TIn, TRec, TLabel>(source, cases, options);\n      const m = mapObjectShallow<typeof s, Wrapped<TIn>>(s, args => wrap(args.value as Reactive<TIn>));\n      return m as Record<TLabel, Wrapped<TIn>>;\n    },\n    syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(additionalSources: T, options: Partial<SyncOptions> = {}) => {\n      const unwrapped = [ source, ...additionalSources ].map(v => resolveSource(v));\n      const x = Ops.syncToArray(unwrapped, options) as Reactive<[ TIn, ...RxValueTypes<T> ]>;\n      return wrap(x); //synchronise<TIn>([ source, ...unwrapped ] as const));\n    },\n    syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<SyncOptions> = {}) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.syncToObject(o, options));\n    },\n    tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => {\n      Ops.tapProcess(source, ...processors)\n      return wrap(source);\n    },\n    tapStream: (divergedStream) => {\n      Ops.tapStream(source, divergedStream);\n      return wrap(source);\n    },\n    tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>) => {\n      Ops.tapOps(source, ...ops);\n      return wrap(source);\n    },\n    throttle: (options: Partial<ThrottleOptions> = {}) => {\n      return wrap(Ops.throttle<TIn>(source, options));\n    },\n    transform: <TOut>(transformer: (value: TIn) => TOut, options: Partial<TransformOpts> = {}) => {\n      return wrap(Ops.transform(source, transformer, options));\n    },\n    timeoutTrigger: <TTrigger>(options: TimeoutTriggerOptions<TTrigger>) => {\n      return wrap(Ops.timeoutTrigger<TIn, TTrigger>(source, options));\n    },\n    toArray: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArray(source, options);\n    },\n    toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArrayOrThrow(source, options);\n    },\n    onValue: (callback: ((value: TIn) => void)) => {\n      const s = resolveSource(source);\n      s.on(message => {\n        if (messageHasValue(message)) callback(message.value);\n      })\n    }\n  }\n}\n","import { intervalToMs } from \"../flow/IntervalType.js\";\nimport { continuously } from \"../flow/Continuously.js\";\nimport type { CountOptions } from \"./Types.js\";\nimport { initLazyStream } from \"./InitStream.js\";\n\n/**\n * Produces an incrementing value. By default starts at 0 and counts\n * forever, incrementing every second.\n * \n * ```js\n * const r = Rx.count();\n * r.onValue(c => {\n *  // 0, 1, 2, 3 ... every second\n * });\n * ```\n * \n * The `limit` is exclusive\n * ```js\n * const r = Rx.count({limit:5});\n * // Yields 0,1,2,3,4\n * ```\n * \n * If limit is less than start, it will count down instead.\n * ```js\n * const r = Rx.count({start:5, limit: 0});\n * // Yie:ds 5,4,3,2,1\n * ```\n * \n * ```js\n * // Count 10, 12, 14 ... every 500ms\n * const r = Rx.count({ start: 10, amount: 2, interval: 500 });\n * ```\n * \n * In addition to setting `limit` (which is exclusive), you can stop with an abort signal\n * ```js\n * const ac = new AbortController();\n * const r = Rx.count({signal:ac.signal});\n * ...\n * ac.abort(`stop`);\n * ```\n * @param options \n */\nexport function count(options: Partial<CountOptions> = {}) {\n\n  const lazy = options.lazy ?? `initial`;\n  const interval = intervalToMs(options.interval, 1000);\n  const amount = options.amount ?? 1;\n  const offset = options.offset ?? 0;\n\n  let produced = 0;\n  let value = offset;\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n  }\n\n  const timer = continuously(() => {\n    if (options.signal?.aborted) {\n      done(`Aborted (${ options.signal.reason })`);\n      return false;\n    }\n    events.set(value);\n    value += 1;\n    produced++;\n    if (produced >= amount) {\n      done(`Limit reached`);\n      return false;\n    }\n  }, interval);\n\n  const events = initLazyStream<number>({\n    onStart() {\n      timer.start();\n    },\n    onStop() {\n      timer.cancel();\n    },\n    onDispose() {\n      timer.cancel();\n    },\n    lazy\n  });\n  return events;\n}\n","import * as Immutable from \"../data/Pathed.js\";\nimport { resolveEl } from \"../dom/ResolveEl.js\";\nimport * as Rx from \"./index.js\";\nimport type { ElementsOptions, PipeDomBinding, BindUpdateOpts, DomBindResolvedSource, DomBindSourceValue, DomBindValueTarget, ElementBind } from './Types.js';\nimport { hasLast, messageHasValue, messageIsSignal } from \"./Util.js\";\nimport { getFromKeys } from \"../collections/map/MapFns.js\";\nimport { afterMatch, beforeMatch } from \"../Text.js\";\nimport { stringSegmentsWholeToEnd, stringSegmentsWholeToFirst } from \"../text/Segments.js\";\nimport { QueueMutable } from \"../collections/index.js\";\nimport { object } from \"./sources/Object.js\";\n\n/**\n * Reactive stream of array of elements that match `query`.\n * @param query \n * @returns \n */\nexport function fromDomQuery(query: string) {\n  const elements = [ ...document.querySelectorAll(query) ] as Array<HTMLElement>;\n\n  return object(elements);\n  /// TODO: MutationObserver to update element list\n}\n\n/**\n * Updates an element's `textContent` when the source value changes.\n * ```js\n * bindText(source, `#blah`);\n * ```\n * \n * Uses {@link bindElement}, with `{elField:'textContent'}` as the options\n * @param elOrQuery \n * @param source \n * @param bindOpts \n */\nexport const bindText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: Partial<Rx.DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `textContent` });\n}\n\n/**\n * Updates an element's `value` (as well as the 'value' attribute) when the source value changes.\n * Use {@link bindValueRange} when setting numeric values\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\nexport const bindValueText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `value`, attribName: `value` });\n}\n\n/**\n * Updates an element's `valueAsNumber` (as well as the 'value' attribute) when the source value changes.\n * ```js\n * // Create a reactive number, with a default value of 10\n * const r1 = Rx.From.number(10);\n * // Bind reactive to HTML input element with id 'inputRange'\n * const b1 = Rx.Dom.bindValueRange(r1,`#inputRange`);\n *\n * // Demo: Change the reactive value every second\n * // ...changing the reactive in turn updates the HTML\n * setInterval(() => {\n *  r1.set(Math.floor(Math.random()*100));\n * }, 1000);\n * ```\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\n// export const bindValueRange = (source: Rx.Reactive<number>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<number, number>> = {}) => {\n//   const el = validateElement(elOrQuery, `range`);\n//   const b = bindElement<number, number>(source, el, { ...bindOpts, elField: `valueAsNumber`, attribName: `value` });\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     if (typeof value === `number`) return value;\n//     return Number.parseFloat(value);\n//   });\n//   const input = Rx.From.domValueAsNumber(el);\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\n// export const bindValueColour = (source: Rx.Reactive<Colour.Colourish>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<Colour.Colourish, string>> = {}) => {\n//   const el = validateElement(elOrQuery, `color`);\n//   const b = bindElement<Colour.Colourish, string>(source, el, {\n//     ...bindOpts,\n//     elField: `value`,\n//     attribName: `value`,\n//     transform(input) {\n//       console.log(`transform from: ${ JSON.stringify(input) } to hex`);\n//       const c = Colour.resolve(input);\n//       return c.to(`srgb`).toString({ format: `hex`, collapse: false });\n//     },\n//   });\n\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     const x = Colour.toHsl(value);\n//     console.log(`transformFromInput: ${ value } x: ${ JSON.stringify(x) }`);\n//     return x;\n//   });\n\n//   const input = Rx.From.domValue<Colour.Hsl>(el, {\n//     domToValue: transformFromInput\n//   });\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\nconst setupInput = <TSource, TDestination>(b: PipeDomBinding, input: Rx.Reactive<TDestination>, source: Rx.Reactive<TSource>, twoway: boolean, transformFromInput: (value: TDestination) => TSource) => {\n  input.onValue(value => {\n    const v = transformFromInput(value);\n    if (twoway && Rx.isWritable(source)) {\n      source.set(v);\n    }\n  });\n  const dispose = () => {\n    input.dispose(`bindInput twoway dispose`);\n    b.remove(false);\n  }\n  return { ...b, dispose, input };\n}\n\nconst validateElement = (elOrQuery: string | HTMLInputElement | null, type?: string): HTMLInputElement => {\n  const el = resolveEl(elOrQuery);\n  if (el.nodeName !== `INPUT`) throw new Error(`HTML INPUT element expected. Got: ${ el.nodeName }`);\n  if (type !== undefined && el.type !== type) throw new Error(`HTML INPUT element expected with type 'range'. Got: ${ el.type }`);\n  return el;\n}\n\n\n/**\n * Updates an element's `innerHTML` when the source value changes\n * ```js\n * bindHtml(source, `#blah`);\n * ```\n * \n * Uses {@link bindElement}, with `{elField:'innerHTML'}` as the options.\n * @param elOrQuery\n * @param source \n * @param bindOpts \n * @returns \n */\nexport const bindHtml = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: DomBindSourceValue<TSource, string> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `innerHTML` });\n}\n\n\n/**\n * Shortcut to bind to an elements attribute\n * @param elOrQuery\n * @param source \n * @param attribute \n * @param bindOpts \n * @returns \n */\n// export const bindAttribute = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, attribute: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, attribName: attribute });\n// }\n\n/**\n * Shortcut to bind to a CSS variable\n * @param elOrQuery\n * @param source \n * @param cssVariable \n * @param bindOpts \n * @returns \n */\n// export const bindCssVariable = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, cssVariable: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, cssVariable: cssVariable });\n// }\n\n/**\n * Creates a new HTML element, calling {@link bind} on it to update when `source` emits new values.\n * \n * \n * ```js\n * // Set textContent of a SPAN with values from `source`\n * create(source, { tagName: `span`, parentEl: document.body })\n * ```\n * \n * If `parentEl` is not given in the options, the created element needs to be manually added\n * ```js\n * const b = create(source);\n * someEl.append(b.el); // Append manually\n * ```\n * \n * ```\n * // Set 'title' attribute based on values from `source`\n * create(source, { parentEl: document.body, attribName: `title` })\n * ```\n * @param source \n * @param options \n * @returns \n */\n// export const create = <V>(source: Rx.Reactive<V>, options: Partial<DomCreateOptions> & Partial<DomBindOptions<V>> = {}): PipeDomBinding => {\n//   const nodeType = options.tagName ?? `DIV`;\n\n//   const el = document.createElement(nodeType);\n//   const b = bind(el, source, options);\n\n//   if (options.parentEl) {\n//     const parentElementOrQuery = resolveEl(options.parentEl);\n//     if (parentElementOrQuery === undefined) throw new Error(`Parent element could not be resolved`);\n//     parentElementOrQuery.append(el);\n//   }\n//   return b;\n// }\n\n/**\n * Update a DOM element's field, attribute or CSS variable when `source` produces a value.\n * \n * ```js\n * // Access via DOM query. Binds to 'textContent' by default\n * bind(readableSource, `#someEl`);\n * \n * // Set innerHTML instead\n * bind(readableSource, someEl, { elField: `innerHTML` });\n * \n * // An attribute\n * bind(readableSource, someEl, { attribName: `width` });\n * \n * // A css variable ('--' optiona)\n * bind(readableSource, someEl, { cssVariable: `hue` });\n * \n * // Pluck a particular field from source data.\n * // Ie someEl.textContent = value.colour\n * bind(readableSource, someEl, { sourceField: `colour` });\n * \n * // Transform value before setting it to field\n * bind(readableSource, someEl, { \n *  field: `innerHTML`, \n *  transform: (v) => `Colour: ${v.colour}`\n * })\n * ```\n * \n * If `source` has an initial value, this is used when first bound.\n * \n * Returns {@link PipeDomBinding} to control binding:\n * ```js\n * const bind = bind(source, `#someEl`);\n * bind.remove();     // Unbind\n * bind.remove(true); // Unbind and remove HTML element\n * ```\n * \n * If several fields need to be updated based on a new value, consider using {@link bindUpdate} instead.\n * @param elOrQuery \n * @param source \n * @param bindOpts \n */\nexport const bindElement = <TSource, TDestination>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, ...binds: Array<DomBindSourceValue<TSource, TDestination> & Rx.DomBindValueTarget>): PipeDomBinding => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  let b = [];\n  if (binds.length === 0) {\n    b.push({ elField: `textContent` });\n  } else {\n    b = [ ...binds ];\n  }\n  const bb = b.map(bind => {\n    if (`element` in bind) return bind as DomBindResolvedSource<TSource, TDestination>;\n    return { ...bind, element: el } as DomBindResolvedSource<TSource, TDestination>\n  });\n  return bind<TSource, TDestination>(source, ...bb);\n}\n\nconst resolveBindUpdater = (bind: DomBindValueTarget, element: HTMLElement): (value: any) => void => {\n  const b = resolveBindUpdaterBase(bind);\n  return (value: any) => {\n    b(value, element);\n  }\n}\n\nconst resolveBindUpdaterBase = (bind: DomBindValueTarget): (value: any, element: HTMLElement) => void => {\n  if (bind.elField !== undefined || (bind.cssVariable === undefined && bind.attribName === undefined && bind.cssProperty === undefined && bind.textContent === undefined && bind.htmlContent === undefined)) {\n    const field = bind.elField ?? `textContent`;\n    return (v: any, element: HTMLElement) => {\n      (element as any)[ field ] = v;\n    }\n  }\n  if (bind.attribName !== undefined) {\n    const attrib = bind.attribName;\n    return (v: any, element: HTMLElement) => {\n      element.setAttribute(attrib, v);\n    }\n  }\n  if (bind.textContent) {\n    return (v: any, element: HTMLElement) => {\n      element.textContent = v;\n    }\n  }\n  if (bind.htmlContent) {\n    return (v: any, element: HTMLElement) => {\n      element.innerHTML = v;\n    }\n  }\n  if (bind.cssVariable !== undefined) {\n    let css = bind.cssVariable;\n    if (!css.startsWith(`--`)) css = `--` + css;\n    return (v: any, element: HTMLElement) => {\n      element.style.setProperty(css, v);\n    }\n  }\n  if (bind.cssProperty !== undefined) {\n    return (v: any, element: HTMLElement) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      (element.style as any)[ bind.cssProperty! ] = v;\n    }\n  }\n  return (_: any, _element: HTMLElement) => {\n    /** no-op */\n  }\n}\n\nconst resolveTransform = <TSource, TDestination>(bind: DomBindSourceValue<TSource, TDestination>) => {\n  if (!bind.transform && !bind.transformValue) return;\n  if (bind.transformValue) {\n    if (bind.sourceField === undefined) throw new Error(`Expects 'sourceField' to be set when 'transformValue' is set`);\n    return (value: TSource) => {\n      const fieldValue = (value as any)[ bind.sourceField ]\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return bind.transformValue!(fieldValue);\n    }\n  } else if (bind.transform) {\n    if (bind.sourceField !== undefined) throw new Error(`If 'transform' is set, 'sourceField' is ignored`);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return (value: TSource) => bind.transform!(value);\n  }\n}\n\n/**\n * Binds `source` to one or more element(s). One or more bindings for the same source\n * can be provided.\n * \n * ```js\n * bind(source, \n *  // Binds .name field of source values to textContent of #some-element\n *  { query: `#some-element`, sourceField: `name` },\n *  { query: `section`, }\n * );\n * ```\n * \n * Can update\n * * CSS variables\n * * CSS styles\n * * textContent / innerHTML\n * * HTML DOM attributes and object fields\n * \n * Can use a particular field on source values, or use the whole value. These can\n * pass through `transformValue` or `transform` respectively.\n * \n * Returns a function to unbind from source and optionally remove HTML element\n * ```js\n * const unbind = bind( . . . );\n * unbind();     // Unbind\n * unbind(true); // Unbind and remove HTML element(s)\n * ```\n * @param source \n * @param bindsUnresolvedElements \n * @returns \n */\nexport const bind = <TSource, TDestination>(source: Rx.Reactive<TSource>, ...bindsUnresolvedElements: Array<Rx.DomBindUnresolvedSource<TSource, TDestination>>): PipeDomBinding => {\n  const binds: Array<DomBindResolvedSource<TSource, TDestination>> = bindsUnresolvedElements.map(bind => {\n    if (bind.element && bind.element !== undefined) return bind as DomBindResolvedSource<TSource, TDestination>;\n    if (bind.query) return {\n      ...bind,\n      element: resolveEl<HTMLElement>(bind.query)\n    }\n    throw new Error(`Unable to resolve element. Missing 'element' or 'query' values on bind. ${ JSON.stringify(bind) }`);\n  });\n\n  const bindsResolved = binds.map(bind => ({\n    update: resolveBindUpdater(bind, bind.element),\n    transformer: resolveTransform(bind),\n    sourceField: bind.sourceField\n  }));\n\n  const update = (value: TSource) => {\n    for (const bind of bindsResolved) {\n      if (bind.transformer) {\n        bind.update(bind.transformer(value));\n      } else {\n        const v = (bind.sourceField) ? value[ bind.sourceField ] : value;\n\n        if (typeof v === `object`) {\n          if (bind.sourceField) {\n            bind.update(JSON.stringify(v));\n          } else {\n            bind.update(JSON.stringify(v));\n          }\n        } else bind.update(v as string);\n      }\n    }\n  }\n  const unsub = source.on(message => {\n    if (messageHasValue(message)) {\n      update(message.value);\n    } else if (messageIsSignal(message)) {\n      console.warn(message);\n    }\n  });\n\n  if (hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElements: boolean) => {\n      unsub();\n      if (removeElements) {\n        for (const bind of binds) {\n          bind.element.remove();\n        }\n      }\n    }\n  }\n}\n\n/**\n * Calls `updater` whenever `source` produces a value. Useful when several fields from a value\n * are needed to update an element.\n * ```js\n * bindUpdate(source, `#someEl`, (v, el) => {\n *  el.setAttribute(`width`, v.width);\n *  el.setAttribute(`height`, v.height);\n * });\n * ```\n * \n * Returns a {@link PipeDomBinding} to manage binding\n * ```js\n * const b = bindUpdate(...);\n * b.remove();     // Disconnect binding\n * b.remove(true); // Disconnect binding and remove element\n * b.el;           // HTML element\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @returns \n */\nexport const bindUpdate = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, updater: (v: V, el: HTMLElement) => void): PipeDomBinding => {\n  const el = resolveEl(elOrQuery);\n\n  const update = (value: V) => {\n    updater(value, el);\n  }\n\n  const unsub = source.on(message => {\n    if (messageHasValue(message)) {\n      console.log(message);\n      update(message.value);\n    } else {\n      console.warn(message);\n    }\n  });\n\n  if (hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Updates a HTML element based on diffs on an object.\n * ```js\n * // Wrap an object\n * const o = Rx.object({ name: `Jane`, ticks: 0 });\n * const b = bindDiffUpdate(`#test`, o, (diffs, el) => {\n *  // el = reference to #test\n * // diff = Array of Changes, \n * //  eg [ { path: `ticks`, value: 797, previous: 0 } ]\n *  for (const diff of diffs) {\n *    if (diff.path === `ticks`) el.textContent = `${diff.previous} -> ${diff.value}`\n *  }\n * })\n * \n * // Eg. update field\n * o.updateField(`ticks`, Math.floor(Math.random()*1000));\n * ```\n * \n * If `initial` is provided as an option, this will be called if `source` has an initial value. Without this, the DOM won't be updated until the first data\n * update happens.\n * ```js\n * bindDiffUpdate(el, source, updater, { \n *  initial: (v, el) => {\n *    el.innerHTML = v.name;\n *  }\n * })\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @param opts \n * @returns \n */\nexport const bindDiffUpdate = <V>(\n  source: Rx.ReactiveDiff<V>,\n  elOrQuery: string | HTMLElement | null,\n  updater: (diffs: Array<Immutable.PathDataChange<any>>, el: HTMLElement) => void,\n  opts: Partial<BindUpdateOpts<V>> = {}\n): PipeDomBinding & { refresh: () => void } => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  //const binds = opts.binds;\n  const update = (value: Array<Immutable.PathDataChange<any>>) => {\n    updater(value, el);\n  }\n\n  const unsub = source.onDiff(value => {\n    update(value);\n  });\n\n  const init = () => {\n    if (Rx.hasLast(source) && opts.initial) opts.initial(source.last(), el);\n  }\n\n  init();\n\n  return {\n    refresh: () => {\n      init();\n    },\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Creates a new HTML element and calls `bindUpdate` so values from `source` can be used\n * to update it.\n * \n * \n * ```js\n * // Creates a span, adding it to <body>\n * const b = createUpdate(dataSource, (value, el) => {\n *  el.width = value.width;\n *  el.height = value.height;\n * }, { \n *  tagName: `SPAN`,\n *  parentEl: document.body\n * })\n * ```\n * @param source \n * @param updater \n * @param options \n * @returns \n */\n// export const createUpdate = <V>(source: Rx.Reactive<V>, updater: (v: V, el: HTMLElement) => void, options: Partial<DomCreateOptions> = {}): PipeDomBinding => {\n//   const tag = options.tagName ?? `DIV`;\n//   const el = document.createElement(tag);\n//   if (options.parentEl) {\n//     const parent = resolveEl(options.parentEl);\n//     parent.append(el);\n//   }\n//   const b = bindUpdate(source, el, updater);\n//   return b;\n// }\n\n\n/**\n * Creates, updates & deletes elements based on pathed values from a reactive.\n * \n * This means that elements are only manipulated if its associated data changes,\n * and elements are not modified if there's no need to.\n * @param source \n * @param options \n */\nexport const elements = <T>(source: Rx.ReactiveDiff<T> | (Rx.ReactiveDiff<T> & Rx.ReactiveInitial<T>), options: Partial<ElementsOptions>) => {\n  const containerEl = options.container ? resolveEl(options.container) : document.body;\n  const defaultTag = options.defaultTag ?? `div`\n  const elByField = new Map<string, HTMLElement>();\n  const binds = new Map<string, ElementBind & {\n    update: ((value: any, el: HTMLElement) => void)\n    path: string\n  }>();\n\n  for (const [ key, value ] of Object.entries(options.binds ?? {})) {\n    const tagName = value.tagName ?? defaultTag;\n    //console.log(`key: ${ key }`);\n    binds.set(key, {\n      ...value,\n      update: resolveBindUpdaterBase(value),\n      transform: resolveTransform(value),\n      tagName,\n      path: key\n    });\n  }\n\n  const findBind = (path: string) => {\n    const bind = getFromKeys(binds, stringSegmentsWholeToEnd(path));\n    if (bind !== undefined) return bind;\n    if (!path.includes(`.`)) return binds.get(`_root`);\n  }\n\n  function* ancestorBinds(path: string) {\n    for (const p of stringSegmentsWholeToFirst(path)) {\n      //console.log(` ancestorBinds path: ${ path } segment: ${ p }`)\n\n      if (binds.has(p)) {\n        //console.log(`  bind: ${ p } found: ${ JSON.stringify(binds.get(p)) }`);\n        yield binds.get(p);\n      } else {\n        //console.log(` bind: ${ p } not found`);\n      }\n    }\n    if (binds.has(`_root`) && path.includes(`.`)) yield binds.get(`_root`);\n  }\n\n\n  const create = (path: string, value: any) => {\n    const rootedPath = getRootedPath(path);\n    console.log(`Rx.Dom.elements.create: ${ path } rooted: ${ rootedPath } value: ${ JSON.stringify(value) }`);\n\n    // Create\n    const bind = findBind(getRootedPath(path));\n    let tagName = defaultTag;\n    if (bind?.tagName) tagName = bind.tagName;\n\n    const el = document.createElement(tagName);\n    el.setAttribute(`data-path`, path);\n    update(path, el, value);\n\n    let parentForEl;\n    for (const b of ancestorBinds(rootedPath)) {\n      //console.log(`  path: ${ rootedPath } b: ${ JSON.stringify(b) }`);\n      if (b?.nestChildren) {\n        // Get root of path\n        const absoluteRoot = beforeMatch(path, `.`);\n        const findBy = b.path.replace(`_root`, absoluteRoot);\n\n        parentForEl = elByField.get(findBy);\n        if (parentForEl === undefined) {\n          //console.log(`    could not find parent. path: ${ path } b.path: ${ b.path } findBy: ${ findBy }`);\n        } else {\n          //console.log(`    found parent`);\n          break;\n        }\n      }\n    }\n    (parentForEl ?? containerEl).append(el);\n    elByField.set(path, el);\n    console.log(`Added el: ${ path }`);\n  }\n\n  const update = (path: string, el: HTMLElement, value: any) => {\n    console.log(`Rx.dom.update path: ${ path } value:`, value);\n\n    const bind = findBind(getRootedPath(path));\n    if (bind === undefined) {\n      //console.log(`Rx.dom.update   no bind for ${ path }`)\n      if (typeof value === `object`) value = JSON.stringify(value);\n      el.textContent = value;\n    } else {\n      //console.log(`Rx.dom.update   got bind! ${ path } `);\n      if (bind.transform) value = bind.transform(value);\n      bind.update(value, el);\n    }\n  }\n\n  const changes = (changes: Array<Immutable.PathDataChange<any> | Immutable.PathData<any>>) => {\n    const queue = new QueueMutable({}, changes);\n    let d = queue.dequeue();\n    const seenPaths = new Set<string>();\n    while (d !== undefined) {\n      //for (const d of changes) {\n      const path = d.path;\n      if (!(`previous` in d) || d.previous === undefined) {\n        // Create\n        console.log(`Rx.Dom.elements.changes no previous. path: ${ path }`);\n\n        create(path, d.value);\n        const subdata = [ ...Immutable.getPathsAndData(d.value, Number.MAX_SAFE_INTEGER, path) ];\n        console.log(subdata);\n        for (const dd of subdata) {\n          if (!seenPaths.has(dd.path)) {\n            queue.enqueue(dd);\n            seenPaths.add(dd.path);\n          }\n        }\n      } else if (d.value === undefined) {\n        // Delete\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`No element to delete? ${ path } `);\n        } else {\n          console.log(`Rx.Dom.elements.changes delete ${ path }`);\n          el.remove();\n        }\n      } else {\n        // Update\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`Rx.Dom.elements.changes No element to update ? ${ path } `);\n          create(path, d.value);\n        } else {\n          //console.log(`Rx.Dom.elements.changes Updating ${ path } `, el);\n          update(path, el, d.value);\n        }\n      }\n      d = queue.dequeue();\n    }\n  }\n\n  /**\n   * Source has changed\n   */\n  source.onDiff(value => {\n    //console.log(`Rx.Dom.elements diff ${ JSON.stringify(value) } `);\n    changes(value);\n  });\n\n  // Source has an initial value, use that\n  if (hasLast(source)) {\n    const last = source.last();\n    // Get data of value as a set of paths and data\n    // but only at first level of depth, because changes() will probe\n    // deeper itself\n    changes([ ...Immutable.getPathsAndData(last as object, 1) ]);\n  }\n};\n\n/**\n * Replaces the root portion of `path` with the magic keyword `_root`\n * @param path \n * @returns \n */\nconst getRootedPath = (path: string) => {\n  const after = afterMatch(path, `.`);\n  return after === path ? `_root` : `_root.` + after;\n}\n\nexport function win() {\n  const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });\n\n  const size = Rx.From.event(window, `resize`, {\n    lazy: `very`,\n    transform: () => generateRect(),\n  });\n  const pointer = Rx.From.event(window, `pointermove`, {\n    lazy: `very`,\n    transform: (args: Event | undefined) => {\n      if (args === undefined) return { x: 0, y: 0 };\n      const pe = args as PointerEvent;\n      return { x: pe.x, y: pe.y }\n    }\n  });\n  const dispose = (reason = `Reactive.win.dispose`) => {\n    size.dispose(reason);\n    pointer.dispose(reason);\n  }\n  return { dispose, size, pointer };\n}\n","import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Whittles down from whole string to last token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToEnd(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n    const trimmed = afterMatch(source, delimiter);\n    if (trimmed === source) {\n      // Delimiter not found\n      break;\n    }\n    source = trimmed;\n  }\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Starts with last token, builds to whole.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsLastToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n    if (ba[ 0 ] === ba[ 1 ] && ba[ 1 ] === source) {\n      // Delimiter not found\n      break;\n    }\n    const v = ba[ 1 ] + accumulator;\n    yield v;\n    accumulator = delimiter + v;\n    source = ba[ 0 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with the first token and build up until end.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsFirstToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n    if (ba[ 0 ] === source && ba[ 1 ] === source) break;\n    accumulator += ba[ 0 ];\n    yield accumulator;\n    accumulator += delimiter;\n    source = ba[ 1 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with whole string and whittle down to starting token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToFirst(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n\n    const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n    if (b === source) break;\n    source = b;\n  }\n}\n\n\n","export * from './Array.js';\nexport * from './ArrayObject.js';\nexport * from './Boolean.js';\n//export * from './Colour.js';\nexport * from './Event.js';\nexport * from './Dom.js';\nexport * from './Function.js';\nexport * from './FunctionPinged.js';\nexport * from './Iterator.js';\nexport * from './Number.js';\nexport * from './Object.js';\nexport * from './ObjectProxy.js';\nexport * from './Observable.js';\n//export * from './Resolve.js';\nexport * from './String.js';\nexport * from './Types.js';","\nimport { continuously } from \"../../flow/Continuously.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport type { Reactive, ReactiveFinite, ReactiveInitial } from \"../Types.js\";\nimport type { ArrayOptions } from \"./Types.js\";\n\nexport const of = <V>(source: Array<V> | Iterable<V>, options: Partial<ArrayOptions> = {}) => {\n  if (Array.isArray(source)) {\n    return array(source, options);\n  } else {}\n}\n\n/**\n * Reads the contents of `array` into a Reactive, with optional time interval\n * between values. A copy of the array is used, so changes will not\n * affect the reactive.\n * \n * See also {@link arrayObject} which monitors changes to array values.\n *\n * Reads items from an array with a given interval, by default 5ms\n * @param array \n * @param options \n * @returns \n */\nexport const array = <V>(sourceArray: Array<V>, options: Partial<ArrayOptions> = {}): Reactive<V> & ReactiveFinite & ReactiveInitial<V> => {\n  const lazy = options.lazy ?? `initial`;\n  const signal = options.signal;\n  const whenStopped = options.whenStopped ?? `continue`;\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const array = [ ...sourceArray ];\n\n  if (lazy !== `very` && whenStopped === `reset`) throw new Error(`whenStopped:'reset' has no effect with 'lazy:${ lazy }'. Use lazy:'very' instead.`);\n\n  const intervalMs = intervalToMs(options.interval, 5);\n  let index = 0;\n  let lastValue = array[ 0 ];\n\n  const s = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStart`);\n      c.start();\n    },\n    onStop() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStop. whenStopped: ${ whenStopped } index: ${ index }`);\n\n      c.cancel();\n      if (whenStopped === `reset`) index = 0;\n    },\n    // onFirstSubscribe() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onFirstSubscribe lazy: ${ lazy } runState: '${ c.runState }'`);\n    //   // Start if in lazy mode and not running\n    //   if (lazy !== `never` && c.runState === `idle`) c.start();\n    // },\n    // onNoSubscribers() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onNoSubscribers lazy: ${ lazy } runState: '${ c.runState }' whenStopped: '${ whenStopped }'`);\n    //   if (lazy === `very`) {\n    //     c.cancel();\n    //     if (whenStopped === `reset`) {\n    //       index = 0;\n    //     }\n    //   }\n    // }\n  });\n\n  const c = continuously(() => {\n    if (signal?.aborted) {\n      s.dispose(`Signalled (${ signal.reason })`);\n      return false; // stop looping\n    }\n    lastValue = array[ index ];\n    index++;\n\n    s.set(lastValue)\n    if (index === array.length) {\n      s.dispose(`Source array complete`);\n      return false; // stop loop\n    }\n  }, intervalMs);\n\n  if (!lazy) c.start();\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dispose: s.dispose,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    isDisposed: s.isDisposed,\n    isDone() {\n      return index === array.length;\n    },\n    last() {\n      return lastValue;\n    },\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: s.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    onValue: s.onValue\n  }\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { isEqualValueDefault } from \"../../util/IsEqual.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveInitial, ReactiveNonInitial, ReactiveArray, Reactive } from \"../Types.js\";\nimport type { ArrayObjectOptions } from \"./Types.js\";\nimport { compareArrays, type ChangeRecord } from \"../../data/Compare.js\";\nimport { remove as ArraysRemove } from '../../collections/arrays/Remove.js';\nimport { insertAt as ArraysInsertAt } from \"../../collections/arrays/InsertAt.js\";\n/**\n * Wraps an array object\n * @param initialValue \n * @param options \n * @returns \n */\nexport function arrayObject<V>(initialValue: ReadonlyArray<V> = [], options: Partial<ArrayObjectOptions<V>> = {}): Reactive<ReadonlyArray<V>> & ReactiveArray<V> & (ReactiveInitial<ReadonlyArray<V>> | ReactiveNonInitial<ReadonlyArray<V>>) {\n  const eq = options.eq ?? isEqualValueDefault;\n  const setEvent = initStream<Array<V>>();\n  //const diffEvent = initStream<Array<Immutable.Change<any>>>();\n  const arrayEvent = initStream<Array<ChangeRecord<number>>>();\n  let value: ReadonlyArray<V> = initialValue;\n  let disposed = false;\n\n  const set = (replacement: Array<V> | ReadonlyArray<V>) => {\n    const diff = compareArrays<V>(value as Array<V>, replacement as Array<V>, eq);\n    //console.log(`Rx.fromArray.set diff`, diff);\n    //if (diff.length === 0) return;\n    //diffEvent.set(diff);\n    value = replacement;\n    setEvent.set([ ...replacement ]);\n  }\n\n  const setAt = (index: number, v: V) => {\n    (value as Array<V>)[ index ] = v;\n    setEvent.set([ ...value ]);\n  }\n\n  const push = (v: V) => {\n    value = [ ...value, v ];\n    setEvent.set([ ...value ]);\n    const cr: ChangeRecord<number> = [ `add`, value.length - 1, v ];\n    arrayEvent.set([ cr ]);\n  }\n\n  const deleteAt = (index: number) => {\n    const valueChanged = ArraysRemove(value, index);\n    if (valueChanged.length === value.length) return; // no change\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    //console.log(diff.summary);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  const deleteWhere = (filter: (value: V) => boolean) => {\n    const valueChanged = value.filter(v => !filter(v));\n    const count = value.length - valueChanged.length;\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n    return count;\n  }\n\n  const insertAt = (index: number, v: V) => {\n    const valueChanged = ArraysInsertAt(value, index, v);\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  // const update = (toMerge: Partial<V>) => {\n  //   // eslint-disable-next-line unicorn/prefer-ternary\n  //   if (value === undefined) {\n  //     value = toMerge as V;\n  //   } else {\n  //     const diff = Immutable.compareData(toMerge, value);\n  //     // console.log(`Rx.fromObject.update value: ${ JSON.stringify(value) }`);\n  //     // console.log(`Rx.fromObject.update  diff: ${ JSON.stringify(diff) }`);\n  //     if (diff.length === 0) return; // No changes\n  //     value = {\n  //       ...value,\n  //       ...toMerge\n  //     }\n  //     diffEvent.set(diff);\n  //   }\n  //   setEvent.set(value);\n  // }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    //diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  const r = {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    last: () => value,\n    on: setEvent.on,\n    onArray: arrayEvent.on,\n    onValue: setEvent.onValue,\n    setAt,\n    push,\n    deleteAt,\n    deleteWhere,\n    insertAt,\n    /**\n     * Set the whole object\n     */\n    set\n  }\n  return r;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function boolean(initialValue: boolean): ReactiveWritable<boolean> & ReactiveInitial<boolean>;\nexport function boolean(): ReactiveWritable<boolean> & ReactiveNonInitial<boolean>;\nexport function boolean(initialValue?: boolean): ReactiveWritable<boolean> & (ReactiveNonInitial<boolean> | ReactiveInitial<boolean>) {\n  let value = initialValue;\n  const events = initStream<boolean>();\n\n  const set = (v: boolean) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}","import type { Passed, Reactive, ReactiveInitial } from \"../Types.js\";\nimport { field } from \"../ops/Field.js\";\nimport { object } from \"./Object.js\";\nimport type { FieldOptions } from \"../ops/Types.js\";\nimport type { EventOptions, EventTriggerOptions } from \"./Types.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport { Elapsed } from \"../../flow/index.js\";\n/**\n * Fired when `eventName` fires on `target`. \n * \n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n * \n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId') \n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport function eventField<TFieldValue = string>(targetOrQuery: EventTarget | string | null, eventName: string, fieldName: string, initialValue: TFieldValue, options: Partial<EventOptions & FieldOptions<any, TFieldValue>> = {}) {\n\n  const initial: Record<string, any> = {};\n  initial[ fieldName ] = initialValue;\n\n  const rxField = field<any, TFieldValue>(\n    event(targetOrQuery, eventName, initial, options),\n    fieldName,\n    options\n  );\n  return rxField;\n}\n\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options: EventOptions<V>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n\n/**\n * Subscribes to an event, emitting data\n * \n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n * \n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n * \n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport function event<TEventArgs extends Record<string, any>>(targetOrQuery: EventTarget | null | string, name: string, initialValue: TEventArgs | undefined, options: Partial<EventOptions> = {}): ReactiveInitial<TEventArgs> & Reactive<TEventArgs> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const lazy = options.lazy ?? false;\n  if (initialValue === undefined) initialValue = {} as TEventArgs;\n  const rxObject = object<TEventArgs>(initialValue, { deepEntries: true });\n  let eventAdded = false;\n  let disposed = false;\n\n  const callback = (args: any) => {\n    if (debugFiring) console.log(`Reactive.event '${ name }' firing '${ JSON.stringify(args) }`)\n    rxObject.set(args as TEventArgs);\n  }\n\n  const remove = () => {\n    if (!eventAdded) return;\n    eventAdded = false;\n    target.removeEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event remove '${ name }'`);\n    }\n  }\n\n  const add = () => {\n    if (eventAdded) return;\n    eventAdded = true;\n    target.addEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event add '${ name }'`);\n    }\n  }\n\n  if (!lazy) add();\n\n  return {\n    last: () => {\n      if (lazy) add();\n      return rxObject.last();\n    },\n    dispose: (reason: string) => {\n      if (disposed) return;\n      disposed = true;\n      remove();\n      rxObject.dispose(reason);\n    },\n    isDisposed() {\n      return disposed;\n    },\n    on: (handler: (v: Passed<TEventArgs>) => void) => {\n      if (lazy) add();\n      return rxObject.on(handler);\n    },\n    onValue: (handler: (v: TEventArgs) => void) => {\n      if (lazy) add();\n      return rxObject.onValue(handler);\n    }\n  }\n}\n\nexport type TriggerData = {\n  sinceLast: number\n  total: number\n}\n\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of \n * times event has been fired.\n * @param targetOrQuery \n * @param name \n * @param options \n * @returns \n */\nexport function eventTrigger(targetOrQuery: EventTarget | null | string, name: string, options: Partial<EventTriggerOptions> = {}): Reactive<TriggerData> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const fireInitial = options.fireInitial ?? false;\n\n  let count = 0;\n  const elapsed = Elapsed.interval();\n\n  const stream = initLazyStream<TriggerData>({\n    lazy: options.lazy ?? `very`,\n    onStart() {\n      target.addEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger add '${ name }'`);\n      }\n      if (fireInitial && count === 0) {\n        callback();\n      }\n    },\n    onStop() {\n      target.removeEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger remove '${ name }'`);\n      }\n    },\n  });\n\n  const callback = (_args?: any) => {\n    if (debugFiring) console.log(`Rx.From.eventTrigger '${ name }' triggered'`)\n    stream.set({\n      sinceLast: elapsed(),\n      total: ++count\n    });\n  }\n\n  return stream;\n}","/**\n * Work with bipolar values (-1...1)\n * \n * Import:\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * ```\n * \n * Overview:\n * * {@link immutable}: Immutable wrapper around a value\n * * {@link clamp}: Clamp on -1..1 scale\n * * {@link scale}: Scale a value to -1..1\n * * {@link toScalar}: Convert -1..1 to 0..1\n * * {@link fromScalar}: Convert from 0..1 to -1..1\n * * {@link towardZero}: Nudge a bipolar value towards zero\n */\nexport * as Bipolar from './Bipolar.js';\n\nexport * from './Clamp.js';\nexport * from './Compare.js';\nexport * as Correlate from './Correlate.js';\nexport * from './Flip.js';\nexport * from './FrequencyMutable.js';\nexport * from './Interpolate.js';\nexport * from './IntervalTracker.js';\nexport * from './KeysToNumbers.js';\nexport * from './MapObject.js';\nexport * from './MovingAverage.js';\nexport * from './NumberTracker.js';\n/**\n * Normalise module\n * * {@link array}: Normalises the contents of an array of known values.\n * * {@link stream}: Normalises a stream of unknown values.\n */\nexport * as Normalise from './Normalise.js';\n\n/**\n * Means of accessing, creating and comparing objects\n * based on 'paths'. This is useful for serialisation.\n * \n */\nexport * as Pathed from './Pathed.js'\nexport * from './MonitorChanges.js';\nexport * from './PointTracker.js';\nexport * as Pool from './Pool.js';\nexport * from './PrimitiveTracker.js';\nexport * from './Process.js';\nexport * from './Proportion.js';\nexport * from './ResolveFields.js';\nexport * from './Scale.js';\nexport * from './Softmax.js';\nexport * from './Table.js';\nexport * from './TrackedValue.js';\nexport * from './TrackerBase.js';\nexport * from './TrackUnique.js';\nexport * from './Types.js';\nexport * from './Util.js';\nexport * from './Wrap.js';\n\nexport * as Graphs from './graphs/index.js'\n\nexport const piPi = Math.PI * 2;\n","\nimport { type RandomOptions, type RandomSource } from '../random/Types.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport { interpolate } from './Interpolate.js';\nimport { scaler as numberScaler } from './Scale.js';\nimport { floatSource } from '../random/FloatSource.js';\n\n/**\n * Wrapper around a bipolar value. Immutable.\n * \n * ```js\n * let b = Bipolar.immutable();\n * let b = Bipolar.immutable(0.5);\n * b = b.add(0.1);\n * ```\n */\nexport type BipolarWrapper = {\n  value: number\n  towardZero: (amt: number) => BipolarWrapper\n  add: (amt: number) => BipolarWrapper\n  multiply: (amt: number) => BipolarWrapper\n  inverse: () => BipolarWrapper\n  asScalar: () => number\n  interpolate: (amt: number, b: number) => BipolarWrapper\n  [ Symbol.toPrimitive ]: (hint: string) => number | string | boolean\n}\n\n/**\n * Wrapper for bipolar-based values. Immutable.\n * All functions will clamp to keep it in legal range.\n * \n * ```js\n * let v = immutable(); // Starts with 0 by default\n * v = v.add(0.1);      // v.value is 0.1\n * v = v.inverse();     // v.value is -0.1\n * v = v.multiply(0.2); // v.value is -0.02\n * \n * v = immutable(1);\n * v = v.towardZero(0.1); // 0.9\n * v = v.interpolate(0.1, 1);\n * ```\n * \n * Wrapped values can be coerced into number:\n * ```js\n * const v = immutable(1);\n * const x = +v+10;\n * // x = 11\n * ```\n * @param startingValue \n * @returns \n */\nexport const immutable = (startingValueOrBipolar: number | BipolarWrapper = 0): BipolarWrapper => {\n  const startingValue = (typeof startingValueOrBipolar === `number`) ? startingValueOrBipolar : startingValueOrBipolar.value;\n\n  if (startingValue > 1) throw new Error(`Cannot be larger than 1`);\n  if (startingValue < -1) throw new Error(`Cannot be smaller than -1`);\n  if (Number.isNaN(startingValue)) throw new Error(`startingValue is NaN`);\n\n  const v = startingValue;\n  return {\n    [ Symbol.toPrimitive ](hint: string) {\n      if (hint === `number`) return v;\n      else if (hint === `string`) return v.toString();\n      return true;\n    },\n    value: v,\n    towardZero: (amt: number) => {\n      return immutable(towardZero(v, amt));\n    },\n    add: (amt: number) => {\n      return immutable(clamp(v + amt));\n    },\n    multiply: (amt: number) => {\n      return immutable(clamp(v * amt));\n    },\n    inverse: () => {\n      return immutable(-v);\n    },\n    interpolate: (amt: number, b: number) => {\n      return immutable(clamp(interpolate(amt, v, b)));\n    },\n    asScalar: () => {\n      return toScalar(v);\n    }\n  }\n}\n\n/**\n * Converts bipolar value to a scalar\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.toScalar(-1); // 0.0\n * Bipolar.toScalar( 0); // 0.5\n * Bipolar.toScalar( 1); // 1.0\n * ```\n * \n * Throws an error if `bipolarValue` is not a number or NaN\n * @param bipolarValue Value to convert to scalar\n * @returns Scalar value on 0..1 range.\n */\nexport const toScalar = (bipolarValue: number) => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Expected v to be a number. Got: ${ typeof bipolarValue }`);\n  if (Number.isNaN(bipolarValue)) throw new Error(`Parameter is NaN`);\n  return (bipolarValue + 1) / 2;\n}\n\n/**\n * Makes a scalar into a bipolar value.\n * \n * That is, input range is 0..1, output range is -1...1\n *\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.fromScalar(1);   // 1\n * Bipolar.fromScalar(0);   // -1\n * Bipolar.fromScalar(0.5); // 0\n * ```\n * \n * Throws an error if `scalarValue` is not on 0..1 scale.\n * @param scalarValue Scalar value to convert\n * @returns Bipolar value on -1..1 scale\n */\nexport const fromScalar = (scalarValue: number) => {\n  throwNumberTest(scalarValue, `percentage`, `v`);\n  return (scalarValue * 2) - 1;\n};\n\n/**\n * Scale a number to -1..1 range\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * \n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n * \n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scale = (inputValue: number, inMin: number, inMax: number) => {\n  return clamp(numberScaler(inMin, inMax, -1, 1)(inputValue));\n}\n\n/**\n * Scale a number, clamped to -1..1 range\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * \n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n * \n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scaleClamped = (inputValue: number, inMin: number, inMax: number) => {\n  return numberScaler(inMin, inMax, -1, 1)(inputValue);\n}\n\n/**\n * Source for random bipolar values\n * ```js\n * const r = Bipolar.randomSource();\n * r(); // Produce random value on -1...1 scale\n * ```\n * \n * Options can be provided, for example\n * ```js\n * // -0.5 to 0.5 range\n * Bipolar.randomSource({ max: 0.5 });\n * ```\n * \n * Consider using {@link random} if you just want a one-off random\n * value.\n * @param source \n * @returns \n */\nexport const randomSource = (maxOrOptions?: number | RandomOptions): RandomSource => {\n  const source = floatSource(maxOrOptions);\n  return () => (source() * 2) - 1;\n}\n\n/**\n * Returns a random bipolar value\n * ```js\n * const r = Bipolar.random(); // -1...1 random\n * ```\n * \n * Options can be provided, eg.\n * ```js\n * Bipolar.random({ max: 0.5 }); // -0.5..0.5 random\n * ```\n * \n * Use {@link randomSource} if you want to generate random\n * values with same settings repeatedly.\n * @param maxOrOptions \n * @returns \n */\nexport const random = (maxOrOptions?: number | RandomOptions): number => {\n  const source = randomSource(maxOrOptions);\n  return source();\n}\n/**\n * Clamp a bipolar value\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.clamp(-1);   // -1\n * Bipolar.clamp(-1.1); // -1\n * ```\n * \n * Throws an error if `bipolarValue` is not a number or NaN.\n * @param bipolarValue Value to clamp\n * @returns Clamped value on -1..1 scale\n */\nexport const clamp = (bipolarValue: number): number => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Parameter must be a number. Got: ${ typeof bipolarValue }`);\n  if (Number.isNaN(bipolarValue)) throw new Error(`v parameter is NaN`);\n  if (bipolarValue > 1) return 1;\n  if (bipolarValue < -1) return -1;\n  return bipolarValue;\n}\n\n/**\n * Pushes a bipolar value toward zero by `amount`.\n * Return value is clamped on bipolar range of -1..1\n * \n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.towardZero(-1, 0.1); // -0.9\n * Bipolar.towardZero( 1, 0.1); //  0.9\n * Bipolar.towardZero( 0, 0.1); //  0.0\n * Bipolar.towardZero( 1, 1.1); //  0.0\n * ```\n * \n * If `amount` is greater than 1, 0 is returned.\n * Throws an error if `bipolarValue` or `amount` are not numbers.\n * Throws an error if `amount` is below zero.\n * @param bipolarValue Bipolar value to nudge toward zero\n * @param amount Amount to nudge by\n * @returns Bipolar value -1...1\n */\nexport const towardZero = (bipolarValue: number, amount: number): number => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Parameter 'v' must be a number. Got: ${ typeof bipolarValue }`);\n  if (typeof amount !== `number`) throw new Error(`Parameter 'amt' must be a number. Got: ${ typeof amount }`);\n  if (amount < 0) throw new Error(`Parameter 'amt' must be positive`);\n  if (bipolarValue < 0) {\n    bipolarValue += amount;\n    if (bipolarValue > 0) bipolarValue = 0;\n  } else if (bipolarValue > 0) {\n    bipolarValue -= amount;\n    if (bipolarValue < 0) bipolarValue = 0;\n  }\n  return bipolarValue;\n}","/**\n * Returns the similarity of `a` and `b` to each other,\n * where higher similarity should be a higher number.\n * @param a\n * @param b\n */\nexport type Similarity<V> = (a: V, b: V) => number;\n\ntype Scored = {\n  readonly score: number;\n};\n\nconst orderScore = (a: Scored, b: Scored) => {\n  if (a.score > b.score) return -1;\n  else if (a.score < b.score) return 1;\n  return 0;\n};\n\n/**\n * Options for alignmnent\n */\nexport type AlignOpts = {\n  /**\n   * If the similarity score is above this threshold,\n   * consider them the same\n   */\n  readonly matchThreshold?: number;\n  /**\n   * If true, additional console messages are printed during\n   * execution.\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Some data with an id property.\n */\nexport type DataWithId<V> = V & {\n  readonly id: string;\n};\n\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFn\n * @param lastData\n * @param newData\n * @param opts\n * @returns\n */\n//eslint-disable-next-line functional/immutable-data\nexport const align = <V>(\n  similarityFn: Similarity<V>,\n  lastData: readonly DataWithId<V>[] | undefined,\n  newData: readonly DataWithId<V>[],\n  opts: AlignOpts = {}\n): readonly DataWithId<V>[] => {\n  const matchThreshold = opts.matchThreshold ?? 0;\n  const debug = opts.debug ?? false;\n  const results = new Map();\n  const newThings: DataWithId<V>[] = [];\n\n  const lastMap = new Map();\n  lastData?.forEach((d, index) => {\n    if (d === undefined) {\n      throw new Error(`'lastData' contains undefined (index: ${index})`);\n    }\n    lastMap.set(d.id, d);\n  });\n\n  //eslint-disable-next-line functional/no-let\n  for (let i = 0; i < newData.length; i++) {\n    const newD = newData[i];\n\n    if (!lastData || lastData.length === 0) {\n      // No last data to compare to\n      if (debug) console.debug(`Correlate.align() new id: ${newD.id}`);\n\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // Which of the old data does the new data match up to best?\n    const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n      id: last.id,\n      score: last === null ? -1 : similarityFn(last, newD),\n      last,\n    }));\n\n    if (scoredLastValues.length === 0) {\n      if (debug) {\n        console.debug(`Correlate.align() no valid last values id: ${newD.id}`);\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n    //eslint-disable-next-line functional/immutable-data\n    scoredLastValues.sort(orderScore);\n\n    // Top-ranked match is pretty low, must be something new\n    const top = scoredLastValues[0];\n    if (top.score < matchThreshold) {\n      if (debug) {\n        console.debug(\n          `Correlate.align() new item does not reach threshold. Top score: ${top.score} id: ${newD.id}`\n        );\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // TODO: If there are close options to pick, need a pluggable\n    // function to determine which is the winner.\n\n    //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n\n    // The new item is considered the same as top ranked\n    if (debug && top.id !== newD.id) {\n      console.log(\n        `Correlate.align() Remapped ${newD.id} -> ${top.id} (score: ${top.score})`\n      );\n    }\n    //eslint-disable-next-line functional/immutable-data\n    results.set(top.id, { ...newD, id: top.id });\n\n    // Remove that old one from the list\n    //eslint-disable-next-line functional/immutable-data\n    lastMap.delete(top.id);\n  }\n\n  //eslint-disable-next-line functional/immutable-data\n  newThings.forEach((t) => results.set(t.id, t));\n  return Array.from(results.values());\n};\n\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn\n * @param opts\n * @returns\n */\nexport const alignById = <V>(fn: Similarity<V>, opts: AlignOpts = {}) => {\n  //eslint-disable-next-line functional/no-let\n  let lastData: readonly DataWithId<V>[] = [];\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const compute = (newData: DataWithId<V>[]) => {\n    lastData = align(fn, lastData, newData, opts);\n    return [...lastData];\n  };\n  return compute;\n};\n","import { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport type { NumberFunction } from './Types.js';\n\n/**\n * Flips a percentage-scale number: `1 - v`.\n *\n * The utility of this function is that it sanity-checks\n * that `v` is in 0..1 scale.\n *\n * ```js\n * flip(1);   // 0\n * flip(0.5); // 0.5\n * flip(0);   // 1\n * ```\n * @param v\n * @returns\n */\nexport const flip = (v: number | NumberFunction) => {\n  if (typeof v === `function`) v = v();\n  throwNumberTest(v, `percentage`, `v`);\n  return 1 - v;\n};\n","/// â Unit tested!\n\nimport { type ToString } from '../util/index.js';\nimport { SimpleEventEmitter } from '../Events.js';\nimport * as KeyValues from '../KeyValue.js';\nimport type { KeyValue } from '../PrimitiveTypes.js';\n\nexport type FrequencyEventMap = {\n  readonly change: { context: any };\n};\n\nexport class FrequencyMutable<V> extends SimpleEventEmitter<FrequencyEventMap> {\n  readonly #store: Map<string, number>;\n  readonly #keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function to key items. Uses JSON.stringify by default\n   */\n  constructor(keyString?: ToString<V> | undefined) {\n    super();\n    this.#store = new Map();\n\n    if (keyString === undefined) {\n      keyString = (a) => {\n        if (a === undefined) throw new Error(`Cannot create key for undefined`);\n        return typeof a === `string` ? a : JSON.stringify(a);\n      };\n    }\n    this.#keyString = keyString;\n  }\n\n  /**\n   * Clear data. Fires `change` event\n   */\n  clear() {\n    this.#store.clear();\n    this.fireEvent(`change`, { context: this });\n  }\n\n  /**\n   * @returns Iterator over keys (ie. groups)\n   */\n  keys(): IterableIterator<string> {\n    return this.#store.keys();\n  }\n\n  /**\n   * @returns Iterator over frequency counts\n   */\n  values(): IterableIterator<number> {\n    return this.#store.values();\n  }\n\n  /**\n   * @returns Copy of entries as an array of `[key, count]`\n   */\n  toArray(): Array<[ key: string, count: number ]> {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   * Returns a string with keys and counts, useful for debugging.\n   * @returns\n   */\n  debugString(): string {\n    //eslint-disable-next-line functional/no-let\n    let t = ``;\n    for (const [ key, count ] of this.#store.entries()) {\n      t += `${ key }: ${ count }, `;\n    }\n    if (t.endsWith(`, `)) return t.slice(0, Math.max(0, t.length - 2));\n    return t;\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Frequency of value, or _undefined_ if it does not exist\n   */\n  frequencyOf(value: V | string): number | undefined {\n    if (typeof value === `string`) return this.#store.get(value);\n\n    const key = this.#keyString(value);\n    return this.#store.get(key);\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Relative frequency of `value`, or _undefined_ if it does not exist\n   */\n  relativeFrequencyOf(value: V | string): number | undefined {\n    //eslint-disable-next-line functional/no-let\n    let freq: number | undefined;\n    if (typeof value === `string`) freq = this.#store.get(value);\n    else {\n      const key = this.#keyString(value);\n      freq = this.#store.get(key);\n    }\n    if (freq === undefined) return;\n\n    const mma = this.minMaxAvg();\n    return freq / mma.total;\n  }\n\n  /**\n   * @returns Copy of entries as an array\n   */\n  entries(): Array<KeyValue> {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   *\n   * @returns Returns `{min,max,avg,total}`\n   */\n  minMaxAvg() {\n    return KeyValues.minMaxAvg(this.entries());\n  }\n\n  /**\n   *\n   * @param sortStyle Sorting style (default: _value_, ie. count)\n   * @returns Sorted array of [key,frequency]\n   */\n  entriesSorted(\n    sortStyle: KeyValues.SortSyles = `value`\n  ): ReadonlyArray<KeyValue> {\n    const s = KeyValues.getSorter(sortStyle);\n    return s(this.entries());\n  }\n\n  /**\n   *\n   * @param values Values to add. Fires _change_ event after adding item(s)\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  add(...values: Array<V>) {\n    if (values === undefined) throw new Error(`value parameter is undefined`);\n\n    const keys = values.map(v => this.#keyString(v));\n\n    //const key = this.#keyString(value);\n    for (const key of keys) {\n      const score = this.#store.get(key) ?? 0;\n      this.#store.set(key, score + 1);\n    }\n    this.fireEvent(`change`, { context: this });\n  }\n}\n\n/**\n * Frequency keeps track of how many times a particular value is seen, but\n * unlike a Map it does not store the data. By default compares\n * items by value (via JSON.stringify).\n *\n * Create with {@link frequencyMutable}.\n *\n * Fires `change` event when items are added or it is cleared.\n *\n * Overview\n * ```\n * const fh = frequencyMutable();\n * fh.add(value); // adds a value\n * fh.clear();    // clears all data\n * fh.keys() / .values() // returns an iterator for keys and values\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\n * ```\n *\n * Usage\n * ```\n * const fh = frequencyMutable();\n * fh.add(`apples`); // Count an occurence of `apples`\n * fh.add(`oranges)`;\n * fh.add(`apples`);\n *\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\n * fhData.forEach((d) => {\n *  const [key,freq] = d;\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\n * })\n * ```\n *\n * Custom key string\n * ```\n * const fh = frequencyMutable( person => person.name);\n * // All people with name `Samantha` will be counted in same group\n * fh.add({name:`Samantha`, city:`Brisbane`});\n * ```\n * @template V Type of items\n */\nexport const frequencyMutable = <V>(keyString?: ToString<V> | undefined) =>\n  new FrequencyMutable<V>(keyString);\n","import { NumberTracker } from './NumberTracker.js';\nimport { type TrackedValueOpts as TrackOpts } from './TrackedValue.js';\n\n/**\n * A `Tracker` that tracks interval between calls to `mark()`\n *\n * @export\n * @class IntervalTracker\n * @extends {ValueTracker}\n */\nexport class IntervalTracker extends NumberTracker {\n  lastMark = 0;\n\n  mark() {\n    if (this.lastMark > 0) {\n      this.seen(performance.now() - this.lastMark);\n    }\n    this.lastMark = performance.now();\n  }\n}\n\n/**\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\n * records the interval between each call to `mark`.\n *\n * ```js\n * import { intervalTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const t = intervalTracker();\n *\n * // Call `mark` to record an interval\n * t.mark();\n * ...\n * t.mark();\n *\n * // Get average time in milliseconds between calls to `mark`\n * t.avg;\n *\n * // Longest and shortest times are available too...\n * t.min / t.max\n * ```\n *\n * Interval tracker can automatically reset after a given number of samples:\n *\n * ```\n * // Reset after 100 samples\n * const t = intervalTracker({ resetAfterSamples: 100} );\n * ```\n * @param opts Options for tracker\n * @returns New interval tracker\n */\nexport const intervalTracker = (opts?: TrackOpts) => new IntervalTracker(opts);\n","/**\n * Returns a copy of `object` with integer numbers as keys instead of whatever it has.\n * ```js\n * keysToNumbers({ '1': true }); // Yields: { 1: true }\n * ```\n * \n * The `onInvalidKey` sets how to handle keys that cannot be converted to integers.\n * * 'throw' (default): throws an exception\n * * 'ignore': that key & value is ignored\n * * 'keep': uses the string key instead\n * \n * \n * ```js\n * keysToNumber({ hello: 'there' }, `ignore`); // Yields: {  }\n * keysToNumber({ hello: 'there' }, `throw`);  // Exception\n * keysToNumber({ hello: 'there' }, `keep`);   // Yields: { hello: 'there' }\n * ```\n * \n * Floating-point numbers will be converted to integer by rounding.\n * ```js\n * keysToNumbers({ '2.4': 'hello' }); // Yields: { 2: 'hello' }\n * ```\n * @param object \n * @param onInvalidKey \n * @returns \n */\nexport const keysToNumbers = <T>(object: Record<any, T>, onInvalidKey: `throw` | `ignore` | `keep` = `throw`): Record<number, T> => {\n  const returnObject: Record<number, T> = {};\n  for (const entry of Object.entries(object)) {\n    const asNumber = Number.parseInt(entry[ 0 ]);\n    if (Number.isNaN(asNumber)) {\n      switch (onInvalidKey) {\n        case `throw`: {\n          throw new TypeError(`Cannot convert key '${ entry[ 0 ] }' to an integer`);\n        }\n        case `ignore`: {\n          continue;\n        }\n        case `keep`: {\n          (returnObject as any)[ entry[ 0 ] ] = entry[ 1 ];\n          continue;\n        }\n        default: {\n          throw new Error(`Param 'onInvalidKey' should be: 'throw', 'ignore' or 'keep'.`);\n        }\n      }\n    }\n    returnObject[ asNumber ] = entry[ 1 ];\n  }\n  return returnObject;\n}\n","import type { Interval } from '../flow/IntervalType.js';\nimport { averageWeighted } from '../numbers/AverageWeighted.js';\nimport { average } from '../numbers/NumericArrays.js';\nimport { QueueMutable } from '../collections/queue/QueueMutable.js';\nimport { throwNumberTest, numberTest } from \"../util/GuardNumbers.js\";\nimport { rateMinimum } from '../flow/RateMinimum.js';\n\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * `add()` adds a new value and returns the calculated average.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma.add(50);  // 50\n * ma.add(100); // 75\n * ma.add(75);  // 75\n * ma.add(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * Use `clear()` to reset the moving average, or `compute()` to get the current value without adding.\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3): (value?: number) => number => {\n  throwNumberTest(scaling, `aboveZero`, `scaling`);\n  let average = 0;\n  let count = 0;\n\n  return (v?: number) => {\n    const r = numberTest(v, ``, `v`);\n    if (r[ 0 ] && v !== undefined) {\n      // Valid number\n      count++;\n      average = average + (v - average) / Math.min(count, scaling);\n    }\n    return average;\n  }\n\n  // let disposed = false;\n  // const ma: MovingAverage = {\n  //   dispose() {\n  //     disposed = true;\n  //   },\n  //   get isDisposed() {\n  //     return disposed;\n  //   },\n  //   add(v: number) {\n  //     if (disposed) throw new Error(`MovingAverage disposed, cannot add`);\n  //     count++;\n  //     average = average + (v - average) / Math.min(count, scaling);\n  //     return average;\n  //   },\n  //   clear() {\n  //     if (disposed) throw new Error(`MovingAverage disposed, cannot clear`);\n  //     average = 0;\n  //     count = 0;\n  //   },\n  //   compute() {\n  //     return average;\n  //   },\n  // };\n  // return ma;\n};\n\nexport type MovingAverageTimedOptions = Readonly<{\n  interval: Interval\n  default?: number\n  abort?: AbortSignal\n}>\n\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * ```js\n * // By default, 0 is added if interval elapses\n * const mat = movingAverageTimed({ interval: 1000 });\n * mat(10); // Add value of 10, returns latest average\n * \n * mat(); // Get current average\n * ```\n * \n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n * \n * Use an AbortSignal to cancel the timer associated with the `movingAverageTimed` function.\n * @param updateRateMs\n * @param value\n * @param scaling\n * @returns\n */\nexport const movingAverageTimed = (options: MovingAverageTimedOptions) => {\n  const average = movingAverageLight();\n  const rm = rateMinimum({\n    ...options,\n    whatToCall: (distance: number) => {\n      average(distance);\n    },\n    fallback() {\n      return options.default ?? 0;\n    }\n  })\n\n  return (v: number) => {\n    rm(v);\n    return average();\n  }\n};\n\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n\n//   const mal = movingAverageLight(scaling);\n\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n\n//   return ma;\n// };\n\n/**\n * Creates a moving average for a set number of `samples`.\n *\n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n * `add` adds a number and returns the computed average. Call `compute` to\n * get the average without adding a new value.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const ma = movingAverage(10);\n * ma.add(10); // 10\n * ma.add(5);  // 7.5\n * ```\n *\n * `clear` clears the average.\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, Easings.gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (\n  samples = 100,\n  weighter?: (v: number) => number\n): (value?: number) => number => {\n  //let disposed = false;\n\n  const q = new QueueMutable<number>({\n    capacity: samples,\n    discardPolicy: `older`,\n  });\n\n  return (v?: number | undefined) => {\n    const r = numberTest(v);\n    if (r[ 0 ] && v !== undefined) {\n      q.enqueue(v);\n    }\n    return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  }\n\n  // const clear = () => {\n  //   q = new QueueMutable<number>({\n  //     capacity: samples,\n  //     discardPolicy: `older`,\n  //   });\n  // };\n\n  // const compute = () => {\n  //   return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  // };\n\n  // const add = (v: number) => {\n  //   q.enqueue(v);\n  //   return compute();\n  // };\n\n  // const dispose = () => {\n  //   disposed = true;\n  // };\n\n  // return { add, compute, clear, dispose, isDisposed: disposed };\n};\n\n/**\n * Moving average.\n * Create via {@link movingAverage} or {@link movingAverageLight}.\n */\n// export type MovingAverage = {\n//   /**\n//    * Clear data\n//    */\n//   clear(): void;\n//   /**\n//    * Returns current average\n//    */\n//   compute(): number;\n//   /**\n//    * Adds a value, returning new average\n//    * @param v Value to add\n//    */\n//   add(v: number): number;\n\n//   dispose(): void;\n//   get isDisposed(): boolean;\n// };\n\nconst PiPi = Math.PI * 2;\n\nconst smoothingFactor = (timeDelta: number, cutoff: number): number => {\n  const r = PiPi * cutoff * timeDelta;\n  return r / (r + 1);\n}\n\nconst exponentialSmoothing = (smoothingFactor: number, value: number, previous: number): number => {\n  return smoothingFactor * value + (1 - smoothingFactor) * previous\n}\n\n/**\n * Noise filtering\n * \n * Algorithm: https://gery.casiez.net/1euro/\n * \n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n  let previousValue = 0;\n  let derivativeLast = 0;\n  let timestampLast = 0;\n\n  const compute = (value: number, timestamp?: number) => {\n    if (timestamp === undefined) timestamp = performance.now();\n    const timeDelta = timestamp - timestampLast;\n\n    // Filtered derivative\n    const s = smoothingFactor(timeDelta, cutoffDefault);\n    const valueDelta = (value - previousValue) / timeDelta;\n    const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n\n    // Filtered signal\n    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n    const a = smoothingFactor(timeDelta, cutoff);\n    const smoothed = exponentialSmoothing(a, value, previousValue);\n\n    previousValue = smoothed;\n    derivativeLast = derivative;\n    timestampLast = timestamp;\n\n    return smoothed;\n  }\n  return compute;\n}","\nimport { scale } from './Scale.js';\nimport { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { clamp } from './Clamp.js';\nimport { minMaxAvg } from '../collections/arrays/MinMaxAvg.js';\n/**\n * Normalises numbers, adjusting min/max as new values are processed.\n * Normalised return values will be in the range of 0-1 (inclusive).\n *\n * [Read more in the docs](https://clinth.github.io/ixfx-docs/data/normalising/)\n *\n * @example\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/data.js'\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passingin `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * Note that if a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault?: number, maxDefault?: number) => {\n  //eslint-disable-next-line functional/no-let\n  let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n\n  throwNumberTest(minDefault);\n  throwNumberTest(maxDefault);\n\n  return (v: number): number => {\n    throwNumberTest(v);\n    min = Math.min(min, v);\n    max = Math.max(max, v);\n    return scale(v, min, max);\n  };\n};\n\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. [Read more in the docs](https://clinth.github.io/ixfx-docs/data/normalising/)\n *\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/data.js'\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (values: ReadonlyArray<number>,\n  minForced?: number,\n  maxForced?: number\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(`Param 'values' should be an array. Got: ${ typeof values }`);\n  }\n  const mma = minMaxAvg(values);\n\n  const min = minForced ?? mma.min;\n  const max = maxForced ?? mma.max;\n\n  return values.map((v) => clamp(scale(v, min, max)));\n};\n","import type { RecursiveReplace } from \"src/TsUtil.js\"\nimport { applyChanges, compareData } from \"./Pathed.js\"\n\ntype RecordValue<T extends Record<string, any>, TReturn> = {\n  [ Property in keyof T ]?: (value: T[ Property ], previous: T[ Property ], field: string) => TReturn\n}\nexport type RecordOptions<T extends Record<string, any>, TReturn> = {\n  onFieldChange: RecordValue<T, TReturn>\n}\n\nexport const compareDataExecute = <T extends Record<string, any>, TReturn>(o: T, options: RecordOptions<T, TReturn>) => {\n  let current = o;\n\n  const cbs = new Map<string, any>();\n  for (const [ k, v ] of Object.entries(options.onFieldChange)) {\n    cbs.set(k.replaceAll(`_`, `.`), v);\n  }\n  return (value: T): RecursiveReplace<T, TReturn> => {\n    const changes = compareData(current, value, { includeParents: true });\n    //if (changes.length === 0) return; // No change\n    //console.log(`pre`, JSON.stringify(changes));\n    for (const c of changes) {\n      const cb = cbs.get(c.path);\n      if (cb) {\n        c.value = cb(c.value, c.previous, c.path) as TReturn;\n      }\n    }\n    console.log(`post`, JSON.stringify(changes));\n    //current = applyChanges(current, changes);\n    return current;\n  }\n}\n\n// const test = {\n//   name: `hello`,\n//   age: 10,\n//   a: {\n//     b: {\n//       c: {\n//         word: `goat`\n//       }\n//     }\n//   }\n// };\n// interceptChanges(test, {\n//   onFieldChange: {\n//     age: (v) => {\n\n//     },\n//     a_b_c: (v)\n//   }\n// })","import type { TimestampedObject, TrackedValueOpts } from './TrackedValue.js';\nimport { TrackerBase } from './TrackerBase.js';\n\n/**\n * A tracked value of type `V`.\n */\nexport abstract class ObjectTracker<V extends object, SeenResultType> extends TrackerBase<V, SeenResultType> {\n  //abstract onSeen(_p: Array<V>): SeenResultType;\n\n  values: Array<TimestampedObject<V>>;\n\n  constructor(opts: TrackedValueOpts = {}) {\n    super(opts);\n    this.values = [];\n  }\n\n  onTrimmed() {\n    // no-op\n  }\n\n  /**\n   * Reduces size of value store to `limit`. \n   * Returns number of remaining items\n   * @param limit\n   */\n  trimStore(limit: number): number {\n    if (limit >= this.values.length) return this.values.length;\n    // Index 0 will be the oldest\n    this.values = this.values.slice(-limit);\n    return this.values.length;\n  }\n\n  /**\n   * Allows sub-classes to be notified when a reset happens\n   * @ignore\n   */\n  onReset() {\n    this.values = [];\n  }\n\n  /**\n   * Tracks a value\n   * @ignore\n   */\n  filterData(p: Array<V> | Array<TimestampedObject<V>>): Array<TimestampedObject<V>> {\n    // Make sure values have a timestamp\n    const ts = p.map((v) =>\n      `at` in v\n        ? v\n        : {\n          ...v,\n          at: Date.now(),\n        }\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const last = ts.at(-1)!;\n\n    if (this.storeIntermediate) this.values.push(...ts);\n    else switch (this.values.length) {\n      case 0: {\n        // Add as initial value\n        this.values.push(last);\n        break;\n      }\n      case 1: {\n        // Add last value\n        this.values.push(last);\n        break;\n      }\n      case 2: {\n        // Replace last value\n        this.values[ 1 ] = last;\n        break;\n      }\n    }\n    return ts;\n  }\n\n  /**\n   * Last seen value. If no values have been added, it will return the initial value\n   */\n  get last() {\n    if (this.values.length === 1) return this.values[ 0 ];\n    //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.values.at(-1)!;\n  }\n\n  /**\n   * Returns the initial value\n   */\n  get initial() {\n    return this.values.at(0);\n  }\n\n  /**\n   * Returns number of recorded values (includes the initial value in the count)\n   */\n  get size() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the elapsed time, in milliseconds since the initial value\n   */\n  get elapsed(): number {\n    return Date.now() - this.values[ 0 ].at;\n  }\n\n}\n","import * as Points from '../geometry/point/index.js';\nimport {\n  TrackedValueMap,\n  type TrackedValueOpts as TrackOpts,\n  type TimestampedObject,\n} from './TrackedValue.js';\nimport { ObjectTracker } from './ObjectTracker.js';\nimport { length as LineLength } from '../geometry/line/Length.js';\nimport { Vectors } from '../geometry/index.js';\nimport { Empty as LinesEmpty } from '../geometry/line/index.js';\nimport type { Coord as PolarCoord } from '../geometry/Polar.js';\nimport type { Line, PolyLine } from '../geometry/line/LineType.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport type { PointRelation } from '../geometry/point/PointRelationTypes.js';\nimport { joinPointsToLines } from '../geometry/line/JoinPointsToLines.js';\nimport type { PointTrack, PointTrackerResults } from './Types.js';\n\n/**\n * Point tracker. Create via `pointTracker()`.\n *\n */\nexport class PointTracker extends ObjectTracker<Point, PointTrackerResults> {\n  /**\n   * Function that yields the relation from initial point\n   */\n  initialRelation: PointRelation | undefined;\n\n  /**\n   * Last result\n   */\n  lastResult: PointTrackerResults | undefined;\n\n  constructor(opts: TrackOpts = {}) {\n    super(opts);\n  }\n\n  onTrimmed(): void {\n    // Force new relation calculations\n    this.initialRelation = undefined;\n  }\n\n  /**\n   * Returns the last x coord\n   */\n  get x() {\n    return this.last.x;\n  }\n\n  /**\n   * Returns the last y coord\n   */\n  get y() {\n    return this.last.y;\n  }\n\n  /**\n   * @ignore\n   */\n  onReset(): void {\n    super.onReset();\n    this.lastResult = undefined;\n    this.initialRelation = undefined;\n  }\n\n  seenEvent(p: PointerEvent): PointTrackerResults {\n    if (`getCoalescedEvents` in p) {\n      const events = p.getCoalescedEvents();\n      const asPoints = events.map(event => ({ x: event.clientX, y: event.clientY }));\n      return this.seen(...asPoints);\n    } else {\n      // @ts-expect-error\n      return this.seen({ x: p.clientX, y: p.clientY });\n    }\n  }\n\n  /**\n   * Tracks a point, returning data on its relation to the\n   * initial point and the last received point.\n   * \n   * Use {@link seenEvent} to track a raw `PointerEvent`.\n   * \n   * @param _p Point\n   */\n  computeResults(\n    _p: Array<TimestampedObject<Point>>\n  ): PointTrackerResults {\n    const currentLast = this.last;\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const previousLast = this.values.at(-2);\n\n    if (this.initialRelation === undefined && this.initial) {\n      // Don't yet have an initial relation function\n      this.initialRelation = Points.relation(this.initial);\n    } else if (this.initialRelation === undefined) {\n      // Don't have an initial relation, but also don't have an initial point :()\n      throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);\n    }\n\n    // Make a new relator based on previous point\n    const lastRelation = previousLast === undefined ? Points.relation(currentLast) : Points.relation(previousLast);\n\n    // Compute relation from initial point to latest\n    const initialRel: PointTrack = this.initialRelation(currentLast);\n\n    const speed = previousLast === undefined ? 0 : LineLength(previousLast, currentLast) / (currentLast.at - previousLast.at);\n\n    // Compute relation from current point to the previous\n    const lastRel: PointTrack = {\n      ...lastRelation(currentLast),\n      speed,\n    };\n\n    const r: PointTrackerResults = {\n      fromInitial: initialRel,\n      fromLast: lastRel,\n      values: [ ...this.values ],\n    };\n    this.lastResult = r;\n    return r;\n  }\n\n  /**\n   * Returns a polyline representation of stored points.\n   * Returns an empty array if points were not saved, or there's only one.\n   */\n  get line(): PolyLine {\n    if (this.values.length === 1) return [];\n    return joinPointsToLines(...this.values);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a polar coordinate\n   */\n  get vectorPolar(): PolarCoord {\n    return Vectors.fromLinePolar(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a Cartesian coordinate\n   */\n  get vectorCartesian(): Point {\n    return Vectors.fromLineCartesian(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a line from initial point to last point.\n   *\n   * If there are less than two points, Lines.Empty is returned\n   */\n  get lineStartEnd(): Line {\n    const initial = this.initial;\n    if (this.values.length < 2 || !initial) return LinesEmpty;\n    return {\n      a: initial,\n      b: this.last,\n    };\n  }\n\n  /**\n   * Returns distance from latest point to initial point.\n   * If there are less than two points, zero is returned.\n   *\n   * This is the direct distance from initial to last,\n   * not the accumulated length.\n   * @returns Distance\n   */\n  distanceFromStart(): number {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? Points.distance(initial, this.last) : 0;\n  }\n\n  /**\n   * Difference between last point and the initial point, calculated\n   * as a simple subtraction of x & y.\n   *\n   * `Points.Placeholder` is returned if there's only one point so far.\n   */\n  difference(): Point {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? Points.subtract(this.last, initial) : Points.Placeholder;\n  }\n\n  /**\n   * Returns angle (in radians) from latest point to the initial point\n   * If there are less than two points, undefined is return.\n   * @returns Angle in radians\n   */\n  angleFromStart(): number | undefined {\n    const initial = this.initial;\n    if (initial !== undefined && this.values.length > 2) {\n      return Points.angle(initial, this.last);\n    }\n  }\n\n  /**\n   * Returns the total length of accumulated points.\n   * Returns 0 if points were not saved, or there's only one\n   */\n  get length(): number {\n    if (this.values.length === 1) return 0;\n    const l = this.line;\n    return LineLength(l);\n  }\n}\n\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport class TrackedPointMap extends TrackedValueMap<\n  Point,\n  PointTracker,\n  PointTrackerResults\n> {\n  constructor(opts: TrackOpts = {}) {\n    super((key, start) => {\n      if (start === undefined) throw new Error(`Requires start point`);\n      const p = new PointTracker({\n        ...opts,\n        id: key,\n      });\n      p.seen(start);\n      return p;\n    });\n  }\n\n  /**\n   * Track a PointerEvent\n   * @param event\n   */\n  seenEvent(event: PointerEvent): Promise<Array<PointTrackerResults>> {\n    if (`getCoalescedEvents` in event) {\n      const events = event.getCoalescedEvents();\n      const seens = events.map(subEvent => super.seen(subEvent.pointerId.toString(), subEvent));\n      return Promise.all(seens);\n    } else {\n      // eslint-disable-next-line unicorn/no-single-promise-in-promise-methods\n      return Promise.all([ super.seen((event as PointerEvent).pointerId.toString(), event) ]);\n    }\n  }\n}\n\n/**\n * Track several named points over time, eg a TensorFlow body pose point.\n * Call `seen()` to track a point. Mutable. If you want to compare\n * a single coordinate with a reference coordinate,  may be a better choice.\n *\n * See also:\n * * [Geometry.Points.relation](Geometry.Points.relation.html): Compute relation info between two points\n * * [Data.pointTracker](Data.pointTracker-1.html): Track relation between points over time\n * * [Guide to Trackers](https://clinth.github.io/ixfx-docs/data/trackers/)\n * \n * Basic usage\n * ```js\n * import { pointsTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const pt = pointsTracker();\n *\n * // Track a point under a given id\n * document.addEventListener(`pointermove`, e => {\n *  const info = await pt.seen(e.pointerId, { x: e.x, y: e.y });\n *  // Yields some info on relation of the point to initial value\n * });\n * ```\n *\n * Do something with last values for all points\n * ```js\n * const c = Points.centroid(...Array.from(pt.last()));\n * ```\n *\n * More functions...\n * ```js\n * pt.size;       // How many named points are being tracked\n * pt.delete(id); // Delete named point\n * pt.reset();    // Clear data\n * ```\n *\n * Accessing by id:\n *\n * ```js\n * pt.get(id);  // Get named point (or _undefined_)\n * pt.has(id);  // Returns true if id exists\n * ```\n *\n * Iterating over data\n *\n * ```js\n * pt.trackedByAge(); // Iterates over tracked points, sorted by age (oldest first)\n * pt.tracked(); // Tracked values\n * pt.ids();     // Iterator over ids\n *\n * // Last received value for each named point\n * pt.last();\n *\n * pt.initialValues(); // Iterator over initial values for each point\n * ```\n *\n * You can work with 'most recently updated' points:\n *\n * ```js\n * // Iterates over points, sorted by age (oldest first)\n * pt.valuesByAge();\n * ```\n *\n * Options:\n * * `id`: Id of this tracker. Optional\n * * `sampleLimit`: How many samples to store\n * * `storeIntermediate`: If _true_, all points are stored internally\n * * `resetAfterSamples`: If set above 0, it will automatically reset after the given number of samples have been seen\n * @param opts\n * @returns\n */\nexport const pointsTracker = (opts: TrackOpts = {}) =>\n  new TrackedPointMap(opts);\n\n/**\n * A tracked point. Create via {@link pointTracker}. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link pointsTracker}: Track several points, useful for multi-touch.\n * * [Guide to Trackers](https://clinth.github.io/ixfx-docs/data/trackers/)\n * \n * ```js\n * import { pointTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Create a tracker on a pointerdown\n * const t = pointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = pointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = pointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = pointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport const pointTracker = (opts: TrackOpts = {}) => new PointTracker(opts);\n","import { SimpleEventEmitter } from '../Events.js';\nimport * as Debug from '../debug/index.js';\n/**\n * Policy for when the pool is fully used\n */\nexport type FullPolicy = `error` | `evictOldestUser`;\n\n/**\n * Pool options\n */\nexport type Opts<V> = {\n  /**\n   * Maximum number of resources for this pool\n   */\n  readonly capacity?: number;\n  /**\n   * If above 0, users will be removed if there is no activity after this interval.\n   * Activity is marked whenever `use` us called with that user key.\n   * Default: disabled\n   */\n  readonly userExpireAfterMs?: number;\n  /**\n   * If above 0, resources with no users will be automatically removed after this interval.\n   * Default: disabled\n   */\n  readonly resourcesWithoutUserExpireAfterMs?: number;\n  /**\n   * Maximum number of users per resource. Defaults to 1\n   */\n  readonly capacityPerResource?: number;\n  /**\n   * What to do if pool is full and a new resource allocation is requested.\n   * Default is `error`, throwing an error when pool is full.\n   */\n  readonly fullPolicy?: FullPolicy;\n  /**\n   * If true, additional logging will trace activity of pool.\n   * Default: false\n   */\n  readonly debug?: boolean;\n  /**\n   * If specified, this function will generate new resources as needed.\n   */\n  readonly generate?: () => V;\n  /**\n   * If specified, this function will be called when a resource is disposed\n   */\n  readonly free?: (v: V) => void;\n};\n\n/**\n * Function that initialises a pool item\n */\n//export type InitPoolItem_ = <V>(id:string)=>V;\n\n/**\n * State of pool\n */\nexport type PoolState = `idle` | `active` | `disposed`;\n\nexport type PoolUserEventMap<V> = {\n  readonly disposed: { readonly data: V; readonly reason: string };\n  readonly released: { readonly data: V; readonly reason: string };\n};\n\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport class PoolUser<V> extends SimpleEventEmitter<PoolUserEventMap<V>> {\n  private _lastUpdate: number;\n  private _pool: Pool<V>;\n  private _state: PoolState;\n  private _userExpireAfterMs: number;\n\n  /**\n   * Constructor\n   * @param key User key\n   * @param resource Resource being used\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  constructor(readonly key: string, readonly resource: Resource<V>) {\n    super();\n    this._lastUpdate = performance.now();\n    this._pool = resource.pool;\n    this._userExpireAfterMs = this._pool.userExpireAfterMs;\n    this._state = `idle`;\n    this._pool.log.log(`PoolUser ctor key: ${ this.key }`);\n  }\n\n  /**\n   * Returns a human readable debug string\n   * @returns\n   */\n  toString() {\n    if (this.isDisposed) return `PoolUser. State: disposed`;\n\n    return `PoolUser. State: ${ this._state } Elapsed: ${ performance.now() - this._lastUpdate } Data: ${ JSON.stringify(this.resource.data) }`;\n  }\n\n  /**\n   * Resets countdown for instance expiry.\n   * Throws an error if instance is disposed.\n   */\n  keepAlive() {\n    if (this._state === `disposed`) throw new Error(`PoolItem disposed`);\n    this._lastUpdate = performance.now();\n  }\n\n  /**\n   * @internal\n   * @param reason\n   * @returns\n   */\n  _dispose(reason: string, data: V) {\n    if (this._state === `disposed`) return;\n    const resource = this.resource;\n    //const data = resource.data;\n    this._state = `disposed`;\n    resource._release(this);\n    this._pool.log.log(`PoolUser dispose key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`disposed`, { data, reason });\n    super.clearEventListeners();\n  }\n\n  /**\n   * Release this instance\n   * @param reason\n   */\n  release(reason: string) {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    const resource = this.resource;\n    const data = resource.data;\n    this._pool.log.log(`PoolUser release key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`released`, { data, reason });\n    this._dispose(`release-${ reason }`, data);\n  }\n\n  // #region Properties\n  get data(): V {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    return this.resource.data;\n  }\n\n  /**\n   * Returns true if this instance has expired.\n   * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n   */\n  get isExpired() {\n    if (this._userExpireAfterMs > 0) {\n      return performance.now() > this._lastUpdate + this._userExpireAfterMs;\n    }\n    return false;\n  }\n\n  /**\n   * Returns elapsed time since last 'update'\n   */\n  get elapsed() {\n    return performance.now() - this._lastUpdate;\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this._state === `disposed`;\n  }\n\n  /**\n   * Returns true if instance is neither disposed nor expired\n   */\n  get isValid() {\n    if (this.isDisposed || this.isExpired) return false;\n    if (this.resource.isDisposed) return false;\n    return true;\n  }\n  // #endregion\n}\n\n/**\n * A resource allocated in the Pool\n */\nexport class Resource<V> {\n  #state: PoolState;\n  #data: V;\n  #users: Array<PoolUser<V>>;\n  readonly #capacityPerResource;\n  readonly #resourcesWithoutUserExpireAfterMs;\n  #lastUsersChange: number;\n\n  /**\n   * Constructor.\n   * @param pool Pool\n   * @param data Data\n   */\n  constructor(readonly pool: Pool<V>, data: V) {\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    if (pool === undefined) throw new Error(`Parameter 'pool' is undefined`);\n\n    this.#data = data;\n    this.#lastUsersChange = 0;\n    this.#resourcesWithoutUserExpireAfterMs =\n      pool.resourcesWithoutUserExpireAfterMs;\n    this.#capacityPerResource = pool.capacityPerResource;\n    this.#users = [];\n    this.#state = `idle`;\n  }\n\n  /**\n   * Gets data associated with resource.\n   * Throws an error if disposed\n   */\n  get data() {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    return this.#data;\n  }\n\n  /**\n   * Changes the data associated with this resource.\n   * Throws an error if disposed or `data` is undefined.\n   * @param data\n   */\n  updateData(data: V) {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    this.#data = data;\n  }\n\n  /**\n   * Returns a human-readable debug string for resource\n   * @returns\n   */\n  toString() {\n    return `Resource (expired: ${ this.isExpiredFromUsers } users: ${ this.#users.length }, state: ${ this.#state }) data: ${ JSON.stringify(this.data) }`;\n  }\n\n  /**\n   * Assigns a user to this resource.\n   * @internal\n   * @param user\n   */\n  _assign(user: PoolUser<V>) {\n    const existing = this.#users.find((u) => u === user || u.key === user.key);\n    if (existing) throw new Error(`User instance already assigned to resource`);\n    this.#users.push(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Releases a user from this resource\n   * @internal\n   * @param user\n   */\n  _release(user: PoolUser<V>) {\n    this.#users = this.#users.filter((u) => u !== user);\n    this.pool._release(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Returns true if resource can have additional users allocated\n   */\n  get hasUserCapacity() {\n    return this.usersCount < this.#capacityPerResource;\n  }\n\n  /**\n   * Returns number of uses of the resource\n   */\n  get usersCount() {\n    return this.#users.length;\n  }\n\n  /**\n   * Returns true if automatic expiry is enabled, and that interval\n   * has elapsed since the users list has changed for this resource\n   */\n  get isExpiredFromUsers() {\n    if (this.#resourcesWithoutUserExpireAfterMs <= 0) return false;\n    if (this.#users.length > 0) return false;\n    return (\n      performance.now() >\n      this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange\n    );\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this.#state === `disposed`;\n  }\n\n  /**\n   * Disposes the resource.\n   * If it is already disposed, it does nothing.\n   * @param reason\n   * @returns\n   */\n  dispose(reason: string) {\n    if (this.#state === `disposed`) return;\n    const data = this.#data;\n    this.#state = `disposed`;\n    this.pool.log.log(`Resource disposed (${ reason })`);\n    for (const u of this.#users) {\n      u._dispose(`resource-${ reason }`, data);\n    }\n    this.#users = [];\n    this.#lastUsersChange = performance.now();\n    this.pool._releaseResource(this, reason);\n\n    if (this.pool.freeResource) this.pool.freeResource(data);\n  }\n}\n\n/**\n * Resource pool\n */\nexport class Pool<V> {\n  private _resources: Array<Resource<V>>;\n  private _users: Map<string, PoolUser<V>>;\n\n  readonly capacity: number;\n  readonly userExpireAfterMs: number;\n  readonly resourcesWithoutUserExpireAfterMs: number;\n\n  readonly capacityPerResource: number;\n  readonly fullPolicy: FullPolicy;\n  private generateResource?: () => V;\n  readonly freeResource?: (v: V) => void;\n\n  readonly log: Debug.LogSet;\n\n  /**\n   * Constructor.\n   *\n   * By default, no capacity limit, one user per resource\n   * @param opts Pool options\n   */\n  constructor(opts: Opts<V> = {}) {\n    this.capacity = opts.capacity ?? -1;\n    this.fullPolicy = opts.fullPolicy ?? `error`;\n    this.capacityPerResource = opts.capacityPerResource ?? 1;\n    this.userExpireAfterMs = opts.userExpireAfterMs ?? -1;\n    this.resourcesWithoutUserExpireAfterMs =\n      opts.resourcesWithoutUserExpireAfterMs ?? -1;\n\n    this.generateResource = opts.generate;\n    this.freeResource = opts.free;\n\n    this._users = new Map();\n    this._resources = [];\n\n    this.log = Debug.logSet(`Pool`, opts.debug ?? false);\n\n    // If we have a time-based expiry, set an interval to\n    // automatically do the housekeeping\n    const timer = Math.max(\n      this.userExpireAfterMs,\n      this.resourcesWithoutUserExpireAfterMs\n    );\n    if (timer > 0) {\n      setInterval(() => {\n        this.maintain();\n      }, timer * 1.1);\n    }\n  }\n\n  /**\n   * Returns a debug string of Pool state\n   * @returns\n   */\n  dumpToString() {\n    //eslint-disable-next-line functional/no-let\n    let r = `Pool\n    capacity: ${ this.capacity } userExpireAfterMs: ${ this.userExpireAfterMs } capacityPerResource: ${ this.capacityPerResource }\n    resources count: ${ this._resources.length }`;\n\n    const resource = this._resources.map((r) => r.toString()).join(`\\r\\n\\t`);\n    r += `\\r\\nResources:\\r\\n\\t` + resource;\n\n    r += `\\r\\nUsers: \\r\\n`;\n    for (const [ k, v ] of this._users.entries()) {\n      r += `\\tk: ${ k } v: ${ v.toString() }\\r\\n`;\n    }\n    return r;\n  }\n\n  /**\n   * Sorts users by longest elapsed time since update\n   * @returns\n   */\n  getUsersByLongestElapsed() {\n    return [ ...this._users.values() ].sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa < bb) return 1;\n      return -1;\n    });\n  }\n\n  /**\n   * Returns resources sorted with least used first\n   * @returns\n   */\n  getResourcesSortedByUse() {\n    return [ ...this._resources ].sort((a, b) => {\n      if (a.usersCount === b.usersCount) return 0;\n      if (a.usersCount < b.usersCount) return -1;\n      return 1;\n    });\n  }\n\n  /**\n   * Adds a resource to the pool.\n   * Throws an error if the capacity limit is reached.\n   * @param resource\n   * @returns\n   */\n  addResource(resource: V) {\n    if (resource === undefined) {\n      throw new Error(`Cannot add undefined resource`);\n    }\n    if (resource === null) throw new Error(`Cannot add null resource`);\n\n    if (this.capacity > 0 && this._resources.length === this.capacity) {\n      throw new Error(\n        `Capacity limit (${ this.capacity }) reached. Cannot add more.`\n      );\n    }\n\n    this.log.log(`Adding resource: ${ JSON.stringify(resource) }`);\n    const pi = new Resource<V>(this, resource);\n    this._resources.push(pi);\n    return pi;\n  }\n\n  /**\n   * Performs maintenance, removing disposed/expired resources & users.\n   * This is called automatically when using a resource.\n   */\n  maintain() {\n    //eslint-disable-next-line functional/no-let\n    let changed = false;\n\n    // Find all disposed resources\n    const nuke: Array<Resource<V>> = [];\n    for (const p of this._resources) {\n      if (p.isDisposed) {\n        this.log.log(`Maintain, disposed resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      } else if (p.isExpiredFromUsers) {\n        this.log.log(`Maintain, expired resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      }\n    }\n\n    // Remove them\n    if (nuke.length > 0) {\n      for (const resource of nuke) {\n        resource.dispose(`diposed/expired`);\n      }\n      changed = true;\n    }\n\n    // Find 'users' to clean up\n    const userKeysToRemove: Array<string> = [];\n    for (const [ key, user ] of this._users.entries()) {\n      if (!user.isValid) {\n        this.log.log(\n          `Maintain. Invalid user: ${ user.key } (Disposed: ${ user.isDisposed } Expired: ${ user.isExpired } Resource disposed: ${ user.resource.isDisposed })`\n        );\n\n        userKeysToRemove.push(key);\n        user._dispose(`invalid`, user.data);\n      }\n    }\n\n    for (const userKey of userKeysToRemove) {\n      this._users.delete(userKey);\n      changed = true;\n    }\n\n    if (changed) {\n      this.log.log(\n        `End: resource len: ${ this._resources.length } users: ${ this.usersLength }`\n      );\n    }\n  }\n\n  /**\n   * Iterate over resources in the pool.\n   * To iterate over the data associated with each resource, use\n   * `values`.\n   */\n  *resources() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r;\n    }\n  }\n\n  /**\n   * Iterate over resource values in the pool.\n   * to iterate over the resources, use `resources`.\n   *\n   * Note that values may be returned even though there is no\n   * active user.\n   */\n  *values() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r.data;\n    }\n  }\n\n  /**\n   * Unassociate a key with a pool item\n   * @param userKey\n   */\n  release(userKey: string, reason?: string): void {\n    const pi = this._users.get(userKey);\n    if (!pi) return;\n    pi.release(reason ?? `Pool.release`);\n  }\n\n  /**\n   * @internal\n   * @param user\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _release(user: PoolUser<V>) {\n    this._users.delete(user.key);\n  }\n\n  /**\n   * @internal\n   * @param resource\n   * @param _\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _releaseResource(resource: Resource<V>, _: string) {\n    this._resources = this._resources.filter((v) => v !== resource);\n  }\n\n  /**\n   * Returns true if `v` has an associted resource in the pool\n   * @param resource\n   * @returns\n   */\n  hasResource(resource: V): boolean {\n    const found = this._resources.find((v) => v.data === resource);\n    return found !== undefined;\n  }\n\n  /**\n   * Returns true if a given `userKey` is in use.\n   * @param userKey\n   * @returns\n   */\n  hasUser(userKey: string): boolean {\n    return this._users.has(userKey);\n  }\n\n  /**\n   * @internal\n   * @param key\n   * @param resource\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  private _assign(key: string, resource: Resource<V>) {\n    const u = new PoolUser<V>(key, resource);\n    this._users.set(key, u);\n    resource._assign(u);\n    return u;\n  }\n\n  /**\n   * @internal\n   * @param userKey\n   * @returns\n   */\n  private _findUser(userKey: string): PoolUser<V> | undefined {\n    // Sort items by number of users per pool item\n    const sorted = this.getResourcesSortedByUse();\n    //eslint-disable-next-line functional/no-let\n    // for (let i=0;i<sorted.length;i++) {\n    //   console.log(i +`. users: ` + sorted[i].usersCount);\n    // }\n    if (sorted.length > 0 && sorted[ 0 ].hasUserCapacity) {\n      // No problem, resource has capacity\n      //this.log.log(`resource has capacity: ${ sorted[ 0 ].data }`);\n      const u = this._assign(userKey, sorted[ 0 ]);\n      return u;\n    }\n\n    // If resource count is below capacity, can we generate more?\n    if (\n      this.generateResource &&\n      (this.capacity < 0 || this._resources.length < this.capacity)\n    ) {\n      this.log.log(\n        `capacity: ${ this.capacity } resources: ${ this._resources.length }`\n      );\n      const resourceGenerated = this.addResource(this.generateResource());\n      const u = this._assign(userKey, resourceGenerated);\n      return u;\n    }\n  }\n\n  /**\n   * Return the number of users\n   */\n  get usersLength() {\n    return [ ...this._users.values() ].length;\n  }\n\n  /**\n   * 'Uses' a resource, returning the value\n   * @param userKey\n   * @returns\n   */\n  useValue(userKey: string): V {\n    const resource = this.use(userKey);\n    return resource.resource.data;\n  }\n\n  /**\n   * Gets a pool item based on a user key.\n   * The same key should return the same pool item,\n   * for as long as it still exists.\n   * @param userKey\n   * @returns\n   */\n  use(userKey: string): PoolUser<V> {\n    const pi = this._users.get(userKey);\n    if (pi) {\n      pi.keepAlive();\n      return pi;\n    }\n\n    this.maintain();\n\n    const match = this._findUser(userKey);\n    if (match) return match;\n\n    // Throw an error if all items are being used\n    if (this.fullPolicy === `error`) {\n      //console.log(this.dumpToString());\n      throw new Error(\n        `Pool is fully used (fullPolicy: ${ this.fullPolicy }, capacity: ${ this.capacity })`\n      );\n    }\n    // Evict oldest user\n    if (this.fullPolicy === `evictOldestUser`) {\n      const users = this.getUsersByLongestElapsed();\n      if (users.length > 0) {\n        this.release(users[ 0 ].key, `evictedOldestUser`);\n\n        const match2 = this._findUser(userKey);\n        if (match2) return match2;\n      }\n    }\n\n    // Evict newest user\n\n    // Evict from random pool item\n    throw new Error(`Pool is fully used (${ this.fullPolicy })`);\n  }\n}\n\n/**\n * Creates an instance of a Pool\n * @param opts\n * @returns\n */\nexport const create = <V>(opts: Opts<V> = {}): Pool<V> => new Pool<V>(opts);\n","import { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { type NumberFunction } from './Types.js';\n\n/**\n * Scales a percentage-scale number, ie: `v * t`.\n * The utility of this function is that it sanity-checks that\n *  both parameters are in the 0..1 scale.\n * @param v Value\n * @param t Scale amount\n * @returns Scaled value\n */\nexport const proportion = (\n  v: number | NumberFunction,\n  t: number | NumberFunction\n) => {\n  if (typeof v === `function`) v = v();\n  if (typeof t === `function`) t = t();\n\n  throwNumberTest(v, `percentage`, `v`);\n  throwNumberTest(t, `percentage`, `t`);\n  return v * t;\n};\n","import * as Rx from '../rx/index.js';\nimport { type PrimitiveOrObject } from \"../PrimitiveTypes.js\";\nimport { isPrimitive } from '../IsPrimitive.js';\nimport { mapObjectShallow } from './MapObject.js';\n\ntype ValueType = string | number | boolean | object\n\ntype FunctionType<V> = (() => V) | (() => Promise<V>);\ntype ValueOrFunction<V> = ValueType | FunctionType<V> | Iterator<V> | AsyncIterator<V>;\nexport type Resolvable<V> = Promise<V> | Rx.Reactive<V> | Generator<V> | AsyncGenerator<V> | IterableIterator<V> | AsyncIterableIterator<V> | ((args: any) => V)\n\nexport type PullRecord<T extends Record<string, PrimitiveOrObject | (() => any) | Rx.Reactive<any>>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number | undefined :\n    T[ K ] extends string ? string | undefined :\n    T[ K ] extends boolean ? boolean | undefined :\n    T[ K ] extends bigint ? bigint | undefined :\n    T[ K ] extends () => Promise<any> ? Awaited<ReturnType<T[ K ]>> :\n    T[ K ] extends () => any ? ReturnType<T[ K ]> :\n    T[ K ] extends Rx.Reactive<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    T[ K ] extends object ? T[ K ] :\n    never };\n\nexport type PullRecordWithInitial<T extends Record<string, PrimitiveOrObject | (() => any) | Rx.Reactive<any>>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number :\n    T[ K ] extends string ? string :\n    T[ K ] extends boolean ? boolean :\n    T[ K ] extends bigint ? bigint :\n    T[ K ] extends () => Promise<any> ? Awaited<ReturnType<T[ K ]>> :\n    T[ K ] extends () => any ? ReturnType<T[ K ]> :\n    T[ K ] extends Rx.Reactive<infer V> ? V :\n    T[ K ] extends Generator<infer V> ? V :\n    T[ K ] extends AsyncGenerator<infer V> ? V :\n    T[ K ] extends IterableIterator<infer V> ? V :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V :\n    T[ K ] extends Array<infer V> ? V :\n    T[ K ] extends object ? T[ K ] :\n    never };\n\nexport type ResolveValue<V> =\n  V extends () => Promise<any> ? Awaited<ReturnType<V>> :\n  V extends () => any ? ReturnType<V> :\n  V extends Iterator<object> ? object :\n  V extends Iterator<number> ? number :\n  V extends Iterator<string> ? string :\n  V extends Iterator<boolean> ? boolean :\n  V extends AsyncIterator<object> ? object :\n  V extends AsyncIterator<number> ? number :\n  V extends AsyncIterator<string> ? string :\n  V extends AsyncIterator<boolean> ? boolean :\n  V extends ValueType ? V : never;\n\nexport type ResolvedObject<V> = Readonly<{\n  [ key in keyof V ]: ResolveValue<V[ key ]>\n}>\n\nasync function resolveValue<V extends ValueType>(valueOrFunction: ValueOrFunction<V>): Promise<V> {\n  if (typeof valueOrFunction === `object` && `next` in valueOrFunction) {\n    const v = await valueOrFunction.next();\n    return v.value as V;\n  }\n  if (typeof valueOrFunction === `function`) {\n    const v = await valueOrFunction() as V;\n    return v;\n  }\n  return valueOrFunction as V;\n}\n\n// const object = {\n//   name: `blah`,\n//   gen: count(5)\n// }\n// const c = resolveValue(count(5));\n// const cc = resolveFields(object);\n// cc.gen\n\n/**\n * Returns a copy of `object`, with the same properties. For each property\n * that has a basic value (string, number, boolean, object), the value is set\n * for the return object. If the property is a function or generator, its value\n * is used instead. Async functions and generators are also usable.\n * \n * In the below example, the function for the property `random` is invoked.\n * ```js\n * const state = {\n *  length: 10,\n *  random: () => Math.random();\n * }\n * const x = resolveFields(state);\n * // { length: 10, random: 0.1235 }\n * ```\n * \n * It also works with generators\n * ```js\n * import { count } from './numbers.js';\n * \n * const state = {\n *  length: 10,\n *  index: count(2) // Generator that yields: 0, 1 and then ends\n * }\n * resolveFields(state); // { length: 10, index: 0 }\n * resolveFields(state); // { length: 10, index: 1 }\n * // Generator finishes after counting twice:\n * resolveFields(state); // { length: 10, index: undefined }\n * ```\n * @param object \n * @returns \n */\nexport async function fieldResolve<V extends object>(object: V): Promise<ResolvedObject<V>> {\n  const output = [];\n  for (const entry of Object.entries(object)) {\n    const key = entry[ 0 ];\n    const valueOrFunction = entry[ 1 ] as ValueOrFunction<typeof entry[ 1 ]>;\n    const value = await resolveValue(valueOrFunction);\n    output.push([ key, value ]);\n  }\n  return Object.fromEntries(output) as ResolvedObject<V>;\n}\n\n/**\n * Returns a function that resolves `object`.\n * \n * Use {@link fieldResolve} to resolve an object directly.\n * @param object \n * @returns \n */\nexport function fieldResolver<V extends object>(object: V) {\n  return () => fieldResolve(object);\n}\n\ntype Updated<Type extends Record<string, any>> = Partial<{\n  [ Property in keyof Type ]: Resolvable<Type[ Property ]> | Updated<Type[ Property ]>\n}>\n\n/**\n * Given an starting data-shape, `reactiveUpdate` allows you to selectively update\n * fields or use a structured set of functions to update fields on-demand.\n * \n * \n * ```js\n * // Shape of the data to update & default values\n * let state = {\n *  size: 0,\n *  text: `s_orig`,\n *  missing: false\n * }\n * \n * // We want to update `size` and `text` fields on-demand (ie when .fetch is called)\n * const updaters = {\n *  size: () => Math.random(),\n *  text: () => `1`,\n * }\n * // Put them together\n * const r = Data.reactiveUpdate(state, updaters);\n * \n * // Fetch a value, triggering updaters\n * state = await r.fetch();\n * \n * // Get the last value witout triggering\n * state = await r.last();\n * ```\n * \n * Data can be updated manually:\n * ```js\n * // Update just the value of the 'missing' field\n * r.update( { missing: true });\n * ```\n * \n * You can subscribe to changes to the object using `onValue`, `onDiff` & `onField`\n * \n * ```js\n * r.onValue(value => {\n *  // Snapshot of whole data when anything changes\n * });\n * \n * r.onDiff(diff => {\n *  // Set of changes that have been made\n * });\n * \n * r.onField(`size`, value => {\n *  // Notified only when 'size' field changes\n * });\n * ```\n * Caveats:\n * * Updaters cannot be nested (ie a deeper object strcture)\n * \n * @param schema \n * @param updaters \n * @returns \n * */\nexport function reactiveUpdate<S extends Record<string, PrimitiveOrObject>>(schema: S, updaters?: Updated<S>) {\n  const current = Rx.From.object<S>(schema);\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  let fetch = async (): Promise<S> => { return current.last() };\n\n  let replaceSource = (field: Extract<keyof S, string>, source: Resolvable<any>, disposeOld: boolean) => { /** no-op */ }\n\n  const applyNewData = (data: Partial<S>): S => {\n    return current.update(data);\n  }\n\n  if (updaters !== undefined) {\n    const rx = pull(updaters as Required<S>);\n    fetch = async (): Promise<S> => {\n      const data = await rx.compute() as Partial<S>;\n      return applyNewData(data);\n    }\n    replaceSource = rx.replaceSource;\n  }\n  return { ...current, pull: fetch, replaceSource }\n}\n\nexport type ReactiveUpdate<T> = {\n  source?: Resolvable<T>\n  //factory?: () => Resolvable<T>\n  value: T\n}\n\n\n/**\n * Given an key-value set of values or {@link Resolvable}, manually pull a composite set of values from it.\n * ```js\n * const data = {\n *  name: `ace`,\n *  x: Math.random,\n * }\n * const p = pull(data);\n * \n * const v = await p.compute(); // Yields: { name: `ace`, x: 0.213 }\n * ```\n * \n * A {@link Resolveable} is a function, generator/iterable, promise or Reactive.\n * \n * It's also possible to replace a source by key\n * ```js\n * p.replaceSource(`x`, () => { Math.random() / 2 });\n * ```\n * @param value \n * @returns \n */\nexport function pull<T extends Record<string, PrimitiveOrObject | Resolvable<any>>>(value: T): {\n  replaceSource: (field: Extract<keyof T, string>, source: Resolvable<any>, disposeOld: boolean) => Rx.Reactive<any> | PrimitiveOrObject | Function,\n  compute: () => Promise<PullRecord<T>>,\n  dispose: () => void,\n  last: () => Partial<PullRecord<T>>\n} {\n  const sources: Record<string, Rx.Reactive<any>> = {};\n  const fixedValues: Record<string, Array<any> | PrimitiveOrObject> = {};\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  const callers: Record<string, Function | (() => any)> = {};\n\n  const setSource = (field: string, source: Resolvable<any> | PrimitiveOrObject) => {\n    if (Array.isArray(source) || isPrimitive(source)) {\n      fixedValues[ field ] = source;\n    } else if (typeof source === `function`) {\n      callers[ field ] = source;\n    } else {\n      try {\n        const s = Rx.resolveSource(source as any);\n        latestToObjectRx.replaceSource(field, s);\n      } catch {\n        fixedValues[ field ] = source;\n      }\n    }\n  }\n\n  const removeSource = (field: string, disposeOld: boolean): Rx.Reactive<any> | PrimitiveOrObject | Function => {\n    if (field in sources) {\n      const s = sources[ field ];\n      delete sources[ field ];\n      if (disposeOld) s.dispose(`ResolveFields.pull.removeSource`);\n      return s;\n    } else if (field in fixedValues) {\n      const s = fixedValues[ field ];\n      delete fixedValues[ field ];\n      return s;\n    } else if (field in callers) {\n      const s = callers[ field ];\n      delete callers[ field ];\n      return s;\n    } else throw new Error(`Field '${ field }' not found`);\n  }\n\n  for (const [ key, v ] of Object.entries(value)) {\n    setSource(key, v);\n  }\n\n  // Merge sources to one Rx\n  const latestToObjectRx = Rx.combineLatestToObject(sources, { onSourceDone: `allow` });\n  let lastRxValue: Record<string, any> | undefined;\n  const latestToObjectOff = latestToObjectRx.onValue(v => {\n    lastRxValue = v;\n  });\n\n  const computeCallers = async () => {\n    const r = {};\n    for (const [ key, value ] of Object.entries(callers)) {\n      (r as any)[ key ] = await value();\n    }\n    return r;\n  }\n\n  let lastComputed: PullRecord<T> = mapObjectShallow<T, undefined>(value, args => {\n    return undefined;\n  }) as PullRecord<T>;\n\n  const compute = async () => {\n    lastComputed = { ...fixedValues, ...lastRxValue, ...(await computeCallers()) } as PullRecord<T>;\n    return lastComputed;\n  }\n\n  const dispose = () => {\n    latestToObjectOff();\n    latestToObjectRx.dispose(`ResolveFields.dispose`);\n  }\n  return {\n    last: () => lastComputed,\n    compute,\n    dispose,\n    /**\n     * Replaces a source, returning previous. This is useful if a source needs to be disposed.\n     * Throws an error if 'field' does not exist.\n     * @param field \n     * @param source \n     * @returns \n     */\n    replaceSource: (field, source, disposeOld) => {\n      const existing = removeSource(field, disposeOld);\n      setSource(field, source);\n      return existing;\n    }\n  };\n}\n","/**\n * Via: https://gist.github.com/cyphunk/6c255fa05dd30e69f438a930faeb53fe\n * @param logits \n * @returns \n */\nexport const softmax = (logits: Array<number>) => {\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const maxLogit = logits.reduce((a, b) => Math.max(a, b), Number.NEGATIVE_INFINITY);\n  const scores = logits.map((l) => Math.exp(l - maxLogit));\n  const denom = scores.reduce((a, b) => a + b);\n  return scores.map((s) => s / denom);\n}","import { toStringDefault, type ToString } from \"../util/index.js\";\n\nexport type TrackUnique<T> = (value: T) => boolean\n\n/**\n * Tracks unique values. Returns _true_ if value is unique.\n * Alternatively: {@link trackUniqueInstances}\n * \n * ```js\n * const t = trackUnique();\n * t(`hello`); // true\n * t(`hello`); // false\n * ```\n * \n * Uses JSON.stringify to compare anything which is not a string.\n * \n * Provide a custom function to convert to string to track uniqueness\n * for more complicated objects.\n * \n * ```js\n * const t = trackUnique(p => p.name);\n * t({ name:`John`, level:2 }); // true\n * \n * // Since we're judging uniques by name only\n * t({ name:`John`, level:3 }); // false\n * ```\n * \n * Return function throws an error if `value` is null or undefined.\n * @returns \n */\nexport const trackUnique = <T>(toString: ToString<T> = toStringDefault): TrackUnique<T> => {\n  const set = new Set<string>();\n\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    const asString = (typeof value === `string`) ? value : toString(value);\n    if (set.has(asString)) return false;\n    set.add(asString);\n    return true;\n  }\n}\n\n/**\n * Tracks unique object instances. Returns _true_ if value is unique.\n * Alternatively: {@link trackUnique} to track by value.\n */\nexport const trackUniqueInstances = <T>(): TrackUnique<T> => {\n\n  const set = new Set<T>();\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    if (set.has(value)) return false;\n    set.add(value);\n    return true;\n  }\n}","export * as Directed from './DirectedGraph.js';\nexport * as Undirected from './UndirectedGraph.js';","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { Table } from \"../Table.js\"\n\n\nexport type Vertex = Readonly<{\n  id: string\n}>\n\nexport type Edge = Readonly<{\n  a: string,\n  b: string,\n  weight?: number\n}>\n\nexport type Graph = Readonly<{\n  edges: ReadonlyArray<Edge>,\n  vertices: IMapImmutable<string, Vertex>\n}>\n\nexport type ConnectOptions = Readonly<{\n  a: string\n  b: string | Array<string>\n  weight?: number\n}>\n\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id\n  }\n}\n\nexport const updateGraphVertex = (graph: Graph, vertex: Vertex): Graph => {\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\nexport const getOrCreate = (graph: Graph, id: string): Readonly<{ graph: Graph, vertex: Vertex }> => {\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\nfunction resolveVertex(graph: Graph, idOrVertex: string | Vertex): Vertex {\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\nexport const hasConnection = (graph: Graph, a: string | Vertex, b: string | Vertex): boolean => {\n  const edge = getConnection(graph, a, b);\n  return edge !== undefined;\n}\n\nexport const getConnection = (graph: Graph, a: string | Vertex, b: string | Vertex): Edge | undefined => {\n  const aa = resolveVertex(graph, a);\n  const bb = resolveVertex(graph, b);\n  for (const edge of graph.edges) {\n    if (edge.a == aa.id && edge.b === bb.id) return edge;\n    if (edge.a == bb.id && edge.b === aa.id) return edge;\n  }\n  return;\n}\n\n/**\n * Connect A <-> B\n * @param graph \n * @param a \n * @param b \n * @param weight \n * @returns \n */\nexport function connectTo(graph: Graph, a: string, b: string, weight?: number): { graph: Graph, edge: Edge } {\n  const aResult = getOrCreate(graph, a);\n  graph = aResult.graph;\n  const bResult = getOrCreate(graph, b);\n  graph = bResult.graph;\n\n  let edge = getConnection(graph, a, b);\n  if (edge !== undefined) return { graph, edge };\n  edge = {\n    a,\n    b,\n    weight\n  }\n\n  const graphChanged: Graph = {\n    ...graph,\n    edges: [ ...graph.edges, edge ]\n  }\n  return { graph: graphChanged, edge }\n}\n\nexport function connect(graph: Graph, options: ConnectOptions): Graph {\n  const { a, weight, b } = options;\n  const destinations = Array.isArray(b) ? b : [ b ];\n\n  for (const destination of destinations) {\n    const result = connectTo(graph, a, destination, weight);\n    graph = result.graph;\n  }\n\n  return graph;\n}\n\nexport const graph = (...initialConnections: Array<ConnectOptions>): Graph => {\n  let g: Graph = {\n    vertices: immutableMap(),\n    edges: []\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\nexport function toAdjacencyMatrix(graph: Graph): Table<boolean> {\n  const v = [ ...graph.vertices.values() ];\n\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    table.setRow(i, v.length, false);\n\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      const connected = hasConnection(graph, ii, jj);\n      if (connected) {\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: Graph): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: Graph): Array<string> => {\n  const r: Array<string> = [];\n\n  r.push(`Vertices: ${ [ ...graph.vertices.values() ].map(v => v.id).join(`, `) }`);\n  // eslint-disable-next-line unicorn/no-array-push-push\n  r.push(`Edges:`);\n  for (const edge of graph.edges) {\n    r.push(stringForEdge(edge));\n  }\n  return r;\n}\n\nconst stringForEdge = (edge: Edge) => {\n  const weight = edge.weight ? ` (${ edge.weight })` : ``;\n  return `${ edge.a } <-> ${ edge.b }${ weight }`\n}\n\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns \n */\nexport function* adjacentVertices(graph: Graph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of graph.edges) {\n    if (edge.a === context) yield resolveVertex(graph, edge.b);\n    else if (edge.b === context) yield resolveVertex(graph, edge.a);\n  }\n}\n\nexport function* edgesForVertex(graph: Graph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of graph.edges) {\n    if (edge.a === context) yield edge;\n    else if (edge.b === context) yield edge;\n  }\n}","import * as Drawing from './Drawing.js';\nimport * as Svg from './Svg.js';\n//import * as Plot from './Plot.js';\n\nimport * as Plot2 from './Plot2.js';\n\nimport * as Palette from './Palette.js';\nimport * as Colour from './Colour.js';\nimport * as SceneGraph from './SceneGraph.js';\nimport * as Video from './Video.js';\n\nexport * as ImageDataGrid from './ImageDataGrid.js';\nexport * as BipolarView from './BipolarView.js';\nexport * as Palette from './Palette.js';\nexport * as Drawing from './Drawing.js';\nexport * as Svg from './Svg.js';\n//export * as Plot from './Plot.js';\n\n\nexport * as Plot2 from './Plot2.js';\nexport * as PlotOld from './PlotOld.js';\nexport * as SceneGraph from './SceneGraph.js';\nexport * from './ScaleCanvas.js';\n\n/**\n * Colour interpolation, scale generation and parsing\n *\n * Overview\n * * {@link interpolator}: Blend colours\n * * {@link scale}: Produce colour scale\n * * {@link opacity}: Give a colour opacity\n * * {@link randomHue}: Generate a random hue\n * * {@link goldenAngleColour}: Pick perceptually different shades\n *\n * CSS\n * * {@link getCssVariable}: Parse a CSS-defined colour\n *\n * Conversions: convert from 'blue', 'rgb(255,0,0)',  'hsl(0, 100%, 50%)' etc:\n * * {@link toHex}: to a hex format string\n * * {@link toHsl}: to a `{h, s, l}` object\n * * {@link toRgb}: to a `{r, g, b}` object\n */\nexport * as Colour from './Colour.js';\n\n/**\n * Working with video, either playback from a file or stream from a video camera.\n *\n * Overview\n * * {@link frames}: Yields frames from a video camera\n * * {@link capture}: Capture frames from a VIDEO element\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import {Video} from '../../ixfx/dist/visual.js';\n * // Import from web\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n * ```\n */\nexport * as Video from './Video.js';\n\ntry {\n  if (typeof window !== `undefined`) {\n    //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Visuals: {\n        SceneGraph,\n        Plot2,\n        Drawing,\n        Svg,\n        Palette,\n        Colour,\n        Video,\n      },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\n\n","import * as Points from '../geometry/point/index.js';\nimport * as Triangles from '../geometry/triangle/index.js';\nimport { throwArrayTest } from '../util/GuardArrays.js';\nimport * as Arcs from '../geometry/arc/index.js';\nimport * as Beziers from '../geometry/bezier/index.js';\nimport * as Ellipses from '../geometry/Ellipse.js';\nimport * as Colours from '../visual/Colour.js';\nimport { resolveEl } from '../dom/ResolveEl.js';\nimport type { IStackImmutable } from '../collections/stack/IStackImmutable.js';\nimport { StackImmutable } from '../collections/stack/StackImmutable.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport type { Line } from '../geometry/line/LineType.js';\nimport type { CirclePositioned } from '../geometry/circle/CircleType.js';\nimport type { Rect, RectPositioned } from '../geometry/rect/index.js';\nimport type { Path } from '../geometry/path/PathType.js';\nimport type { Triangle } from '../geometry/triangle/TriangleType.js';\n\nimport { empty as RectsEmpty } from '../geometry/rect/Empty.js';\nimport { corners as RectsCorners } from '../geometry/rect/Corners.js';\nimport { isLine } from '../geometry/line/Guard.js';\nimport { roundUpToMultiple } from '../numbers/Round.js';\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst PIPI = Math.PI * 2;\n\nexport type CanvasContextQuery =\n  | null\n  | string\n  | CanvasRenderingContext2D\n  | HTMLCanvasElement;\n\n/**\n * Gets a 2d drawing context from canvas element or query, or throws an error\n * @param canvasElCtxOrQuery Canvas element reference or DOM query\n * @returns Drawing context.\n */\nexport const getContext = (\n  canvasElementContextOrQuery: CanvasContextQuery\n): CanvasRenderingContext2D => {\n  if (canvasElementContextOrQuery === null) {\n    throw new Error(\n      `canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`\n    );\n  }\n  if (canvasElementContextOrQuery === undefined) {\n    throw new Error(\n      `canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`\n    );\n  }\n\n  const ctx =\n    canvasElementContextOrQuery instanceof CanvasRenderingContext2D\n      ? canvasElementContextOrQuery\n      : canvasElementContextOrQuery instanceof HTMLCanvasElement\n        ? canvasElementContextOrQuery.getContext(`2d`)\n        // eslint-disable-next-line unicorn/no-nested-ternary\n        : typeof canvasElementContextOrQuery === `string`\n          ? resolveEl<HTMLCanvasElement>(canvasElementContextOrQuery).getContext(`2d`)\n          : canvasElementContextOrQuery;\n  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);\n  return ctx;\n};\n\nexport type DrawingHelper = ReturnType<typeof makeHelper>\n/**\n * Makes a helper object that wraps together a bunch of drawing functions that all use the same drawing context\n * @param ctxOrCanvasEl Drawing context or canvs element reference\n * @param canvasBounds Bounds of drawing (optional). Used for limiting `textBlock`\n * @returns\n */\nexport const makeHelper = (\n  ctxOrCanvasEl: CanvasContextQuery,\n  canvasBounds?: Rect\n) => {\n  const ctx = getContext(ctxOrCanvasEl);\n  return {\n    ctx,\n    paths(pathsToDraw: Array<Path>, opts?: DrawingOpts): void {\n      paths(ctx, pathsToDraw, opts);\n    },\n    line(lineToDraw: Line | Array<Line>, opts?: DrawingOpts): void {\n      line(ctx, lineToDraw, opts);\n    },\n    rect(\n      rectsToDraw: RectPositioned | Array<RectPositioned>,\n      opts?: DrawingOpts & { filled?: boolean }\n    ): void {\n      rect(ctx, rectsToDraw, opts);\n    },\n    bezier(\n      bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n      opts?: DrawingOpts\n    ): void {\n      bezier(ctx, bezierToDraw, opts);\n    },\n    connectedPoints(\n      pointsToDraw: Array<Point>,\n      opts?: DrawingOpts & { loop?: boolean }\n    ): void {\n      connectedPoints(ctx, pointsToDraw, opts);\n    },\n    pointLabels(pointsToDraw: Array<Point>, opts?: DrawingOpts): void {\n      pointLabels(ctx, pointsToDraw, opts);\n    },\n    dot(\n      dotPosition: Point | Array<Point>,\n      opts?: DotOpts\n    ): void {\n      dot(ctx, dotPosition, opts);\n    },\n    circle(\n      circlesToDraw: CirclePositioned | Array<\n        CirclePositioned>,\n      opts: DrawingOpts\n    ): void {\n      circle(ctx, circlesToDraw, opts);\n    },\n    arc(\n      arcsToDraw: Arcs.ArcPositioned | Array<Arcs.ArcPositioned>,\n      opts: DrawingOpts\n    ): void {\n      arc(ctx, arcsToDraw, opts);\n    },\n    textBlock(\n      lines: Array<string>,\n      opts: DrawingOpts & {\n        anchor: Point;\n        anchorPadding?: number;\n        bounds?: RectPositioned;\n      }\n    ): void {\n      if (opts.bounds === undefined && canvasBounds !== undefined) {\n        opts = { ...opts, bounds: { ...canvasBounds, x: 0, y: 0 } };\n      }\n      textBlock(ctx, lines, opts);\n    },\n  };\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = {\n  /**\n   * Stroke style\n   */\n  readonly strokeStyle?: string;\n  /**\n   * Fill style\n   */\n  readonly fillStyle?: string;\n  /**\n   * If true, diagnostic helpers will be drawn\n   */\n  readonly debug?: boolean;\n};\n\nexport type LineOpts = {\n  readonly lineWidth?: number;\n  readonly lineCap?: CanvasLineCap;\n  readonly lineJoin?: CanvasLineJoin;\n};\n\n/**\n * Creates a drawing op to apply provided options\n * @param opts Drawing options that apply\n * @returns Stack\n */\nconst optsOp = (opts: DrawingOpts): StackOp =>\n  coloringOp(opts.strokeStyle, opts.fillStyle);\n\n/**\n * Applies drawing options to `ctx`, returning a {@link DrawingStack}\n * @param ctx Context\n * @param opts Options\n * @returns\n */\nconst applyOpts = (\n  ctx: CanvasRenderingContext2D,\n  opts: DrawingOpts = {},\n  ...additionalOps: ReadonlyArray<StackOp>\n): DrawingStack => {\n  if (ctx === undefined) throw new Error(`ctx undefined`);\n\n  // Create a drawing stack, pushing an op generated from drawing options\n  //eslint-disable-next-line functional/immutable-data\n  const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);\n\n  // Apply stack to context\n  stack.apply();\n  return stack;\n};\n\n/**\n * Draws one or more arcs.\n * @param ctx\n * @param arcs\n * @param opts\n */\nexport const arc = (\n  ctx: CanvasRenderingContext2D,\n  arcs: Arcs.ArcPositioned | ReadonlyArray<Arcs.ArcPositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (arc: Arcs.ArcPositioned) => {\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\n    ctx.stroke();\n  };\n\n  const arcsArray = Array.isArray(arcs) ? arcs : [ arcs ];\n  for (const arc of arcsArray) {\n    draw(arc);\n  }\n\n};\n\n/**\n * A drawing stack operation\n */\nexport type StackOp = (ctx: CanvasRenderingContext2D) => void;\n\n/**\n * A drawing stack (immutable)\n */\nexport type DrawingStack = {\n  /**\n   * Push a new drawing op\n   * @param ops Operation to add\n   * @returns stack with added op\n   */\n  push(...ops: ReadonlyArray<StackOp>): DrawingStack;\n  /**\n   * Pops an operatiomn\n   * @returns Drawing stack with item popped\n   */\n  pop(): DrawingStack;\n  /**\n   * Applies drawing stack\n   */\n  apply(): DrawingStack;\n};\n\n/**\n * Colouring drawing op. Applies `fillStyle` and `strokeStyle`\n * @param strokeStyle\n * @param fillStyle\n * @returns\n */\nconst coloringOp = (\n  strokeStyle: string | CanvasGradient | CanvasPattern | undefined,\n  fillStyle: string | CanvasGradient | CanvasPattern | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    // eslint-disable-next-line functional/immutable-data\n    if (fillStyle) ctx.fillStyle = fillStyle;\n    // eslint-disable-next-line functional/immutable-data\n    if (strokeStyle) ctx.strokeStyle = strokeStyle;\n  };\n  return apply;\n};\n\nconst lineOp = (\n  lineWidth: number | undefined,\n  lineJoin: CanvasLineJoin | undefined,\n  lineCap: CanvasLineCap | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    // eslint-disable-next-line functional/immutable-data\n    if (lineWidth) ctx.lineWidth = lineWidth;\n    // eslint-disable-next-line functional/immutable-data\n    if (lineJoin) ctx.lineJoin = lineJoin;\n    // eslint-disable-next-line functional/immutable-data\n    if (lineCap) ctx.lineCap = lineCap;\n  };\n  return apply;\n};\n\n/**\n * Creates and returns an immutable drawing stack for a context\n * @param ctx Context\n * @param stk Initial stack operations\n * @returns\n */\nexport const drawingStack = (\n  ctx: CanvasRenderingContext2D,\n  stk?: IStackImmutable<StackOp>\n): DrawingStack => {\n  if (stk === undefined) stk = new StackImmutable<StackOp>();\n\n  const push = (...ops: Array<StackOp>): DrawingStack => {\n    if (stk === undefined) stk = new StackImmutable<StackOp>();\n    //eslint-disable-next-line functional/immutable-data\n    const s = stk.push(...ops);\n    for (const o of ops) o(ctx);\n    return drawingStack(ctx, s);\n  };\n\n  const pop = (): DrawingStack => {\n    //eslint-disable-next-line functional/immutable-data\n    const s = stk?.pop();\n    return drawingStack(ctx, s);\n  };\n\n  const apply = (): DrawingStack => {\n    if (stk === undefined) return drawingStack(ctx);\n    for (const op of stk.data) op(ctx);\n    return drawingStack(ctx, stk);\n  };\n\n  return { push, pop, apply };\n};\n\n/**\n * Draws a curved line through a set of points\n * @param ctx \n * @param points \n * @param opts \n */\nexport const lineThroughPoints = (\n  ctx: CanvasRenderingContext2D,\n  points: ReadonlyArray<Point>,\n  opts?: DrawingOpts\n): void => {\n  applyOpts(ctx, opts);\n\n  // https://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas\n  ctx.moveTo(points[ 0 ].x, points[ 0 ].y);\n\n  for (const [ index, p ] of points.entries()) {\n    if (index + 2 >= points.length) continue;\n    const pNext = points[ index + 1 ];\n    const mid = {\n      x: (p.x + pNext.x) / 2,\n      y: (p.y + pNext.y) / 2,\n    };\n    const cpX1 = (mid.x + p.x) / 2;\n    const cpX2 = (mid.x + pNext.x) / 2;\n    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);\n    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);\n  }\n};\n\n/**\n * Draws one or more circles. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n *\n * ```js\n * // Draw a circle with radius of 10 at 0,0\n * circle(ctx, {radius:10});\n *\n * // Draw a circle of radius 10 at 100,100\n * circle(ctx, {radius: 10, x: 100, y: 100});\n *\n * // Draw two blue outlined circles\n * circle(ctx, [ {radius: 5}, {radius: 10} ], {strokeStyle:`blue`});\n * ```\n * @param ctx Drawing context\n * @param circlesToDraw Circle(s) to draw\n * @param opts Drawing options\n */\nexport const circle = (\n  ctx: CanvasRenderingContext2D,\n  circlesToDraw: CirclePositioned | ReadonlyArray<CirclePositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (c: CirclePositioned) => {\n    ctx.beginPath();\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\n    if (opts.strokeStyle) ctx.stroke();\n    //eslint-disable-next-line functional/immutable-data\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  if (Array.isArray(circlesToDraw)) {\n    for (const c of circlesToDraw) draw(c);\n  } else {\n    draw(circlesToDraw as CirclePositioned);\n  }\n};\n\n/**\n * Draws one or more ellipses. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n * @param ctx\n * @param ellipsesToDraw\n * @param opts\n */\nexport const ellipse = (\n  ctx: CanvasRenderingContext2D,\n  ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | ReadonlyArray<Ellipses.EllipsePositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (ellipse: Ellipses.EllipsePositioned) => {\n    ctx.beginPath();\n    const rotation = ellipse.rotation ?? 0;\n    const startAngle = ellipse.startAngle ?? 0;\n    const endAngle = ellipse.endAngle ?? PIPI;\n    ctx.ellipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, rotation, startAngle, endAngle);\n    if (opts.strokeStyle) ctx.stroke();\n    //eslint-disable-next-line functional/immutable-data\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ ellipsesToDraw ];\n  for (const ellipse of ellipsesArray) {\n    draw(ellipse);\n  }\n};\n\n/**\n * Draws one or more paths.\n * supported paths are quadratic beziers and lines.\n * @param ctx\n * @param pathsToDraw\n * @param opts\n */\nexport const paths = (\n  ctx: CanvasRenderingContext2D,\n  pathsToDraw: ReadonlyArray<Path> | Path,\n  opts: { readonly strokeStyle?: string; readonly debug?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (path: Path) => {\n    // Call appropriate drawing function depending on the type of path\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\n    else if (isLine(path)) line(ctx, path, opts);\n    else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n  };\n\n  if (Array.isArray(pathsToDraw)) {\n    for (const p of pathsToDraw) draw(p);\n  } else {\n    draw(pathsToDraw as Path);\n  }\n};\n\n/**\n * Draws a line between all the given points.\n * If a fillStyle is specified, it will be filled.\n *\n * See also:\n * * {@link line}: Draw one or more lines\n *\n * @param ctx\n * @param pts\n */\nexport const connectedPoints = (\n  ctx: CanvasRenderingContext2D,\n  pts: ReadonlyArray<Point>,\n  opts: {\n    readonly lineWidth?: number\n    readonly loop?: boolean\n    readonly fillStyle?: string\n    readonly strokeStyle?: string\n  } = {}\n) => {\n  const shouldLoop = opts.loop ?? false;\n\n\n  throwArrayTest(pts);\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  // Draw points\n  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(pts[ 0 ].x, pts[ 0 ].y);\n  for (const pt of pts) ctx.lineTo(pt.x, pt.y);\n\n  if (shouldLoop) ctx.lineTo(pts[ 0 ].x, pts[ 0 ].y);\n\n  // if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n  if (\n    opts.strokeStyle ||\n    (opts.strokeStyle === undefined && opts.fillStyle === undefined)\n  ) {\n    ctx.stroke();\n  }\n  if (opts.fillStyle) {\n    //eslint-disable-next-line functional/immutable-data\n    ctx.fill();\n  }\n};\n\n/**\n * Draws labels for a set of points\n * @param ctx\n * @param pts Points to draw\n * @param opts\n * @param labels Labels for points\n */\nexport const pointLabels = (\n  ctx: CanvasRenderingContext2D,\n  pts: ReadonlyArray<Point>,\n  opts: { readonly fillStyle?: string } = {},\n  labels?: ReadonlyArray<string>\n) => {\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  for (const [ index, pt ] of pts.entries()) {\n    const label =\n      labels !== undefined && index < labels.length ? labels[ index ] : index.toString();\n    ctx.fillText(label.toString(), pt.x, pt.y);\n  }\n};\n\n/**\n * Returns `point` with the canvas's translation matrix applied\n * @param ctx\n * @param point\n * @returns\n */\nexport const translatePoint = (\n  ctx: CanvasRenderingContext2D,\n  point: Point\n): Point => {\n  const m = ctx.getTransform();\n  return {\n    x: point.x * m.a + point.y * m.c + m.e,\n    y: point.x * m.b + point.y * m.d + m.f,\n  };\n};\n\n/**\n * Creates a new HTML IMG element with a snapshot of the\n * canvas. Element will need to be inserted into the document.\n *\n * ```\n * const myCanvas = document.getElementById('someCanvas');\n * const el = copyToImg(myCanvas);\n * document.getElementById('images').appendChild(el);\n * ```\n * @param canvasEl\n * @returns\n */\nexport const copyToImg = (canvasEl: HTMLCanvasElement): HTMLImageElement => {\n  const img = document.createElement(`img`);\n  //eslint-disable-next-line functional/immutable-data\n  img.src = canvasEl.toDataURL(`image/jpeg`);\n  return img;\n};\n\nexport type DotOpts = DrawingOpts & {\n  readonly radius?: number;\n  readonly stroke?: boolean;\n  readonly filled?: boolean;\n  readonly strokeWidth?: number;\n}\n\n/**\n * Draws filled circle(s) at provided point(s)\n * @param ctx\n * @param pos\n * @param opts\n */\nexport const dot = (\n  ctx: CanvasRenderingContext2D,\n  pos: Point | ReadonlyArray<Point>,\n  opts?: DotOpts\n) => {\n  if (opts === undefined) opts = {};\n  const radius = opts.radius ?? 10;\n\n  applyOpts(ctx, opts);\n\n  const makePath = () => {\n    ctx.beginPath();\n\n    // x&y for arc is the center of circle\n    if (Array.isArray(pos)) {\n      for (const p of pos) {\n        ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n      }\n    } else {\n      const p = pos as Point;\n      ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n    }\n  }\n  makePath();\n  if (opts.filled || !opts.stroke) {\n    ctx.fill();\n  }\n  if (opts.stroke) {\n    if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n    //makePath();\n    ctx.stroke();\n  }\n};\n\n/**\n * Draws a cubic or quadratic bezier\n * @param ctx\n * @param bezierToDraw\n * @param opts\n */\nexport const bezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n  opts?: DrawingOpts\n) => {\n  if (Beziers.isQuadraticBezier(bezierToDraw)) {\n    quadraticBezier(ctx, bezierToDraw, opts);\n  } else if (Beziers.isCubicBezier(bezierToDraw)) {\n    cubicBezier(ctx, bezierToDraw, opts);\n  }\n};\n\nconst cubicBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.CubicBezier,\n  opts: DrawingOpts = {}\n) => {\n  // eslint-disable-next-line functional/no-let\n  let stack = applyOpts(ctx, opts);\n\n  const { a, b, cubic1, cubic2 } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n\n  if (isDebug) {\n    /*\n     * const ss = ctx.strokeStyle;\n     * ctx.strokeStyle = ss;\n     */\n  }\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colours.opacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colours.opacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n\n    stack.apply();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(cubic1.x, cubic1.y);\n    ctx.stroke();\n    ctx.moveTo(b.x, b.y);\n    ctx.lineTo(cubic2.x, cubic2.y);\n    ctx.stroke();\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\n    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\n\n    dot(ctx, cubic1, { radius: 3 });\n    dot(ctx, cubic2, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\nconst quadraticBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier,\n  opts: DrawingOpts = {}\n) => {\n  const { a, b, quadratic } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n  // eslint-disable-next-line functional/no-let\n  let stack = applyOpts(ctx, opts);\n\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    /*\n     * const fs = ctx.fillStyle;\n     * const ss = ctx.strokeStyle;\n     * ctx.fillStyle = opts.strokeStyle ?? `gray`;\n     * ctx.strokeStyle = opts.strokeStyle ?? `gray`;\n     */\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colours.opacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colours.opacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n    connectedPoints(ctx, [ a, quadratic, b ]);\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\n    dot(ctx, quadratic, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    /*\n     * ctx.fillStyle = fs;\n     * ctx.strokeStyle = ss;\n     */\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\n/**\n * Draws one or more lines.\n *\n * Each line is drawn independently, ie it's not assumed lines are connected.\n *\n * See also:\n * * {@link connectedPoints}: Draw a series of connected points\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const line = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Line | ReadonlyArray<Line>,\n  opts: LineOpts & DrawingOpts = {}\n) => {\n  const isDebug = opts.debug ?? false;\n  const o = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);\n  applyOpts(ctx, opts, o);\n\n  const draw = (d: Line) => {\n    const { a, b } = d;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    if (isDebug) {\n      ctx.fillText(`a`, a.x, a.y);\n      ctx.fillText(`b`, b.x, b.y);\n      dot(ctx, a, { radius: 5, strokeStyle: `black` });\n      dot(ctx, b, { radius: 5, strokeStyle: `black` });\n    }\n    ctx.stroke();\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) draw(t);\n  } else {\n    draw(toDraw as Line);\n  }\n};\n\n/**\n * Draws one or more triangles\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const triangle = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Triangle | ReadonlyArray<Triangle>,\n  opts: DrawingOpts & { readonly filled?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (t: Triangle) => {\n    connectedPoints(ctx, Triangles.corners(t), { ...opts, loop: true });\n\n    if (opts.debug) {\n      pointLabels(ctx, Triangles.corners(t), undefined, [ `a`, `b`, `c` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Triangle);\n  }\n};\n\n// export const arrowFromTip = (ctx:CanvasRenderingContext2D, tipPos: Point, tailLength:number, opts:DrawingOpts) => {\n//   if (opts.fillStyle) ctx.fillStyle = opts.fillStyle;\n//   if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n\n//   ctx.save();\n//   ctx.translate\n//   ctx.restore();\n// }\n\n/**\n * Draws one or more rectangles.\n * \n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const rect = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Rect | RectPositioned | ReadonlyArray<RectPositioned>,\n  opts: DrawingOpts & {\n    readonly filled?: boolean;\n    readonly stroked?: boolean;\n  } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const filled = opts.filled ?? (opts.fillStyle === undefined ? false : true);\n  const stroked = opts.stroked ?? (opts.strokeStyle === undefined ? false : true);\n  const draw = (d: RectPositioned | Rect) => {\n    const x = `x` in d ? d.x : 0;\n    const y = `y` in d ? d.y : 0;\n    if (filled) ctx.fillRect(x, y, d.width, d.height);\n    if (stroked ?? true) ctx.strokeRect(x, y, d.width, d.height);\n\n    if (opts.debug) {\n      pointLabels(ctx, RectsCorners(d), undefined, [ `NW`, `NE`, `SE`, `SW` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as RectPositioned);\n  }\n};\n\n/**\n * Returns the width of `text`. Rounds number up to nearest multiple if provided. If\n * text is empty or undefined, 0 is returned.\n * @param ctx\n * @param text\n * @param widthMultiple\n * @returns\n */\nexport const textWidth = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0,\n  widthMultiple?: number\n): number => {\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // if (widthMultiple) return roundUpToMultiple(m.width, widthMultiple) + padding;\n  // return m.width + padding;\n  const rect = textRect(ctx, text, padding, widthMultiple);\n  return rect.width;\n};\n\nexport const textRect = (ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0, widthMultiple?: number): Rect => {\n  if (text === undefined || text === null || text.length === 0) return RectsEmpty;\n  const m = ctx.measureText(text);\n\n  const width = (widthMultiple) ? roundUpToMultiple(m.width, widthMultiple) + padding : m.width + padding;\n\n  return {\n    width: width,\n    height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding\n  }\n}\n\nexport const textHeight = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0): number => {\n  const rect = textRect(ctx, text, padding);\n  return rect.height;\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // return m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding;\n}\n\n\n/**\n * Draws a block of text. Each array item is considered a line.\n * @param ctx\n * @param lines\n * @param opts\n */\nexport const textBlock = (\n  ctx: CanvasRenderingContext2D,\n  lines: ReadonlyArray<string>,\n  opts: DrawingOpts & {\n    readonly anchor: Point;\n    readonly anchorPadding?: number;\n    readonly bounds?: RectPositioned;\n  }\n) => {\n  applyOpts(ctx, opts);\n  const anchorPadding = opts.anchorPadding ?? 0;\n\n  const anchor = opts.anchor;\n  const bounds = opts.bounds ?? { x: 0, y: 0, width: 1_000_000, height: 1_000_000 };\n\n  // Measure each line\n  //eslint-disable-next-line functional/prefer-tacit\n  const blocks = lines.map((l) => ctx.measureText(l));\n\n  // Get width and height\n  const widths = blocks.map((tm) => tm.width);\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n\n  // Find extremes\n  const maxWidth = Math.max(...widths);\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  // eslint-disable-next-line functional/no-let\n  let { x, y } = anchor;\n\n  if (anchor.x + maxWidth > bounds.width) {\n    x = bounds.width - (maxWidth + anchorPadding);\n  } else x -= anchorPadding;\n\n  if (x < bounds.x) x = bounds.x + anchorPadding;\n\n  if (anchor.y + totalHeight > bounds.height) {\n    y = bounds.height - (totalHeight + anchorPadding);\n  } else y -= anchorPadding;\n\n  if (y < bounds.y) y = bounds.y + anchorPadding;\n\n  for (const [ index, line ] of lines.entries()) {\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n};\n\nexport type HorizAlign = `left` | `right` | `center`;\nexport type VertAlign = `top` | `center` | `bottom`;\n\n/**\n * Draws an aligned text block\n */\nexport const textBlockAligned = (\n  ctx: CanvasRenderingContext2D,\n  text: ReadonlyArray<string> | string,\n  opts: DrawingOpts & {\n    readonly bounds: RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }\n) => {\n  const { bounds } = opts;\n  const { horiz = `left`, vert = `top` } = opts;\n\n  const lines = typeof text === `string` ? [ text ] : text;\n\n  applyOpts(ctx, opts);\n\n  ctx.save();\n  ctx.translate(bounds.x, bounds.y);\n  ctx.textAlign = `left`;\n  ctx.textBaseline = `top`;\n  const middleX = bounds.width / 2;\n  const middleY = bounds.height / 2;\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let y = 0;\n  if (vert === `center`) y = middleY - totalHeight / 2;\n  else if (vert === `bottom`) {\n    y = bounds.height - totalHeight;\n  }\n\n  for (const [ index, line ] of lines.entries()) {\n    let x = 0;\n    if (horiz === `center`) x = middleX - blocks[ index ].width / 2;\n    else if (horiz === `right`) x = bounds.width - blocks[ index ].width;\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n\n  ctx.restore();\n};\n","import { minIndex } from '../numbers/NumericArrays.js';\nimport * as Points from '../geometry/point/index.js';\nimport { clamp } from '../data/Clamp.js';\nimport { flip } from '../data/Flip.js';\nimport { scale } from '../data/Scale.js';\nimport * as Sg from './SceneGraph.js';\nimport { textRect, textWidth } from './Drawing.js';\nimport { getPaths, getField } from '../data/Pathed.js';\nimport { ifNaN, throwNumberTest } from '../util/GuardNumbers.js';\nimport type { Rect, RectPositioned, PointCalculableShape } from '../geometry/Types.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport { subtract as RectsSubtract } from '../geometry/rect/Subtract.js';\nimport { scaleCanvas } from './ScaleCanvas.js';\nimport { parentSizeCanvas } from '../dom/CanvasSizing.js';\nimport type { MinMaxAvgTotal } from '../collections/arrays/Types.js';\nimport { minMaxAvg } from '../collections/arrays/MinMaxAvg.js';\n\n/**\n * \n *  const dataStream = new DataStream();\n *  dataStream.in({ key: `x`, value: 0.5 }); \n *  const label = (obj:any) => {\n *    if (`key` in obj) return obj;\n *    return { key: randomKey(), ...obj }\n *  }\n *  const stream = pipeline(dataStream, label);\n *  // Actively compute size of window based on window width\n *  const windowSize = ops.divide(rxWindow.innerWidth, pointSize);\n *  const dataWindow = window(stream, windowSize);\n *  const dataToPoints = (value);\n * \n *  const drawPlot = (dataWindow) => {\n *    for (const dataPoint in dataWindow) {\n *    }\n *  }\n */\n\n/**\n * A data source\n */\nexport type DataSource = {\n  dirty: boolean;\n  type: string;\n  get range(): DataRange;\n  add(value: number): void;\n  clear(): void;\n}\n\n/**\n * Plot options\n */\nexport type Opts = {\n  /**\n   * If true, Canvas will be resized to fit parent\n   */\n  autoSize?: boolean;\n  /**\n   * Colour for axis lines & labels\n   */\n  axisStrokeColour?: string;\n\n  axisTextColour?: string\n\n  legendTextColour?: string\n  /**\n   * Width for axis lines\n   */\n  axisStrokeWidth?: number;\n};\n\n/**\n * Series options\n */\nexport type SeriesOpts = {\n  /**\n   * Colour for series\n   */\n  colour: string;\n  /**\n   * Visual width/height (depends on drawingStyle)\n   */\n  width?: number;\n  /**\n   * How series should be rendered\n   */\n  drawingStyle?: `line` | `dotted` | `bar`;\n  /**\n   * Preferred data range\n   */\n  axisRange?: DataRange;\n  /**\n   * If true, range will stay at min/max, rather than continuously adapting\n   * to the current data range.\n   */\n  visualRangeStretch?: boolean;\n};\n\nexport type DataPoint = {\n  value: number;\n  index: number;\n  title?: string;\n};\n\nexport type DataHitPoint = (\n  pt: Point\n) => [ point: DataPoint | undefined, distance: number ];\n\nclass ArrayDataSource implements DataSource {\n  data: Array<number>;\n  series: Series;\n  dirty = false;\n  type = `array`;\n\n  private _range: MinMaxAvgTotal | undefined;\n\n  constructor(series: Series) {\n    this.series = series;\n    this.data = [];\n    this.dirty = true;\n  }\n\n  clear() {\n    this.set([]);\n    this._range = undefined;\n  }\n\n  set(data: Array<number>) {\n    this.data = data;\n    this.dirty = true;\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get range(): DataRange {\n    if (!this.dirty && this._range !== undefined) return this._range;\n    this.dirty = false;\n    const updatedRange = minMaxAvg(this.data);\n    if (this._range === undefined || updatedRange.max !== this._range.max || updatedRange.min !== this._range.min) {\n      this._range = updatedRange;\n      return { ...this._range, changed: true };\n    } else {\n      return { ...this._range, changed: false };\n\n    }\n  }\n\n  add(value: number) {\n    this.data = [ ...this.data, value ];\n    this.dirty = true;\n  }\n}\n\nclass StreamingDataSource extends ArrayDataSource {\n  desiredDataPointMinWidth = 5;\n\n  add(value: number) {\n    const lastWidth = this.series.lastPxPerPt;\n    if (lastWidth > -1 && lastWidth < this.desiredDataPointMinWidth) {\n      // Remove older data\n      const pts = Math.floor(this.desiredDataPointMinWidth / lastWidth);\n      const d = [ ...this.data.slice(pts), value ];\n      super.set(d);\n    } else super.add(value);\n  }\n}\n\nexport type DataRange = {\n  min: number;\n  max: number;\n  changed?: boolean;\n};\n\nexport class Series {\n  name: string;\n  colour: string;\n  source: DataSource;\n  drawingStyle: `line` | `dotted` | `bar`;\n  width = 3;\n  dataHitPoint: DataHitPoint | undefined;\n  tooltip?: string;\n  precision = 2;\n\n  readonly axisRange: DataRange;\n\n  // How many pixels wide per data point on last draw\n  lastPxPerPt = -1;\n\n  protected _visualRange: DataRange;\n  protected _visualRangeStretch: boolean;\n\n  constructor(\n    name: string,\n    sourceType: `array` | `stream`,\n    private plot: Plot,\n    opts: SeriesOpts\n  ) {\n    this.name = name;\n\n    this.drawingStyle = opts.drawingStyle ?? `line`;\n    this.colour = opts.colour;\n    this.width = opts.width ?? 3;\n    this.axisRange = opts.axisRange ?? { min: Number.NaN, max: Number.NaN };\n    this._visualRange = { ...this.axisRange };\n    this._visualRangeStretch = opts.visualRangeStretch ?? true;\n\n    if (sourceType === `array`) {\n      this.source = new ArrayDataSource(this);\n    } else if (sourceType === `stream`) {\n      this.source = new StreamingDataSource(this);\n    } else throw new Error(`Unknown sourceType. Expected array|stream`);\n  }\n\n  formatValue(v: number) {\n    return v.toFixed(this.precision);\n  }\n\n  get visualRange(): DataRange {\n    let vr = this._visualRange;\n    const sourceRange = this.source.range;\n    let changed = false;\n\n    if (sourceRange.changed) {\n      if (this._visualRangeStretch) {\n        // Stretch range to lowest/highest-seen min/max\n        const rmin = Math.min(ifNaN(vr.min, sourceRange.min), sourceRange.min);\n        const rmax = Math.max(ifNaN(vr.max, sourceRange.max), sourceRange.max);\n        if (rmin !== vr.min || rmax !== vr.max) {\n          // Changed\n          vr = { min: rmin, max: rmax };\n          changed = true;\n        }\n      } else {\n        // Use actual range of data\n        if (!isRangeEqual(sourceRange, vr)) {\n          vr = sourceRange;\n          changed = true;\n        }\n      }\n    }\n    this._visualRange = vr;\n    return { ...vr, changed };\n  }\n\n  scaleValue(value: number): number {\n    if (this.source === undefined) return value;\n    const r = this.visualRange;\n    if (r.changed) {\n      this.plot.notify(`range-change`, this.plot.plotArea);\n    }\n    if (r.min == r.max) {\n      // No real scale - only received the same value for this series\n      return 0.5;\n    }\n    return scale(value, r.min, r.max);\n  }\n\n  add(value: number) {\n    throwNumberTest(value, ``, `value`);\n    this.source.add(value);\n    //this.plot.plotArea.layoutInvalidated(`Series.add`);\n    this.plot.plotArea.drawingInvalidated(`Series.add`);\n  }\n\n  /**\n   * Clears the underlying source\n   * and sets a flag that the plot area needs redrawing\n   */\n  clear() {\n    this.source.clear();\n    this._visualRange = { ...this.axisRange };\n    this.plot.plotArea.layoutInvalidated(`Series.clear`);\n  }\n}\n\nexport class PlotArea extends Sg.CanvasBox {\n  paddingPx = 5;\n  piPi = Math.PI * 2;\n  // If pointer is more than this distance away from a data point, it's ignored\n  pointerDistanceThreshold = 20;\n  lastRangeChange = 0;\n  pointer: Point | undefined;\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `PlotArea`, region);\n\n  }\n\n  clear() {\n    this.lastRangeChange = 0;\n    this.pointer = undefined;\n  }\n\n  protected measureSelf(\n    opts: Sg.MeasureState,\n    _parent?: Sg.Measurement\n  ): Rect | string {\n\n    const axisY = opts.getActualSize(`AxisY`);\n    const padding = this.paddingPx;\n    const legend = opts.getActualSize(`Legend`);\n    const legendHeight = legend?.height ?? 0;\n\n    const axisX = opts.getActualSize(`AxisX`);\n    const axisXHeight = axisX?.height ?? 0;\n\n    if (!axisY) return `No AxisY. Measured: ${ opts.whatIsMeasured().join(`, `) }`;\n    if (!legend) return `No Legend`;\n    if (!axisX) return `No AxisX`;\n\n    return {\n      width: opts.bounds.width - axisY.width - this.paddingPx,\n      height: opts.bounds.height - legendHeight - axisXHeight - padding,\n    };\n  }\n\n  protected layoutSelf(measureState: Sg.MeasureState, _layoutState: Sg.LayoutState, _parent: Sg.Layout) {\n    const axisY = measureState.getActualSize(`AxisY`);\n    //const axisX = measureState.getActualSize(`AxisX`);\n    const padding = this.paddingPx;\n\n    //const legend = measureState.getActualSize(`Legend`);\n    //const legendHeight = legend?.height ?? 0;\n\n    //const axisXHeight = axisX?.height ?? 0;\n    const axisYWidth = axisY?.width ?? 0;\n\n    //const height = this._measuredSize?.height ?? 0;\n\n    return {\n      x: axisYWidth,\n      y: padding // layoutState.bounds.height - height - axisXHeight - legendHeight\n    }\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    //this.debugLog(`onNotify message: ${ message } source: ${ source.id }`);\n    if (message === `measureApplied` && source === this.plot.axisY)\n      this.layoutInvalidated(`PlotArea.onNotify measureApplied to axisY`);\n    if (message === `laidout` && source === this.plot.legend)\n      this.layoutInvalidated(`PlotArea.onNotify laidout to legend`);\n  }\n\n  // protected onClick(p: Point): void {\n  //   this.plot.frozen = !this.plot.frozen;\n  // }\n\n  protected onPointerLeave(): void {\n    for (const series of this.plot.series.values()) {\n      series.tooltip = undefined;\n    }\n    this.pointer = undefined;\n    (this.plot.legend as Sg.CanvasBox).drawingInvalidated(`PlotArea.onPointerLeave`);\n  }\n\n  protected onPointerMove(p: Point): void {\n    this.pointer = p;\n    this.plot.legend.drawingInvalidated(`PlotArea.onPointerMove`);\n  }\n\n  protected measurePreflight(): void {\n    this.updateTooltip();\n  }\n\n  updateTooltip() {\n    const p = this.pointer;\n    if (p === undefined) return;\n\n    for (const series of this.plot.series.values()) {\n      if (p === undefined) {\n        series.tooltip = undefined;\n        return;\n      }\n      if (series.dataHitPoint === undefined) return;\n      const v = series.dataHitPoint(p);\n      if (v[ 0 ] === undefined) return;\n      if (v[ 1 ] > this.pointerDistanceThreshold) return; // too far away\n      series.tooltip = series.formatValue(v[ 0 ].value);\n      //this.plot.legend.onLayoutNeeded();\n    }\n    this.plot.legend.drawingInvalidated(`PlotArea.updateTooltip`);\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    if (this.plot.frozen) return;\n    const seriesCopy = this.plot.seriesArray(); // [...this.plot.series.values()];\n    //ctx.fillStyle = `hsla(10,50%,50%,0.5)`;\n    //ctx.fillRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n\n    // Using -1 for y to catch a few random peaks from sharp lines\n    ctx.clearRect(0, -1, this.canvasRegion.width, this.canvasRegion.height);\n\n    for (const series of seriesCopy) {\n      if (series.source.type === `array` || series.source.type === `stream`) {\n        const arraySeries = series.source as ArrayDataSource;\n        if (arraySeries.data === undefined) return;\n        const d = [ ...arraySeries.data ];\n        this.drawDataSet(series, d, ctx);\n      } else console.warn(`Unknown data source type ${ series.source.type }`);\n    }\n  }\n\n  computeY(series: Series, rawValue: number) {\n    const s = series.scaleValue(rawValue);\n    return flip(s) * this.canvasRegion.height + this.paddingPx;\n  }\n\n  drawDataSet(\n    series: Series,\n    d: Array<number>,\n    ctx: CanvasRenderingContext2D\n  ): void {\n    const padding = this.paddingPx + series.width;\n    const v = RectsSubtract(this.canvasRegion, padding * 2, padding * 3.5);\n    const pxPerPt = v.width / d.length;\n\n    series.lastPxPerPt = pxPerPt;\n    let x = padding;\n\n    ctx.strokeStyle = series.colour;\n    ctx.lineWidth = series.width;\n    const shapes: Array<DataPoint & PointCalculableShape> = [];\n\n    series.dataHitPoint = (pt: Point): [ DataPoint, number ] => {\n      const distances = shapes.map((v) => Points.distanceToExterior(pt, v));\n      const index = minIndex(...distances);\n      const closest = shapes[ index ];\n      if (closest === undefined) [ undefined, 0 ];\n      return [ closest, distances[ index ] ];\n    };\n\n    // eslint-disable-next-line unicorn/prefer-switch\n    if (series.drawingStyle === `line`) {\n      let y = 0;\n      ctx.beginPath();\n\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let index = 0; index < d.length; index++) {\n        const scaled = clamp(series.scaleValue(d[ index ]));\n        y = padding + this.paddingPx + v.height * flip(scaled);\n        shapes.push({ x, y, index: index, value: d[ index ] });\n\n        if (index == 0) ctx.moveTo(x + pxPerPt / 2, y);\n        else ctx.lineTo(x + pxPerPt / 2, y);\n\n        if (y > this.canvasRegion.height)\n          console.warn(`${ y } h: ${ this.canvasRegion.height }`);\n        x += pxPerPt;\n      }\n      ctx.strokeStyle = series.colour;\n      ctx.stroke();\n    } else if (series.drawingStyle === `dotted`) {\n      let y = 0;\n      ctx.fillStyle = series.colour;\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let index = 0; index < d.length; index++) {\n        const scaled = series.scaleValue(d[ index ]);\n        y = padding + v.height * flip(scaled);\n        ctx.beginPath();\n        ctx.arc(x + pxPerPt / 2, y, series.width, 0, this.piPi);\n        ctx.fill();\n        shapes.push({ radius: series.width, x, y, index: index, value: d[ index ] });\n        x += pxPerPt;\n      }\n    } else if (series.drawingStyle === `bar`) {\n      ctx.fillStyle = series.colour;\n      const interBarPadding = Math.ceil(pxPerPt * 0.1);\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let index = 0; index < d.length; index++) {\n        const scaled = series.scaleValue(d[ index ]);\n        const h = v.height * scaled;\n        const r = {\n          x: x + interBarPadding,\n          y: v.height - h + padding,\n          width: pxPerPt - interBarPadding,\n          height: h,\n          index: index,\n          value: d[ index ],\n        };\n        ctx.fillRect(r.x, r.y, r.width, r.height);\n        shapes.push(r);\n        x += pxPerPt;\n      }\n    }\n  }\n}\n\nexport class Legend extends Sg.CanvasBox {\n  sampleSize = { width: 10, height: 10 };\n  padding = 3;\n  widthSnapping = 20;\n\n  labelMeasurements = new Map<string, RectPositioned>();\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `Legend`, region);\n  }\n\n  clear() {\n    /** no-op */\n  }\n\n  protected layoutSelf(measureState: Sg.MeasureState, layoutState: Sg.LayoutState, _parent: Sg.Layout) {\n    const axisY = measureState.getActualSize(`AxisY`);\n    const axisYWidth = axisY?.width ?? 0;\n\n    const height = this._measuredSize?.height ?? 0;\n    return {\n      x: axisYWidth,\n      y: layoutState.bounds.height - height\n    }\n  }\n\n  protected measureSelf(\n    opts: Sg.CanvasMeasureState,\n    _parent?: Sg.Measurement\n  ): Rect | RectPositioned | string {\n    const series = this.plot.seriesArray();\n    const sample = this.sampleSize;\n    const padding = this.padding;\n    const widthSnapping = this.widthSnapping;\n    const ctx = opts.ctx;\n\n    const yAxis = opts.measurements.get(`AxisY`);\n    const yAxisWidth = yAxis?.actual.width ?? 0;\n\n    let x = padding;\n    let y = padding;\n    const availableWidth = opts.bounds.width - yAxisWidth - padding;\n\n    //let rows = 1;\n    let rowHeight = 0;\n    for (const s of series) {\n      const startX = x;\n      x += sample.width + padding;\n      ctx.textBaseline = `middle`;\n\n      const text = textRect(ctx, s.name, padding, widthSnapping);\n\n      x += textWidth(ctx, s.name, padding, widthSnapping);\n\n      if (s.tooltip) {\n        x += textWidth(ctx, s.tooltip, padding, widthSnapping);\n      }\n      const r = { width: 10, height: 10, x: startX, y };\n\n      this.labelMeasurements.set(s.name, r)\n      rowHeight = Math.min(sample.height + padding + padding, text.height + padding + padding);\n      x += padding;\n      if (x > availableWidth) {\n        x = padding;\n        y += rowHeight;\n        //rows++;\n\n      }\n    }\n\n    return {\n      width: availableWidth,\n      height: y + rowHeight\n    }\n    // const ctx = (opts as Sg.CanvasMeasureState).ctx;\n\n    // const usableWidth = opts.bounds.width - yAxisWidth;\n\n    // let width = padding;\n    // for (const s of series) {\n    //   width += sample.width + padding;\n    //   width += textWidth(ctx, s.name, padding, widthSnapping);\n    //   width += textWidth(ctx, s.tooltip, padding, widthSnapping);\n    // }\n\n    // const rows = Math.max(1, Math.ceil(width / usableWidth));\n    // console.log(`rows: ${ rows }`);\n    // const h = rows * (this.sampleSize.height + this.padding + this.padding);\n    // return {\n    //   x: yAxisWidth,\n    //   y: opts.bounds.height - h,\n    //   width: usableWidth,\n    //   height: h,\n    // };\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    const series = this.plot.seriesArray();\n    const sample = this.sampleSize;\n    const padding = this.padding;\n    this.debugLog(`drawSelf`);\n\n    ctx.clearRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n    for (const s of series) {\n      const r = this.labelMeasurements.get(s.name);\n      if (r === undefined) continue;\n      let x = r.x;\n\n      // Draw colour chip\n      ctx.fillStyle = s.colour;\n      ctx.fillRect(x, r.y, sample.width, sample.height);\n      x += sample.width + padding;\n\n      // Label\n      ctx.textBaseline = `middle`;\n      ctx.fillStyle = this.plot.legendTextColour;\n      ctx.fillText(s.name, x, r.y + sample.height / 2);\n\n      if (s.tooltip) {\n        ctx.fillStyle = this.plot.legendTextColour;\n        ctx.fillText(s.tooltip, r.x, r.y + sample.height / 2);\n      }\n    }\n    // const series = this.plot.seriesArray();\n    // const sample = this.sampleSize;\n    // const padding = this.padding;\n    // const widthSnapping = this.widthSnapping;\n\n    // let x = padding;\n    // let y = padding;\n\n    // ctx.clearRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n    // let rows = 1;\n    // for (const s of series) {\n    //   ctx.fillStyle = s.colour;\n    //   ctx.fillRect(x, y, sample.width, sample.height);\n    //   x += sample.width + padding;\n    //   ctx.textBaseline = `middle`;\n    //   ctx.fillStyle = this.plot.legendTextColour;\n    //   ctx.fillText(s.name, x, y + sample.height / 2);\n    //   x += textWidth(ctx, s.name, padding, widthSnapping);\n\n    //   if (s.tooltip) {\n    //     ctx.fillStyle = this.plot.legendTextColour;\n    //     ctx.fillText(s.tooltip, x, y + sample.height / 2);\n    //     x += textWidth(ctx, s.tooltip, padding, widthSnapping);\n    //   }\n    //   x += padding;\n    //   if (x > this.canvasRegion.width - 100) {\n    //     x = padding;\n    //     y += sample.height + padding + padding;\n    //     rows++;\n    //     this.debugLog(`drawSelf rows: ${ rows }`);\n    //   }\n    // }\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    this.debugLog(`onNotify ${ message } source: ${ source.id }`);\n    if (message === `measureApplied` && source === (this._parent as Plot).axisY) {\n      this.layoutInvalidated(`Legend.onNotify measureApplied to axisY`);\n\n    } else if (message == `range-change`) {\n      //this.layoutInvalidated(`Legend.onNotify range-change`);\n    }\n  }\n}\n\nexport class AxisX extends Sg.CanvasBox {\n  paddingPx = 2;\n  colour?: string;\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `AxisX`, region);\n  }\n\n  clear() {\n    /** no-op */\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    //this.debugLog(message);\n    if (message === `measureApplied` && source === this.plot.axisY) {\n      this.layoutInvalidated(`AxisX.onNotify measureApplied to axisY`);\n    }\n    // if (message === `measureApplied` && source === this.plot.legend) {\n    //   this.layoutInvalidated(`AxisX.onNotify measureApplied to legend`);\n    // }\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    const plot = this.plot;\n    const v = this.canvasRegion;\n    const strokeWidth = plot.axisStrokeWidth;\n\n    const colour = this.colour ?? plot.axisStrokeColour;\n    ctx.strokeStyle = colour;\n\n    ctx.clearRect(0, 0, v.width, v.height);\n    //ctx.fillStyle = `hsla(200,50%,50%,0.5)`;\n    //ctx.fillRect(0, 0, v.width, v.height);\n    //this.debugLog(`drawSelf: ${ v.width } x ${ v.height } padding: ${ this.paddingPx }`);\n    ctx.beginPath();\n    ctx.lineWidth = strokeWidth;\n    ctx.moveTo(0, strokeWidth / 2);\n    ctx.lineTo(v.width, strokeWidth / 2);\n    ctx.stroke();\n  }\n\n  protected measureSelf(\n    opts: Sg.CanvasMeasureState,\n    _parent?: Sg.Measurement\n  ): Rect | RectPositioned | string {\n    const plot = this.plot;\n    const padding = this.paddingPx;\n    const yAxis = opts.measurements.get(`AxisY`);\n    const yAxisWidth = yAxis?.actual.width ?? 0;\n\n    // TODO: If we start using x-axis labels\n    const heightOfText = 0;//textHeight(opts.ctx, `100`, padding);\n    const h = plot.axisStrokeWidth + heightOfText + padding + padding;\n\n    return {\n      width: opts.bounds.width - yAxisWidth - padding,\n      height: h,\n    };\n  }\n\n  protected layoutSelf(measureState: Sg.MeasureState, _layoutState: Sg.LayoutState, _parent?: Sg.Layout | undefined): Point | undefined {\n    const yAxis = measureState.measurements.get(`AxisY`);\n    const legend = measureState.getActualSize(`Legend`);\n    const legendHeight = legend?.height ?? 0;\n\n    const yAxisWidth = yAxis?.actual.width ?? 0;\n\n    const height = this._measuredSize?.height ?? 0;\n    return {\n      x: yAxisWidth,\n      y: measureState.bounds.height - height - legendHeight\n    }\n  }\n}\n\nconst isRangeEqual = (a: DataRange, b: DataRange) =>\n  a.max === b.max && a.min === b.min;\nconst isRangeSinglePoint = (a: DataRange) => a.max === a.min;\n\nexport class AxisY extends Sg.CanvasBox {\n  // Number of digits axis will be expected to show as a data legend\n  private _maxDigits = 1;\n\n  seriesToShow: string | undefined;\n  paddingPx = 2;\n  colour?: string;\n\n  lastRange: DataRange;\n  lastPlotAreaHeight = 0;\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `AxisY`, region);\n    this.lastRange = { min: 0, max: 0 };\n  }\n\n  clear() {\n    this.lastRange = { min: 0, max: 0 };\n    this.lastPlotAreaHeight = 0;\n  }\n\n  protected measurePreflight(): void {\n    //this.debugLog(`measurePreflight`);\n    // const series = this.getSeries();\n    // if (\n    //   series !== undefined &&\n    //   !isRangeEqual(series.visualRange, this.lastRange)\n    // ) {\n    //   this.layoutInvalidated(`AxisY.measurePreflight`);\n    // }\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    //this.debugLog(message);\n    const pa = this.plot.plotArea;\n    if (message === `range-change`) {\n      // Notification that series range has changed\n      this.drawingInvalidated(`range-change`);\n      return;\n    }\n\n    if (message === `measureApplied` && source === pa && (pa.canvasRegion.height !== this.lastPlotAreaHeight)) {\n      this.lastPlotAreaHeight = pa.canvasRegion.height;\n      this.drawingInvalidated(`AxisY.onNotify height change`);\n    }\n  }\n\n  protected measureSelf(copts: Sg.CanvasMeasureState): Rect {\n    //this.debugLog(`measureSelf. needsLayout: ${ this._needsLayoutX } needsDrawing: ${ this._needsDrawing }`);\n\n    if (copts.ctx === undefined) throw new Error(`opts.ctx is undefined`);\n\n    const paddingPx = this.paddingPx;\n    let width = this.plot.axisStrokeWidth + paddingPx;\n\n    const series = this.getSeries();\n    if (series !== undefined) {\n      const r = series.visualRange;\n      this._maxDigits =\n        Math.ceil(r.max).toString().length + series.precision + 1;\n\n      const textToMeasure = `9`.repeat(this._maxDigits);\n      width += textWidth(copts.ctx, textToMeasure, paddingPx * 2);\n    }\n    const w = copts.resolveToPx(this.desiredRegion?.width, width, width);\n    return {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      width: w!,\n      height: copts.bounds.height,\n    };\n  }\n\n  protected layoutSelf(_measureState: Sg.MeasureState, _layoutState: Sg.LayoutState, _parent?: Sg.Layout | undefined): Point {\n    return { x: 0, y: 0 }\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    const s = this.getSeries();\n    if (s === undefined) {\n      if (this.seriesToShow === undefined) return;\n      console.warn(`Plot AxisY series '${ this.seriesToShow }' is missing.`);\n    } else {\n      this.seriesAxis(s, ctx);\n    }\n  }\n\n  getSeries(): Series | undefined {\n    return this.seriesToShow === undefined ?\n      // Pick first series\n      this.plot.seriesArray()[ 0 ] :\n      // Try designated series name\n      this.plot.series.get(this.seriesToShow);\n  }\n\n  seriesAxis(series: Series, ctx: CanvasRenderingContext2D) {\n    const plot = this.plot;\n    const plotArea = plot.plotArea;\n    const v = this.canvasRegion;\n    const paddingPx = this.paddingPx;\n    const r = series.visualRange;\n    const strokeWidth = plot.axisStrokeWidth;\n\n    const colour = this.colour ?? plot.axisStrokeColour;\n    ctx.strokeStyle = colour;\n    ctx.fillStyle = colour;\n\n    if (Number.isNaN(r.min) && Number.isNaN(r.max)) return; // Empty\n    this.lastRange = r;\n    ctx.clearRect(0, 0, v.width, v.height);\n\n    // ctx.fillStyle = `yellow`;\n    // ctx.fillRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n\n    ctx.beginPath();\n    ctx.lineWidth = strokeWidth;\n    const lineX = v.width - strokeWidth / 2;\n    ctx.moveTo(lineX, plotArea.paddingPx + strokeWidth);\n    ctx.lineTo(lineX, plotArea.canvasRegion.height + paddingPx + strokeWidth + strokeWidth);\n    ctx.stroke();\n\n    ctx.textBaseline = `top`;\n    const fromRight = v.width - paddingPx * 4;\n\n    ctx.fillStyle = plot.axisTextColour;\n    if (isRangeSinglePoint(r)) {\n      this.debugLog(`rangeSinglePoint`);\n      drawText(ctx, series.formatValue(r.max), (size) => [\n        fromRight - size.width,\n        plotArea.computeY(series, r.max) - paddingPx * 4,\n      ]);\n    } else {\n      // Draw min/max data labels\n      drawText(ctx, series.formatValue(r.max), (size) => [\n        fromRight - size.width,\n        plotArea.computeY(series, r.max) + strokeWidth / 2,\n      ]);\n      drawText(ctx, series.formatValue(r.min), (size) => [\n        fromRight - size.width,\n        plotArea.computeY(series, r.min) - 5,\n      ]);\n    }\n  }\n}\n\nconst drawText = (\n  ctx: CanvasRenderingContext2D,\n  text: string,\n  position: (size: TextMetrics) => [ x: number, y: number ]\n) => {\n  if (ctx === undefined) throw new Error(`ctx is undefined`);\n  const size = ctx.measureText(text);\n  const xy = position(size);\n  ctx.fillText(text, xy[ 0 ], xy[ 1 ]);\n};\n\n/**\n * Canvas-based data plotter.\n *\n * ```\n * const p = new Plot(document.getElementById(`myCanvas`), opts);\n *\n * // Plot 1-5 as series  test'\n * p.createSeries(`test`, `array`, [1,2,3,4,5]);\n *\n * // Create a streaming series, add a random number\n * const s = p.createSeries(`test2`, `stream`);\n * s.add(Math.random());\n * ```\n * `createSeries` returns the {@link Series} instance with properties for fine-tuning\n *\n * For simple usage, use `plot(someData)` which automatically creates\n * series for the properties of an object.\n */\nexport class Plot extends Sg.CanvasBox {\n  plotArea: PlotArea;\n  legend: Legend;\n  axisX: AxisX;\n  axisY: AxisY;\n  axisStrokeColour: string;\n  axisTextColour: string;\n  legendTextColour: string;\n\n  axisStrokeWidth: number;\n  series: Map<string, Series>;\n  private _frozen = false;\n  private _canvasEl: HTMLCanvasElement;\n  private _ctx: CanvasRenderingContext2D;\n\n  defaultSeriesOpts?: SeriesOpts;\n  constructor(canvasElementOrQuery: HTMLCanvasElement | string, opts: Opts = {}) {\n    const { ctx, element, bounds } = scaleCanvas(canvasElementOrQuery);\n    super(undefined, `Plot`);//bounds);\n    this._canvasEl = element;\n    this._ctx = ctx;\n\n    if (opts.autoSize) {\n      parentSizeCanvas(element, (event) => {\n        this.drawingInvalidated(`resize`);\n        this.layoutInvalidated(`resize`);\n        this.update(event.ctx, true);\n      });\n    }\n\n    this.axisStrokeColour = opts.axisStrokeColour ?? `black`;\n    this.axisTextColour = opts.axisTextColour ?? `black`;\n    this.legendTextColour = opts.legendTextColour ?? `black`;\n\n    this.axisStrokeWidth = opts.axisStrokeWidth ?? 3;\n    this.series = new Map();\n    this.plotArea = new PlotArea(this, bounds);\n    this.legend = new Legend(this, bounds);\n    this.axisX = new AxisX(this, bounds);\n    this.axisY = new AxisY(this, bounds);\n\n    // this.plotArea.debugLayout = true;\n    // this.axisX.debugLayout = true;\n    // this.axisY.debugLayout = true;\n    // this.legend.debugLayout = true;\n    // this.debugLayout = true;\n  }\n\n  update(ctx?: CanvasRenderingContext2D, force = false) {\n    if (ctx === undefined) ctx = this._ctx;\n    super.update(ctx, force);\n    // this.plotArea.update(ctx, force);\n    // this.axisX.update(ctx, force);\n    // this.axisY.update(ctx, force);\n    // this.legend.update(ctx, force);\n  }\n\n  /**\n   * Calls 'clear()' on each of the series\n   */\n  clearSeries() {\n    for (const series of this.series.values()) {\n      series.clear();\n    }\n    this.update();\n  }\n\n  /**\n   * Removes all series, plot, legend\n   * and axis data.\n   */\n  clear() {\n    this.series = new Map();\n    this.plotArea.clear();\n    this.legend.clear();\n    this.axisX.clear();\n    this.axisY.clear();\n    this.layoutInvalidated(`Plot.clear`);\n    this.drawingInvalidated(`Plot.clear`);\n    this.update();\n  }\n\n  get frozen(): boolean {\n    return this._frozen;\n  }\n\n  set frozen(v: boolean) {\n    this._frozen = v;\n    if (v) {\n      this._canvasEl.classList.add(`frozen`);\n      this._canvasEl.title = `Plot frozen. Tap to unfreeze`;\n    } else {\n      this._canvasEl.title = ``;\n      this._canvasEl.classList.remove(`frozen`);\n    }\n  }\n\n  seriesArray(): Array<Series> {\n    return [ ...this.series.values() ];\n  }\n\n  get seriesLength(): number {\n    return this.series.size;\n  }\n\n  /**\n   * Plots a simple object, eg `{ x: 10, y: 20, z: 300 }`\n   * Series are automatically created for each property of `o`\n   *\n   * Be sure to call `update()` to visually refresh.\n   * @param o\n   */\n  plot(o: any) {\n    const paths = getPaths(o, true);\n    let seriesCreated = false;\n    for (const p of paths) {\n      let s = this.series.get(p);\n      if (s === undefined) {\n        s = this.createSeries(p, `stream`);\n        s.drawingStyle = `line`;\n        seriesCreated = true;\n      }\n      s.add(getField(o, p));\n    }\n    if (seriesCreated) this.legend.layoutInvalidated(`new series`);\n    this.update();\n  }\n\n  createSeriesFromObject(o: any, prefix = ``): Array<Series> {\n    const keys = Object.keys(o);\n    const create = (key: string): Array<Series> => {\n      const v = o[ key ];\n      if (typeof v === `object`) {\n        return this.createSeriesFromObject(v, `${ prefix }${ key }.`);\n      } else if (typeof v === `number`) {\n        return [ this.createSeries(key, `stream`) ];\n      } else {\n        return [];\n      }\n    };\n    return keys.flatMap(k => create(k));\n  }\n\n  createSeries(\n    name?: string,\n    type: `stream` | `array` = `array`,\n    seriesOpts?: SeriesOpts\n  ): Series {\n    const seriesLength = this.seriesLength;\n\n    if (name === undefined) name = `series-${ seriesLength }`;\n    if (this.series.has(name))\n      throw new Error(`Series name '${ name }' already in use`);\n\n    let opts: SeriesOpts = {\n      colour: `hsl(${ (seriesLength * 25) % 360 }, 70%,50%)`,\n      ...seriesOpts,\n    };\n    if (this.defaultSeriesOpts) opts = { ...this.defaultSeriesOpts, ...opts };\n\n    const s = new Series(name, type, this, opts);\n    // if (type === `array` && initialData !== undefined) {\n    //   (s.source as ArrayDataSource).set(initialData);\n    // }\n\n    this.series.set(name, s);\n    this.setReady(true, true);\n    this.plotArea.drawingInvalidated(`Plot.createSeries`);\n    return s;\n  }\n}\n","// #region imports\nimport { intersectsPoint as RectsIntersectsPoint } from '../geometry/rect/Intersects.js';\nimport { isPlaceholder as RectsIsPlaceholder } from '../geometry/rect/Guard.js';\nimport { emptyPositioned as RectsEmptyPositioned } from '../geometry/rect/Empty.js';\nimport { placeholderPositioned as RectsPlaceholderPositioned, placeholder as RectsPlaceholder } from '../geometry/rect/Placeholder.js';\nimport { hue as randomHue } from '../random/index.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport type { Rect, RectPositioned } from '../geometry/rect/index.js';\nimport { isEqualSize as RectIsEqualSize } from '../geometry/rect/IsEqual.js';\nimport { isEqual as PointsIsEqual } from '../geometry/point/IsEqual.js';\nimport { Empty as PointsEmpty } from '../geometry/point/Empty.js';\nimport { withoutUndefined } from '../collections/arrays/Filter.js';\nimport { clamp as RectsClamp } from '../geometry/rect/Clamp.js';\nimport { subtract as PointsSubtract } from '../geometry/point/Subtract.js';\n// #endregion\nexport type Measurement = {\n  actual: Rect;\n  ref: Box;\n  children: Array<Measurement | undefined>;\n};\n\nexport type Layout = {\n  actual: Point;\n  ref: Box;\n  children: Array<Layout | undefined>;\n};\n\nexport type PxUnit = {\n  value: number;\n  type: `px`;\n};\n\nexport type PcUnit = {\n  value: number;\n  type: `pc`;\n};\n\nexport type BoxUnit = PxUnit | PcUnit;\n\nexport type BoxRect = {\n  x?: BoxUnit;\n  y?: BoxUnit;\n  width?: BoxUnit;\n  height?: BoxUnit;\n};\n\nexport const boxUnitFromPx = (v: number): PxUnit => {\n  return { type: `px`, value: v };\n}\nexport const boxRectFromPx = (x: number, y: number, width: number, height: number): BoxRect => {\n  return {\n    x: boxUnitFromPx(x),\n    y: boxUnitFromPx(y),\n    width: boxUnitFromPx(width),\n    height: boxUnitFromPx(height)\n  }\n}\nexport const boxRectFromRectPx = (r: RectPositioned): BoxRect => {\n  return {\n    x: boxUnitFromPx(r.x),\n    y: boxUnitFromPx(r.y),\n    width: boxUnitFromPx(r.width),\n    height: boxUnitFromPx(r.height)\n  }\n}\n\nconst unitIsEqual = (a: BoxUnit, b: BoxUnit): boolean => {\n  if (a.type === `px` && b.type === `px`) {\n    return a.value === b.value;\n  }\n  return false;\n};\n\nconst boxRectIsEqual = (\n  a: BoxRect | undefined,\n  b: BoxRect | undefined\n): boolean => {\n  if (a === undefined && b === undefined) return true;\n  if (a === undefined) return false;\n  if (b === undefined) return false;\n  if (a.x && b.x && !unitIsEqual(a.x, b.x)) return false;\n  if (a.y && b.y && !unitIsEqual(a.y, b.y)) return false;\n  if (a.width && b.width && !unitIsEqual(a.width, b.width)) return false;\n  if (a.height && b.height && !unitIsEqual(a.height, b.height)) return false;\n  return true;\n};\n\nclass BaseState {\n  bounds: RectPositioned;\n  pass: number;\n  constructor(bounds: RectPositioned) {\n    this.bounds = bounds;\n    this.pass = 0;\n  }\n\n  resolveToPx(u: BoxUnit | undefined, maxValue: number, defaultValue?: number): number | undefined {\n    if (u === undefined && defaultValue !== undefined) return defaultValue;\n    if (u === undefined) return; //throw new Error(`unit undefined`);\n    if (u.type === undefined) throw new TypeError(`Expected 'type' and 'value' fields. Type is missing`);\n    if (u.value === undefined) throw new TypeError(`Expected 'type' and 'value' fields. Value is missing`);\n\n\n    if (u.type === `px`) return u.value;\n    if (u.type === `pc`) return u.value * maxValue;\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    // @ts-expect-error\n    throw new Error(`Unknown unit type: ${ u.type }`);\n  }\n\n  resolveBox(box: BoxRect | undefined): Rect | RectPositioned | undefined {\n    if (box === undefined) return undefined;\n    const x = this.resolveToPx(box.x, this.bounds.width);\n    const y = this.resolveToPx(box.y, this.bounds.height);\n    const width = this.resolveToPx(box.width, this.bounds.width);\n    const height = this.resolveToPx(box.height, this.bounds.height);\n    if (!width || !height) throw new TypeError(`Expected width and height`);\n    if (x === undefined && y === undefined) {\n      return Object.freeze({ width, height });\n    } else {\n      if (!x || !y) throw new TypeError(`Expected x and y`);\n      return Object.freeze({\n        x, y, width, height\n      });\n    }\n  }\n}\n\nexport class MeasureState extends BaseState {\n  measurements: Map<string, Measurement>;\n\n  constructor(bounds: RectPositioned) {\n    super(bounds);\n    this.measurements = new Map<string, Measurement>();\n  }\n\n  getActualSize(id: string): Rect | undefined {\n    const s = this.measurements.get(id);\n    if (s === undefined) return;\n    if (RectsIsPlaceholder(s.actual)) return;\n    return s.actual;\n  }\n\n  whatIsMeasured(): Array<string> {\n    return [ ...this.measurements.keys() ]\n  }\n}\n\nexport class LayoutState extends BaseState {\n  layouts: Map<string, Layout>;\n\n  constructor(bounds: RectPositioned) {\n    super(bounds);\n    this.layouts = new Map<string, Layout>();\n  }\n}\n/**\n * Box\n */\nexport abstract class Box {\n\n  /** Rectangle Box occupies in canvas/etc */\n  canvasRegion: RectPositioned = RectsPlaceholderPositioned;\n\n  private _desiredRect: BoxRect | undefined;\n\n  protected _measuredSize: Rect | undefined;\n  protected _layoutPosition: Point | undefined;\n\n  protected children: Array<Box> = [];\n  protected readonly _parent: Box | undefined;\n  private _idMap = new Map<string, Box>();\n\n  debugLayout = false;\n\n  private _visible = true;\n  protected _ready = true;\n\n  takesSpaceWhenInvisible = false;\n\n  protected _needsMeasuring = true;\n  protected _needsLayoutX = true;\n  protected _needsDrawing = true;\n\n  debugHue = randomHue();\n  readonly id: string;\n\n  /**\n   * Constructor.\n   * \n   * If `parent` is provided, `parent.onChildAdded(this)` is called.\n   * @param parent parent box \n   * @param id id of this box\n   */\n  constructor(parent: Box | undefined, id: string) {\n    this.id = id;\n    this._parent = parent;\n\n    parent?.onChildAdded(this);\n  }\n\n  /**\n   * Returns _true_ if `box` is a child\n   * @param box \n   * @returns \n   */\n  hasChild(box: Box): boolean {\n    const byReference = this.children.find((c) => c === box);\n    const byId = this.children.find((c) => c.id === box.id);\n    return byReference !== undefined || byId !== undefined;\n  }\n\n  /**\n   * Sends a message to all child boxes.\n   * \n   * This first calls `onNotify` on this instance,\n   * before calling `notify()` on each child.\n   * @param message \n   * @param source \n   */\n  notify(message: string, source: Box) {\n    this.onNotify(message, source);\n    for (const c of this.children) c.notify(message, source);\n  }\n\n  *getChildren() {\n    return this.children.entries();\n  }\n\n  /**\n   * Handles a received message\n   * @param _message \n   * @param _source \n   */\n  protected onNotify(_message: string, _source: Box) {\n    /** no-op */\n  }\n\n  /**\n   * Notification a child box has been added\n   * \n   * Throws if\n   * - child has parent as its own child\n   * - child is same as this\n   * - child is already child of this\n   * @param child \n   */\n  protected onChildAdded(child: Box) {\n    if (child.hasChild(this)) throw new Error(`Recursive`);\n    if (child === this) throw new Error(`Cannot add self as child`);\n    if (this.hasChild(child)) throw new Error(`Child already present`);\n\n    this.children.push(child);\n    this._idMap.set(child.id, child);\n\n    this.layoutInvalidated(`Box.onChildAdded`);\n  }\n\n  /**\n   * Sets `_ready` to `ready`. If `includeChildren` is _true_,\n   * `setReady` is called on each child\n   * @param ready \n   * @param includeChildren \n   */\n  setReady(ready: boolean, includeChildren = false) {\n    this._ready = ready;\n    if (includeChildren) {\n      for (const c of this.children) c.setReady(ready, includeChildren);\n    }\n  }\n\n  /**\n   * Gets visible state\n   */\n  get visible(): boolean {\n    return this._visible;\n  }\n\n  /**\n   * Sets visible state\n   */\n  set visible(v: boolean) {\n    if (this._visible === v) return;\n    this._visible = v;\n\n    // Invalidated because we skip measuring when it is invisible\n    this.layoutInvalidated(`Box.set visible`);\n  }\n\n  /**\n   * Gets the box's desired region, or _undefined_\n   */\n  get desiredRegion(): BoxRect | undefined {\n    return this._desiredRect;\n  }\n\n  /**\n   * Sets the box's desired region.\n   * Calls `onLayoutNeeded()`\n   */\n  set desiredRegion(v: BoxRect | undefined) {\n    if (boxRectIsEqual(v, this._desiredRect)) return;\n    this._desiredRect = v;\n    this.layoutInvalidated(`set desiredRegion`);\n  }\n\n  /**\n   * Calls `notifyChildLayoutNeeded`\n   */\n  layoutInvalidated(reason: string) {\n    if (reason === undefined) debugger;\n    this.debugLog(`layoutInvalidated ${ reason }`);\n    this._needsMeasuring = true;\n    this._needsLayoutX = true;\n    // TODO: Only set to true during measuring if it actually changes\n    this._needsDrawing = true;\n    this.notifyChildLayoutNeeded();\n  }\n\n  drawingInvalidated(_reason: string): void {\n    this._needsDrawing = true;\n    //this.debugLog(`drawingInvalidated ${ reason }`);\n  }\n\n  /**\n   * Called from a child, notifying us that\n   * its layout has changed\n   * @returns \n   */\n  private notifyChildLayoutNeeded() {\n    // TODO: Not all layout changes require re-layout higher up\n    this._needsDrawing = true;\n    this._needsLayoutX = true;\n    this._needsMeasuring = true;\n    if (this._parent === undefined) return;\n    this._parent.notifyChildLayoutNeeded();\n  }\n\n  /**\n   * Returns the root box\n   */\n  get root(): Box {\n    if (this._parent === undefined) return this;\n    return this._parent.root;\n  }\n\n  /**\n   * Prepare for measuring\n   */\n  protected measurePreflight() {\n    /** no-up */\n  }\n\n  /**\n   * Applies actual size, returning _true_ if size is different than before\n   * \n   * 1. Sets `_needsLayout` to _false_.\n   * 2. Sets `visual` to `m`\n   * 3. Calls `measureApply` on each child\n   * 4. If there's a change or `force`, sets `needsDrawing` to _true_, and notifies root of `measureApplied`\n   * @param m Measurement for box\n   * @returns \n   */\n  protected measureApply(m: Measurement) {\n    this._needsMeasuring = false;\n\n    const different = this._measuredSize === undefined ? true : !RectIsEqualSize(m.actual, this._measuredSize);\n    if (different) {\n      //this.debugLog(`measureApply: Size is different than previous. Actual: ${ JSON.stringify(m.actual) } current: ${ JSON.stringify(this._measuredSize) }`);\n      this._needsLayoutX = true;\n    }\n\n    this._measuredSize = { width: m.actual.width, height: m.actual.height };\n\n    for (const c of m.children) {\n      if (c !== undefined) c.ref.measureApply(c);\n    }\n\n    if (different) {\n      this.root.notify(`measureApplied`, this);\n    }\n    return different;\n  }\n\n  protected layoutApply(l: Layout) {\n    this._needsLayoutX = false;\n\n    const different = this._layoutPosition === undefined ? true : !PointsIsEqual(l.actual, this._layoutPosition);\n    // if (different) {\n    //   this.debugLog(`layoutApply. Position different than previous. ${ JSON.stringify(l.actual) }`);\n    // }\n    this._layoutPosition = { x: l.actual.x, y: l.actual.y };\n\n    for (const c of l.children) {\n      if (c !== undefined) c.ref.layoutApply(c);\n    }\n\n    if (different) {\n      this.root.notify(`layoutApplied`, this);\n    }\n    return different;\n  }\n\n  /**\n   * Debug log from this box context\n   * @param m \n   */\n  debugLog(m: any) {\n    if (!this.debugLayout) return;\n    console.log(this.id, m);\n\n  }\n\n  layoutStart(measureState: MeasureState, layoutState: LayoutState, force: boolean, parent?: Layout): Layout | undefined {\n    const m: Layout = {\n      ref: this,\n      actual: PointsEmpty,\n      children: [],\n    };\n    // Stash away measurement by id\n    layoutState.layouts.set(this.id, m);\n\n    const currentPosition = this.layoutSelf(measureState, layoutState, parent);\n    this.root.notify(`laidout`, this);\n\n    // For some reason we can't measure\n    if (currentPosition === undefined) return;\n\n    // Assign\n    m.actual = currentPosition;\n\n    m.children = this.children.map((c) => c.layoutStart(measureState, layoutState, force, m));\n    if (withoutUndefined(m.children).length < this.children.length) {\n      return undefined; // One of the children did not resolve\n    }\n    return m;\n  }\n\n  protected layoutSelf(\n    measureState: MeasureState,\n    layoutState: LayoutState,\n    _parent?: Layout\n  ): Point | undefined {\n    // TODO: Proper layout\n    const box = layoutState.resolveBox(this._desiredRect);\n    const x = box === undefined ? 0 : (`x` in box ? box.x : 0);\n    const y = box === undefined ? 0 : (`y` in box ? box.y : 0);\n    if (x === undefined) debugger;\n    if (y === undefined) debugger;\n    return { x, y }\n  }\n\n  /**\n   * Start of measuring\n   * 1. Keeps track of measurements in `opts.measurements`\n   * 2. If this box takes space\n   * 2.1. Measure itself if needed\n   * 2.2. Use size\n   * 2. Calls `measureStart` on each child\n   * @param opts Options\n   * @param force Force measurement\n   * @param parent Parent's measurement \n   * @returns Measurement\n   */\n  measureStart(\n    opts: MeasureState,\n    force: boolean,\n    parent?: Measurement\n  ): Measurement | undefined {\n    this.measurePreflight();\n\n    const m: Measurement = {\n      ref: this,\n      // So far no known measurement\n      actual: RectsPlaceholder,\n      children: [],\n    };\n    // Stash away measurement by id\n    opts.measurements.set(this.id, m);\n\n    if (!this._visible && !this.takesSpaceWhenInvisible) {\n      // If we're not visible, there's no actual size\n      m.actual = RectsEmptyPositioned;\n    } else {\n      let currentMeasurement: Rect | string | undefined = this._measuredSize;\n\n      // If we need to, measure how big it actually is\n      if (this._needsMeasuring || this._measuredSize === undefined) {\n        currentMeasurement = this.measureSelf(opts, parent);\n        this.root.notify(`measured`, this);\n      }\n\n      // For some reason we can't measure\n      if (typeof currentMeasurement === `string`) {\n        //this.debugLog(`measureStart: measureSelf failed: ${ currentMeasurement }`);\n        return;\n      } else if (currentMeasurement === undefined) {\n        //this.debugLog(`measureStart: measureSelf failed for some other reason`);\n        return;\n      }\n\n      // Assign\n      m.actual = currentMeasurement;\n    }\n\n    m.children = this.children.map((c) => c.measureStart(opts, force, m));\n    if (withoutUndefined(m.children).length < this.children.length) {\n      //this.debugLog(`measureStart: Child failed measureStart`);\n      return undefined; // One of the children did not resolve\n    }\n\n    return m;\n  }\n\n  /**\n   * Measure the box\n   * 1. Uses desired rectangle, if possible\n   * 2. Otherwise uses parent's size\n   * @param opts Measure state\n   * @param parent Parent size\n   * @returns \n   */\n  protected measureSelf(\n    opts: MeasureState,\n    parent?: Measurement\n  ): Rect | string {\n    let size = RectsPlaceholder;\n\n    const context = parent ? parent.actual : opts.bounds;\n    const desired = opts.resolveBox(this._desiredRect);\n\n    size = desired ? RectsClamp(desired, context) : context;\n\n    if (RectsIsPlaceholder(size)) {\n      return `Box.measureSelf - No size for box?`;\n    }\n    return size;\n  }\n\n\n  /**\n   * Gets initial state for a run of measurements & layout.\n   * \n   * Called when update() is called\n   * @param context\n   */\n  protected abstract updateBegin(context: any): [ MeasureState, LayoutState ];\n\n  protected abstract updateComplete(measureChanged: boolean, layoutChanged: boolean): void;\n\n  // protected updateDone(state: MeasureState, force: boolean): void {\n  //   this.onUpdateDone(state, force);\n  //   for (const c of this.children) c.updateDone(state, force);\n  // }\n\n  /**\n   * Update has completed\n   * @param state \n   * @param force \n   */\n  //abstract onUpdateDone(state: MeasureState, force: boolean): void;\n\n  /**\n   * Update\n   * 1. Calls `this.updateBegin()` to initialise measurement state\n   * 2. In a loop, run `measureStart()` and then `measureApply` if possible\n   * 3. Call `updateDone` when finished\n   * @param force Force update\n   * @returns \n   */\n  update(context: object, force = false) {\n    if (context === undefined) throw new Error(`context is undefined`);\n\n    if (!this._needsMeasuring && !this._needsLayoutX && !force) return;\n    const [ measureState, layoutState ] = this.updateBegin(context);\n    let attempts = 5;\n    let measureApplied = false;\n    let layoutApplied = false;\n\n    // Measure everything\n    if (this._needsMeasuring || force) {\n      //this.debugLog(`update: needs measuring (force: ${ force }) bounds: ${ JSON.stringify(measureState.bounds) }`);\n      while (attempts--) {\n        const m = this.measureStart(measureState, force);\n        if (m !== undefined) {\n          // Apply measurements\n          this.measureApply(m);\n          if (!this._ready) return;\n          measureApplied = true;\n        }\n      }\n      //this.updateDone(state, force);\n      if (!measureApplied) this.debugLog(`Ran out of measurement attempts`);\n    }\n\n    // Lay it out\n    if (this._needsLayoutX || force) {\n      const p = this.layoutStart(measureState, layoutState, force);\n      if (p === undefined) {\n        this.debugLog(`Warning: could not layout`);\n      } else {\n        this.layoutApply(p);\n        layoutApplied = true;\n      }\n    }\n    this.updateComplete(measureApplied, layoutApplied);\n  }\n}\n\n/**\n * Canvas measure state\n */\nexport class CanvasMeasureState extends MeasureState {\n  readonly ctx: CanvasRenderingContext2D;\n  constructor(bounds: RectPositioned, ctx: CanvasRenderingContext2D) {\n    super(bounds);\n    this.ctx = ctx;\n    if (ctx === undefined) throw new Error(`ctx is undefined`);\n  }\n}\n\nexport class CanvasLayoutState extends LayoutState {\n  readonly ctx: CanvasRenderingContext2D;\n  constructor(bounds: RectPositioned, ctx: CanvasRenderingContext2D) {\n    super(bounds);\n    this.ctx = ctx;\n    if (ctx === undefined) throw new Error(`ctx is undefined`);\n\n  }\n}\n\n/**\n * A Box that exists on a HTMLCanvasElement\n */\nexport class CanvasBox extends Box {\n  readonly bounds: RectPositioned | undefined;\n  constructor(\n    parent: CanvasBox | undefined,\n    //canvasElement: HTMLCanvasElement,\n    id: string,\n    bounds?: RectPositioned\n  ) {\n    super(parent, id);\n    this.bounds = bounds;\n    this.debugLog(`CanvasBox ctor bounds: ${ JSON.stringify(bounds) }`);\n  }\n\n  static fromCanvas(canvasElement: HTMLCanvasElement): CanvasBox {\n    const box = new CanvasBox(undefined, `canvas-box`, canvasElement.getBoundingClientRect());\n    return box;\n  }\n\n  /**\n   * Called if this is the parent Box\n   */\n  public addEventHandlers(element: HTMLElement) {\n    element.addEventListener(`pointermove`, (event) => {\n      const p = { x: event.offsetX, y: event.offsetY };\n      this.notifyPointerMove(p);\n    });\n\n    element.addEventListener(`pointerleave`, (_event) => {\n      this.notifyPointerLeave();\n    });\n\n    element.addEventListener(`click`, (event) => {\n      const p = { x: event.offsetX, y: event.offsetY };\n      this.notifyClick(p);\n    });\n  }\n\n  protected onClick(_p: Point) {\n    /** no-up */\n  }\n\n  /**\n   * Click event has happened on canvas\n   * 1. If it's within our range, call `onClick` and pass to all children via `notifyClick`\n   * @param p \n   * @returns \n   */\n  private notifyClick(p: Point) {\n    if (RectsIsPlaceholder(this.canvasRegion)) return;\n    if (RectsIntersectsPoint(this.canvasRegion, p)) {\n      const pp = PointsSubtract(p, this.canvasRegion.x, this.canvasRegion.y);\n      this.onClick(pp);\n      // TODO: Only call `notifyClick` if child is within range?\n      for (const c of this.children) (c as CanvasBox).notifyClick(pp);\n    }\n  }\n\n  /**\n   * Pointer has left\n   * 1. Pass notification to all children via `notifyPointerLeave`\n   */\n  private notifyPointerLeave() {\n    this.onPointerLeave();\n    for (const c of this.children) (c as CanvasBox).notifyPointerLeave();\n  }\n\n  /**\n   * Pointer has moved\n   * 1. If it's within range `onPointerMove` is called, and pass on to all children via `notifyPointerMove`\n   * @param p \n   * @returns \n   */\n  private notifyPointerMove(p: Point) {\n    if (RectsIsPlaceholder(this.canvasRegion)) return;\n    if (RectsIntersectsPoint(this.canvasRegion, p)) {\n      const pp = PointsSubtract(p, this.canvasRegion.x, this.canvasRegion.y);\n      this.onPointerMove(pp);\n      for (const c of this.children) (c as CanvasBox).notifyPointerMove(pp);\n    }\n  }\n\n  /**\n   * Handler when pointer has left\n   */\n  protected onPointerLeave() {\n    /** no-up */\n  }\n\n  /**\n   * Handler when pointer moves within our region\n   * @param _p \n   */\n  protected onPointerMove(_p: Point) {\n    /** no-up */\n\n  }\n\n  /**\n   * Performs recalculations and drawing as necessary\n   * If nothing needs to happen, function returns.\n   * @param context \n   * @param force Force update\n   */\n  update(context: CanvasRenderingContext2D, force = false) {\n    super.update(context, force);\n    this.draw(context, force);\n  }\n\n  getBounds(): RectPositioned | undefined {\n    return this.bounds === undefined && this._parent ? (this._parent as CanvasBox).bounds : this.bounds;\n  }\n\n  /**\n   * Update begins.\n   * @returns MeasureState\n   */\n  protected updateBegin(context: CanvasRenderingContext2D): [ MeasureState, LayoutState ] {\n    if (context === undefined) throw new Error(`Context is undefined`);\n    let bounds = this.getBounds();\n    //this.debugLog(`updateBegin bounds: ${ JSON.stringify(bounds) } measured: ${ JSON.stringify(this._measuredSize) }`);\n\n    if (bounds === undefined) {\n      this.debugLog(`No bounds for element or parent, using canvas bounds`);\n      bounds = { x: 0, y: 0, width: context.canvas.width, height: context.canvas.height }\n    }\n    return [\n      new CanvasMeasureState(bounds, context),\n      new CanvasLayoutState(bounds, context)\n    ]\n    // if (this.region) {\n    //   return new CanvasMeasureState(this.region);\n    // } else {\n    //   const s = this.canvasEl.getBoundingClientRect();\n\n    //   return new CanvasMeasureState(\n    //     {\n    //       x: 0,\n    //       y: 0,\n    //       width: s.width,\n    //       height: s.height,\n    //     },\n    //     ctx\n    //   );\n    // }\n  }\n\n  protected updateComplete(_measureChanged: boolean, _layoutChanged: boolean): void {\n    //this.debugLog(`updateComplete. measureChanged: ${ _measureChanged } layoutChanged: ${ _layoutChanged } pos: ${ JSON.stringify(this._layoutPosition) }`);\n    this.canvasRegion = RectsPlaceholderPositioned;\n  }\n\n  protected measureApply(m: Measurement): boolean {\n    const different = super.measureApply(m);\n    if (different) this.canvasRegion = RectsPlaceholderPositioned;\n    return different;\n  }\n\n  protected layoutApply(l: Layout): boolean {\n    const different = super.layoutApply(l);\n    if (different) this.canvasRegion = RectsPlaceholderPositioned;\n    return different;\n  }\n\n  public draw(ctx: CanvasRenderingContext2D, force = false) {\n    //this.debugLog(`draw. needs drawing: ${ this._needsDrawing } force: ${ force } pos: ${ JSON.stringify(this._layoutPosition) } size: ${ JSON.stringify(this._measuredSize) }`);\n\n    // if (!this._needsDrawing && !force) return;\n\n    if (this._needsDrawing || force) {\n      if (RectsIsPlaceholder(this.canvasRegion)) {\n        if (this._layoutPosition === undefined) return;\n        if (this._measuredSize === undefined) return;\n        this.canvasRegion = {\n          x: this._layoutPosition.x,\n          y: this._layoutPosition.y,\n          width: this._measuredSize.width,\n          height: this._measuredSize.height\n        }\n      }\n\n      //this.debugLog(`draw: canvasRegion: ${ JSON.stringify(this.canvasRegion) }`);\n      if (this._needsLayoutX || this._needsMeasuring) {\n        //this.debugLog(`draw: warning: drawing with outdated layout / measurements`);\n      }\n      ctx.save();\n      const v = this.canvasRegion;\n      ctx.translate(v.x, v.y);\n\n      if (this.debugLayout) {\n        //ctx.clearRect(0,0,v.width,v.height);\n\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = `hsl(${ this.debugHue }, 100%, 50%)`;\n\n        //ctx.fillStyle = ctx.strokeStyle;\n        //ctx.fillRect(0,0,v.width,v.height);\n\n        ctx.strokeRect(0, 0, v.width, v.height);\n\n        ctx.fillStyle = ctx.strokeStyle;\n        ctx.fillText(this.id, 10, 10, v.width);\n\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(v.width, v.height);\n        ctx.stroke();\n      }\n\n      this.drawSelf(ctx);\n\n      this._needsDrawing = false;\n      ctx.restore();\n    }\n    for (const c of this.children) {\n      (c as CanvasBox).draw(ctx, force)\n    }\n  }\n\n  /**\n   * Draw this object\n   * @param _ctx \n   */\n  protected drawSelf(_ctx: CanvasRenderingContext2D): void {\n    /** no-up */\n  }\n}\n","import type { Rect } from \"./RectTypes.js\";\n\n/**\n * Clamps `value` so it does not exceed `maximum`\n * on either dimension. x,y are ignored.\n * \n * ```js\n * clamp({ width:100, height:5 }, { width:10, height:10 }); // { width:10, height:5 }\n * \n * clamp({ width:10, height:10 }, { width:10, height:10 }); // { width:10, height:10 }\n * ```\n * \n * Any existing data on `value` is copied to output.\n * @param value Input rectangle\n * @param maximum Maximum allowed size\n */\nexport const clamp = (value: Rect, maximum: Rect): Rect => {\n  return Object.freeze({\n    ...value,\n    width: Math.min(value.width, maximum.width),\n    height: Math.min(value.height, maximum.height)\n  });\n}","import { resolveEl } from \"../dom/ResolveEl.js\";\n\n/**\n * Scales a canvas to account for retina displays.\n * \n * ```js\n * const r = scaleCanvas(`#my-canvas`);\n * r.ctx;      // CanvasRendering2D\n * r.element;  // HTMLCanvasElement\n * r.bounds;   // {x:number,y:number,width:number,height:number}\n * ```\n * \n * Eg:\n * ```js\n * const { ctx } = scaleCanvas(`#my-canvas`);\n * ctx.fillStyle = `red`;\n * ctx.fillRect(0,0,100,100);\n * ```\n * \n * Throws an error if `domQueryOrElement` does not resolve.w\n * @param domQueryOrElement \n * @returns \n */\nexport const scaleCanvas = (domQueryOrElement: HTMLCanvasElement | string) => {\n  const canvasElement = resolveEl<HTMLCanvasElement>(domQueryOrElement);\n  const ratio = window.devicePixelRatio;\n  canvasElement.style.width = canvasElement.width + `px`;\n  canvasElement.style.height = canvasElement.height + `px`;\n  canvasElement.width *= devicePixelRatio;\n  canvasElement.height *= devicePixelRatio;\n\n  const getContext = () => {\n    const ctx = canvasElement.getContext(`2d`);\n\n    if (ctx === null) throw new Error(`Could not get drawing context`);\n    ctx.save();\n    ctx.scale(ratio, ratio);\n    return ctx;\n  }\n  return { ctx: getContext(), element: canvasElement, bounds: canvasElement.getBoundingClientRect() };\n}","import type { Interval } from '../flow/IntervalType.js';\nimport * as Rx from '../rx/index.js';\n\n/**\n * Returns an Reactive for window resize. Default 100ms debounce.\n * @param timeoutMs\n * @returns\n */\nexport const windowResize = (elapsed?: Interval) => Rx.Ops.debounce<{ innerWidth: number, innerHeight: number }>({ elapsed: elapsed ?? 100 })(Rx.From.event(window, `resize`, { innerWidth: 0, innerHeight: 0 }));\n\n/**\n * Observe when document's class changes\n *\n * ```js\n * const c = themeChangeObservable();\n * c.on(msg => {\n *  // do something...\n * });\n * ```\n * @returns\n */\nexport const themeChange = () => {\n  const m = Rx.From.observable<Array<MutationRecord>>(stream => {\n    const ro = new MutationObserver((entries) => {\n      stream.set(entries);\n    });\n    const opts: MutationObserverInit = {\n      attributeFilter: [ `class` ],\n      attributes: true,\n    };\n    ro.observe(document.documentElement, opts);\n\n    return () => {\n      ro.disconnect();\n    }\n  });\n  return m;\n}\n\n/**\n * Observe when element resizes. Specify `timeoutMs` to debounce, uses 100ms by default.\n *\n * ```\n * const o = resizeObservable(myEl, 500);\n * o.subscribe(() => {\n *  // called 500ms after last resize\n * });\n * ```\n * @param elem\n * @param timeoutMs Tiemout before event gets triggered\n * @returns\n */\nexport const resizeObservable = (\n  elem: Readonly<Element>,\n  timeout?: Interval\n) => {\n  if (elem === null) {\n    throw new Error(`elem parameter is null. Expected element to observe`);\n  }\n  if (elem === undefined) {\n    throw new Error(`elem parameter is undefined. Expected element to observe`);\n  }\n\n  const m = Rx.From.observable<Array<ResizeObserverEntry>>(stream => {\n    const ro = new ResizeObserver((entries) => {\n      stream.set(entries);\n    });\n    ro.observe(elem);\n\n    return () => {\n      ro.unobserve(elem);\n    };\n  });\n  return Rx.Ops.debounce<Array<ResizeObserverEntry>>({ elapsed: timeout ?? 100 })(m);\n}\n","import { resizeObservable, windowResize } from \"./DomRx.js\";\nimport type { ElementResizeArgs as ElementResizeArguments } from \"./ElementSizing.js\";\nimport { resolveEl } from \"./ResolveEl.js\";\n\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport type CanvasResizeArgs = ElementResizeArguments<HTMLCanvasElement> & {\n  readonly ctx: CanvasRenderingContext2D;\n};\n\n\n/**\n * Resizes given canvas to its parent element.\n * To resize canvas to match the viewport, use {@link fullSizeCanvas}.\n *\n * Provide a callback for when resize happens.\n * @param domQueryOrEl Query string or reference to canvas element\n * @param onResized Callback for when resize happens, eg for redrawing canvas\n * @returns Observable\n */\nexport const parentSizeCanvas = (\n  domQueryOrEl: Readonly<string | HTMLCanvasElement>,\n  onResized?: (args: CanvasResizeArgs) => void,\n  timeoutMs = 100\n) => {\n  const el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n  if (el.nodeName !== `CANVAS`) {\n    throw new Error(\n      `Expected HTML element with node name CANVAS, not ${ el.nodeName }`\n    );\n  }\n  const parent = el.parentElement;\n  if (parent === null) throw new Error(`Element has no parent`);\n\n  const ctx = (el).getContext(`2d`);\n  if (ctx === null) throw new Error(`Could not create drawing context`);\n\n  //const safetyMargin = 4;\n\n  el.style.width = `100%`;\n  el.style.height = `100%`;\n\n\n  const ro = resizeObservable(parent, timeoutMs).onValue(\n    entries => {\n      const entry = entries.find((v) => v.target === parent);\n      if (entry === undefined) return;\n\n      const width = entry.contentRect.width;\n      const height = entry.contentRect.height;\n      //console.log(`contentH: ${e.contentRect.height} current: ${el.getBoundingClientRect().height}`);\n\n      // el.setAttribute(`width`, width-safetyMargin + `px`);\n      // el.setAttribute(`height`, height-safetyMargin + `px`);\n      el.setAttribute(`width`, el.offsetWidth + `px`);\n      el.setAttribute(`height`, el.offsetHeight + `px`);\n\n      if (onResized !== undefined) {\n        const bounds = {\n          min: Math.min(width, height),\n          max: Math.max(width, height),\n          width,\n          height,\n          center: { x: width / 2, y: height / 2 },\n        };\n        onResized({ ctx, el, bounds });\n      }\n    }\n  );\n\n  return ro;\n};\n\n\n/**\n * Resizes given canvas element to match window size.\n * To resize canvas to match its parent, use {@link parentSizeCanvas}.\n *\n * To make the canvas appear propery, it sets the following CSS:\n * ```css\n * {\n *  top: 0;\n *  left: 0;\n *  zIndex: -1;\n *  position: fixed;\n * }\n * ```\n * Pass _true_ for `skipCss` to avoid this.\n *\n * Provide a callback for when resize happens.\n * @param domQueryOrEl Query string or reference to canvas element\n * @param onResized Callback for when resize happens, eg for redrawing canvas\n * @param skipCss if true, style are not added\n * @returns Observable\n */\nexport const fullSizeCanvas = (\n  domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>,\n  onResized?: (args: CanvasResizeArgs) => void,\n  skipCss = false\n) => {\n  if (domQueryOrEl === null || domQueryOrEl === undefined) {\n    throw new Error(`domQueryOrEl is null or undefined`);\n  }\n  const el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n  if (el.nodeName !== `CANVAS`) {\n    throw new Error(\n      `Expected HTML element with node name CANVAS, not ${ el.nodeName }`\n    );\n  }\n  const ctx = el.getContext(`2d`);\n  if (ctx === null) throw new Error(`Could not create drawing context`);\n\n  const update = () => {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    el.width = width;\n    el.height = height;\n\n    if (onResized !== undefined) {\n      const bounds = {\n        min: Math.min(width, height),\n        max: Math.max(width, height),\n        width,\n        height,\n        center: { x: width / 2, y: height / 2 },\n      };\n      onResized({ ctx, el, bounds });\n    }\n  };\n\n  // Setup\n  if (!skipCss) {\n    el.style.top = `0`;\n    el.style.left = `0`;\n    el.style.zIndex = `-100`;\n    el.style.position = `fixed`;\n  }\n\n  const r = windowResize();\n  r.onValue(update);\n\n  update();\n  return r;\n};\n","/**\n * Manage a set of colours. Uses CSS variables as a fallback if colour is not added\n *\n */\nexport type Palette = {\n  setElementBase(el: Element): void;\n  has(key: string): boolean;\n\n  /**\n   * Returns a colour by name.\n   *\n   * If the colour is not found:\n   *  1. Try to use a CSS variable `--key`, or\n   *  2. The next fallback colour is used (array cycles)\n   *\n   * @param key\n   * @param fallback\n   * @returns\n   */\n  get(key: string, fallback?: string): string;\n\n  /**\n   * Gets a colour by key, adding and returning fallback if not present\n   * @param key Key of colour\n   * @param fallback Fallback colour if key is not found\n   */\n  getOrAdd(key: string, fallback?: string): string;\n\n  /**\n   * Adds a colour with a given key\n   *\n   * @param key\n   * @param value\n   */\n  add(key: string, value: string): void;\n\n  alias(from: string, to: string): void;\n};\n\nexport const create = (fallbacks?: readonly string[]): Palette =>\n  new PaletteImpl(fallbacks);\n\nclass PaletteImpl {\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #store: Map<string, string> = new Map();\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #aliases: Map<string, string> = new Map();\n\n  readonly fallbacks: readonly string[];\n  #lastFallback = 0;\n\n  #elementBase: Element;\n\n  constructor(fallbacks?: readonly string[]) {\n    if (fallbacks !== undefined) this.fallbacks = fallbacks;\n    else this.fallbacks = [ `red`, `blue`, `green`, `orange` ];\n    this.#elementBase = document.body;\n  }\n\n  setElementBase(el: Element) {\n    this.#elementBase = el;\n  }\n\n  add(key: string, colour: string) {\n    this.#store.set(key, colour);\n  }\n\n  alias(from: string, to: string) {\n    this.#aliases.set(from, to);\n  }\n\n  get(key: string, fallback?: string): string {\n    const alias = this.#aliases.get(key);\n    if (alias !== undefined) key = alias;\n\n    const c = this.#store.get(key);\n    if (c !== undefined) return c;\n\n    const varName = `--` + key;\n    // eslint-disable-next-line functional/no-let\n    let fromCss = getComputedStyle(this.#elementBase)\n      .getPropertyValue(varName)\n      .trim();\n\n    // Not found\n    if (fromCss === undefined || fromCss.length === 0) {\n      if (fallback !== undefined) return fallback;\n      fromCss = this.fallbacks[ this.#lastFallback ];\n      this.#lastFallback++;\n      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;\n    }\n    return fromCss;\n  }\n\n  getOrAdd(key: string, fallback?: string): string {\n    if (this.has(key)) return this.get(key);\n    const c = this.get(key, fallback);\n    this.add(key, c);\n    return c;\n  }\n\n  has(key: string): boolean {\n    return this.#store.has(key);\n  }\n}\n","import * as Drawing from \"./Drawing.js\";\nimport * as Bipolar from \"../data/Bipolar.js\";\nimport * as Queues from \"../collections/queue/index.js\";\nimport * as Colour from \"./Colour.js\";\nimport { type CirclePositioned } from \"../geometry/index.js\";\nimport type { IQueueImmutable } from \"../collections/queue/IQueueImmutable.js\";\n\n/**\n * Options\n */\nexport type BipolarViewOptions = Readonly<{\n  width?: number,\n  height?: number,\n  labelPrecision?: number\n  labels?: [ string, string ],\n  axisColour?: string,\n  bgColour?: string,\n  whiskerColour?: string,\n  whiskerSize?: number,\n  dotColour?: string,\n  dotRadius?: number,\n  showWhiskers?: boolean,\n  showDot?: boolean,\n  showLabels?: boolean,\n  padding?: number,\n  labelColour?: string,\n  axisWidth?: number,\n  asPercentages?: boolean,\n  /**\n   * If non-zero, will render the last X number of values with increasing opacity.\n   * Default: 0\n   */\n  displayLastValues?: number\n  /**\n   * If _true_, (default) negative y values are at the bottom.\n   * If _false_  negative y values are at the top.\n   */\n  yAxisBottomNegative?: boolean,\n  /**\n   * Custom rendering for background\n   */\n  renderBackground?: Render\n}>\n\nfunction getNumericAttribute(el: HTMLElement, name: string, defaultValue: number) {\n  const a = el.getAttribute(name);\n  if (a === null) return defaultValue;\n  return Number.parseInt(a);\n}\n\nexport type Render = (ctx: CanvasRenderingContext2D, width: number, height: number) => void;\n/**\n * A function that plots a point on the graph\n */\nexport type BipolarView = (x: number, y: number) => void;\n\n/**\n * Initialises a plotter for bipolar values (-1...1)\n * \n * ```js\n * const p = BipolarView.init(`#my-canvas`);\n * // Shows the dot at 1, 0.5\n * p(1, 0.5);\n * ```\n * @param elementQuery \n * @param opts \n * @returns \n */\nexport const init = (elementQuery: string, opts: BipolarViewOptions = {}): BipolarView => {\n  const element = document.querySelector<HTMLCanvasElement>(elementQuery);\n  if (!element) throw new Error(`Element query could not be found (${ elementQuery })`);\n  const labels = opts.labels ?? [ `x`, `y` ];\n  const labelPrecision = opts.labelPrecision ?? 2;\n  const asPercentages = opts.asPercentages ?? false;\n  const displayLastValues = opts.displayLastValues ?? 0;\n  // Flags\n  const showWhiskers = opts.showWhiskers ?? true;\n  const showDot = opts.showDot ?? true;\n  const showLabels = opts.showLabels ?? true;\n  const yAxisBottomNegative = opts.yAxisBottomNegative ?? true;\n  // Colours\n  const axisColour = Colour.resolveToString(opts.axisColour, `silver`);\n  const bgColour = Colour.resolveToString(opts.bgColour, `white`);\n  const whiskerColour = Colour.resolveToString(opts.whiskerColour, `black`);\n  const dotColour = Colour.resolveToString(opts.dotColour, opts.whiskerColour, `black`);\n  const labelColour = Colour.resolveToString(opts.labelColour, opts.axisColour, `silver`);\n\n  // Sizes\n  const axisWidth = (opts.axisWidth ?? 1 * window.devicePixelRatio);\n  const dotRadius = (opts.dotRadius ?? 5 * window.devicePixelRatio);\n  const pad = (opts.padding ?? 10 * window.devicePixelRatio);\n  const whiskerSize = (opts.whiskerSize ?? 5 * window.devicePixelRatio);\n  const width = (opts.width ?? getNumericAttribute(element, `width`, 200) * window.devicePixelRatio);\n  const height = (opts.height ?? getNumericAttribute(element, `height`, 200) * window.devicePixelRatio);\n\n  let lastValues: IQueueImmutable<CirclePositioned> | undefined;\n  if (displayLastValues > 0) {\n    lastValues = Queues.immutable<CirclePositioned>({\n      capacity: displayLastValues,\n      discardPolicy: `older`\n    });\n  }\n\n  element.width = width;// * window.devicePixelRatio;\n  element.height = height;// * window.devicePixelRatio;\n  element.style.width = `${ (width / window.devicePixelRatio) }px`;\n  element.style.height = `${ (height / window.devicePixelRatio) }px`;\n\n  const midY = height / 2;\n  const midX = width / 2;\n  const ctx = element.getContext(`2d`);\n  if (!ctx) throw new Error(`Could not create drawing context`);\n\n  if (window.devicePixelRatio >= 2) {\n    ctx.font = `20px sans-serif`;\n  }\n  const percentageFormat = (v: number) => `${ Math.round(v * 100) }%`;\n  const fixedFormat = (v: number) => v.toFixed(labelPrecision);\n\n  const valueFormat = asPercentages ? percentageFormat : fixedFormat;\n  if (showLabels) {\n    labels[ 0 ] = labels[ 0 ] + `:`;\n    labels[ 1 ] = labels[ 1 ] + `:`;\n  } else {\n    labels[ 0 ] = ``;\n    labels[ 1 ] = ``;\n  }\n\n  const renderBackground: Render = opts.renderBackground ?? ((ctx, width, height): void => {\n    if (opts.bgColour === `transparent`) {\n      ctx.clearRect(0, 0, width, height);\n    } else {\n      ctx.fillStyle = bgColour;\n      ctx.fillRect(0, 0, width, height);\n    }\n  });\n\n  return (x: number, y: number) => {\n    x = Bipolar.clamp(x);\n    y = Bipolar.clamp(y);\n\n    renderBackground(ctx, width, height);\n\n    // Labels\n    ctx.fillStyle = labelColour;\n    ctx.textBaseline = `top`;\n    ctx.save();\n    ctx.translate(midX, midY);\n    ctx.rotate(-Math.PI / 2);\n    ctx.fillText((labels[ 1 ] + ` ` + valueFormat(y)).trim(), -midX + pad, 1);\n    ctx.restore();\n    ctx.fillText((labels[ 0 ] + ` ` + valueFormat(x)).trim(), pad, midX + 2);\n\n    if (!yAxisBottomNegative) y *= -1;\n\n    // Axes\n    ctx.strokeStyle = axisColour;\n    ctx.lineWidth = axisWidth;\n    ctx.beginPath();\n    ctx.moveTo(pad, midY);\n    ctx.lineTo(width - pad, midY);\n    ctx.moveTo(midX, pad);\n    ctx.lineTo(midX, height - pad);\n    ctx.stroke();\n    ctx.closePath();\n\n    const yy = (height - pad - pad) / 2 * -y;\n    const xx = (width - pad - pad) / 2 * x;\n    const dotPos = { x: xx, y: yy, radius: dotRadius };\n\n    if (lastValues) {\n      lastValues = lastValues.enqueue(dotPos);\n    }\n    ctx.save();\n    ctx.translate(midX, midY);\n\n    // Dot\n    if (showDot) {\n      if (lastValues) {\n        const opacityStep = 1 / lastValues.length;\n        let opacity = 1;\n        // eslint-disable-next-line unicorn/no-array-for-each\n        lastValues.forEach(d => {\n          const colour = Colour.opacity(dotColour, opacity);\n          Drawing.circle(ctx, d, { fillStyle: colour });\n          opacity -= opacityStep;\n        });\n      } else {\n        Drawing.circle(ctx, dotPos, { fillStyle: dotColour });\n      }\n    }\n\n    // Whiskers\n    if (showWhiskers) {\n      ctx.strokeStyle = whiskerColour;\n\n      // y line\n      ctx.beginPath();\n      ctx.moveTo(0, yy - whiskerSize);\n      ctx.lineTo(0, yy + whiskerSize);\n\n      // x line\n      ctx.moveTo(xx - whiskerSize, 0);\n      ctx.lineTo(xx + whiskerSize, 0);\n      ctx.stroke();\n      ctx.closePath();\n    }\n\n    // Restore transform\n    ctx.restore();\n  }\n}\n","import { type ICircularArray } from '../collections/arrays/CircularArray.js';\nimport { resolveEl } from '../dom/ResolveEl.js';\nimport * as Colour from './Colour.js';\nimport * as Drawing from './Drawing.js';\nimport {\n  ofArrayMutable,\n  ofCircularMutable,\n  type IMapOfMutableExtended,\n} from '../collections/map/index.js';\nimport type { Rect, Point } from '../geometry/Types.js';\nimport { parentSizeCanvas } from '../dom/CanvasSizing.js';\nimport { minMaxAvg } from '../collections/arrays/MinMaxAvg.js';\n\nexport type Plotter = {\n  add(value: number, series?: string, skipDrawing?: boolean): void;\n  drawValue(index: number): void;\n  /**\n   * Draws current data. Useful if skipDrawing was true for earlier add() calls.\n   */\n  draw(): void;\n  clear(): void;\n  dispose(): void;\n};\n\n/**\n * Series\n */\nexport type Series = {\n  min: number;\n  max: number;\n  range: number;\n  name: string;\n  colour: string;\n  lastValue?: number;\n  hoverValue?: number;\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = PlotOpts & {\n  x: Axis;\n  y: Axis;\n  ctx: CanvasRenderingContext2D;\n  textHeight: number;\n  capacity: number;\n  coalesce: boolean;\n  margin: number;\n  canvasSize: Rect;\n  clearCanvas: boolean;\n  translucentPlot?: boolean;\n  highlightIndex?: number;\n  leadingEdgeDot: boolean;\n  debug: boolean;\n  digitsPrecision: number;\n  lineWidth: number;\n  defaultSeriesColour: string;\n  defaultSeriesVariable?: string;\n  showLegend: boolean;\n  pointer: { x: number; y: number };\n};\n\n/**\n * Properties for an axis\n */\nexport type Axis = {\n  allowedSeries?: Array<string>;\n  /**\n   * Name of axis, eg `x`\n   */\n  name: string;\n  /**\n   * Colour to use for axis labels\n   */\n  colour?: string;\n  /**\n   * Forced scale for values\n   */\n  scaleRange?: [ number, number ];\n  /**\n   * Forced range for labelling, by default\n   * uses scaleRange\n   */\n  labelRange?: [ number, number ];\n  /**\n   * Width of axis line\n   */\n  lineWidth: number;\n  /**\n   * How line ends\n   */\n  endWith: `none` | `arrow`;\n  /**\n   * Where to place the name of the axis\n   */\n  namePosition: `none` | `end` | `side`;\n  /**\n   * Width for y axis, height for x axis\n   */\n  textSize: number;\n  /**\n   * If true, axis labels (ie numeric scale) are shown. Default: true\n   */\n  showLabels: boolean;\n  /**\n   * If true, a line is drawn to represent axis. Default: true\n   */\n  showLine: boolean;\n};\n\nexport type SeriesColours = Record<string, string | undefined>;\n\n/**\n * Plotter options\n */\nexport type PlotOpts = {\n  debug?: boolean;\n  seriesColours?: SeriesColours;\n  /**\n   * Default: 2\n   */\n  digitsPrecision?: number;\n  x?: Axis;\n  y?: Axis;\n  plotSize?: Rect;\n  autoSizeCanvas?: boolean;\n  style?: `connected` | `dots` | `none`;\n  //palette?: Palette.Palette\n  /**\n   * Number of items to keep in the circular array\n   * Default: 10\n   */\n  capacity?: number;\n  //showYAxis?:boolean\n  //showXAxis?:boolean\n  //yAxes?: string[]|string\n  textHeight?: number;\n  /**\n   * Width of plotted line\n   */\n  lineWidth?: number;\n  /**\n   * If true, sub-pixel data points are ignored\n   */\n  coalesce?: boolean;\n  /**\n   * Fixed range to scale Y values. By default normalises values\n   * as they come in. This will also determine the y-axis labels and drawing\n   */\n  //fixedRange?:[number,number]\n  /**\n   * How many horizontal pixels per data point. If unspecified,\n   * it will scale based on width of canvas and capacity.\n   */\n  //dataXScale?:number\n  defaultSeriesColour?: string;\n  defaultSeriesVariable?: string;\n  showLegend?: boolean;\n};\n\nconst piPi = Math.PI * 2;\n\nexport const defaultAxis = (name: string): Axis => ({\n  endWith: `none`,\n  lineWidth: 1,\n  namePosition: `none`,\n  name: name,\n  showLabels: name === `y`,\n  showLine: true,\n  // For y axis, it's the width, for x axis it's the text height\n  textSize: name === `y` ? 20 : 10,\n});\n\nexport const calcScale = (\n  buffer: BufferType,\n  drawingOpts: DrawingOpts,\n  seriesColours?: SeriesColours\n) => {\n  //const seriesNames = buffer.keys();\n  const scales: Array<Series> = [];\n\n  for (const s of buffer.keys()) {\n    //seriesNames.forEach(s => {\n\n    const series = [ ...buffer.get(s) ];\n    if (series.length === 0) break;\n\n    let { min, max } = minMaxAvg(series);\n    let range = max - min;\n\n    let colour;\n    if (seriesColours !== undefined) {\n      colour = seriesColours[ s ];\n    }\n    if (colour == undefined) {\n      colour = drawingOpts.defaultSeriesVariable ? Colour.getCssVariable(\n        `accent`,\n        drawingOpts.defaultSeriesColour\n      ) : drawingOpts.defaultSeriesColour;\n    }\n\n    if (range === 0) {\n      range = min;\n      min = min - range / 2;\n      max = max + range / 2;\n    }\n    scales.push({\n      min,\n      max,\n      range,\n      name: s,\n      colour: colour,\n    });\n  }\n  return scales;\n};\n\nexport const add = (buffer: BufferType, value: number, series = ``) => {\n  buffer.addKeyedValues(series, value);\n};\n\nexport type BufferType =\n  | IMapOfMutableExtended<number, ICircularArray<number>>\n  | IMapOfMutableExtended<number, ReadonlyArray<number>>;\n\nexport const drawValue = (\n  index: number,\n  buffer: BufferType,\n  drawing: DrawingOpts\n) => {\n  const c = {\n    ...drawing,\n    translucentPlot: true,\n    leadingEdgeDot: false,\n  };\n  draw(buffer, c);\n\n  drawing = {\n    ...drawing,\n    highlightIndex: index,\n    leadingEdgeDot: true,\n    translucentPlot: false,\n    style: `none`,\n    clearCanvas: false,\n  };\n  draw(buffer, drawing);\n};\n\nconst scaleWithFixedRange = (\n  buffer: BufferType,\n  range: [ number, number ],\n  drawing: DrawingOpts\n) =>\n  calcScale(buffer, drawing, drawing.seriesColours).map((s) => ({\n    ...s,\n    range: range[ 1 ] - range[ 0 ],\n    min: range[ 0 ],\n    max: range[ 1 ],\n  }));\n\n/**\n * Draws a `buffer` of data with `drawing` options.\n *\n * @param buffer\n * @param drawing\n */\nexport const draw = (buffer: BufferType, drawing: DrawingOpts) => {\n  const { x: xAxis, y: yAxis, ctx, canvasSize } = drawing;\n  const margin = drawing.margin;\n  // const cap = drawing.capacity === 0 ? buffer.lengthMax : drawing.capacity;\n  const series = drawing.y.scaleRange\n    ? scaleWithFixedRange(buffer, drawing.y.scaleRange, drawing)\n    : calcScale(buffer, drawing, drawing.seriesColours);\n\n  if (drawing.clearCanvas)\n    ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);\n\n  if (drawing.debug) {\n    ctx.strokeStyle = `orange`;\n    ctx.strokeRect(0, 0, canvasSize.width, canvasSize.height);\n  }\n\n  // Move in for margin\n  ctx.translate(margin, margin);\n\n  // Calculate/use plot area\n  const plotSize = drawing.plotSize ?? plotSizeFromBounds(canvasSize, drawing);\n\n  // Draw vertical axes\n  const axisSize = {\n    height: plotSize.height + margin + margin,\n    width: plotSize.width,\n  };\n\n  if (yAxis.showLabels || yAxis.showLine) {\n    // Draw the labels for each series\n    for (const s of series) {\n      if (yAxis.allowedSeries !== undefined && !yAxis.allowedSeries.includes(s.name)) continue;\n      drawYSeriesScale(s, axisSize, drawing);\n    }\n\n    // Draw vertical line\n    if (series.length > 0 && yAxis.showLine)\n      drawYLine(axisSize, series[ 0 ], drawing);\n  }\n\n  // Draw x/horizontal axis if needed\n  if ((xAxis.showLabels || xAxis.showLine) && series.length > 0) {\n    const yPos = yAxis.labelRange ? yAxis.labelRange[ 0 ] : series[ 0 ].min;\n    drawXAxis(\n      plotSize.width,\n      calcYForValue(yPos, series[ 0 ], plotSize.height) +\n      margin +\n      xAxis.lineWidth,\n      drawing\n    );\n  }\n\n  const plotDrawing = {\n    ...drawing,\n    plotSize,\n  };\n\n  const ptr = Drawing.translatePoint(ctx, drawing.pointer);\n  // Draw data for each series\n  for (const s of series) {\n    const data = buffer.getSource(s.name);\n    if (data === undefined) continue;\n\n    let leadingEdgeIndex =\n      buffer.typeName === `circular`\n        ? (data as ICircularArray<number>).pointer - 1\n        : data.length - 1;\n    if (drawing.highlightIndex !== undefined)\n      leadingEdgeIndex = drawing.highlightIndex;\n    ctx.save();\n    ctx.translate(0, margin + margin);\n\n    drawSeriesData(s, data, plotSize, plotDrawing, leadingEdgeIndex);\n    ctx.restore();\n  }\n\n  if (drawing.showLegend) {\n    ctx.save();\n    ctx.translate(0, plotSize.height + margin + margin + margin);\n    const legendSize = {\n      width: plotSize.width,\n      height: drawing.x.textSize + margin + margin,\n    };\n    drawLegend(series, drawing, legendSize);\n    ctx.restore();\n  }\n  ctx.resetTransform();\n};\n\n/**\n * Draw vertical axis\n * @param series\n * @param height\n * @param drawing\n */\nconst drawYSeriesScale = (\n  series: Series,\n  plotSize: Rect,\n  drawing: DrawingOpts\n) => {\n  const { ctx, y, digitsPrecision, margin } = drawing;\n  const { height } = plotSize;\n\n  if (drawing.debug) {\n    ctx.strokeStyle = `purple`;\n    ctx.strokeRect(0, 0, y.textSize, height + margin);\n  }\n\n  ctx.fillStyle = series.colour.length > 0 ? series.colour : `white`;\n\n  // Override colour with axis-defined colour\n  if (y.colour) ctx.fillStyle = y.colour;\n\n  // Draw labels\n  const min = y.labelRange ? y.labelRange[ 0 ] : series.min;\n  const max = y.labelRange ? y.labelRange[ 1 ] : series.max;\n  const range = y.labelRange ? max - min : series.range;\n  const mid = min + range / 2;\n  const halfHeight = drawing.textHeight / 2;\n\n  ctx.textBaseline = `top`;\n  ctx.fillText(\n    min.toFixed(digitsPrecision),\n    0,\n    calcYForValue(min, series, height) - halfHeight\n  );\n  ctx.fillText(\n    mid.toFixed(digitsPrecision),\n    0,\n    calcYForValue(mid, series, height) - halfHeight\n  );\n  ctx.fillText(\n    max.toFixed(digitsPrecision),\n    0,\n    calcYForValue(max, series, height) - margin\n  );\n\n  ctx.translate(y.textSize + margin, 0);\n};\n\nconst drawYLine = (plotSize: Rect, series: Series, drawing: DrawingOpts) => {\n  if (series === undefined) throw new Error(`series undefined`);\n  const { ctx, y } = drawing;\n  const { height } = plotSize;\n\n  const min = y.labelRange ? y.labelRange[ 0 ] : series.min;\n  const max = y.labelRange ? y.labelRange[ 1 ] : series.max;\n\n  const minPos = calcYForValue(min, series, height);\n  const maxPos = calcYForValue(max, series, height);\n\n  // Draw line\n  ctx.translate(y.lineWidth, 0);\n  ctx.lineWidth = y.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(0, minPos);\n  ctx.lineTo(0, maxPos);\n  ctx.strokeStyle = series.colour;\n  if (y.colour) ctx.strokeStyle = y.colour;\n  ctx.stroke();\n  ctx.translate(y.lineWidth, 0);\n};\n\nconst drawLegend = (\n  series: Array<Series>,\n  drawing: DrawingOpts,\n  size: { width: number; height: number }\n) => {\n  const { ctx } = drawing;\n  const lineSampleWidth = 10;\n\n  let x = 0;\n  const lineY = drawing.margin * 3;\n  const textY = drawing.margin;\n\n  ctx.lineWidth = drawing.lineWidth;\n\n  for (const s of series) {\n    ctx.moveTo(x, lineY);\n    ctx.strokeStyle = s.colour;\n    ctx.lineTo(x + lineSampleWidth, lineY);\n    ctx.stroke();\n    x += lineSampleWidth + drawing.margin;\n\n    let label = s.name;\n    if (s.lastValue)\n      label += ` ` + s.lastValue.toFixed(drawing.digitsPrecision);\n    const labelSize = ctx.measureText(label);\n\n    ctx.fillStyle = s.colour;\n    ctx.fillText(label, x, textY);\n    x += labelSize.width;\n  }\n};\n\nconst drawXAxis = (width: number, yPos: number, drawing: DrawingOpts) => {\n  const { ctx, x, y } = drawing;\n\n  if (!x.showLine) return;\n\n  if (x.colour) ctx.strokeStyle = x.colour;\n  ctx.lineWidth = x.lineWidth;\n  ctx.beginPath();\n\n  // Assumes ctx is translated after drawing Y axis\n  ctx.moveTo(0, yPos);\n  ctx.lineTo(width, yPos);\n  ctx.stroke();\n};\n\n/**\n * Draw series data\n * @param series\n * @param values\n * @param plotSize\n * @param drawing\n */\nconst drawSeriesData = (\n  series: Series,\n  values: ArrayLike<number>,\n  plotSize: Rect,\n  drawing: DrawingOpts,\n  leadingEdgeIndex: number\n) => {\n  const { ctx, lineWidth, translucentPlot = false, margin, x: xAxis } = drawing;\n  const style = drawing.style ?? `connected`;\n  const height = plotSize.height - margin;\n\n  let dataXScale = 1;\n  if (xAxis.scaleRange) {\n    const xAxisRange = xAxis.scaleRange[ 1 ] - xAxis.scaleRange[ 0 ];\n    dataXScale = plotSize.width / xAxisRange;\n  } else {\n    dataXScale = drawing.capacity === 0 ? plotSize.width / values.length : plotSize.width / drawing.capacity;\n  }\n\n  // Step through data faster if per-pixel density is above one\n  const incrementBy = drawing.coalesce\n    ? (dataXScale < 0\n      ? Math.floor(1 / dataXScale)\n      : 1)\n    : 1;\n\n  let x = 0;\n  let leadingEdge: Point | undefined;\n\n  if (drawing.debug) {\n    ctx.strokeStyle = `green`;\n    ctx.strokeRect(0, 0, plotSize.width, plotSize.height);\n  }\n\n  const colourTransform = (c: string) => {\n    if (translucentPlot) return Colour.opacity(c, 0.2);\n    return c;\n  };\n\n  if (style === `dots`) {\n    ctx.fillStyle = colourTransform(series.colour);\n  } else if (style === `none`) {} else {\n    ctx.beginPath();\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = colourTransform(series.colour);\n  }\n\n  for (let index = 0; index < values.length; index += incrementBy) {\n    const y = calcYForValue(values[ index ], series, height) - 1;\n\n    if (style === `dots`) {\n      ctx.beginPath();\n      ctx.arc(x, y, lineWidth, 0, piPi);\n      ctx.fill();\n    } else if (style === `none`) {} else {\n      if (index == 0) ctx.moveTo(x, y);\n      ctx.lineTo(x, y);\n    }\n\n    if (index === leadingEdgeIndex) {\n      leadingEdge = { x, y };\n      series.lastValue = values[ index ];\n    }\n    x += dataXScale;\n  }\n\n  if (style === `connected`) {\n    ctx.stroke();\n  }\n\n  // Draw a circle at latest data point\n  if (leadingEdge !== undefined && drawing.leadingEdgeDot) {\n    ctx.beginPath();\n    ctx.fillStyle = colourTransform(series.colour); // drawing.palette.getOrAdd(`series${series.name}`));\n    ctx.arc(leadingEdge.x, leadingEdge.y, 3, 0, 2 * Math.PI);\n    ctx.fill();\n  }\n};\n\nconst calcYForValue = (v: number, series: Series, height: number) =>\n  (1 - (v - series.min) / series.range) * height;\n\n/**\n * Calculates lost area, given a margin value, axis settings.\n * @param margin\n * @param x\n * @param y\n * @param showLegend\n * @returns\n */\nconst calcSizing = (margin: number, x: Axis, y: Axis, showLegend: boolean) => {\n  let fromLeft = margin;\n  if (y.showLabels) fromLeft += y.textSize;\n  if (y.showLine) fromLeft += y.lineWidth;\n  if (y.showLabels || y.showLine) fromLeft += margin + margin;\n  const fromRight = margin;\n\n  const fromTop = margin + margin;\n  let fromBottom = margin + margin;\n  fromBottom += x.showLabels ? x.textSize : margin;\n  if (x.showLine) fromBottom += x.lineWidth;\n  if (x.showLabels || x.showLine) fromBottom += margin;\n\n  if (showLegend) fromBottom += x.textSize;\n\n  return {\n    left: fromLeft,\n    right: fromRight,\n    top: fromTop,\n    bottom: fromBottom,\n  };\n};\n\nconst plotSizeFromBounds = (\n  bounds: Rect,\n  opts: { margin: number; y: Axis; x: Axis; showLegend: boolean }\n): Rect => {\n  const { width, height } = bounds;\n  const sizing = calcSizing(opts.margin, opts.x, opts.y, opts.showLegend);\n  return {\n    width: width - sizing.left - sizing.right,\n    height: height - sizing.top - sizing.bottom,\n  };\n};\n\nconst canvasSizeFromPlot = (\n  plot: Rect,\n  opts: { margin: number; y: Axis; x: Axis; showLegend: boolean }\n): Rect => {\n  const { width, height } = plot;\n  const sizing = calcSizing(opts.margin, opts.x, opts.y, opts.showLegend);\n  return {\n    width: width + sizing.left + sizing.right,\n    height: height + sizing.top + sizing.bottom,\n  };\n};\n\n/**\n * Creates a simple horizontal data plot within a DIV.\n *\n * ```\n * const p = plot(`#parentDiv`);\n * p.add(10);\n * p.clear();\n *\n * // Plot data using series\n * p.add(-1, `temp`);\n * p.add(0.4, `humidty`);\n * ```\n *\n * Options can be specified to customise plot\n * ```\n * const p = plot(`#parentDiv`, {\n *  capacity: 100,     // How many data points to store (default: 10)\n *  showYAxis: false,  // Toggle whether y axis is shown (default: true)\n *  lineWidth: 2,      // Width of plot line (default: 2)\n *  yAxes:  [`temp`],  // Only show these y axes (by default all are shown)\n *  coalesce: true,    // If true, sub-pixel data points are skipped, improving performance for dense plots at the expense of plot precision\n * });\n * ```\n *\n * For all `capacity` values other than `0`, a circular array is used to track data. Otherwise an array is used that will\n * grow infinitely.\n *\n * By default, will attempt to use CSS variable `--series[seriesName]` for axis colours.\n *  `--series[name]-axis` for titles. Eg `--seriesX`. For data added without a named series,\n * it will use `--series` and `--series-axis`.\n * @param parentElOrQuery\n * @param opts\n * @return Plotter instance\n */\nexport const plot = (\n  parentElementOrQuery: string | HTMLElement,\n  opts: PlotOpts\n): Plotter => {\n  if (parentElementOrQuery === null)\n    throw new Error(`parentElOrQuery is null. Expected string or element`);\n\n  const parentEl = resolveEl(parentElementOrQuery);\n  let canvasEl: HTMLCanvasElement;\n  let destroyCanvasEl = true;\n  let plotSize: Rect | undefined = opts.plotSize;\n  let canvasSize: Rect;\n  if (parentEl.nodeName === `CANVAS`) {\n    // Use provided canvas\n    canvasEl = parentEl as HTMLCanvasElement;\n    destroyCanvasEl = false;\n    canvasSize = { width: canvasEl.width, height: canvasEl.height };\n  } else {\n    // Create a CANVAS that fills parent\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    parentEl.append(canvasEl);\n    plotSize = opts.plotSize;\n    canvasSize = { width: canvasEl.width, height: canvasEl.height };\n  }\n\n  const pointer = { x: 0, y: 0 };\n\n  const onPointerMove = (event: PointerEvent) => {\n    pointer.x = event.offsetX;\n    pointer.y = event.offsetY;\n  };\n\n  canvasEl.addEventListener(`pointermove`, onPointerMove);\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const ctx = canvasEl.getContext(`2d`)!;\n\n  const capacity = opts.capacity ?? 10;\n  const buffer =\n    capacity > 0\n      ? ofCircularMutable<number>({ capacity })\n      : ofArrayMutable<number>();\n  const metrics = ctx.measureText(`Xy`);\n  const coalesce = opts.coalesce ?? true;\n\n  // Sanity-check\n  if (ctx === null) throw new Error(`Drawing context not available`);\n\n  let xAxis = defaultAxis(`x`);\n  if (opts.x) xAxis = { ...xAxis, ...opts.x };\n  let yAxis = defaultAxis(`y`);\n  if (opts.y) yAxis = { ...yAxis, ...opts.y };\n\n  let drawingOpts: DrawingOpts = {\n    ...opts,\n    y: yAxis,\n    x: xAxis,\n    pointer: pointer,\n    capacity,\n    coalesce,\n    plotSize,\n    canvasSize,\n    ctx,\n    textHeight:\n      opts.textHeight ??\n      metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent,\n    style: opts.style ?? `connected`,\n    defaultSeriesColour: opts.defaultSeriesColour ?? `yellow`,\n    margin: 3,\n    clearCanvas: true,\n    leadingEdgeDot: true,\n    debug: opts.debug ?? false,\n    digitsPrecision: opts.digitsPrecision ?? 2,\n    lineWidth: opts.lineWidth ?? 2,\n    showLegend: opts.showLegend ?? false,\n  };\n\n  if (plotSize) {\n    // Size canvas based on given plot size\n    const canvasSize = canvasSizeFromPlot(plotSize, drawingOpts);\n    canvasEl.width = canvasSize.width;\n    canvasEl.height = canvasSize.height;\n\n    drawingOpts.canvasSize = canvasSize;\n  }\n\n  if (opts.autoSizeCanvas) {\n    parentSizeCanvas(canvasEl, (args) => {\n      const bounds = args.bounds;\n      drawingOpts = {\n        ...drawingOpts,\n        plotSize: plotSizeFromBounds(bounds, drawingOpts),\n        canvasSize: bounds,\n      };\n      draw(buffer, drawingOpts);\n    });\n  }\n\n  return {\n    drawValue: (index: number) => {\n      drawValue(index, buffer, drawingOpts);\n    },\n    dispose: () => {\n      canvasEl.removeEventListener(`pointermove`, onPointerMove);\n      if (destroyCanvasEl) canvasEl.remove();\n    },\n    add: (value: number, series = ``, skipDrawing = false) => {\n      add(buffer, value, series);\n      if (skipDrawing) return;\n      draw(buffer, drawingOpts);\n    },\n    draw: () => {\n      draw(buffer, drawingOpts);\n    },\n    clear: () => {\n      buffer.clear();\n    },\n  };\n};\n","export * from './CanvasHelper.js';\nexport * from './CanvasSizing.js';\nexport * from './Css.js';\nexport * as Variables from './CssVariables.js';\nexport * from './DataDisplay.js';\nexport * as DataTable from './DataTable.js';\nexport * as Rx from './DomRx.js';\nexport * as DragDrop from './DragDrop.js';\nexport * from './El.js';\nexport * from './ElementSizing.js';\nexport * from './ErrorHandler.js';\n/**\n * Functions for working with DOM elements\n */\nexport * as Forms from './Forms.js';\nexport * from './InlineConsole.js';\nexport * from './Log.js';\nexport * from './PointerVisualise.js';\nexport * from './Query.js';\nexport * from './ResolveEl.js';\nexport * from './SetProperty.js';\nexport * from './Util.js';\n\n\n","import type { Rect } from '../geometry/rect/RectTypes.js';\nimport { scaler, type ScaleBy, type ScalerCombined } from \"../geometry/Scaler.js\";\nimport { resolveEl } from \"./ResolveEl.js\";\nimport { empty as RectsEmpty } from '../geometry/rect/Empty.js';\nimport { multiply as RectsMultiply } from \"../geometry/rect/Multiply.js\";\nimport { windowResize } from \"./DomRx.js\";\nimport { SimpleEventEmitter } from \"../Events.js\";\nimport { guard as RectsGuard } from '../geometry/rect/Guard.js';\n/**\n * Options\n */\nexport type CanvasOpts = {\n  /**\n   * If _true_ (default) canvas is cleared when a resize happens\n   */\n  readonly clearOnResize: boolean\n  /**\n   * If true, it won't add any position CSS\n   */\n  readonly skipCss: boolean;\n  readonly scaleBy: ScaleBy;\n  /**\n   * Callback when canvas is resized\n   * @param size \n   * @returns \n   */\n  readonly onResize?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n  /**\n   * Automatically set canvas to fill. Default: 'none'\n   * * 'viewport': size of screen\n   * * 'parent': size of parent element\n   * * 'none': no resizing. Use 'width' and 'height' options to set the logical size of the canvas\n   * \n   */\n  readonly fill: `viewport` | `parent` | `none`\n  /**\n   * Logical width of canvas.\n   * Ignored if `fill` is set to 'viewport' or 'parent'\n   */\n  readonly width: number\n  /**\n   * Logical height of canvas.\n   * Ignored if `fill` is set to 'viewport' or 'parent'\n   */\n  readonly height: number\n  /**\n   * If set, the z-index for this canvas.\n   * By default, fullscreen canvas will be given -1\n   */\n  readonly zIndex: number\n  /**\n   * If specified, this function be called in an animation loop.\n   * @param ctx \n   * @param size \n   * @returns \n   */\n  readonly draw?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n};\n\nexport type CanvasEvents = {\n  /**\n   * Fired when canvas is resized\n   */\n  resize: { size: Rect, helper: CanvasHelper, ctx: CanvasRenderingContext2D }\n}\n\n/**\n * A wrapper for the CANVAS element that scales the canvas for high-DPI displays\n * and helps with resizing.\n * \n * ```js\n * const canvas = new CanvasHelper(`#my-canvas`, { fill: `viewport` });\n * const { ctx, width, height } = canvas.ctx; // Get drawing context, width & height\n * ```\n * \n * Draw whenever it is resized using the 'resize' event\n * ```js\n * canvas.addEventListener(`resize`, ({ctx, size}) => {\n *  // Use ctx...  \n * });\n * ```\n * \n * Or provide a function when initialising:\n * ```js\n * const onResize = (ctx, size) => {\n *  // Do drawing\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { fill: `viewport`, onResize });\n * ```\n * \n * Automatically draw at animation speeds:\n * ```js\n * const draw = () => {\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { fill: `viewport`, draw });\n * ```\n * @param domQueryOrEl Canvas element to wrap\n * @param opts Options\n * @returns \n */\nexport class CanvasHelper extends SimpleEventEmitter<CanvasEvents> {\n  readonly el: HTMLCanvasElement;\n  readonly opts: CanvasOpts\n\n  #scaler: ScalerCombined;\n  #currentSize: Rect = RectsEmpty;\n  #ctx: CanvasRenderingContext2D | undefined;\n\n  constructor(domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>, opts: Partial<CanvasOpts> = {}) {\n    super();\n    if (!domQueryOrEl) throw new Error(`Param 'domQueryOrEl' is null or undefined`);\n    this.el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n    if (this.el.nodeName !== `CANVAS`) {\n      throw new Error(`Expected CANVAS HTML element. Got: ${ this.el.nodeName }`);\n    }\n    this.opts = {\n      fill: opts.fill ?? `none`,\n      height: opts.height ?? -1,\n      width: opts.width ?? -1,\n      zIndex: opts.zIndex ?? -1,\n      scaleBy: opts.scaleBy ?? `both`,\n      onResize: opts.onResize,\n      clearOnResize: opts.clearOnResize ?? true,\n      draw: opts.draw,\n      skipCss: opts.skipCss ?? false\n    }\n\n    this.#scaler = scaler(`both`);\n    this.#init();\n  }\n\n  #getContext(reset = false) {\n    if (this.#ctx === undefined || reset) {\n      const ratio = this.ratio;\n      const c = this.el.getContext(`2d`);\n      if (c === null) throw new Error(`Could not create drawing context`);\n      this.#ctx = c;\n      // Reset scale\n      c.setTransform(1, 0, 0, 1, 0, 0);\n      c.scale(ratio, ratio);\n    }\n    return this.#ctx;\n  };\n\n  #setLogicalSize(logicalSize: Rect) {\n    RectsGuard(logicalSize, `logicalSize`);\n\n    const ratio = window.devicePixelRatio || 1;\n\n    // Scaler for going between relative and logical units\n    this.#scaler = scaler(this.opts.scaleBy, logicalSize);\n\n    // Scaled logical size for DPI\n    const pixelScaled = RectsMultiply(logicalSize, ratio, ratio);\n\n    // Canvas will actually be much larger, based on DPI\n    this.el.width = pixelScaled.width;\n    this.el.height = pixelScaled.height;\n\n    // But scaled down on screen\n    this.el.style.width = logicalSize.width.toString() + `px`;\n    this.el.style.height = logicalSize.height.toString() + `px`;\n\n    // Since dimensions have change, reset context\n    this.#getContext(true);\n\n    if (this.opts.clearOnResize) {\n      this.ctx.clearRect(0, 0, this.width, this.height);\n    }\n\n    this.#currentSize = logicalSize;\n\n    // Notify listeners of resize\n    const r = this.opts.onResize;\n    if (r) {\n      setTimeout(() => { r(this.ctx, this.size, this) }, 100);\n    }\n    this.fireEvent(`resize`, { ctx: this.ctx, size: this.#currentSize, helper: this });\n  }\n\n  /**\n   * Notified that parent has changed size\n   * @returns \n   */\n  #onParentResize() {\n    const parentEl = this.el.parentElement;\n    if (!parentEl) return;\n    const bounds = parentEl.getBoundingClientRect();\n    this.#setLogicalSize({ width: bounds.width, height: bounds.height });\n  }\n\n  /**\n   * Notified that window has changed size\n   */\n  #onWindowResize() {\n    this.#setLogicalSize({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  };\n\n  #init() {\n    switch (this.opts.fill) {\n      case `viewport`: {\n        if (!this.opts.skipCss) {\n          this.el.style.position = `absolute`;\n          this.el.style.left = `0px`;\n          this.el.style.top = `0px`;\n          this.el.style.zIndex = this.opts.zIndex.toString();\n        }\n        const r = windowResize();\n        r.onValue(() => { this.#onWindowResize() });\n\n        this.#onWindowResize();\n        break;\n      }\n      case `parent`: {\n        const parentEl = this.el.parentElement;\n        if (!parentEl) throw new Error(`Canvas element has no parent?!`);\n        if (!this.opts.skipCss) {\n          this.el.style.position = `relative`;\n          this.el.style.left = `0px`;\n          this.el.style.top = `0px`;\n        }\n        // const r = resizeObservable(parentEl);\n        // r.onValue(onParentResize);\n        const r = windowResize();\n        r.onValue(() => { this.#onParentResize() });\n        this.#onParentResize();\n        break;\n      }\n      case `none`: {\n        // Use current size\n        let { width, height } = this.el.getBoundingClientRect();\n        if (this.opts.width > 0) width = this.opts.width;\n        if (this.opts.height > 0) height = this.opts.height;\n        const desiredSize = { width, height };\n        this.#setLogicalSize(desiredSize);\n        break;\n      }\n      default: {\n        throw new Error(`Unknown 'fill' value. Expecting: 'none', 'viewport' or 'fill'`);\n      }\n    }\n\n    // If there is a 'draw' callback, set up an animation loop\n    const d = this.opts.draw;\n    if (d) {\n      const sched = () => {\n        d(this.ctx, this.#currentSize, this);\n        requestAnimationFrame(sched);\n      }\n      setTimeout(() => { sched() }, 100);\n    }\n  }\n\n  /**\n   * Clears the canvas.\n   * \n   * Shortcut for:\n   * `this.ctx.clearRect( 0, 0, this.width, this.height)`\n   */\n  clear() {\n    if (this.#ctx) {\n      this.#ctx.clearRect(0, 0, this.width, this.height);\n    }\n  }\n\n  /**\n   * Gets the drawing context\n   */\n  get ctx() {\n    if (this.#ctx === undefined) throw new Error(`Context not available`);\n    return this.#getContext();\n  }\n\n  /**\n   * Gets the logical width of the canvas\n   * See also: {@link height}, {@link size}\n   */\n  get width() {\n    return this.#currentSize.width;\n  }\n\n  /**\n   * Gets the logical height of the canvas\n   * See also: {@link width}, {@link size}\n   */\n  get height() {\n    return this.#currentSize.height;\n  }\n\n  /**\n   * Gets the logical size of the canvas\n   * See also: {@link width}, {@link height}\n   */\n  get size() {\n    return this.#currentSize;\n  }\n\n  /**\n   * Gets the current scaling ratio being used\n   * to compensate for high-DPI display\n   */\n  get ratio() {\n    return window.devicePixelRatio || 1;\n  }\n\n  /**\n   * Returns the width or height, whichever is smallest\n   */\n  get dimensionMin() {\n    return Math.min(this.width, this.height);\n  }\n\n  /**\n   * Returns the width or height, whichever is largest\n   */\n  get dimensionMax() {\n    return Math.max(this.width, this.height);\n  }\n\n  /**\n   * Returns a {@link Scaler} that converts from relative to absolute\n   * coordinates.\n   * This is based on the canvas size.\n   * \n   * ```js\n   * // Assuming a canvas of 800x600\n   * toAbsolute({ x: 1, y: 1 });      // { x: 800, y: 600}\n   * toAbsolute({ x: 0, y: 0 });      // { x: 0, y: 0}\n   * toAbsolute({ x: 0.5, y: 0.5 });  // { x: 400, y: 300}\n   * ```\n   */\n  get toAbsolute() {\n    return this.#scaler.abs;\n  }\n\n  /**\n   * Returns a {@link Scaler} that converts from absolute\n   * to relative coordinates.\n   * This is based on the canvas size.\n   * \n   * ```js\n   * // Assuming a canvas of 800x500\n   * toRelative({ x: 800, y:600 });  // { x: 1,   y: 1 }\n   * toRelative({ x: 0,   y: 0 });   // { x: 0,   y: 0 }\n   * toRelative({ x: 400, y: 300 }); // { x: 0.5, y: 0.5 }\n   * ```\n   */\n  get toRelative() {\n    return this.#scaler.rel;\n  }\n\n  /**\n   * Gets the center coordinate of the canvas\n   */\n  get center() {\n    return { x: this.width / 2, y: this.height / 2 }\n  }\n}","import { resolveEls, type QueryOrElements } from \"./ResolveEl.js\";\n\n/**\n * Adds `cssClass` to element(s) if `value` is true.\n * ```js\n * setClass(`#someId`, true, `activated`);\n * ```\n * @param query \n * @param value \n * @param cssClass \n * @returns \n */\nexport const setCssClass = (selectors: QueryOrElements, value: boolean, cssClass: string) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n\n  for (const element of elements) {\n    if (value) element.classList.add(cssClass);\n    else element.classList.remove(cssClass);\n  }\n};\n\n/**\n * Toggles a CSS class on all elements that match selector\n * @param selectors \n * @param cssClass \n * @returns \n */\nexport const setCssToggle = (selectors: QueryOrElements, cssClass: string) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n  for (const element of elements) {\n    element.classList.toggle(cssClass);\n  }\n}\n\nexport const setCssDisplay = (selectors: QueryOrElements, value: string) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n  for (const element of elements) {\n    (element).style.display = value;\n  }\n};","import * as Text from \"../Text.js\"\nimport { resolveEl } from \"./ResolveEl.js\"\n\n/**\n * CSS Variable\n */\nexport type CssVariable = {\n  /**\n   * CSS variable to read for the value. `--` prefix is not needed\n   */\n  variable: string\n  /**\n   * Attribute name, eg 'width' for a Canvas element.\n   */\n  attribute?: string\n  field?: string\n  /**\n   * Optional default value\n   */\n  defaultValue: string | undefined\n}\n\n/**\n * CSS Variable by id\n */\nexport type CssVariableByIdOption = CssVariable & {\n  id: string\n}\n\n/**\n * CSS variable by query\n */\nexport type CssVariableByQueryOption = CssVariable & {\n  query: string\n}\n\n/**\n * CSS variable by element reference\n */\nexport type CssVariableByElementOption = CssVariable & {\n  element: (HTMLElement | SVGElement) | Array<Element>\n}\n\n/**\n * CSS variable option\n */\nexport type CssVariableOption = CssVariable & (CssVariableByElementOption | CssVariableByIdOption | CssVariableByQueryOption);\n\n/**\n * Parse data as attributes.\n * \n * This is a first step of going from a relatively human-friendly simple array format\n * into setting HTML attributes based on a CSS variable. The second step is to call `setFromVariables`\n * \n * ```js\n * // Array of arrays is treated as a set of key-value pairs\n * const options = [ [`indicator-fill`, `gray`], [`backdrop-fill`, `whitesmoke`] ]\n * const attrs = parseAsAttributes(options);\n * Yields:\n * [\n *  { variable: `indicator-fill`, attribute: `fill`, id: `indicator`, defaultValue: `gray` }\n *  { variable: `backdrop-fill`, attribute: `fill`, id: `backdrop`, defaultValue: `whitesmoke` }\n * ]\n * \n * // Assign\n * setFromCssVariables(document.body, attrs);\n * ```\n * @param options \n * @returns \n */\nexport const parseAsAttributes = (options: Array<string | Array<string>>): Array<CssVariable & CssVariableByIdOption> => {\n  return options.map(opt => {\n    let defaultValue;\n    // Nested array, treat second element as default value, name as first\n    if (Array.isArray(opt)) {\n      defaultValue = opt[ 1 ];\n      opt = opt[ 0 ];\n    }\n    const dash = opt.indexOf(`-`);\n    if (dash < 0) throw new Error(`Simple expression expects form of: 'elementid-attribute'`);\n    return {\n      variable: opt,\n      attribute: opt.slice(dash + 1),\n      id: opt.slice(0, dash),\n      defaultValue\n    }\n  })\n}\n\n/**\n * Reads the value of a CSS variable and assign it to HTML attributes or object field.\n * \n * ```js\n * const options = [\n *  // Set the 'width' attribute to the value of --some-css-variable to all elements with class 'blah'\n *  { query: `.blah`, variable: `some-css-variable`, attribute: `width` }\n *  // Set #blah's 'size' attribute to the value of css variable '--size'\n *  { id: 'blah', variable: 'size', attribute: 'size' }\n *  // Sets someEL.blah = css variable '--hue'\n *  { element: someEl, variable: `hue`, field: `blah` }\n * ]\n * \n * setFromVariables(document.body, ...options);\n * ```\n * \n * The first parameter is the context for which CSS variable values are fetched\n * as well as for resolving query selectors. This can usually be `document.body`.\n * @param context Context element which is needed for relative querying. Otherwise use document.body\n * @param options Details of what to do\n */\nexport const setFromVariables = (context: HTMLElement | string, ...options: Array<CssVariableOption>) => {\n  const contextEl = resolveEl(context);\n  const style = window.getComputedStyle(contextEl);\n\n  for (const opt of options) {\n    const variable = Text.afterMatch(opt.variable, `--`);\n    let v = style.getPropertyValue(`--${ variable }`);\n    if (v === null || v.length === 0) {\n      if (opt.defaultValue === undefined) { continue; }\n      else { v = opt.defaultValue; }\n    }\n\n    let query: string | undefined;\n    let els;//: SVGElement | HTMLElement | null | undefined;\n    if (`query` in opt && opt.query !== undefined) {\n      query = opt.query;\n    } else if (`id` in opt && opt.id !== undefined) {\n      query = `#${ opt.id }`;\n    } else if (`element` in opt && opt.element !== undefined) {\n      els = Array.isArray(opt.element) ? opt.element : [ opt.element ];\n    }\n    if (query === undefined) {\n      if (els === undefined) {\n        throw new Error(`Missing query, id or element`);\n      }\n    } else {\n      els = [ ...contextEl.querySelectorAll(query) ] as Array<Element>;// as SVGElement | HTMLElement | null | undefined;\n    }\n    if (els === null) continue;\n    if (els === undefined) continue;\n    if (opt.attribute) {\n      for (const el of els) {\n        (el as HTMLElement).setAttribute(opt.attribute, v);\n      }\n    } else if (opt.field) {\n      for (const el of els) {\n        (el as any)[ opt.field ] = v;\n      }\n    } else {\n      throw new Error(`Neither 'attribute' or 'field' to set is defined in option (${ JSON.stringify(opt) })`);\n    }\n  }\n}","import { round } from '../numbers/Round.js';\nimport { resolveEl as resolveElement } from './ResolveEl.js';\nimport JSON5 from 'json5';\n\nexport type FormattingOptions = {\n  readonly precision?: number\n  readonly roundNumbers?: number\n}\nexport type DataTableOpts = FormattingOptions & {\n  readonly formatter?: DataFormatter\n  readonly objectsAsTables?: boolean\n  readonly idPrefix?: string\n};\n\nexport type DataTable<V> = {\n  update(data: V): void;\n  remove(): boolean;\n};\n\nconst toHtmlSimple = (v: any, options: FormattingOptions): string => {\n  if (v === null) return `(null)`;\n  if (v === undefined) return `(undefined)`;\n  if (typeof v === `boolean`) return v ? `true` : `false`;\n  if (typeof v === `string`) return `\"${ v }\"`;\n  if (typeof v === `number`) {\n    let vAsNumber = v;\n    if (options.roundNumbers !== undefined) vAsNumber = round(options.roundNumbers, v)\n    if (options.precision !== undefined) return vAsNumber.toFixed(options.precision);\n    return vAsNumber.toString();\n  }\n  if (typeof v === `object`) return toTableSimple(v, options);\n  return JSON5.stringify(v);\n}\n\nconst toTableSimple = (v: object, options: FormattingOptions): string => {\n  let html = `<div style=\"display:grid; grid-template-columns: repeat(2, 1fr)\">`;\n  for (const entry of Object.entries(v)) {\n    const value = toHtmlSimple(entry[ 1 ], options);\n    html += `<div class=\"label\" style=\"display:table-cell\">${ entry[ 0 ] }</div>\n      <div class=\"data\" style=\"display:table-cell\">${ value }</div>`\n  }\n  html += `</div>`;\n  return html;\n}\n\n/**\n * Creates a table of data points for each object in the map\n * ```\n * const t = DataTable.fromList(parentEl, map);\n * t.update(newMap);\n * ```\n */\nexport const fromList = (\n  parentOrQuery: HTMLElement | string,\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: Map<string, object>\n): DataTable<Map<string, object>> => {\n  const parent = resolveElement(parentOrQuery);\n  let container: HTMLDivElement | undefined = document.createElement(\n    `DIV`\n  ) as HTMLDivElement;\n  parent.append(container);\n\n  const remove = () => {\n    if (!container) return false;\n    container.remove();\n    container = undefined;\n    return true;\n  };\n\n  const update = (data: ReadonlyMap<string, object>) => {\n    const seenTables = new Set();\n\n    for (const [ key, value ] of data) {\n      const tKey = `table-${ key }`;\n      seenTables.add(tKey);\n      let t: HTMLElement | null = parent.querySelector(`#${ tKey }`);\n      if (t === null) {\n        t = document.createElement(`table`);\n        if (!t) throw new Error(`Could not create table element`);\n        //eslint-disable-next-line functional/immutable-data\n        t.id = tKey;\n        parent.append(t);\n      }\n\n      updateElement(t as HTMLTableElement, value);\n    }\n\n    // Remove tables that aren't present in map\n    // eslint-disable-next-line unicorn/prefer-spread\n    const tables = Array.from(parent.querySelectorAll(`table`));\n    for (const t of tables) {\n      if (!seenTables.has(t.id)) {\n        t.remove();\n      }\n    }\n  };\n\n  if (data) update(data);\n  return { update, remove };\n  // return (d: ReadonlyMap<string, object>) => {\n  //   update(d);\n  // };\n};\n\n/**\n * Format data. Return _undefined_ to signal that\n * data was not handled.\n */\nexport type DataFormatter = (data: object, path: string) => string | undefined;\n\n/**\n * Updates the given table element so each entry in the map is a\n * row in the table.\n *\n * Rows are keyed by the map key. Rows with keys not found in the map are deleted.\n * @param t Table\n * @param data Map of data\n * @param opts Options\n * @returns\n */\nconst updateElement = (\n  //eslint-disable-next-line functional/prefer-immutable-types\n  t: HTMLTableElement,\n  data: object,\n  opts: DataTableOpts = {}\n) => {\n  const precision = opts.precision ?? 2;\n  const idPrefix = opts.idPrefix ?? ``;\n  const objectsAsTables = opts.objectsAsTables ?? false;\n\n  if (data === undefined) {\n    //eslint-disable-next-line functional/immutable-data\n    t.innerHTML = ``;\n    return;\n  }\n  const seenRows = new Set();\n\n  for (const [ key, value ] of Object.entries(data)) {\n    const domKey = `${ idPrefix }-row-${ key }`;\n    // Keep track of keys currently in object\n    seenRows.add(domKey);\n\n    // Is there already a row for this key?\n    let rowEl = t.querySelector(`tr[data-key='${ domKey }']`);\n    if (rowEl === null) {\n      // No row, add it\n      rowEl = document.createElement(`tr`);\n      t.append(rowEl);\n      rowEl.setAttribute(`data-key`, domKey);\n\n      const keyEl = document.createElement(`td`);\n      keyEl.textContent = key;\n      keyEl.classList.add(`label`);\n      rowEl.append(keyEl);\n    }\n\n    // Is there already a cell for the value?\n    let valEl = rowEl.querySelector(`td[data-key='${ domKey }-val']`);\n\n    if (valEl === null) {\n      // No, create the cell\n      valEl = document.createElement(`td`);\n      valEl.classList.add(`data`);\n      valEl.setAttribute(`data-key`, `${ domKey }-val`);\n      rowEl.append(valEl);\n    }\n\n    // Format the value as HTML\n    let valueHTML: string | undefined;\n    if (opts.formatter) {\n      valueHTML = opts.formatter(value, key);\n    }\n\n    // If there's no formatter, or not handled...\n    if (valueHTML === undefined) {\n      if (typeof value === `object`) {\n        valueHTML = objectsAsTables ? toTableSimple(value, opts) : JSON5.stringify(value);\n      } else if (typeof value === `number`) {\n        valueHTML = opts.roundNumbers ? Math.round(value).toString() : value.toFixed(precision);\n      } else if (typeof value === `boolean`) {\n        valueHTML = value ? `true` : `false`;\n      } else if (typeof value === `string`) {\n        valueHTML = `\"${ value }\"`;\n      } else {\n        valueHTML = JSON.stringify(value);\n      }\n    }\n\n    // Set the cell value\n    (valEl as HTMLElement).innerHTML = valueHTML;\n  }\n\n  // Remove rows that aren't present in data\n  // eslint-disable-next-line unicorn/prefer-spread\n  const rows = Array.from(t.querySelectorAll(`tr`));\n  for (const r of rows) {\n    const key = r.getAttribute(`data-key`);\n    if (!seenRows.has(key)) {\n      r.remove();\n    }\n  }\n};\n\n/**\n * Creates a HTML table where each row is a key-value pair from `data`.\n * First column is the key, second column data.\n *\n * ```js\n * const dt = fromObject(`#hostDiv`);\n * ```\n *\n * `dt` is a function to call when you want to update data:\n *\n * ```js\n * dt({\n *  name: `Blerg`,\n *  height: 120\n * });\n * ```\n */\nexport const fromObject = (\n  parentOrQuery: HTMLElement | string,\n  data?: object,\n  opts?: DataTableOpts\n): DataTable<object> => {\n  const parent = resolveElement(parentOrQuery);\n  const idPrefix = opts?.idPrefix ?? Math.floor(Math.random() * 1000).toString();\n\n  let t: HTMLTableElement | undefined = document.createElement(`table`);\n  parent.append(t);\n\n  const remove = () => {\n    if (!t) return false;\n    t.remove();\n    t = undefined;\n    return true;\n  };\n\n  // Update already if there's initial data\n  if (data) updateElement(t, data, opts);\n\n  const update = (d: object) => {\n    if (!t) throw new Error(`Table disposed`);\n    updateElement(t, d, { ...opts, idPrefix });\n  };\n\n  return { remove, update };\n};\n","import { fromObject } from \"./DataTable.js\";\n\nexport type DataDisplayOptions = {\n  theme?: `dark` | `light`\n}\n\n// TODO Visually show data which has changed since last update\n// TODO Click on a field to show a sparkline for it\n/**\n * Creates a simple display for data. Designed to show ixfx state data\n * \n * ```js\n * // Create once\n * const display = new DataDisplay();\n * \n * // Call .update to show state\n * display.update(state);\n * ```\n */\nexport class DataDisplay {\n\n  dataTable;\n\n  /**\n   * Constructor\n   * @param options Options\n   */\n  constructor(options: DataDisplayOptions = {}) {\n    const theme = options.theme ?? `dark`;\n\n    const existing = document.querySelector(`#ixfx-data-display`);\n    if (existing !== null) throw new Error(`DataDisplay already loaded on this page`);\n\n    const container = document.createElement(`div`);\n    container.id = `ixfx-data-display`;\n    container.classList.add(`theme-${ theme }`);\n\n    const css = document.createElement(`style`);\n    css.textContent = `\n    #ixfx-data-display {\n      background: white;\n      color: black;\n      border: 2px solid hsl(0deg 0.61% 90%);\n      border-radius: 4px;\n      z-index: 1000;\n      opacity: 40%;\n      padding: 1em;\n      font-family: monospace;\n      position: fixed;\n      right: 1em;\n      top: 1em;\n    }\n    #ixfx-data-display.theme-dark {\n      background: black;\n      color: white;\n      border: 2px solid hsl(0deg 0.61% 10%);\n    }\n    #ixfx-data-display:hover {\n      opacity: 100%;\n    }\n    #ixfx-data-display table {\n      border-collapse: collapse;\n    }\n    #ixfx-data-display tr:not(:last-child) {\n      border-bottom: 2px solid hsl(0deg 0.61% 90%);\n    }\n    #ixfx-data-display.dark tr:not(:last-child) {\n      border-bottom: 2px solid hsl(0deg 0.61% 10%);\n    }\n    #ixfx-data-display td {\n      padding-bottom: 0.4em;\n      padding-top: 0.4em;\n    }\n    #ixfx-data-display .label {\n      color: hsl(0deg 0.61% 60%);\n      text-align: right;\n      padding-right: 0.5em;\n    }\n    #ixfx-data-display.theme-dark .label {\n      color: gray;\n    }\n    `\n\n    container.style.display = `inline-block`;\n    document.body.append(css);\n    document.body.append(container);\n\n    this.dataTable = fromObject(container, undefined, {\n      objectsAsTables: true,\n      roundNumbers: 2\n    });\n  }\n\n  update(data: object) {\n    this.dataTable.update(data);\n  }\n}","import { Points } from '../geometry/index.js';\nimport type { Point } from '../geometry/point/PointType.js'\nexport type DragState = {\n  readonly token?: object;\n  readonly initial: Point;\n  readonly delta: Point;\n};\n\nexport type DragStart = {\n  readonly allow: boolean;\n  readonly token: object;\n};\nexport type DragListener = {\n  readonly start?: () => DragStart;\n  readonly progress?: (state: DragState) => boolean;\n  readonly abort?: (reason: string, state: DragState) => void;\n  readonly success?: (state: DragState) => void;\n};\n\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const draggable = (elem: SVGElement, listener: DragListener) => {\n  //eslint-disable-next-line functional/no-let\n  let initial = Points.Placeholder;\n  //eslint-disable-next-line functional/no-let\n  let token: object;\n\n  // De-select if there's a click elsewhere\n  const onParentClick = () => {\n    const selected = elem.classList.contains(`drag-sel`);\n    if (selected) {\n      elem.classList.remove(`drag-sel`);\n    }\n  };\n\n  // Click to select\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const onElementClick = (event: MouseEvent) => {\n    const selected = elem.classList.contains(`drag-sel`);\n    if (selected) {\n      elem.classList.remove(`drag-sel`);\n    } else {\n      elem.classList.add(`drag-sel`);\n    }\n    event.stopPropagation();\n  };\n\n  elem.ownerDocument.addEventListener(`click`, onParentClick);\n  elem.addEventListener(`click`, onElementClick);\n\n  // Remove event handlers\n  const dragCleanup = () => {\n    elem.classList.remove(`drag-progress`);\n\n    elem.ownerDocument.removeEventListener(`pointermove`, onPointerMove);\n    elem.ownerDocument.removeEventListener(`pointerup`, onPointerUp);\n    elem.ownerDocument.removeEventListener(`pointercancel`, onDragCancel);\n  };\n\n  const dispose = () => {\n    console.log(`drag dispose`);\n    if (elem.classList.contains(`drag-progress`)) {\n      onDragCancel(undefined, `dispose`);\n    } else {\n      dragCleanup();\n    }\n    elem.ownerDocument.removeEventListener(`click`, onParentClick);\n    elem.removeEventListener(`click`, onElementClick);\n  };\n\n  // Dragging\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const onPointerMove = (moveEvent: PointerEvent) => {\n    moveEvent.preventDefault();\n    moveEvent.stopPropagation();\n\n    const offset = Points.isPlaceholder(initial)\n      ? { x: moveEvent.offsetX, y: moveEvent.offsetY }\n      : {\n        x: moveEvent.x - initial.x,\n        y: moveEvent.y - initial.y,\n      };\n    const state: DragState = {\n      delta: offset,\n      initial: initial,\n      token,\n    };\n    if (typeof listener.progress !== `undefined` && !listener.progress(state)) {\n      onDragCancel(undefined, `discontinued`);\n    }\n  };\n\n  // Done dragging\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const onPointerUp = (upEvent: PointerEvent) => {\n    dragCleanup();\n    const offset = {\n      x: upEvent.x - initial.x,\n      y: upEvent.y - initial.y,\n    };\n    const state: DragState = {\n      initial: initial,\n      token,\n      delta: offset,\n    };\n    if (typeof listener.success !== `undefined`) {\n      listener.success(state);\n    }\n  };\n\n  // Drag is cancelled\n  const onDragCancel = (\n    //eslint-disable-next-line functional/prefer-immutable-types\n    event: PointerEvent | MouseEvent | undefined,\n    reason = `pointercancel`\n  ) => {\n    dragCleanup();\n    const state: DragState = {\n      token,\n      initial: initial,\n      delta: { x: -1, y: -1 },\n    };\n    if (typeof listener.abort !== `undefined`) {\n      listener.abort(reason, state);\n    }\n  };\n\n  elem.addEventListener(`pointerdown`, (event) => {\n    const selected = elem.classList.contains(`drag-sel`);\n    if (!selected) return;\n\n    initial = { x: event.x, y: event.y };\n    const s =\n      typeof listener.start === `undefined`\n        ? { allow: true, token }\n        : listener.start();\n    if (!s.allow) return;\n\n    token = s.token;\n\n    elem.classList.add(`drag-progress`);\n    elem.ownerDocument.addEventListener(`pointermove`, onPointerMove);\n    elem.ownerDocument.addEventListener(`pointerup`, onPointerUp);\n    elem.ownerDocument.addEventListener(`pointercancel`, onDragCancel);\n  });\n\n  return dispose;\n};\n","import { setCssClass, setCssDisplay, setCssToggle } from \"./Css.js\";\nimport { resolveEl, resolveEls, type QueryOrElements } from \"./ResolveEl.js\";\nimport { setHtml, setText } from \"./SetProperty.js\";\n\nexport const el = (selectors: QueryOrElements) => {\n  const elements = resolveEls(selectors);\n  const text = setText(elements);\n  const html = setHtml(elements);\n  return {\n    text,\n    html,\n    cssDisplay: (value: string) => { setCssDisplay(elements, value); },\n    cssClass: (value: boolean, cssClass: string) => { setCssClass(elements, value, cssClass); },\n    cssToggle: (cssClass: string) => { setCssToggle(elements, cssClass); },\n    el: () => elements[ 0 ],\n    els: () => elements\n  }\n}\n\nexport const elRequery = (selectors: string) => {\n  ({\n    text: (value: string | number) => { setText(selectors, value); },\n    html: (value: string | number) => { setHtml(selectors, value); },\n    cssDisplay: (value: string) => { setCssDisplay(selectors, value); },\n    cssClass: (value: boolean, cssClass: string) => { setCssClass(selectors, value, cssClass); },\n    cssToggle: (cssClass: string) => { setCssToggle(selectors, cssClass); },\n    el: () => resolveEl(selectors),\n    els: () => resolveEls(selectors)\n  });\n}\n","import type { Point } from \"../geometry/point/PointType.js\";\nimport { resolveEl } from \"./ResolveEl.js\";\nimport { resizeObservable, windowResize } from \"./DomRx.js\";\n\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport type ElementResizeArgs<V extends HTMLElement | SVGSVGElement> = {\n  readonly el: V;\n  readonly bounds: {\n    readonly width: number;\n    readonly height: number;\n    readonly center: Point;\n    readonly min: number;\n    readonly max: number;\n  };\n};\n\n\nexport const fullSizeElement = <V extends HTMLElement>(\n  domQueryOrEl: string | V,\n  onResized?: (args: ElementResizeArgs<V>) => void\n) => {\n  const el = resolveEl<V>(domQueryOrEl);\n\n  const r = windowResize();\n  const update = () => {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    el.setAttribute(`width`, width.toString());\n    el.setAttribute(`height`, height.toString());\n\n    if (onResized !== undefined) {\n      const bounds = {\n        min: Math.min(width, height),\n        max: Math.max(width, height),\n        width,\n        height,\n        center: {\n          x: width / 2,\n          y: height / 2,\n        },\n      };\n      onResized({ el, bounds });\n    }\n  };\n  r.onValue(update);\n\n  update();\n  return r;\n};\n\n/**\n * Sets width/height atributes on the given element according to the size of its parent.\n * @param domQueryOrEl Elememnt to resize\n * @param onResized Callback when resize happens\n * @param timeoutMs Timeout for debouncing events\n * @returns\n */\nexport const parentSize = <V extends HTMLElement | SVGSVGElement>(\n  domQueryOrEl: string | V,\n  onResized?: (args: ElementResizeArgs<V>) => void,\n  timeoutMs = 100\n) => {\n  const el = resolveEl<V>(domQueryOrEl);\n  const parent = el.parentElement;\n  if (parent === null) throw new Error(`Element has no parent`);\n\n  const ro = resizeObservable(parent, timeoutMs).onValue(\n    (entries: ReadonlyArray<ResizeObserverEntry>) => {\n      const entry = entries.find((v) => v.target === parent);\n      if (entry === undefined) return;\n\n      const width = entry.contentRect.width;\n      const height = entry.contentRect.height;\n\n      el.setAttribute(`width`, `${ width }px`);\n      el.setAttribute(`height`, `${ height }px`);\n      if (onResized !== undefined) {\n        const bounds = {\n          min: Math.min(width, height),\n          max: Math.max(width, height),\n          width,\n          height,\n          center: { x: width / 2, y: height / 2 },\n        };\n        onResized({ el, bounds });\n      }\n    }\n  );\n\n  return ro;\n};","import { getErrorMessage } from \"../debug/GetErrorMessage.js\";\n\n/**\n * Creates an error handler to show errors on-screen.\n * This is useful when testing on mobile devices that lack access to the console.\n *\n * ```js\n * const e = defaultErrorHandler();\n * ```\n *\n * Manual control:\n * ```js\n * const e = defaultErrorHandler();\n * e.show(someError);\n * e.hide();\n * ```\n * @returns\n */\nexport const defaultErrorHandler = () => {\n  //eslint-disable-next-line functional/no-let\n  let enabled = true;\n  const container = document.createElement(`div`);\n  container.style.color = `black`;\n  container.style.border = `2px solid red`;\n  container.style.backgroundColor = `hsl(0, 80%, 90%)`;\n  container.style.padding = `1em`;\n  container.style.display = `none`;\n  container.style.top = `1em`;\n  container.style.left = `1em`;\n  container.style.position = `absolute`;\n\n  container.style.fontFamily = `monospace`;\n\n  const messageElement = document.createElement(`div`);\n  messageElement.style.maxWidth = `50vw`;\n  messageElement.style.maxHeight = `50vh`;\n  messageElement.style.overflowY = `scroll`;\n\n  container.innerHTML = `<h1>Error</h1>`;\n  container.append(messageElement);\n\n  const styleButton = (b: HTMLButtonElement) => {\n    b.style.padding = `0.3em`;\n    b.style.marginTop = `1em`;\n  };\n\n  const buttonClose = document.createElement(`button`);\n  buttonClose.textContent = `Close`;\n  buttonClose.addEventListener(`click`, () => {\n    hide();\n  });\n\n  const buttonStop = document.createElement(`button`);\n  buttonStop.textContent = `Stop displaying errors`;\n  buttonStop.addEventListener(`click`, () => {\n    enabled = false;\n    hide();\n  });\n\n  styleButton(buttonClose);\n  styleButton(buttonStop);\n\n  container.append(buttonClose);\n  container.append(buttonStop);\n  document.body.append(container);\n\n  const show = (ex: Error | string | Event) => {\n    container.style.display = `inline`;\n    messageElement.innerHTML += (ex as any).stack ? `<pre>${ (ex as any).stack }</pre>` : `<p>${ getErrorMessage(ex) }</p>`;\n  };\n\n  const hide = () => {\n    container.style.display = `none`;\n  };\n\n  // eslint-disable-next-line unicorn/prefer-add-event-listener\n  window.onerror = (message, url, lineNo, colNo, error) => {\n    if (enabled) {\n      if (error) {\n        console.log(error);\n        show(error);\n      } else {\n        console.log(message);\n        show(message);\n      }\n    }\n  };\n\n  window.addEventListener(`unhandledrejection`, (event) => {\n    console.log(event.reason);\n    if (enabled) {\n      show(event.reason);\n    }\n  });\n  return { show, hide };\n};\n","export const addShadowCss = (\n  parentEl: Readonly<HTMLElement>,\n  styles: string\n): ShadowRoot => {\n  const styleEl = document.createElement(`style`);\n\n  //eslint-disable-next-line functional/immutable-data\n  styleEl.textContent = styles;\n  //eslint-disable-next-line functional/no-let\n  let shadowRoot;\n  if (parentEl.shadowRoot) {\n    shadowRoot = parentEl.shadowRoot;\n    //eslint-disable-next-line functional/immutable-data\n    shadowRoot.innerHTML = ``;\n  } else {\n    shadowRoot = parentEl.attachShadow({ mode: `open` });\n  }\n  shadowRoot.append(styleEl);\n  return shadowRoot;\n};\n","import { resolveEl } from './ResolveEl.js';\nimport { addShadowCss } from './ShadowDom.js';\n\nexport type LogOpts = {\n  readonly reverse?: boolean;\n  readonly capacity?: number;\n  readonly timestamp?: boolean;\n  readonly collapseDuplicates?: boolean;\n  readonly monospaced?: boolean;\n  readonly minIntervalMs?: number;\n  readonly css?: string;\n};\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type Log = {\n  clear(): void;\n  error(messageOrError: unknown): void;\n  log(message?: string | object | number): HTMLElement | undefined;\n  warn(message?: string | object | number): HTMLElement | undefined;\n  //eslint-disable-next-line functional/prefer-immutable-types\n  append(el: HTMLElement): void;\n  dispose(): void;\n  readonly isEmpty: boolean;\n};\n\n/**\n * Allows writing to a DOM element in console.log style. Element grows in size, so use\n * something like `overflow-y: scroll` on its parent\n *\n * ```\n * const l = log(`#dataStream`); // Assumes HTML element with id `dataStream` exists\n * l.log(`Hi`);\n * l.log(); // Displays a horizontal rule\n *\n * const l = log(document.getElementById(`dataStream`), {\n *  timestamp: true,\n *  truncateEntries: 20\n * });\n * l.log(`Hi`);\n * l.error(`Some error`); // Adds class `error` to line\n * ```\n *\n * For logging high-throughput streams:\n * ```\n * // Silently drop log if it was less than 5ms since the last\n * const l = log(`#dataStream`, { minIntervalMs: 5 });\n *\n * // Only the last 100 entries are kept\n * const l = log(`#dataStream`, { capacity: 100 });\n * ```\n *\n * @param {(HTMLElement | string | undefined)} elOrId Element or id of element\n * @param {LogOpts} opts\n * @returns {Log}\n */\nexport const log = (\n  //eslint-disable-next-line functional/prefer-immutable-types\n  domQueryOrElement: HTMLElement | string,\n  opts: LogOpts = {}\n): Log => {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const {\n    capacity = 0,\n    monospaced = true,\n    timestamp = false,\n    collapseDuplicates = true,\n    css = ``,\n  } = opts;\n\n  // eslint-disable-next-line functional/no-let\n  let added = 0;\n  // eslint-disable-next-line functional/no-let\n  let lastLog: string | undefined;\n  // eslint-disable-next-line functional/no-let\n  let lastLogRepeats = 0;\n\n  const parentElement = resolveEl<HTMLElement>(domQueryOrElement);\n  const fontFamily = monospaced\n    ? `Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", Monaco, \"Courier New\", Courier, monospace`\n    : `normal`;\n  const shadowRoot = addShadowCss(\n    parentElement,\n    `\n  .log {\n    font-family: ${ fontFamily };\n    background-color: var(--code-background-color);\n    padding: var(--padding1, 0.2em);\n    overflow-y: auto;\n    height:100%;\n  }\n  .timestamp {\n    margin-right: 0.5em;\n    opacity: 0.5;\n    font-size: 70%;\n    align-self: center;\n  }\n  .line {\n    display: flex;\n    padding-bottom: 0.1em;\n    padding-top: 0.1em;\n  }\n  .line:hover {\n  \n  }\n  .error {\n    color: red;\n  }\n  .badge {\n    border: 1px solid currentColor;\n    align-self: center;\n    font-size: 70%;\n    padding-left: 0.2em;\n    padding-right: 0.2em;\n    border-radius: 1em;\n    margin-left: 0.5em;\n    margin-right: 0.5em;\n  }\n  .msg {\n    flex: 1;\n    word-break: break-word;\n  }\n  ${ css }\n  `\n  );\n\n  const el = document.createElement(`div`);\n  // eslint-disable-next-line functional/immutable-data,unicorn/no-keyword-prefix\n  el.className = `log`;\n  shadowRoot.append(el);\n\n  const error = (messageOrError: string | Error) => {\n    const line = document.createElement(`div`);\n\n    if (typeof messageOrError === `string`) {\n      // eslint-disable-next-line functional/immutable-data\n      line.innerHTML = messageOrError;\n    } else if (messageOrError instanceof Error) {\n      const stack = messageOrError.stack;\n      line.innerHTML = stack === undefined ? messageOrError.toString() : stack.toString();\n    } else {\n      // eslint-disable-next-line functional/immutable-data\n      line.innerHTML = messageOrError as string;\n    }\n    line.classList.add(`error`);\n    append(line);\n    lastLog = undefined;\n    lastLogRepeats = 0;\n  };\n\n  //eslint-disable-next-line functional/no-let\n  let lastLogTime = 0;\n\n  const warn = (whatToLog: unknown = ``): HTMLElement | undefined => {\n    const element = log(whatToLog);\n    if (!element) return element;\n    element.classList.add(`warning`);\n    return element;\n  }\n  const log = (whatToLog: unknown = ``): HTMLElement | undefined => {\n    // eslint-disable-next-line functional/no-let\n    let message: string | undefined;\n    const interval = window.performance.now() - lastLogTime;\n    if (opts.minIntervalMs && interval < opts.minIntervalMs) return;\n    lastLogTime = window.performance.now();\n\n    if (typeof whatToLog === `object`) {\n      message = JSON.stringify(whatToLog);\n    } else if (whatToLog === undefined) {\n      message = `(undefined)`;\n    } else if (whatToLog === null) {\n      message = `(null)`;\n    } else if (typeof whatToLog === `number`) {\n      if (Number.isNaN(message)) message = `(NaN)`;\n      message = whatToLog.toString();\n    } else {\n      message = whatToLog as string;\n    }\n\n    if (message.length === 0) {\n      const rule = document.createElement(`hr`);\n      lastLog = undefined;\n      append(rule);\n    } else if (message === lastLog && collapseDuplicates) {\n      const lastElement = el.firstElementChild as HTMLElement;\n      // eslint-disable-next-line functional/no-let\n      let lastBadge = lastElement.querySelector(`.badge`);\n      if (lastBadge === null) {\n        lastBadge = document.createElement(`div`);\n        // eslint-disable-next-line functional/immutable-data,unicorn/no-keyword-prefix\n        lastBadge.className = `badge`;\n        lastElement.insertAdjacentElement(`beforeend`, lastBadge);\n      }\n      if (lastElement !== null) {\n        // eslint-disable-next-line functional/immutable-data\n        lastBadge.textContent = (++lastLogRepeats).toString();\n      }\n      return lastElement;\n    } else {\n      const line = document.createElement(`div`);\n      // eslint-disable-next-line functional/immutable-data\n      line.textContent = message;\n      append(line);\n      lastLog = message;\n      return line;\n    }\n  };\n\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const append = (line: HTMLElement) => {\n    if (timestamp) {\n      const wrapper = document.createElement(`div`);\n      const timestamp = document.createElement(`div`);\n      // eslint-disable-next-line functional/immutable-data,unicorn/no-keyword-prefix\n      timestamp.className = `timestamp`;\n      // eslint-disable-next-line functional/immutable-data\n      timestamp.textContent = new Date().toLocaleTimeString();\n      wrapper.append(timestamp, line);\n      line.classList.add(`msg`);\n      wrapper.classList.add(`line`);\n      line = wrapper;\n    } else {\n      line.classList.add(`line`, `msg`);\n    }\n\n    if (opts.reverse) {\n      el.append(line);\n    } else {\n      el.insertBefore(line, el.firstChild);\n    }\n\n    if (capacity > 0 && ++added > capacity * 2) {\n      while (added > capacity) {\n        el.lastChild?.remove();\n        added--;\n      }\n    }\n\n    if (opts.reverse) {\n      // Scroll to bottom\n      //eslint-disable-next-line functional/immutable-data\n      el.scrollTop = el.scrollHeight;\n    }\n    lastLogRepeats = 0;\n  };\n\n  const clear = () => {\n    // eslint-disable-next-line functional/immutable-data\n    el.innerHTML = ``;\n    lastLog = undefined;\n    lastLogRepeats = 0;\n    added = 0;\n  };\n\n  const dispose = () => {\n    el.remove();\n  };\n\n  return {\n    error,\n    log,\n    warn,\n    append,\n    clear,\n    dispose,\n    get isEmpty() {\n      return added === 0;\n    },\n  };\n};\n","import { getErrorMessage } from '../debug/GetErrorMessage.js';\nimport { afterMatch } from '../Text.js';\nimport { log, type LogOpts } from './Log.js';\n\nexport type InlineConsoleOptions = LogOpts;\n\n/**\n * Adds an inline console to the page. A DIV is added to display log messages.\n * \n * Captures all console.log, console.warn and console.error calls, as well as unhandled exceptions.\n * \n * ```js\n * // Adds the DIV and intercepts console logs\n * inlineConsole();\n * \n * console.log(`Hello`); // message is displayed in the inline console\n * ```\n * @param opts \n */\nexport const inlineConsole = (opts: InlineConsoleOptions = {}) => {\n  const original = {\n    log: console.log,\n    error: console.error,\n    warn: console.warn\n  };\n\n  const logElement = document.createElement(`DIV`);\n  logElement.id = `ixfx-log`;\n  logElement.style.position = `fixed`;\n  logElement.style.left = `0px`;\n  logElement.style.top = `0px`;\n  logElement.style.pointerEvents = `none`;\n  logElement.style.display = `none`;\n\n  document.body.prepend(logElement);\n\n  const logger = log(logElement, opts);\n\n  const visibility = (show: boolean) => {\n    logElement.style.display = show ? `block` : `none`;\n  }\n\n  console.error = (message?: any, ...optionalParameters: Array<any>) => {\n    logger.error(message);\n    if (optionalParameters.length > 0) {\n      logger.error(optionalParameters);\n    }\n    original.error(message, ...optionalParameters);\n    visibility(true);\n  }\n\n  console.warn = (message?: any, ...optionalParameters: Array<any>) => {\n    logger.warn(message);\n    if (optionalParameters.length > 0) {\n      logger.warn(optionalParameters);\n    }\n    visibility(true);\n  }\n\n  console.log = (message?: any, ...optionalParameters: Array<any>) => {\n    logger.log(message);\n    if (optionalParameters.length > 0) {\n      logger.log(optionalParameters);\n    }\n    original.log(message, ...optionalParameters);\n    visibility(true);\n  }\n\n  //eslint-disable-next-line unicorn/prefer-add-event-listener\n  window.onerror = (event, source, lineno, _colno, error) => {\n    const abbreviatedSource = source === undefined ? `` : afterMatch(source, `/`, { fromEnd: true });\n    //const eventString = typeof event === `string` ? event : JSON.stringify(event).toString();\n    const eventString = getErrorMessage(error);\n    //const errorString = error === undefined ? `` : error.message;\n\n    logger.error(eventString + ` (${ abbreviatedSource }:${ lineno })`);\n    visibility(true);\n  }\n}","import {\n  pointsTracker,\n} from '../data/PointTracker.js';\nimport { resolveEl as resolveElement } from './ResolveEl.js';\nimport * as Svg from '../visual/Svg.js';\nimport { fullSizeElement } from './ElementSizing.js';\n\nexport type Opts = {\n  readonly touchRadius?: number;\n  readonly mouseRadius?: number;\n  readonly trace?: boolean;\n  readonly hue?: number;\n};\n\n/**\n * Visualises pointer events within a given element.\n *\n * ```js\n * // Show pointer events for whole document\n * pointerVis(document);\n * ```\n *\n * Note you may need to set the following CSS properties on the target element:\n *\n * ```css\n * touch-action: none;\n * user-select: none;\n * overscroll-behavior: none;\n * ```\n *\n * Options\n * * touchRadius/mouseRadius: size of circle for these kinds of pointer events\n * * trace: if true, intermediate events are captured and displayed\n * @param elOrQuery\n * @param opts\n */\nexport const pointerVisualise = (\n  //eslint-disable-next-line functional/prefer-immutable-types\n  elOrQuery: HTMLElement | string,\n  opts: Opts = {}\n) => {\n  const touchRadius = opts.touchRadius ?? 45;\n  const mouseRadius = opts.touchRadius ?? 20;\n  const trace = opts.trace ?? false;\n  const hue = opts.hue ?? 100;\n\n  const startFillStyle = `hsla(${ hue }, 100%, 10%, 10%)`;\n\n  //eslint-disable-next-line functional/no-let\n  let currentHue = hue;\n\n  const el = resolveElement(elOrQuery);\n  const tracker = pointsTracker({\n    storeIntermediate: trace,\n  });\n\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const svg = document.createElementNS(\n    `http://www.w3.org/2000/svg`,\n    `svg`\n  ) as any as SVGElement & HTMLElement;\n  //eslint-disable-next-line functional/immutable-data\n  svg.id = `pointerVis`;\n  svg.style.zIndex = `-1000`;\n  svg.style.position = `fixed`;\n  svg.style.top = `0`;\n  svg.style.left = `0`;\n  svg.style.width = `100%`;\n  svg.style.height = `100%`;\n  svg.style.boxSizing = `border-box`;\n  svg.style.border = `3px solid red`;\n  svg.style.pointerEvents = `none`;\n  svg.style.touchAction = `none`;\n\n  fullSizeElement(svg);\n  let pointerCount = 0;\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const lostPointer = (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n    tracker.delete(id);\n    currentHue = hue;\n    svg.querySelector(`#pv-start-${ id }`)?.remove();\n\n    for (let index = 0; index < pointerCount + 10; index++) {\n      svg.querySelector(`#pv-progress-${ id }-${ index }`)?.remove();\n    }\n    pointerCount = 0;\n  };\n\n  const trackPointer = async (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n    const pt = { x: event.x, y: event.y };\n    const type = event.pointerType;\n    if (event.type === `pointermove` && !tracker.has(id)) {\n      return;\n    }\n    const info = (await tracker.seen(event.pointerId.toString(), { x: event.clientX, y: event.clientY }));\n\n    if (info.values.length === 1) {\n      const el = Svg.Elements.circle(\n        {\n          ...info.values[ 0 ],\n          radius: type === `touch` ? touchRadius : mouseRadius,\n        },\n        svg,\n        {\n          fillStyle: startFillStyle,\n        },\n        `#pv-start-${ id }`\n      );\n      el.style.pointerEvents = `none`;\n      el.style.touchAction = `none`;\n    }\n\n    const fillStyle = `hsla(${ currentHue }, 100%, 50%, 50%)`;\n\n    const el2 = Svg.Elements.circle(\n      { ...pt, radius: type === `touch` ? touchRadius : mouseRadius },\n      svg,\n      {\n        fillStyle,\n      },\n      `#pv-progress-${ id }-${ info.values.length }`\n    );\n    el2.style.pointerEvents = `none`;\n    el2.style.touchAction = `none`;\n    currentHue += 1;\n    pointerCount = info.values.length;\n  };\n\n  document.body.append(svg);\n\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  el.addEventListener(`pointerdown`, trackPointer);\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  el.addEventListener(`pointermove`, trackPointer);\n  el.addEventListener(`pointerup`, lostPointer);\n  el.addEventListener(`pointerleave`, lostPointer);\n  el.addEventListener(`contextmenu`, (event) => {\n    event.preventDefault();\n  });\n};\n","import { trackUniqueInstances } from \"../data/TrackUnique.js\";\nexport type ElementQueryOptions = {\n  /**\n   * If true, elements are only returned once, even if that match several queries\n   */\n  ensureUnique: boolean\n}\n\n/**\n * Async iterator over DOM query strings\n * ```js\n * query(`div`); // all DIVs\n * query([`.class`, `.and-other-class`]); // All things with these two classes\n * ```\n * @param queryOrElement \n * @returns \n */\nexport async function* query(queryOrElement: string | HTMLElement | Array<string | HTMLElement> | AsyncGenerator<string | HTMLElement>, options: Partial<ElementQueryOptions> = {}): AsyncGenerator<HTMLElement> {\n\n  if (typeof queryOrElement === `string`) {\n    return query([ queryOrElement ], options);\n  } else if (typeof queryOrElement === `object` && `nodeName` in queryOrElement) {\n    return query([ queryOrElement ], options);\n  }\n\n  const ensureUnique = options ?? false;\n  const isUnique = ensureUnique ? trackUniqueInstances<HTMLElement>() : (_: HTMLElement) => true;\n\n  if (Array.isArray(queryOrElement)) {\n    for (const item of queryOrElement) {\n      if (typeof item === `string`) {\n        for (const element of document.querySelectorAll(item)) {\n          const elementProper = element as HTMLElement;\n          if (isUnique(elementProper)) {\n            yield elementProper;\n          }\n        }\n      } else {\n        if (isUnique(item)) {\n          yield item;\n        }\n      }\n    }\n  } else {\n    for await (const item of queryOrElement) {\n      if (typeof item === `string`) {\n        for (const element of document.querySelectorAll(item)) {\n          if (isUnique(element as HTMLElement)) {\n            yield element as HTMLElement;\n          }\n        }\n      } else {\n        if (isUnique(item)) {\n          yield item;\n        }\n      }\n    }\n  }\n}","import * as Points from '../geometry/point/index.js';\nimport JSON5 from 'json5';\nimport type { CardinalDirection } from '../geometry/Grid.js';\nimport { cardinal } from '../geometry/rect/index.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport { resolveEl } from './ResolveEl.js';\nimport { getPointParameter } from '../geometry/point/GetPointParameter.js';\n\nexport type PointSpaces = `viewport` | `screen` | `document`;\n\n/**\n * Convert an absolute point to relative, in different coordinate spaces.\n *\n * When calling the returned function, the input value must be in the same\n * scale as the intended output scale.\n *\n * Viewport-relative is used by default.\n *\n * @example Get relative position of click in screen coordinates\n * ```js\n * const f = pointScaler({ to: 'screen' });\n * document.addEventListener('click', evt => {\n *  const screenRelative = f(evt.screenX, evt.screenY);\n *  // Yields {x,y} on 0..1 scale\n * });\n * ```\n *\n * @example Get relative position of click in viewport coordinates\n * ```js\n * const f = pointScaler({ to: 'viewport' });\n * document.addEventListener('click', evt => {\n *  const viewportRelative = f(evt.clientX, evt.clientY);\n *  // Yields {x,y} on 0..1 scale\n * });\n * ```\n *\n * @example Get relative position of click in document coordinates\n * ```js\n * const f = pointScaler({ to: 'document' });\n * document.addEventListener('click', evt => {\n *  const documentRelative = f(evt.pageX, evt.pageY);\n *  // Yields {x,y} on 0..1 scale\n * });\n * ```\n *\n * @param opts\n * @returns\n */\nexport const pointScaler = (reference: PointSpaces = `viewport`) => {\n  switch (reference) {\n    case `viewport`: {\n      return (a: Readonly<Point | number | Array<number>>, b?: number) => {\n        const pt = getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x / window.innerWidth,\n          y: pt.y / window.innerHeight,\n        });\n      };\n    }\n    case `screen`: {\n      return (a: Readonly<Point | number | Array<number>>, b?: number) => {\n        const pt = getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x / screen.width,\n          y: pt.y / screen.height,\n        });\n      };\n    }\n    case `document`: {\n      return (a: Readonly<Point | number | Array<number>>, b?: number) => {\n        const pt = getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x / document.body.scrollWidth,\n          y: pt.y / document.body.scrollHeight,\n        });\n      };\n    }\n    default: {\n      throw new Error(\n        `Unknown 'reference' parameter: ${ JSON.stringify(reference) }`\n      );\n    }\n  }\n};\n\nexport type ElPositionOpts = {\n  readonly target?: PointSpaces;\n  readonly relative?: boolean;\n  readonly anchor?: CardinalDirection | `center`;\n};\n\n/**\n * Returns a function which yields element position in target coordinate space with optional scaling.\n * Live position is calculated when the function is invoked.\n * Use {@link positionRelative} to simply get relative position of element in given coordinate space.\n *\n * @example Absolute position of #blah in viewport coordinate space\n * ```js\n * const f = positionFn('#blah');\n * f(); // Yields: {x,y}\n * // Or:\n * positionFn('#blah')(); // Immediately invoke\n * ```\n *\n * @example Relative position of element in viewport-space\n * ```js\n * const f = positionFn(evt.target, { relative: true });\n * f(); // Yields: {x,y}\n * ```\n *\n * @example Relative position of #blah in screen-space\n * ```js\n * const f = positionFn('#blah', { target: 'screen', relative: true });\n * f(); // Yields: {x,y}\n * ```\n *\n * By default, top-left corner (north west) is used. Other cardinal points or 'center' can be specified:\n * ```js\n * // Relative position by center\n * positionFn('#blah', { relative: true, anchor: 'center' });\n *\n * // ...by bottom-right corner\n * positionFn('#blah', { relative: true, anchor: 'se' });\n * ```\n *\n * This function is useful if you have a stable DOM element and conversion target.\n * If the DOM element is changing continually, consider using {@link viewportToSpace} to\n * convert from viewport coordinates to target coordinates:\n *\n * ```js\n * // Eg.1 Absolute coords in screen space\n * const vpToScreen = viewportToSpace('screen');\n * vpToScreen(el.getBoundingClientRect());\n *\n * // Eg.2 Relative coords in viewport space\n * const vpRelative = pointScaler(); // Re-usable scaler. Default uses viewport\n * vpRelative(el.getBoundingClientRect()); // Yields: { x,y }\n *\n * // Eg.3 Relative coords in screen space\n * const vpToScreen = viewportToSpace('screen'); // Map viewport->screen\n * const screenRelative = pointScaler('screen'); // Scale screen units\n *\n * // Combine into a resuable function that takes an element\n * const mapAndScale = (el) => screenRelative(vpToScreen(el.getBoundingClientRect()));\n *\n * // Call\n * mapAndScale(document.getElementById('blah')); // Yields: { x,y }\n * ```\n * @param domQueryOrEl\n * @param coordinateSpace\n * @param scaled\n * @returns\n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport const positionFn = (\n  domQueryOrEl: Readonly<string | HTMLElement>,\n  opts: ElPositionOpts = {}\n): (() => Point) => {\n  const targetSpace = opts.target ?? `viewport`;\n  const relative = opts.relative ?? false;\n  const anchor = opts.anchor ?? `nw`;\n\n  const el = resolveEl(domQueryOrEl);\n  const vpToSpace = viewportToSpace(targetSpace);\n\n  if (relative) {\n    const s = pointScaler(targetSpace);\n    return () => s(vpToSpace(cardinal(el.getBoundingClientRect(), anchor)));\n  } else {\n    return () => vpToSpace(cardinal(el.getBoundingClientRect(), anchor));\n  }\n};\n\n/**\n * Returns a {x,y} Point on a cardinal position of element.\n * ```\n * // Top edge, middle horizontal position\n * const pos = cardinalPosition(`#blah`, `n`);\n * ```\n * @param domQueryOrEl \n * @param anchor \n * @returns \n */\nexport const cardinalPosition = (\n  domQueryOrEl: Readonly<string | HTMLElement>,\n  anchor: CardinalDirection | `center` = `nw`\n): Point => {\n  const el = resolveEl(domQueryOrEl);\n  return cardinal(el.getBoundingClientRect(), anchor);\n};\n/**\n * Returns relative position of element in target coordinate space, or viewport by default.\n * Relative means that { x:0.5, y: 0.5 } is the middle of the target space. Eg for viewport, that means its the middle of the browser window.\n * ```js\n * // These all yield { x, y }\n * elPositionRelative('#blah');\n * elPositionRelative(evt.target, 'screen');\n * ```\n * @param domQueryOrEl DOM query or element\n * @param target Target coordinate space, or viewport by default\n * @returns Point\n */\nexport const positionRelative = (\n  domQueryOrEl: Readonly<string | HTMLElement>,\n  target: PointSpaces = `viewport`\n): Point => {\n  const f = positionFn(domQueryOrEl, { relative: true, target });\n  return f();\n};\n\n/**\n * Returns a function that converts input viewport coordinate space\n * to an output coordinate space.\n *\n * ```js\n * // f() will convert from viewport to document coordinate space\n * const f = viewportToSpace('document');\n *\n * // {x:100,y:100} is viewport coordinate space\n * f(100,100); // Yields: { x, y } converted to document space\n * ```\n *\n * Or immediately invoke for one-off use:\n * ```js\n * viewportToSpace('document')(100,100); // Yields: { x, y }\n * ```\n * @param targetSpace\n * @returns\n */\nexport const viewportToSpace = (targetSpace: PointSpaces = `viewport`) => {\n  switch (targetSpace) {\n    case `screen`: {\n      return (a: Readonly<Point | Array<number> | number>, b?: number) => {\n        const pt = getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x + window.screenX,\n          y: pt.y + window.screenY,\n        });\n      };\n    }\n    case `document`: {\n      return (a: Readonly<Point | Array<number> | number>, b?: number) => {\n        const pt = getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x + window.scrollX,\n          y: pt.y + window.scrollY,\n        });\n      };\n    }\n    case `viewport`: {\n      return (a: Readonly<Point | Array<number> | number>, b?: number) => {\n        const pt = getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x,\n          y: pt.y,\n        });\n      };\n    }\n    default: {\n      throw new Error(\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Unexpected target coordinate space: ${ targetSpace }. Expected: viewport, document or screen`\n      );\n    }\n  }\n};\n\n/**\n * Position element by relative coordinate. Relative to window dimensions by default\n * @param element DOM element to position, or query\n * @param relativePos Window-relative coordinate. 0.5/0.5 is middle of window.\n */\nexport const positionFromMiddle = (\n  domQueryOrEl: string | HTMLElement,\n  relativePos: Point,\n  relativeTo: `window` | `screen` = `window`\n) => {\n  if (!domQueryOrEl) throw new Error(`domQueryOrEl is null or undefined`);\n  const el = resolveEl<HTMLElement>(domQueryOrEl);\n\n  // Convert relative to absolute units\n  const absPosition = Points.multiply(\n    relativePos,\n    window.innerWidth,\n    window.innerHeight\n  );\n\n  const thingRect = el.getBoundingClientRect();\n  const offsetPos = Points.subtract(\n    absPosition,\n    thingRect.width / 2,\n    thingRect.height / 2\n  );\n\n  // Apply via CSS\n  el.style.transform = `translate(${ offsetPos.x }px, ${ offsetPos.y }px)`;\n};\n\n\n\n\n\n\n\n/**\n * Given an array of class class names, this will cycle between them each time\n * it is called.\n *\n * Eg, assume `list` is: [ `a`, `b`, `c` ]\n *\n * If `el` already has the class `a`, the first time it is called, class `a`\n * is removed, and `b` added. The next time `b` is swapped for `c`. Once again,\n * `c` will swap with `a` and so on.\n *\n * If `el` is undefined or null, function silently returns.\n * @param el Element\n * @param list List of class names\n * @returns\n */\nexport const cycleCssClass = (\n  el: Readonly<HTMLElement>,\n  list: ReadonlyArray<string>\n) => {\n  if (el === null || !el) return;\n  if (!Array.isArray(list)) {\n    throw new TypeError(`List should be an array of strings`);\n  }\n\n  for (let index = 0; index < list.length; index++) {\n    if (el.classList.contains(list[ index ])) {\n      el.classList.remove(list[ index ]);\n      if (index + 1 < list.length) {\n        el.classList.add(list[ index + 1 ]);\n      } else {\n        el.classList.add(list[ 0 ]);\n      }\n      return;\n    }\n  }\n  el.classList.add(list[ 0 ]);\n};\n\n\n\n/**\n * Source: https://zellwk.com/blog/translate-in-javascript\n * @param domQueryOrEl\n */\nexport const getTranslation = (\n  domQueryOrEl: Readonly<string | HTMLElement>\n): Point => {\n  // Source:\n  // https://raw.githubusercontent.com/zellwk/javascript/master/src/browser/dom/translate-values.js\n\n  const el = resolveEl<HTMLElement>(domQueryOrEl);\n  const style = window.getComputedStyle(el);\n  const matrix = style.transform;\n\n  // No transform property. Simply return 0 values.\n  if (matrix === `none` || typeof matrix === `undefined`) {\n    return {\n      x: 0,\n      y: 0,\n      z: 0,\n    };\n  }\n\n  // Can either be 2d or 3d transform\n  const matrixType = matrix.includes(`3d`) ? `3d` : `2d`;\n  // @ts-expect-error\n  const matrixValues = matrix.match(/matrix.*\\((.+)\\)/)[ 1 ].split(`, `);\n\n  // 2d Matrixes have 6 values\n  // Last 2 values are X and Y.\n  // 2d Matrixes does not have Z value.\n  if (matrixType === `2d`) {\n    return {\n      x: Number.parseFloat(matrixValues[ 4 ]),\n      y: Number.parseFloat(matrixValues[ 5 ]),\n      z: 0,\n    };\n  }\n\n  // 3d Matrixes have 16 values\n  // The 13th, 14th, and 15th values are X, Y, and Z\n  if (matrixType === `3d`) {\n    return {\n      x: Number.parseFloat(matrixValues[ 12 ]),\n      y: Number.parseFloat(matrixValues[ 13 ]),\n      z: Number.parseFloat(matrixValues[ 14 ]),\n    };\n  }\n\n  return { x: 0, y: 0, z: 0 };\n};\n\n\n/**\n * Creates an element after `sibling`\n * ```\n * const el = createAfter(siblingEl, `DIV`);\n * ```\n * @param sibling Element\n * @param tagName Element to create\n * @returns New element\n */\nexport const createAfter = (\n  sibling: Readonly<HTMLElement>,\n  tagName: string\n): HTMLElement => {\n  const el = document.createElement(tagName);\n  sibling.parentElement?.insertBefore(el, sibling.nextSibling);\n  return el;\n};\n\n/**\n * Creates an element inside of `parent`\n * ```\n * const newEl = createIn(parentEl, `DIV`);\n * ```\n * @param parent Parent element\n * @param tagName Tag to create\n * @returns New element\n */\nexport const createIn = (\n  parent: Readonly<HTMLElement>,\n  tagName: string\n): HTMLElement => {\n  const el = document.createElement(tagName);\n  parent.append(el);\n  return el;\n};\n\n/**\n * Remove all child nodes from `parent`\n * @param parent\n */\nexport const clear = (parent: Readonly<HTMLElement>) => {\n  let c = parent.lastElementChild;\n\n  while (c) {\n    c.remove();\n    c = parent.lastElementChild;\n  }\n};\n\n\n/**\n * Copies string representation of object to clipboard\n * @param obj\n * @returns Promise\n */\nexport const copyToClipboard = (object: object) => {\n  const p = new Promise((resolve, reject) => {\n    //const json = JSON.stringify(obj, null, 2);\n    const string_ = JSON5.stringify(object);\n    navigator.clipboard.writeText(JSON.stringify(string_)).then(\n      () => {\n        resolve(true);\n      },\n      (error) => {\n        console.warn(`Could not copy to clipboard`);\n        console.log(string_);\n        reject(new Error(error));\n      }\n    );\n  });\n  return p;\n};\n\n/**\n * Inserts `element` into `parent` sorted according to its HTML attribute `data-sort`.\n * \n * Assumes:\n * * Every child of `parent` and `element`, has a `data-sort` attribute. This is the basis for sorting.\n * * `parent` starts off empty or pre-sorted.\n * * Order of `parent`'s children is not changed (ie it always remains sorted)\n * @param parent \n * @param element \n */\nexport const insertSorted = (parent: HTMLElement, element: HTMLElement) => {\n  const elSort = element.getAttribute(`data-sort`) ?? ``;\n  let elAfter;\n  let elBefore;\n  for (const c of parent.children) {\n    const sort = c.getAttribute(`data-sort`) ?? ``;\n    if (elSort >= sort) elAfter = c;\n    if (elSort <= sort) elBefore = c;\n    if (elAfter !== undefined && elBefore !== undefined) break;\n  }\n  if (elAfter !== undefined) {\n    elAfter.insertAdjacentElement(`afterend`, element);\n  } else if (elBefore === undefined) {\n    parent.append(element);\n  } else {\n    elBefore.insertAdjacentElement(`beforebegin`, element);\n  }\n}\n\nexport type CreateUpdateElement<V> = (\n  item: V,\n  //eslint-disable-next-line functional/prefer-readonly-type\n  el: HTMLElement | null\n) => HTMLElement;\n\nexport const reconcileChildren = <V>(\n  parentEl: HTMLElement,\n  //eslint-disable-next-line functional/prefer-readonly-type\n  list: Map<string, V>,\n  createUpdate: CreateUpdateElement<V>\n) => {\n  if (parentEl === null) throw new Error(`parentEl is null`);\n  if (parentEl === undefined) throw new Error(`parentEl is undefined`);\n\n  const seen = new Set<string>();\n\n  for (const [ key, value ] of list) {\n    const id = `c-${ key }`;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const el = parentEl.querySelector(`#${ id }`);\n    const finalEl = createUpdate(value, el as HTMLElement);\n    if (el !== finalEl) {\n      finalEl.id = id;\n      parentEl.append(finalEl);\n    }\n    seen.add(id);\n  }\n\n  const prune: Array<HTMLElement> = [];\n  for (const child of parentEl.children) {\n    if (!seen.has(child.id)) {\n      prune.push(child as HTMLElement);\n    }\n  }\n\n  // for (let index = 0; index < parentEl.children.length; index++) {\n  //   const c = parentEl.children[ index ] as HTMLElement;\n  //   if (!seen.has(c.id)) {\n  //     prune.push(c);\n  //   }\n  // }\n\n  for (const p of prune) p.remove();\n};\n\n\n\n/**\n * Gets a HTML element by id, throwing an error if not found\n * @param id \n * @returns \n */\nexport const byId = <V extends HTMLElement>(id: string): HTMLElement => {\n  // eslint-disable-next-line unicorn/prefer-query-selector\n  const element = document.getElementById(id);\n  if (element === null) throw new Error(`HTML element with id '${ id }' not found`);\n  return element as V;\n}\n\n","import * as Colour from '../../visual/Colour.js';\nimport type { ReactiveInitial, ReactiveWritable, Reactive } from \"../Types.js\";\nimport { eventTrigger } from \"./Event.js\";\nimport type { DomNumberInputValueOptions, DomValueOptions } from \"./Types.js\";\nimport { resolveEl } from '../../dom/ResolveEl.js';\nimport { transform } from '../ops/Transform.js';\nimport { hasLast } from '../Util.js';\nimport { Visual } from 'src/index.js';\n\n/**\n * Reactive getting/setting of values to a HTML INPUT element.\n * \n * Sets the 'type' attribute of element to 'range'.\n * \n * Options:\n * - relative: if _true_, sets min/max values of attribute. Default: _false_\n * - inverted:  if _true_ flips min/max. Default: _false_\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domNumberInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomNumberInputValueOptions> = {}): ReactiveInitial<number> & ReactiveWritable<number> {\n  const input = domInputValue(targetOrQuery, options);\n  const el = input.el;\n  const relative = options.relative ?? false;\n  const inverted = options.inverted ?? false;\n\n  const rx = transform(input, v => {\n    return Number.parseFloat(v);\n  });\n\n  if (relative) {\n    //el.setAttribute(`max`, inverted ? \"0\" : \"1\");\n    el.max = inverted ? \"0\" : \"1\";\n    //el.setAttribute(`min`, inverted ? \"1\" : \"0\");\n    el.min = inverted ? \"1\" : \"0\";\n    if (!el.hasAttribute(`step`)) {\n      //el.setAttribute(`step`, \"0.1\");\n      el.step = \"0.1\";\n    }\n  }\n  //el.setAttribute(`type`, `range`);\n  el.type = `range`;\n\n  const set = (value: number) => {\n    input.set(value.toString());\n  }\n\n  return {\n    ...rx,\n    last() {\n      return Number.parseFloat(input.last())\n    },\n    set\n  };\n}\n\nexport function domHslInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): ReactiveInitial<Colour.Hsl> & Reactive<Colour.Hsl> & ReactiveWritable<Colour.Hsl> {\n\n  const input = domInputValue(targetOrQuery, {\n    ...options,\n    upstreamFilter(value) {\n      return (typeof value === `object`) ? Visual.Colour.toHex(value) : value;\n    },\n  });\n  const rx = transform(input, v => {\n    return Colour.toHsl(v);\n  });\n  return {\n    ...rx,\n    last() {\n      return Colour.toHsl(input.last())\n    },\n    set(value) {\n      input.set(Colour.toHex(value));\n    },\n  };\n}\n\n/**\n * A stream of values when the a HTMLInputElement changes. Eg a <input type=\"range\">\n * ```js\n * const r = Rx.From.domInputValue(`#myEl`);\n * r.onValue(value => {\n *  // value will be string\n * });\n * ```\n * \n * Options:\n * * emitInitialValue: If _true_ emits the HTML value of element (default: false)\n * * attributeName: If set, this is the HTML attribute value is set to when writing to stream (default: 'value')\n * * fieldName: If set, this is the DOM object field set when writing to stream (default: 'value')\n * * when: 'changed'|'changing' when values are emitted. (default: 'changed')\n * * fallbackValue:  Fallback value to use if field/attribute cannot be read (default: '')\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): { el: HTMLInputElement } & ReactiveInitial<string> & ReactiveWritable<string> {\n  const target: HTMLInputElement | null = (typeof targetOrQuery === `string` ? document.querySelector(targetOrQuery) : targetOrQuery);\n  if (target === null && typeof targetOrQuery === `string`) throw new Error(`Element query could not be resolved '${ targetOrQuery }'`);\n  if (target === null) throw new Error(`targetOrQuery is null`)\n\n  const el = resolveEl(targetOrQuery);\n  const when = options.when ?? `changed`;\n  const eventName = when === `changed` ? `change` : `input`;\n  const emitInitialValue = options.emitInitialValue ?? false;\n  const fallbackValue = options.fallbackValue ?? ``;\n  const upstreamSource = options.upstreamSource;\n  let upstreamSourceUnsub = () => {}\n\n  let attribName = options.attributeName;\n  let fieldName = options.fieldName;\n\n  if (fieldName === undefined && attribName === undefined) {\n    attribName = fieldName = `value`;\n  }\n\n  const readValue = () => {\n    let value: string | null | undefined;\n    if (attribName) {\n      value = el.getAttribute(attribName);\n    }\n    if (fieldName) {\n      value = (el as any)[ fieldName ]\n    }\n    if (value === undefined || value === null) value = fallbackValue;\n    //console.log(`domInputValue readValue: ${ value }`);\n    return value;\n  }\n\n  const setValue = (value: string) => {\n    if (attribName) {\n      el.setAttribute(attribName, value);\n    }\n    if (fieldName) {\n      (el as any)[ fieldName ] = value;\n    }\n  }\n\n  const setUpstream = (v: any) => {\n    v = options.upstreamFilter ? options.upstreamFilter(v) : v;\n    setValue(v);\n  }\n  if (upstreamSource) {\n    upstreamSourceUnsub = upstreamSource.onValue(setUpstream);\n    if (hasLast(upstreamSource)) {\n      setUpstream(upstreamSource.last());\n    }\n  }\n\n  // Input element change event stream\n  const rxEvents = eventTrigger(el, eventName, {\n    fireInitial: emitInitialValue,\n    debugFiring: options.debugFiring ?? false,\n    debugLifecycle: options.debugLifecycle ?? false,\n  });\n\n  // Transform to get values\n  const rxValues = transform(rxEvents, _trigger => readValue());\n\n  return {\n    ...rxValues,\n    el,\n    last() {\n      return readValue()\n    },\n    set(value) {\n      setValue(value);\n    },\n    dispose(reason) {\n      upstreamSourceUnsub();\n      rxValues.dispose(reason);\n      rxEvents.dispose(reason);\n    },\n  }\n}","import { getErrorMessage } from \"../../debug/GetErrorMessage.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { Reactive, Unsubscriber } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal, messageIsSignal } from \"../Util.js\";\nimport type { PingedFunctionOptions, PingedFunctionFunction } from \"./Types.js\";\n\n\n/**\n * Creates a reactive with `callback` as a value source. This gets called whenever `source` emits a value.\n *\n * @param callback \n * @param source \n * @param options \n * @returns \n */\nexport function pinged<T, TSource>(source: Reactive<TSource>, callback: PingedFunctionFunction<T, TSource>, options: Partial<PingedFunctionOptions> = {}) {\n  const closeOnError = options.closeOnError ?? true;\n  const lazy = options.lazy ?? `initial`;\n\n  const internalAbort = new AbortController();\n  const internalAbortCallback = (reason: string) => { internalAbort.abort(reason) };\n\n  let upstreamOff: Unsubscriber | undefined;\n\n  if (options.signal) {\n    options.signal.addEventListener(`abort`, (_) => {\n      done(`Signal received (${ options.signal?.reason })`);\n    })\n  }\n\n  const events = initStream<T>({\n    onFirstSubscribe() {\n      if (lazy !== `never` && upstreamOff === undefined) start();\n    },\n    onNoSubscribers() {\n      // Unsubscribe from source if we're very lazy\n      // Stay subscribed if we're only initially lazy or not lazy at all\n      if (lazy === `very` && upstreamOff !== undefined) {\n        upstreamOff();\n        upstreamOff = undefined;\n      }\n    },\n  })\n\n  const start = () => {\n    upstreamOff = source.on(message => {\n      if (messageIsDoneSignal(message)) {\n        done(`Upstream closed`);\n      } else if (messageIsSignal(message)) {\n        events.signal(message.signal);\n      } else if (messageHasValue(message)) {\n        void trigger(message.value);\n      }\n    });\n  }\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n    if (upstreamOff) upstreamOff();\n  }\n\n  const trigger = async (value: TSource) => {\n    try {\n      const v = await callback(value, internalAbortCallback);\n      events.set(v);\n      // Feedback from callback\n      if (internalAbort.signal.aborted) {\n        done(`callback function aborted (${ internalAbort.signal.reason })`);\n        return false\n      }\n    } catch (error) {\n      if (closeOnError) {\n        done(`Function error: ${ getErrorMessage(error) }`);\n        return false;\n      } else {\n        events.signal(`warn`, getErrorMessage(error));\n      }\n    }\n  }\n\n  if (lazy === `never`) start();\n  return events;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function number(initialValue: number): ReactiveWritable<number> & ReactiveInitial<number>;\nexport function number(): ReactiveWritable<number> & ReactiveNonInitial<number>;\nexport function number(initialValue?: number): ReactiveWritable<number> & (ReactiveNonInitial<number> | ReactiveInitial<number>) {\n  let value = initialValue;\n  const events = initStream<number>();\n\n  const set = (v: number) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}\n","import { object } from \"./Object.js\";\nimport { symbol, type ReactiveDiff, type ReactiveInitial } from \"../Types.js\";\n\nexport type ReactiveProxied<V> = V & {\n  [ symbol ]: ReactiveDiff<V> & ReactiveInitial<V>\n}\n/**\n * Creates a proxy of `target`, so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n * \n * ```js\n * const { proxy, rx } = Rx.From.objectProxy({ colour: `red`, x: 10, y: 20 });\n * \n * rx.onValue(v => {\n *  // Get notified when proxy is changed\n * });\n * \n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n * \n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n * \n * The benefit of `objectProxy` instead of {@link Rx.From.object} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n * \n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = Rx.From.objectProxy({ colour: `red` });\n * ```\n * \n * See also:\n * * {@link objectProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * @param target \n * @returns \n */\nexport const objectProxy = <V extends object>(target: V): { proxy: V, rx: ReactiveDiff<V> & ReactiveInitial<V> } => {\n  const rx = object(target);\n\n  const proxy = new Proxy(target, {\n    set(target, p, newValue, _receiver) {\n\n      const isArray = Array.isArray(target);\n      //console.log(`Rx.fromProxy set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n\n      // Ignore length if target is array\n      if (isArray && p === `length`) return true;\n\n      if (typeof p === `string`) {\n        rx.updateField(p, newValue);\n      }\n\n      // If target is array and field looks like an array index...\n      if (isArray && typeof p === `string`) {\n        const pAsNumber = Number.parseInt(p);\n        if (!Number.isNaN(pAsNumber)) {\n          target[ pAsNumber ] = newValue;\n          return true;\n        }\n      }\n      (target as any)[ p ] = newValue;\n      return true;\n    }\n  });\n  return { proxy, rx }\n}\n\n/**\n * Same as {@link proxy}, but the return value is the proxied object along with \n * the Reactive wrapped as symbol property.\n * \n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n * \n * This means of access can be useful as the return result\n * is a bit neater, being a single object instead of two. \n * @param target \n * @returns \n */\nexport const objectProxySymbol = <V extends object>(target: V): ReactiveProxied<V> => {\n  const { proxy, rx } = objectProxy(target);\n\n  const p = proxy as ReactiveProxied<V>;\n  p[ symbol ] = rx;\n  return p;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveWritable } from \"../Types.js\";\nimport { messageHasValue } from \"../Util.js\";\nimport { manual } from \"../index.js\";\n\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n * \n *  // To send a value:\n *  stream.set(someValue);\n * \n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n * \n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n * \n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init \n * @returns \n */\nexport function observable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): Reactive<V> {\n  const ow = observableWritable(init);\n  return {\n    dispose: ow.dispose,\n    isDisposed: ow.isDisposed,\n    on: ow.on,\n    onValue: ow.onValue\n  }\n}\n\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init \n * @returns \n */\nexport function observableWritable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): ReactiveWritable<V> & Reactive<V> {\n  let onCleanup: (() => void) | undefined = () => {/** no-op */ };\n  const ow = manual<V>({\n    onFirstSubscribe() {\n      onCleanup = init(ow);\n    },\n    onNoSubscribers() {\n      if (onCleanup) onCleanup();\n    },\n  });\n\n  return {\n    ...ow,\n    onValue: (callback: (value: V) => void) => {\n      return ow.on(message => {\n        if (messageHasValue(message)) {\n          callback(message.value);\n        }\n      });\n    }\n  };\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function string(initialValue: string): ReactiveWritable<string> & ReactiveInitial<string>;\nexport function string(): ReactiveWritable<string> & ReactiveNonInitial<string>;\nexport function string(initialValue?: string): ReactiveWritable<string> & (ReactiveNonInitial<string> | ReactiveInitial<string>) {\n  let value = initialValue;\n  const events = initStream<string>();\n\n  const set = (v: string) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}"],"mappings":"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","names":["module","document","object","key","length","c","source","exports","pos","codePointAt","max","min","fromCodePoint","line","parse","token","string","buffer","count","stringify","stack","value","i","list","JSON5","average","max","min","rank","sum","tally","wrap","run","log","iterator","stream","stream","field","event","compareData","field","compareData","split","object","compareData","field","value","event","field","elapsed","elapsed","max","min","average","sum","tally","rank","annotate","event","stream","event","init","elapsed","elements","el","stream","distance","object","graph","vertices","line","distance","to","stringForEdge","immutable","isReactive","process","object","wrap","min","max","average","sum","tally","source","query","elements","el","bind","field","init","create","changes","array","filter","count","insertAt","remove","add","count","elapsed","stream","clamp","immutable","scale","scaleClamped","immutable","clamp","scale","scaleClamped","count","minMaxAvg","object","average","count","distance","smoothingFactor","array","min","max","array","compareData","event","Empty","r","object","field","value","adjacentVertices","connect","connectTo","createVertex","dumpGraph","getOrCreate","graph","toAdjacencyMatrix","updateGraphVertex","createVertex","updateGraphVertex","graph","getOrCreate","resolveVertex","connectTo","connect","immutable","toAdjacencyMatrix","dumpGraph","debugGraphToArray","adjacentVertices","draw","arc","ellipse","corners","rect","line","clamp","byId","clamp","event","getContext","elapsed","stream","timeout","el","plot","subtract","v","event","paths","create","create","el","to","el","ctx","width","height","clamp","opacity","piPi","min","max","plot","event","canvasSize","scaler","guard","multiply","elements","query","el","JSON5","remove","data","event","elements","el","event","el","line","log","timestamp","clear","event","el","event","el2","import_json5","el","object","JSON5","el","target","init","min","max","sum","average","tally","rank","transform"]}