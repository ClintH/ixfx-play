{"version":3,"sources":["../src/collections/arrays/Equality.ts","../src/collections/arrays/Zip.ts","../src/numbers/AverageWeighted.ts"],"sourcesContent":["import { isEqualDefault, isEqualValueDefault, type IsEqual } from \"../../util/IsEqual.js\";\nimport { guardArray } from \"./GuardArray.js\";\n\n\n/**\n * Returns _true_ if the two arrays have the same items at same indexes. Use {@link isEqualValues} to\n * compare values regardless of position.\n * \n * Returns _false_ if arrays are of different length.\n * By default uses === semantics for equality checking.\n * \n * ```js\n * isEqual([ 1, 2, 3], [ 1, 2, 3 ]); // true\n * isEqual([ 1, 2, 3], [ 3, 2, 1 ]); // false\n * ```\n * \n * Compare by value\n * ```js\n * isEqual(a, b, isEqualValueDefault);\n * ```\n * \n * Custom compare, eg based on `name` field:\n * ```js\n * isEqual(a, b, (compareA, compareB) => compareA.name === compareB.name);\n * ```\n * @param arrayA \n * @param arrayB \n * @param eq \n */\nexport const isEqual = <V>(arrayA: Array<V>, arrayB: Array<V>, eq = isEqualDefault<V>): boolean => {\n  guardArray(arrayA, `arrayA`);\n  guardArray(arrayB, `arrayB`);\n\n  if (arrayA.length !== arrayB.length) return false;\n  // eslint-disable-next-line unicorn/no-for-loop\n  for (let indexA = 0; indexA < arrayA.length; indexA++) {\n    if (!(eq(arrayA[ indexA ], arrayB[ indexA ]))) return false;\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if all values in the array are the same\n * \n * Uses value-based equality checking by default.\n * \n * @example Uses default equality function:\n * ```js\n * import { isContentsTheSame } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const a1 = [ 10, 10, 10 ];\n * isContentsTheSame(a1); // True\n *\n * const a2 = [ { name:`Jane` }, { name:`John` } ];\n * isContentsTheSame(a2); // True, even though object references are different\n * ```\n *\n * If we want to compare by value for objects that aren't readily\n * converted to JSON, you need to provide a function:\n *\n * ```js\n * isContentsTheSame(someArray, (a, b) => {\n *  return (a.eventType === b.eventType);\n * });\n * ```\n *\n * Returns _true_ if `array` is empty.\n * @param array Array\n * @param equality Equality checker. Uses string-conversion checking by default\n * @returns\n */\nexport const isContentsTheSame = <V>(\n  array: ReadonlyArray<V> | Array<V>,\n  equality?: IsEqual<V>\n): boolean => {\n  // Unit tested\n\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array.`);\n  if (array.length === 0) return true;\n  const eq = equality ?? isEqualValueDefault;\n  const a = array[ 0 ];\n  const r = array.some((v) => !eq(a, v));\n  if (r) return false;\n  return true;\n};","\n/**\n * Zip combines the elements of two or more arrays based on their index.\n *\n * ```js\n * import { zip } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const a = [1,2,3];\n * const b = [`red`, `blue`, `green`];\n *\n * const c = zip(a, b);\n * // Yields:\n * // [\n * //   [1, `red`],\n * //   [2, `blue`],\n * //   [3, `green`]\n * // ]\n * ```\n *\n * Typically the arrays you zip together are all about the same logical item. Eg, in the above example\n * perhaps `a` is size and `b` is colour. So thing #1 (at array index 0) is a red thing of size 1. Before\n * zipping we'd access it by `a[0]` and `b[0]`. After zipping, we'd have c[0], which is array of [1, `red`].\n * @param arrays\n * @returns Zipped together array\n */\n\nimport { isContentsTheSame } from \"./Equality.js\";\n\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const zip = (\n  ...arrays: Array<Array<any>> | ReadonlyArray<Array<any>> | ReadonlyArray<ReadonlyArray<any>>\n): Array<any> => {\n  // Unit tested\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => a.length);\n  if (!isContentsTheSame(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue = [];\n  const length = lengths[ 0 ];\n\n  for (let index = 0; index < length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    returnValue.push(arrays.map((a) => a[ index ]));\n  }\n  return returnValue;\n};","import { zip } from '../collections/arrays/Zip.js';\nimport { weight } from './NumericArrays.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * // All items weighted evenly\n * Arrays.averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * Arrays.averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * Arrays.averageWeighted[1,2,3], Easings.gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * import { Easings } from 'https://unpkg.com/ixfx/dist/modulation.js';\n *\n * const data = [1,2,3];\n * const w = Arrays.weight(data, Easings.gaussian());\n * const avg = Arrays.averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n */\nexport const averageWeighted = (\n  data: Array<number> | ReadonlyArray<number>,\n  weightings: Array<number> | ReadonlyArray<number> | ((value: number) => number)\n): number => {\n  if (typeof weightings === `function`) weightings = weight(data, weightings);\n\n  const ww = zip(data, weightings);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const [ totalV, totalW ] = ww.reduce(\n    (accumulator: Array<number>, v: Array<number>) => [ accumulator[ 0 ] + v[ 0 ] * v[ 1 ], accumulator[ 1 ] + v[ 1 ] ],\n    [ 0, 0 ]\n  );\n  return totalV / totalW;\n};"],"mappings":";;;;;;;;;;;;AA6BO,IAAM,UAAU,CAAI,QAAkB,QAAkB,KAAK,mBAA+B;AACjG,aAAW,QAAQ,QAAQ;AAC3B,aAAW,QAAQ,QAAQ;AAE3B,MAAI,OAAO,WAAW,OAAO,OAAQ,QAAO;AAE5C,WAAS,SAAS,GAAG,SAAS,OAAO,QAAQ,UAAU;AACrD,QAAI,CAAE,GAAG,OAAQ,MAAO,GAAG,OAAQ,MAAO,CAAC,EAAI,QAAO;AAAA,EACxD;AACA,SAAO;AACT;AAgCO,IAAM,oBAAoB,CAC/B,OACA,aACY;AAGZ,MAAI,CAAC,MAAM,QAAQ,KAAK,EAAG,OAAM,IAAI,MAAM,gCAAgC;AAC3E,MAAI,MAAM,WAAW,EAAG,QAAO;AAC/B,QAAM,KAAK,YAAY;AACvB,QAAM,IAAI,MAAO,CAAE;AACnB,QAAM,IAAI,MAAM,KAAK,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC;AACrC,MAAI,EAAG,QAAO;AACd,SAAO;AACT;;;ACvDO,IAAM,MAAM,IACd,WACY;AAEf,MAAI,OAAO,KAAK,CAAC,MAAM,CAAC,MAAM,QAAQ,CAAC,CAAC,GAAG;AACzC,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACnD;AACA,QAAM,UAAU,OAAO,IAAI,CAAC,MAAM,EAAE,MAAM;AAC1C,MAAI,CAAC,kBAAkB,OAAO,GAAG;AAC/B,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AAEA,QAAM,cAAc,CAAC;AACrB,QAAM,SAAS,QAAS,CAAE;AAE1B,WAAS,QAAQ,GAAG,QAAQ,QAAQ,SAAS;AAE3C,gBAAY,KAAK,OAAO,IAAI,CAAC,MAAM,EAAG,KAAM,CAAC,CAAC;AAAA,EAChD;AACA,SAAO;AACT;;;ACXO,IAAM,kBAAkB,CAC7B,MACA,eACW;AACX,MAAI,OAAO,eAAe,WAAY,cAAa,OAAO,MAAM,UAAU;AAE1E,QAAM,KAAK,IAAI,MAAM,UAAU;AAE/B,QAAM,CAAE,QAAQ,MAAO,IAAI,GAAG;AAAA,IAC5B,CAAC,aAA4B,MAAqB,CAAE,YAAa,CAAE,IAAI,EAAG,CAAE,IAAI,EAAG,CAAE,GAAG,YAAa,CAAE,IAAI,EAAG,CAAE,CAAE;AAAA,IAClH,CAAE,GAAG,CAAE;AAAA,EACT;AACA,SAAO,SAAS;AAClB;","names":[]}