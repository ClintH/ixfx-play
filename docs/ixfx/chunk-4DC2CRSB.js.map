{"version":3,"sources":["../src/collections/queue/index.ts","../src/collections/queue/QueueFns.ts","../src/collections/queue/QueueImmutable.ts","../src/collections/queue/QueueMutable.ts"],"sourcesContent":["export type QueueDiscardPolicy = `older` | `newer` | `additions`;\n\n/**\n * Queue options.\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n */\nexport type QueueOpts = {\n  /**\n   * @private\n   */\n  readonly debug?: boolean;\n  /**\n   * Capcity limit\n   */\n  readonly capacity?: number;\n  /**\n   * Default is `additions`, meaning new items are discarded.\n   *\n   * `older`: Removes items front of the queue (ie older items are discarded)\n   *\n   * `newer`: Remove from rear of queue to make space for new items (ie newer items are discarded)\n   *\n   * `additions`: Only adds new items that there are room for (ie. brand new items are discarded)\n   *\n   */\n  readonly discardPolicy?: QueueDiscardPolicy;\n};\n\nexport { type IQueueMutable } from './IQueueMutable.js';\nexport { type IQueueImmutable } from './IQueueImmutable.js';\nexport { immutable } from './QueueImmutable.js';\nexport { mutable } from './QueueMutable.js';\n","import type { QueueOpts } from './index.js';\n\nexport const debug = (opts: QueueOpts, msg: string): void => {\n  /* eslint-disable-next-line functional/no-expression-statements */\n  opts.debug ? console.log(`queue:${msg}`) : null;\n};\n\nexport const trimQueue = <V>(\n  opts: QueueOpts,\n  queue: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = queue.length + toAdd.length;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  const policy = opts.discardPolicy ?? `additions`;\n  // debug(\n  //   opts,\n  //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n  // );\n  // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n\n  switch (policy) {\n    // Only add what we can from toAdd\n    case `additions`:\n      // debug(\n      //   opts,\n      //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n      //     potentialLength - capacity\n      //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n      // );\n      if (queue.length === 0) return toAdd.slice(0, toAdd.length - toRemove);\n      if (queue.length === opts.capacity) {\n        return queue; // Completely full\n      } else {\n        // Only add some from the new array (from the front)\n        return [...queue, ...toAdd.slice(0, toRemove - 1)];\n      }\n    // Remove from rear of queue (last index) before adding new things\n    case `newer`:\n      if (toRemove >= queue.length) {\n        // New items will completely flush out old\n        //debug(opts, `slice start: ${toAdd.length - capacity}`);\n        if (queue.length === 0) {\n          // Special case when queue starts off empty\n          return [...toAdd.slice(0, capacity - 1), toAdd[toAdd.length - 1]];\n        }\n        const tmp = toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n        //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n        return tmp;\n      } else {\n        // Keep some of the old\n        // const toAddFinal = toAdd.slice(\n        //   0,\n        //   Math.min(toAdd.length, capacity - toRemove + 1)\n        // );\n        // Cap 5, queue 5, toAdd: 10.\n        const countToAdd = Math.max(1, toAdd.length - queue.length);\n        const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n        const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n        // debug(\n        //   opts,\n        //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n        //     queue.length\n        //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n        //     toKeep\n        //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n        //     toAddFinal\n        //   )}`\n        // );\n        const t = [...toKeep, ...toAddFinal];\n        //debug(opts, `final: ${JSON.stringify(t)}`);\n        return t;\n      }\n    // Remove from the front of the queue (0 index). ie. older items are discarded\n    case `older`:\n      // If queue is A, B and toAdd is C, D this yields A, B, C, D\n      return [...queue, ...toAdd].slice(toRemove);\n    default:\n      throw new Error(`Unknown overflow policy ${policy}`);\n  }\n};\n\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @template V\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = <V>(\n  opts: QueueOpts,\n  queue: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n  const potentialLength = queue.length + toAdd.length;\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n\n  const toReturn = overSize\n    ? trimQueue(opts, queue, toAdd)\n    : [...queue, ...toAdd];\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n    throw new Error(\n      `Bug! Expected return to be at capacity. Return len: ${\n        toReturn.length\n      } capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`\n    );\n  }\n  if (!opts.capacity && toReturn.length !== potentialLength) {\n    throw new Error(\n      `Bug! Return length not expected. Return len: ${\n        toReturn.length\n      } expected: ${potentialLength} opts: ${JSON.stringify(opts)}`\n    );\n  }\n  return toReturn;\n};\n\n// Remove from front of queue (0 index)\nexport const dequeue = <V>(\n  opts: QueueOpts,\n  queue: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (queue.length === 0) throw new Error(`Queue is empty`);\n  return queue.slice(1);\n};\n\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @template V\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: QueueOpts,\n  queue: ReadonlyArray<V>\n): V | undefined => queue[0];\n\nexport const isEmpty = <V>(opts: QueueOpts, queue: ReadonlyArray<V>): boolean =>\n  queue.length === 0;\n\nexport const isFull = <V>(\n  opts: QueueOpts,\n  queue: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return queue.length >= opts.capacity;\n  }\n  return false;\n};\n","import type { IQueueImmutable } from './IQueueImmutable.js';\nimport { peek, isFull, isEmpty, enqueue, dequeue } from './QueueFns.js';\nimport { type QueueOpts } from './index.js';\n\n// -------------------------------\n// Immutable\n// -------------------------------\nexport class QueueImmutable<V> implements IQueueImmutable<V> {\n  readonly opts: QueueOpts;\n  readonly data: ReadonlyArray<V>;\n\n  /**\n   * Creates an instance of Queue.\n   * @param {QueueOpts} opts Options foor queue\n   * @param {V[]} data Initial data. Index 0 is front of queue\n   * @memberof Queue\n   */\n  constructor(opts: QueueOpts = {}, data: ReadonlyArray<V> = []) {\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n    this.opts = opts;\n    this.data = data;\n  }\n\n  forEach(fn: (v: V) => void) {\n    //eslint-disable-next-line functional/no-let\n    for (let i = this.data.length - 1; i >= 0; i--) {\n      fn(this.data[i]);\n    }\n  }\n\n  forEachFromFront(fn: (v: V) => void) {\n    // From front of queue\n    this.data.forEach(fn); //(vv) => fn(vv));\n  }\n\n  enqueue(...toAdd: ReadonlyArray<V>): QueueImmutable<V> {\n    return new QueueImmutable<V>(\n      this.opts,\n      enqueue(this.opts, this.data, ...toAdd)\n    );\n  }\n\n  dequeue(): QueueImmutable<V> {\n    return new QueueImmutable<V>(this.opts, dequeue(this.opts, this.data));\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n}\n\n/**\n * Returns an immutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * let q = Queues.immutable();           // Create\n * q = q.enqueue(`a`, `b`);   // Add two strings\n * const front = q.peek();    // `a` is at the front of queue (oldest)\n * q = q.dequeue();           // q now just consists of `b`\n * ```\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.immutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @template V Data type of items\n * @param opts\n * @param startingItems Index 0 is the front of the queue\n * @returns A new queue\n */\nexport const immutable = <V>(\n  opts: QueueOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IQueueImmutable<V> => {\n  opts = { ...opts }; // Make a copy of options\n  return new QueueImmutable(opts, [...startingItems]); // Make a copy of array so it can't be modified\n};\n","import { type IQueueMutable } from './IQueueMutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './QueueFns.js';\nimport { type QueueOpts } from './index.js';\n\n/**\n * Returns a mutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = Queues.mutable();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @template V Data type of items\n * @param opts\n * @param startingItems Items are added in array order. So first item will be at the front of the queue.\n */\nexport class QueueMutable<V> implements IQueueMutable<V> {\n  readonly opts: QueueOpts;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<V>;\n\n  constructor(opts: QueueOpts = {}, data: ReadonlyArray<V> = []) {\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n    this.opts = opts;\n    this.data = data;\n  }\n\n  enqueue(...toAdd: ReadonlyArray<V>): number {\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = enqueue(this.opts, this.data, ...toAdd);\n    return this.data.length;\n  }\n\n  dequeue(): V | undefined {\n    const v = peek(this.opts, this.data);\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = dequeue(this.opts, this.data);\n    return v;\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n}\n\nexport function mutable<V>(\n  opts: QueueOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IQueueMutable<V> {\n  return new QueueMutable({ ...opts }, [...startingItems]);\n}\n"],"mappings":"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","names":[]}